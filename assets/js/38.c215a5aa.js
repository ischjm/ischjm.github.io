(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{375:function(a,t,s){"use strict";s.r(t);var n=s(0),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"ir"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ir"}},[a._v("#")]),a._v(" IR")]),a._v(" "),t("blockquote",[t("p",[a._v("在编译原理时，我们用抽象语法树去作为中间表示形式。静态分析器也需要一种程序的表示形式，这个表示格式需要时简便的、利于静态分析算法的设计的。真正好的IR也并没有严格的定义。绝大部分静态分析器的IR应该是一个什么样子？源程序-> IR -> 后续分析。")])]),a._v(" "),t("h2",{attrs:{id:"compilers-and-static-analyzers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compilers-and-static-analyzers"}},[a._v("#")]),a._v(" Compilers and Static Analyzers")]),a._v(" "),t("h3",{attrs:{id:"compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[a._v("#")]),a._v(" Compiler")]),a._v(" "),t("p",[a._v("将Source Code翻译转换为Machine Code的过程中，识别源代码中的错误。")]),a._v(" "),t("p",[a._v("编译的过程：")]),a._v(" "),t("ol",[t("li",[a._v("Scanner - 词法分析 Lexical Analysis\n词法分析的规则描述形式化的方法是：Regular Expression。将合法的单词生成Tokens。")]),a._v(" "),t("li",[a._v("Parser -  语法分析 Syntax Analysis\n将词法分析生成的Tokens交给语法分析器，使用Context-Free Grammer（上下文无关文法）。将合法的程序生成AST（抽象语法树）")]),a._v(" "),t("li",[a._v("Type Checker - 语义分析 Semantic Analysis\n利用抽象语法树对语义进行分析，从编译器的角度将，只能做简单的检查，如：类型检查。形式化语言是：Attribute Grammer。生成Decorated AST。")]),a._v(" "),t("li",[a._v("Translator - 编译优化\n如果还需要优化等操作，需要将上一步生成的结果转化为IR（通常为三地址码），并进行Static Analysis。")]),a._v(" "),t("li",[a._v("CodeGenerator - 生成机器码")])]),a._v(" "),t("p",[a._v("那么能不能直接将源程序生成三地址码的IR，进行静态分析呢？不行的，我们关注的问题是一个相对高级的内容，如果基本的词法、语法等都无法通过，后续也没有什么意义。因此，我们的静态分析是建立在一个通过了前端的校验的合法IR之上的。")]),a._v(" "),t("h2",{attrs:{id:"ast-vs-ir"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ast-vs-ir"}},[a._v("#")]),a._v(" AST vs. IR")]),a._v(" "),t("p",[a._v("为什么要用三地址码的IR呢？AST不能解决问题吗？")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("AST")]),a._v(" "),t("th",[a._v("IR")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("high-level")]),a._v(" "),t("td",[a._v("low-level")])]),a._v(" "),t("tr",[t("td",[a._v("closed to grammar structure")]),a._v(" "),t("td",[a._v("closed to machine code")])]),a._v(" "),t("tr",[t("td",[a._v("usually language dependent")]),a._v(" "),t("td",[a._v("usually language independent")])]),a._v(" "),t("tr",[t("td",[a._v("suitable for fast type checking")]),a._v(" "),t("td",[a._v("compact and uniform")])]),a._v(" "),t("tr",[t("td",[a._v("lack of control flow information")]),a._v(" "),t("td",[a._v("contains control flow information")])]),a._v(" "),t("tr",[t("td"),a._v(" "),t("td",[a._v("usually considered as the basis for static analysis")])])])]),a._v(" "),t("p",[a._v("以上的三地址码利于静态分析的特性，导致静态分析通常基于IR进行分析。")]),a._v(" "),t("h2",{attrs:{id:"ir-three-address-code-3ac"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ir-three-address-code-3ac"}},[a._v("#")]),a._v(" IR: Three-Address Code (3AC)")]),a._v(" "),t("blockquote",[t("p",[a._v("There is at most one operator on the right side of an instruction.")])]),a._v(" "),t("p",[a._v("通常情况下右边只有一个操作符。转换时通常引入临时变量。三地址码包含最多三个地址。地址由以下的形式表示：")]),a._v(" "),t("ul",[t("li",[a._v("标识符：a,b")]),a._v(" "),t("li",[a._v("常量值：3")]),a._v(" "),t("li",[a._v("静态分析器自动生成的临时变量：t1,t2")])]),a._v(" "),t("p",[a._v("常见的三地址码形式：")]),a._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x = y bop z  bop: 二元操作符 \nx = uop y    uop: 一元操作符\nx = y   无操作符\ngoto L  无条件跳转 L 是一个标签\nif x goto L 有条件跳转\nif x rop y goto L \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h2",{attrs:{id:"_3ac-in-real-static-analyzer-soot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3ac-in-real-static-analyzer-soot"}},[a._v("#")]),a._v(" 3AC in Real Static Analyzer: Soot")]),a._v(" "),t("p",[t("em",[t("strong",[a._v("Soot")])]),a._v(": Soot's is "),t("em",[t("strong",[a._v("Jimple")])]),a._v(": typed 3-address code.")]),a._v(" "),t("p",[a._v("Most popular static analysis framework for Java")]),a._v(" "),t("p",[a._v("比如下面的Java程序：")]),a._v(" "),t("div",{staticClass:"language-JAVA line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("nju"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("sa"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("examples")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FOrLoop3AC")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("i"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("i"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t\t\tx "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br")])]),t("p",[a._v("可以生成如下的***Jimple***")]),a._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public static void main(java.lang.String[])\n{\n\tjava.lang.String[] r0;\n\tint i1;\n\n\tr0 := @parameter0: java.lang.String[];\n\ti1 = 0;\n\nlabel1:\n\tif i1 >=10 goto label2;\n\ti1 = i1+1;\n\tgoto label1;\n\nlabel2:\n\treturn;\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br")])]),t("p",[a._v("DoWhile Loop 、Method Call、Class 对应的Jimple，可以在课件里看到。")]),a._v(" "),t("p",[a._v("Tips: 关于Java中的调用指令")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("指令")]),a._v(" "),t("th",[a._v("说明")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("invokeinterface")]),a._v(" "),t("td",[a._v("用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。（Invoke interface method）")])]),a._v(" "),t("tr",[t("td",[a._v("invokevirtual")]),a._v(" "),t("td",[a._v("指令用于调用对象的实例方法，根据对象的实际类型进行分派（Invoke instance method; dispatch based on class）")])]),a._v(" "),t("tr",[t("td",[a._v("invokestatic")]),a._v(" "),t("td",[a._v("用以调用类方法（Invoke a class (static) method ）")])]),a._v(" "),t("tr",[t("td",[a._v("invokespecial")]),a._v(" "),t("td",[a._v("指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。（Invoke instance method; special handling for superclass, private, and instance initialization method invocations ）")])]),a._v(" "),t("tr",[t("td",[a._v("invokedynamic")]),a._v(" "),t("td",[a._v("JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(Invoke dynamic method)")])])])]),a._v(" "),t("p",[a._v("关于Method Signature："),t("code",[a._v("class name : return type method name(parameter1 type....)")])]),a._v(" "),t("h2",{attrs:{id:"static-single-assignment-ssa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#static-single-assignment-ssa"}},[a._v("#")]),a._v(" Static Single Assignment (SSA)")]),a._v(" "),t("p",[a._v("SSA是IR中一个经典的转化格式。SSA给每一个定义一个新的名字，并且在后面进行调用。每一个标识符都有唯一的定义。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053631443.png",alt:"image-20220130053631443"}})]),a._v(" "),t("p",[a._v("但是对于分支而言，可能出现下面的特殊情况，于是引入了一个特殊的运算。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053646668.png",alt:"image-20220130053646668"}})]),a._v(" "),t("p",[a._v("为什么要有SSA，那么为什么又不用SSA？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053731250.png",alt:"image-20220130053731250"}})]),a._v(" "),t("h2",{attrs:{id:"basic-blocks-bb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic-blocks-bb"}},[a._v("#")]),a._v(" Basic Blocks (BB)")]),a._v(" "),t("p",[a._v("BB是满足以下的特征的最大指令的集合：")]),a._v(" "),t("ul",[t("li",[a._v("入口只有一个，不存在第二条控制流走入BB中的第二条或者第三条指令")]),a._v(" "),t("li",[a._v("出口应该是最后一个指令，不存在从其他非最后指令走出。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053745107.png",alt:"image-20220130053745107"}})]),a._v(" "),t("p",[a._v("BB怎么划分？")]),a._v(" "),t("p",[a._v("一条一条看，尝试把下一行加入，查看是否符合规则（goto的label，存在goto），直到最后。")]),a._v(" "),t("ol",[t("li",[a._v("决定leader\n"),t("ul",[t("li",[a._v("程序第一条指令")]),a._v(" "),t("li",[a._v("jump的target")]),a._v(" "),t("li",[a._v("上一条指令存在一个jump")])])]),a._v(" "),t("li",[a._v("建立BB\n"),t("ul",[t("li",[a._v("由入口到下一个入口之间的指令")])])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053801622.png",alt:"image-20220130053801622"}})]),a._v(" "),t("h2",{attrs:{id:"control-flow-graphs-cfg"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#control-flow-graphs-cfg"}},[a._v("#")]),a._v(" Control Flow Graphs (CFG)")]),a._v(" "),t("p",[a._v("怎么在BB的基础上构建CFG呢？")]),a._v(" "),t("ol",[t("li",[a._v("将语句的label转化为BB的label，从细粒度变为粗粒度的label之后，如果block中存在语句的变化，可能CFG不会产生太大的变化。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053816837.png",alt:"image-20220130053816837"}})]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("按照规则添加边")])]),a._v(" "),t("p",[a._v("添边规则：")]),a._v(" "),t("ul",[t("li",[a._v("有条件或者无条件的从A到B跳转")]),a._v(" "),t("li",[a._v("B紧接着A顺序执行时添加边，如果A最后一条是无条件的goto，那么不应该添边")])]),a._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[a._v("添加程序真正的出口和入口，如果有多个return，则存在多个exit。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220130053834486.png",alt:"image-20220130053834486"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);