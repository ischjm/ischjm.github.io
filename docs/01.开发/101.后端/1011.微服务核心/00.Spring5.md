---
title: Spring5
date: 2022-01-01 00:00:00
permalink: /dev/java/core/spring5
author:
 name: p0jo
 link: https://wiki.pwddd.com
categories:
  - 开发
  - 后端
  - 微服务核心
tags:
  - SSM
  - Spring5
---

# Spring5

## Spring简介

### 概述

Spring是一个控制反转(SpringIOC)和面向切面的(SpringAOP)的轻量级框架。Spring是一个框架集,内部集成了很多的功能,可以根据需求选择对应的子框架使用。

作用：
- 简化企业项目的开发的流程，提升开发效率
- 便于代码的后期维护升级
- 将代码之间的耦合性降低

Spring Framework 组成部分

![image-20220129172849912](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129172849912.png)

核心概念：
- SpringIOC：控制反转，把创建对象过程交给Spring进行管理
- SpringAOP：面向切面，不修改源代码进行功能增强

### SpringDemo

> Spring组件下载地址：[JFrog (spring.io)](https://repo.spring.io/ui/native/release/org/springframework/spring/)

1. 创建项目，导入基础Jar包

	![image-20220129173531933](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173531933.png)

2. 创建测试类

```java
	package com.pwddd.spring5; 
	public class User { 
		public void add(){ 
			System.out.println("add......."); 
		} 
	}
```

3. 创建配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="user" class="com.pwddd.spring5.User" />
</beans>
```

4. 编写测试代码

```java
@Test
public void testAdd(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean1.xml");
    User user = applicationContext.getBean("user", User.class);
    System.out.println(user);
    user.add();
}
```

## SpringIOC

### 背景

在使用MVC的结构体系来完成后台功能代码的声明时，在一定程度上降低了代码的冗余，但是层与层之间的*耦合性过高*，造成代码升级维护特别麻烦。比如，某天业务层某个类文件需要替换为新的类文件，那么，控制层所有调用该业务类的代码需要全部修改为调用新的业务类。
解决办法就是将**层与层对象之间的关系解耦，由直接关系变为间接关系。**

### IOC底层原理

#### 什么是IOC

控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理
使用IOC目的：为了耦合度降低

#### 原理讲解

![image-20220129173640323](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173640323.png)

#### BeanFactory接口

IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。Spring提供IOC容器实现两种方式：（两个接口）
- BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用
	- 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象
- ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用
	- 加载配置文件时候就会把在配置文件对象进行创建

### Bean管理

Bean管理包含**两个方面**：
- Spring创建对象
- Spring注入属性

Bean管理的**两种方式**：
- 基于XML进行配置
- 基于注解的方式实现

#### 基于XML进行配置

##### 创建对象

在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建。创建对象时，默认执行无参数构造方法完成对象的创建。在bean标签有很多属性，常用的属性有两个：
- id属性：唯一标识
- class属性：类全路径（包类路径）

user Bean配置：

```xml
<bean id="user" class="com.pwddd.spring5.User" />
```

##### 注入属性

注入属性有两种方式：
- 使用set方法进行注入
- 使用构造器进行注入
- p名称空间注入（实际上是set方法注入）

###### 使用set进行注入

1. 创建类，编写对应属性的set方法。

```java
package com.pwddd.spring5;

public class Book {
    public String name;
    public String author;

    public void setName(String name) {
        this.name = name;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                '}';
    }
}
```

2. 编写XML配置文件，使用`property`进行注入

```XML
<bean id="book" class="com.pwddd.spring5.Book" >
    <property name="name" value="红楼"></property>
    <property name="author" value="曹雪芹"></property>
</bean>
```

###### 使用带参构造进行注入

1. 创建类，并生成带参构造器。

```JAVA
package com.pwddd.spring5;

public class Order {
    public String id;
    public String phone;

    @Override
    public String toString() {
        return "Order{" +
                "id='" + id + '\'' +
                ", phone='" + phone + '\'' +
                '}';
    }

    public Order(String id, String phone) {
        this.id = id;
        this.phone = phone;
    }
}
```

2. 编写配置XML配置文件，使用`constructor-arg`进行注入。

```xml
<bean id="order" class="com.pwddd.spring5.Order" >
    <constructor-arg index="0" value="00001"></constructor-arg>
    <constructor-arg index="1" value="上海"></constructor-arg>
</bean>
```

###### P名称空间注入
1. 添加p名称空间xmlns

```xml
xmlns:p="http://www.springframework.org/schema/p"
```

2. 编写XML配置文件

```xml
<!--    p注入需要添加xmlns：p
        p注入需要set方法
-->
<bean id="book" class="com.pwddd.spring5.Book" p:name="西游记" p:author="hahah" />
```

##### 不同类型的属性注入方式

###### 字面量NULL

```XML
<bean id="order" class="com.pwddd.spring5.Order" >
  <constructor-arg index="0">
      <null></null>
  </constructor-arg>
  <constructor-arg index="1">
      <null></null>
  </constructor-arg>
</bean>
```

###### 包含特殊字符的属性值

```xml
<constructor-arg index="1">
    <value><![CDATA[<>hahah<>]]>&gt; &lt; </value>
</constructor-arg>
```

###### 外部bean

`UserService`中需要依赖`UserDao`，可以使用外部Bean的方式将`UserDao`注入到`UserService`中。

1. 创建`UserService` 

```java
package com.pwddd.spring5.service.impl;

import com.pwddd.spring5.dao.UserDao;
import com.pwddd.spring5.service.UserService;

public class UserServiceImpl implements UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void addUser() {
        System.out.println("service...addUser");
        userDao.addUser();
    }
}
```

2. 创建`UserDao`

```java
package com.pwddd.spring5.dao.impl;

import com.pwddd.spring5.dao.UserDao;

public class UserDaoImpl implements UserDao {
    @Override
    public void addUser() {
        System.out.println("dao......addUser");
    }
}
```

3. 编写配置文件，使用`ref`注入外部Bean

```xml
<bean id="userService" class="com.pwddd.spring5.service.impl.UserServiceImpl">
    <property name="userDao" ref="userDaoImpl"></property>
</bean>

<bean id="userDaoImpl" class="com.pwddd.spring5.dao.impl.UserDaoImpl"></bean>
```

4. 编写测试代码

```java
@Test
public void testUser(){
	UserService userService = context.getBean("userService", UserService.class);
	userService.addUser();
}
```

###### 内部Bean

如果需要在实体类中表示类和类之间的对应关系，可以使用内部Bean方式进行表示。

1. 编写测试`Dept`类

```java
package com.pwddd.spring5;

public class Dept {
    private String dname;
    public void setDname(String dname) {
        this.dname = dname;
    }
}
```

2. 编写测试`Emp`类

```java
package com.pwddd.spring5;

public class Emp {
    private String ename;
    private String gender;
    //员工属于某一个部门，使用对象形式表示
    private Dept dept;
    public void setDept(Dept dept) {
        this.dept = dept;
    }
    public void setEname(String ename) {
        this.ename = ename;
    }
    public void setGender(String gender) {
        this.gender = gender;
    }
}
```

3. 第一种方式配置文件

```xml
<bean id="emp" class="com.pwddd.spring5.Emp">
  <property name="ename"  value="lalal"></property>
  <property name="gender" value="male"></property>
  <property name="dept">
      <bean id="dept" class="com.pwddd.spring5.Dept">
          <property name="dname" value="安保"></property> 
      </bean>
  </property>
</bean>
```

4. 第二种方式需要在Emp中生成Dept的get方法

```java
public Dept getDept() { return dept; }
```

5. 第二种方式配置文件

```xml
<bean id="emp" class="com.pwddd.spring5.Emp">
    <property name="gender" value="male"></property>
    <property name="ename"  value="lalal"></property>
    <property name="dept" ref="dept"></property>
    <property name="dept.dname" value="保安"></property>
</bean>
<bean id="dept" class="com.pwddd.spring5.Dept">
    <property name="dname"  value="财务"></property>
</bean>
```

###### 集合类型

集合类型支持Array、List、Map、set等类型。

1. 编写测试类，类中包含集合类型的依赖关系

```java
package com.pwddd.spring5;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Stu {
    public String[] courses;

    public List<String> lists;

    public Map<String, String> maps;

    public Set<String> sets;

    public void setCourses(String[] courses) {
        this.courses = courses;
    }

    public void setLists(List<String> lists) {
        this.lists = lists;
    }

    public void setMaps(Map<String, String> maps) {
        this.maps = maps;
    }

    public void setSets(Set<String> sets) {
        this.sets = sets;
    }

    @Override
    public String toString() {
        return "Stu{" +
                "courses=" + Arrays.toString(courses) +
                ", lists=" + lists +
                ", maps=" + maps +
                ", sets=" + sets +
                '}';
    }
}
```

2. 编写XML配置文件配置注入。

```xml
<bean id="stu" class="com.pwddd.spring5.Stu">
    <property name="courses">
        <array>
            <value>语文</value>
            <value>数学</value>
        </array>
    </property>

    <property name="lists">
        <list>
            <value>张三</value>
            <value>李四</value>
        </list>
    </property>

    <property name="maps">
        <map>
            <entry key="Java" value="1"></entry>
            <entry key="C" value="2"></entry>
        </map>
    </property>

    <property name="sets">
        <set>
            <value>aaa</value>
            <value>bbb</value>
        </set>
    </property>
</bean>
```

###### 集合内容提取

如果多个依赖注入需要引用相同的集合值，那么可以将集合值提取出来，用的时候直接引用即可。提取需要引入`util`。

实例XML配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
<util:list id="bookList">
        <value>haha</value>
        <value>lala</value>
    </util:list>

    <bean id="book" class="com.pwddd.spring5.Book">
        <property name="bookList" ref="bookList"></property>
    </bean>

</beans>
```

##### 工厂Bean

Spring有两种类型bean，一种普通bean，另外一种工厂bean（FactoryBean，不同于BeanFactory）
-   普通bean：在配置文件中定义bean类型就是返回类型
-   工厂bean：在配置文件定义bean类型可以和返回类型不一样

工厂Bean的使用方式：
 1. 创建类，使这个类成为工厂，并实现FactoryBean接口

```java
package com.pwddd.spring5;

import com.pwddd.spring5.Course;
import org.springframework.beans.factory.FactoryBean;

public class MyFactoryBean implements FactoryBean<Course> {
  @Override
  public Course getObject() throws Exception {
	  Course course = new Course();
	  course.setcName("aaa");
	  return course;
  }

  @Override
  public Class<?> getObjectType() {
	  return Course.class;
  }
}
```

 2. 实现接口里面的方法，在实现的方法中定义返回的bean类型

```java
<bean id="factoryBean" class="com.pwddd.spring5.MyFactoryBean"></bean>
```

##### Bean的作用域

在Spring里面，默认情况下，bean是单实例对象。

![image-20220129173726255](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173726255.png)

可以通过配置文件设置Bean是单例的还是多例的模式：
在spring配置文件bean标签里面有属性`（scope）`用于设置单实例还是多实例
第一个值 默认值，`singleton`，表示是单实例对象
第二个值` prototype`，表示是多实例对象

```xml
<bean id="course" class="com.pwddd.spring5.Course" scope="prototype"></bean>
```

**singleton和prototype区别** 
- singleton单实例，prototype多实例 
- 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象
- 设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象

##### Bean生命周期和后置处理器

###### Bean生命周期

- 通过构造器创建bean实例（无参数构造）
-   为bean的属性设置值和对其他bean引用（调用set方法）
-   把bean实例传递bean后置处理器的方法postProcessBeforeInitialization
-   调用bean的初始化的方法（需要进行配置初始化的方法）
-   把bean实例传递bean后置处理器的方法 postProcessAfterInitialization
-   bean可以使用了（对象获取到了）
-   当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）

###### 后置处理器

创建后置处理器需要实现`BeanPostProcessor`接口，并重写`%Before%`和`%After%`两个方法。

##### 属性自动装配

根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入。

```xml
根据名称自动装配
<bean id="emp" class="com.pwddd.spring5.Emp" autowire="byName"></bean>
    <bean id="dept" class="com.pwddd.spring5.Dept"></bean>
    <bean id="dept2" class="com.pwddd.spring5.Dept"></bean>

根据类型自动装配  报错 存在两个相同的类型
<bean id="emp" class="com.pwddd.spring5.Emp" autowire="byType"></bean>
    <bean id="dept" class="com.pwddd.spring5.Dept"></bean>
    <bean id="dept2" class="com.pwddd.spring5.Dept"></bean>
```

##### 引入外部配置文件

配置数据源的方式1：

```xml
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="jdbc:mysql://localhost:3306/aaaa" />
    <property name="username" value="root" />
    <property name="password" value="root" />
    <property name="driverClassName" value="com.mysql.jdbc.driver" />
</bean>
```

配置数据源的方式2：

1. 创建`jdbc.properties`外部配置文件

```properties
jdbc.url=jdbc:mysql://localhost:3306/aaa
jdbc.username=root
jdbc.password=root
jdbc.driver=com.jdbc.mysql.driver
```

2. 引入到XML中，并进行引用。

```xml
<context:property-placeholder location="classpath:jdbc.properties"></context:property-placeholder>
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="username" value="${jdbc.username}" />
    <property name="url" value="${jdbc.url}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

#### 基于注解进行配置

注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)。注解可以放在类上面、方法上面、属性上面。使用注解进行配置可以简化XML文件。

###### 创建对象

Spring针对Bean管理中创建对象提供注解
- @Component -- 普通bean
- @Service  -- service层
- @Controller   -- controller层
- @Repository  --dao层

使用方式：

1. 开启组件扫描

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:context="http://www.springframework.org/schema/context"
     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd">
  <context:component-scan base-package="com.pwddd.spring5.anno"></context:component-scan>
</beans>
```

2. 将注解加到类上

```java
package com.pwddd.spring5.anno;

import org.springframework.stereotype.Service;

@Service(value = "userService")
public class UserService {

}
```

3. 配置组件扫描过滤
组件扫描可以配置扫描某些组件、不扫描某些组件。

```xml
<context:component-scan base-package="com.pwddd.spring5.anno" use-default-filters="false">
    <context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/>
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```

##### 注入属性

注入属性有下面几种注解的方式：
- @Autowired：根据属性类型进行自动装配
- @Qualifier：根据名称进行注入 这个@Qualifier注解的使用，和上面@Autowired一起使用
- @Resource：可以根据类型注入，可以根据名称注入
- @Value：注入普通类型属性

测试类：

```java
package com.pwddd.spring5.anno;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service(value = "userService")
public class UserService {
//    @Autowired
//    @Qualifier(value = "dao")
  @Resource
  public UserDao userDao;

  @Value("halo")
  public String name;

  public void test(){
      System.out.println(name);
      userDao.add();
  }
}
```

##### 完全注解开发

使用一个类来替换xml文件，进行配置。

```java
@Configuration  // 声明这是一个配置类
@ComponentScan(basePackages = {"com.pwddd.spring5.anno"})  //配置包扫描
public class SpringConfig {
}
```

测试代码`AnnotationConfigApplicationContext`使用类生成`context`对象

```java
@Test
public void test(){
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    UserService userService = context.getBean("userService", UserService.class);
    userService.test();
}
```

##### 注解方式的配置文件注入

```JAVA
package com.pwddd.spring5.dao.impl;  
  
import com.pwddd.spring5.dao.UserDao;  
import com.pwddd.spring5.entity.User;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.beans.factory.annotation.Value;  
import org.springframework.context.annotation.PropertySource;  
import org.springframework.stereotype.Repository;  
  
@Repository  
@PropertySource("classpath:test.properties")  
public class UserDaoImpl implements UserDao {  
  
 @Value("${properties.result}")  
 private String result;  
  
 @Override  
 public User getUserByUserName(String username) {  
 System.out.println(result);  
 return new User("zhangsan","male",12);  
 }  
}

```

## SpringAOP

### AOP概念

面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。

![image-20220129173816048](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173816048.png)

### AOP底层原理

AOP底层使用动态代理实现，动态代理有两种，一种是有接口的情况，使用JDK的动态代理。

![image-20220129173832103](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173832103.png)

第二种是没有接口的情况，使用cglib动态代理

![image-20220129173848151](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173848151.png)

JDK动态代理实现的方式

![image-20220129173900186](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173900186.png)

1. 创建接口，定义相关的方法

```java
package com.pwddd.spring5aop.test;

public interface UserDao {
    int add(int a, int b);
    String update(String id);
}

package com.pwddd.spring5aop.test;

public class UserDaoImpl implements UserDao{
    @Override
    public int add(int a, int b) {
        System.out.println("add... 方法执行了！");
        return a+b;
    }

    @Override
    public String update(String id) {
        return id;
    }
}
```

2. 创建代理类

```java
package com.pwddd.spring5aop.test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

public class JDKProxy {
    public static void main(String[] args) {
        Class[] interfaces = {UserDao.class};
        UserDaoImpl userDao = new UserDaoImpl();
        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoPRoxy(userDao));
        System.out.println("result:"+dao.add(1, 2));
    }
}

class UserDaoPRoxy implements InvocationHandler{
    private Object obj;

    public UserDaoPRoxy(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        // 方法执行之前
        System.out.println("方法执行之前:"+method.getName()+ Arrays.toString(args));
        Object result = method.invoke(obj, args);
        System.out.println("方法执行之后:"+obj);
        return result;
    }
}
```

### AOP相关概念

连接点
	- 类里的那些方法可以被增强，这些可以被增强的方法称为连接点
切入点
	- 实际被真正增强的方法称为切入点
通知（增强）
	- 用于增强的逻辑部分
	- 分为：前置、后置、环绕、异常、返回（最终）通知类型
切面
	- 实际上把增强应用到切入点的过程，这个动作。

### AOP环境准备

Spring 框架一般都是基于 AspectJ 实现 AOP 操作。AspectJ 不是 Spring 组成部分，是一个独立 的AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作。
基于AspectJ有两种实现AOP的操作方式：
-  基于XML文件的方式
-  基于注解的方式

依赖的JAR包：

![image-20220129173914217](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173914217.png)

```TEXT
切入点表达式
切入点表达式作用：知道对哪个类里面的哪个方法进行增强
语法结构： execution([权限修饰符] [返回值类型] [类全路径\].方法名(\[形参列表\])
举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 
	execution(* com.atguigu.dao.BookDao.add(..)) 
举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 
	execution(* com.atguigu.dao.BookDao.* (..)
举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 
	execution(* com.atguigu.dao.*.** (..))
```

### 基于注解方式的配置

1. 创建增强类和被增强的方法

```java
public class User {
    public void add(){
        /**
         * 被增强方法
         */
        System.out.println("add........");
    }
}
```

2. 创建增强类和相关增强方法

```java
public class UserProxy {
    /**
     * 增强方法
     */
    public void before(){
        System.out.println("before ..... UserProxy");
    }
```

3. 进行配置，开启注解扫描，生成代理对象

```xml
<!--    开启注解扫描-->
 <context:component-scan base-package="com.pwddd.spring5aop.aopanno" />
<!--    开启生成代理对象-->
 <aop:aspectj-autoproxy />
```

4. 配置通知类型

```JAVA
@Before(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void before(){
    System.out.println("before ..... UserProxy");
}

@After(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void after(){
    System.out.println("after ..... UserProxy");
}
@AfterThrowing(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void afterThrowing(){
    System.out.println("afterThrowing ..... UserProxy");
}

@AfterReturning(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void afterReturning(){
    System.out.println("afterReturning ..... UserProxy");
}

@Around(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {

    System.out.println("around ..... qian");
    proceedingJoinPoint.proceed();
    System.out.println("around ------ hou");
}
```

5. 相同切入点表达式可抽取出来

```java
/**
 * 抽取相同的切入点表达式
 */
@Pointcut(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
public void mypoint(){

}

/**
 * 增强方法
 */
@Before(value = "mypoint()")
public void before(){
    System.out.println("before ..... UserProxy");
}
```

6. 多个增强的方法作用于同一个方法，可以设置优先级

```JAVA
@Component
@Aspect
@Order(1)
public class PersonProxy {
    @Before(value = "execution(* com.pwddd.spring5aop.aopanno.User.add(..))")
    public void before(){
        System.out.println("person ......");
    }
}

从小到大优先级降低
```

7. 配置完全注解开发

```java
package com.pwddd.spring5aop.aopanno;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackages = {"com.pwddd.spring5aop.aopanno"})  // 开启注解扫描
@EnableAspectJAutoProxy(proxyTargetClass = true)  // 开启配置aop对象
public class SpringConfig {
}
```
> **TIPS: 当程序运行抛出异常时，AfterThrowing、After存在，AfterReturning不存在。**

### 基于XML方式配置

1. 创建增强类、增强方法、被增强类、被增强方法

```java
package com.pwddd.spring5aop.aopxml;

/**
 * 增强类
 */
public class BookProxy {
    /**
     * 增强方法
     */
    public void before(){
        System.out.println("before.....");
    }
}

package com.pwddd.spring5aop.aopxml;

/**
 * 被增强类
 */
public class Book {
    /**
     * 被增强方法
     */
    public void buy(){
        System.out.println("buy .....");
    }
}
```

2. 编写Spring配置文件

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:context="http://www.springframework.org/schema/context"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

  <bean id="book" class="com.pwddd.spring5aop.aopxml.Book" />
  <bean id="bookProxy" class="com.pwddd.spring5aop.aopxml.BookProxy" />

<!--    // 配置切入点-->
  <aop:config>
      <aop:pointcut id="buy" expression="execution(* com.pwddd.spring5aop.aopxml.Book.buy(..))"/>
      <aop:aspect ref="bookProxy">
          <aop:before method="before" pointcut-ref="buy" />
      </aop:aspect>
  </aop:config>
</beans>
```

## JdbcTemplate

### 概述

Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作。

### 准备工作

1. 导入相关Jar包

![image-20220129173936716](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173936716.png)

2. 配置Spring配置文件，开启注解扫描、配置数据源、配置JDBCTemplate对象。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
<!--    开启注解扫描-->
    <context:component-scan base-package="com.pwddd.spring5.jdbc" />
<!--    导入配置文件-->
    <context:property-placeholder location="classpath:jdbc.properties" />
<!--    配置数据源-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="driverClassName" value="${jdbc.driver}" />
        <property name="password" value="${jdbc.password}" />
    </bean>

<!--    配置jdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource" />
    </bean>

</beans>
```

3.  编写相关业务方法

 service

```java
package com.pwddd.spring5.jdbc.service.impl;

import com.pwddd.spring5.jdbc.dao.BookDao;
import com.pwddd.spring5.jdbc.service.BookService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class BookServiceImpl implements BookService {
	@Autowired
	private BookDao bookDao;

}	
```

Dao

```java
package com.pwddd.spring5.jdbc.dao.impl;

import com.pwddd.spring5.jdbc.dao.BookDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class BookDaoImpl implements BookDao {
	@Autowired
	private JdbcTemplate jdbcTemplate;
}	
```

4. 编写测试方法

```java
package com.pwddd.spring5.jdbc.test;

import com.pwddd.spring5.jdbc.service.BookService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestJDBC {

@Test
public void testJDBC(){
	ApplicationContext applicationContext =
			new ClassPathXmlApplicationContext("bean1.xml");
	BookService bookServiceImpl = applicationContext.getBean("bookServiceImpl", BookService.class);
	System.out.println(bookServiceImpl);
}
}
```

### CRUD

#### CUD

在进行增删改操作，调用jdbcTemplate的update方法进行。

![image-20220129173952657](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129173952657.png)

该方法有两个参数，第一个为SQL语句、第二个为可变参数。
测试代码：

```java
package com.pwddd.spring5.jdbc.dao.impl;

import com.pwddd.spring5.jdbc.dao.BookDao;
import com.pwddd.spring5.jdbc.entity.Book;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int add(Book book) {
        String sql = "insert into book values(?,?,?)";
        Object[] args = {book.getBookId(),book.getBookName(),book.getBookAuthor()};
        return jdbcTemplate.update(sql,args);
    }

    @Override
    public int deleteBookById(String id) {
        String sql = "delete from book where bookid=?";
        Object[] args = {id};
        return jdbcTemplate.update(sql,args);
    }

    @Override
    public int updateBookInfo(Book book) {
        String sql = "update book set bookname=?,bookauthor=? where bookid=?";
        Object[] args = {book.getBookName(),book.getBookAuthor(),book.getBookId()};
        return jdbcTemplate.update(sql,args);
    }
}
```

#### R

jdbcTemplate查询总共分为三种情况：
- 使用聚合函数查询单个值
- 查询单条记录信息
- 查询列表

##### 单值查询

单值查询是利用SQL语句的聚合函数如Count查询单个字段。使用如下方法进行查询：

![image-20220129174005291](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174005291.png)

该方法共两个参数，第一个为SQL语句，第二个参数为返回值的类型。
实例代码：

```JAVA
@Override
public int queryBookNum() {
    String sql = "select count(*) from book";
    Integer integer = jdbcTemplate.queryForObject(sql, Integer.class);
    return integer;
}
```

##### 单条记录查询

单条记录查询的结果对应一个实体类。使用如下的方法进行查询：

![image-20220129174020103](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174020103.png)

该方法有三个参数：
- SQL语句
- RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装
- 可变的SQL语句参数。

实例代码：

```java
@Override
public Book queryBookById(String id) {
    String sql = "select * from book where bookid=?";
    Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);
    return book;
}
```

##### 集合查询

集合查询的查询结果是一个集合，使用如下的方法进行查询：

![image-20220129174030568](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174030568.png)

该方法的参数类似单条记录查询。

实例代码：

```JAVA
@Override
public List<Book> queryAllBook() {
    String sql = "select * from book";
    List<Book> books = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));
    return books;
}
```

#### 批量操作

以上的方法都只能单次处理单条数据，往往遇到需要批量处理数据库数据的需求，上面的方法就力不从心了。jdbcTemplate也提供了数据库批量操作的方法。

![image-20220129174042343](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174042343.png)

该方法的参数和上面增删改的操作方法相似，只是可变参数换成了Object数组的List集合，单个Object数组对应数据库中的一个记录。

实例代码：

```JAVA
@Override
public void batchDelete(List<Object[]> args) {
    String sql = "delete from book where bookid=?";
    jdbcTemplate.batchUpdate(sql,args);
}

@Override
public void batchUpdate(List<Object[]> args) {
    String sql = "update book set bookname=?,bookauthor=? where bookid=?";
    jdbcTemplate.batchUpdate(sql,args);
}

@Override
public void batchAdd(List<Object[]> args) {
    String sql = "insert into book values(?,?,?)";
    jdbcTemplate.batchUpdate(sql,args);
}
```

测试代码：

```java
@Test
public void batch(){
    List<Object[]> addArgs = new ArrayList<>();
    Object[] o1 = {"100","test100","a100"};
    Object[] o2 = {"200","test200","a200"};
    Object[] o3 = {"300","test300","a300"};
    addArgs.add(o1);
    addArgs.add(o2);
    addArgs.add(o3);
//        bookServiceImpl.batchAdd(addArgs);
    List<Object[]> updateArgs = new ArrayList<>();
    Object[] ou1 = {"TEST100","a100","100"};
    Object[] ou2 = {"TEST200","a200","200"};
    Object[] ou3 = {"TEST300","a300","300"};
    updateArgs.add(ou1);
    updateArgs.add(ou2);
    updateArgs.add(ou3);
    bookServiceImpl.batchUpdate(updateArgs);
    List<Object[]> delArgs = new ArrayList<>();
    Object[] od1 = {"100"};
    Object[] od2 = {"300"};
    delArgs.add(od1);
    delArgs.add(od2);
    bookServiceImpl.batchDelete(delArgs);
}
```

## 事务

### 概念

事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。典型的业务场景就是转账，lucy 转账 100 元 给 mary，lucy 少 100，mary 多 100

事务有四个特性：
- 原子性
- 一致性
- 隔离性
- 持久性

### 测试代码

模拟上述的转账的例子

1. 创建Dao

```java
package com.pwddd.dao.impl;

import com.pwddd.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void reduceMoney() {
        String sql = "update bank set money=money-100 where id=1";
        jdbcTemplate.update(sql);
    }

    @Override
    public void addMoney() {
        String sql = "update bank set money=money+100 where id=2";
        jdbcTemplate.update(sql);
    }
}
```

2. 创建Service

```java
package com.pwddd.service.impl;

import com.pwddd.dao.UserDao;
import com.pwddd.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;

    @Override
    public void accountMoney() {
        userDao.reduceMoney();

        int i = 1/0;
        userDao.addMoney();
    }
}
```

如果没有事务，则当少钱之后报错，没有多钱，就会导致不一致的情况。

### 事务的操作过程

事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）
在 Spring 进行事务管理操作有两种方式：
- 编程式事务管理
- 声明式事务管理（使用）

编程式事务管理如图：

![image-20220129174104028](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174104028.png)

声明式事务管理有两种实现方式：
- 基于注解的实现
- 基于XML的实现

在 Spring 进行声明式事务管理，底层使用 AOP 原理，Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。

![image-20220129174118283](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174118283.png)

### 基于注解方式的事务管理

完全注解开发的方式进行事务管理：

```java
package com.pwddd.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@Configuration
@ComponentScan(basePackages = "com.pwddd")
@EnableTransactionManagement  // 开启事务
public class SpringConfig {

    @Bean
    public DruidDataSource getDataSource(){
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setUrl("jdbc:mysql://localhost:3306/srping5test");
        druidDataSource.setDriverClassName("com.mysql.jdbc.Driver");
        druidDataSource.setUsername("root");
        druidDataSource.setPassword("123456");
        return druidDataSource;
    }

    @Bean
    public JdbcTemplate getJdbcTemplete(DruidDataSource dataSource){
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }

    @Bean
    public TransactionManager getTransactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
}
```

在想要进行事务的类或者方法上添加注解

```java
package com.pwddd.service.impl;

import com.pwddd.dao.UserDao;
import com.pwddd.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;

    @Override
    public void accountMoney() {
        userDao.reduceMoney();

        int i = 1/0;
        userDao.addMoney();
    }

}
```

#### 注解相关参数解释

在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数。

![image-20220129174135972](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174135972.png)

##### propagation：事务传播行为

![image-20220129174148321](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174148321.png)

![image-20220129174202951](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174202951.png)

##### ioslation：事务隔离级别

事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题。在隔离性中常见的三个问题是：脏读、不可重复读、虚（幻）读。

1. 脏读：一个未提交事务读取到另一个未提交事务的数据

![image-20220129174216392](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174216392.png)

2. 不可重复读：一个未提交事务读取到另一提交事务修改数据

![image-20220129174230775](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174230775.png)

3. 虚读：一个未提交事务读取到另一提交事务添加数据

解决以上问题，可以配置注解的相关参数。

![image-20220129174243791](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174243791.png)

##### timeout：超时时间

事务需要在一定时间内进行提交，如果不提交进行回滚。默认值是 -1 ，设置时间以秒单位进行计算。

##### readOnly：是否只读

读：查询操作，写：添加修改删除操作，readOnly 默认值 false，表示可以查询，可以添加修改删除操作。设置 readOnly 值是 true，设置成 true 之后，只能查询。

##### rollbackFor：回滚

设置出现哪些异常进行事务回滚

##### noRollbackFor：不回滚

设置出现哪些异常不进行事务回滚

### 基于XML配置事务

示例代码：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <context:component-scan base-package="com.pwddd" />
    <context:property-placeholder location="classpath:jdbc.properties" />
    <bean id="datasource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}" />
        <property name="password" value="${jdbc.password}" />
        <property name="username" value="${jdbc.username}" />
        <property name="url" value="${jdbc.url}" />
    </bean>
    <bean id="transcationManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="datasource" />
    </bean>

    <tx:advice id="txadvice">
        <tx:attributes>
            <tx:method name="accountMoney" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>

    <aop:config>
        <aop:pointcut id="pt" expression="execution(* com.pwddd.service.impl.UserServiceImpl.*(..))"/>
        <aop:advisor advice-ref="txadvice" pointcut-ref="pt" />
    </aop:config>

</beans>
```

## Spring5新特性

### 概述

> 整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除

### 整合日志框架

Spring 5.0 框架自带了通用的日志封装。并且已经移除 Log4jConfigListener，官方建议使用 Log4j2。

1. 导入Jar包

![image-20220129174259510](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129174259510.png)

2. 创建Log4j2.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="DEBUG">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
    </Appenders>
    <Loggers>
        <Root level="error">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
</Configuration>
```

### Nullable注解

@Nullable 注解可以使用在方法上面，属性上面，参数上面。表示方法返回可以为空，属性值可以 为空，参数值可以为空注解。

### 核心容器支持函数式风格

实例代码：

```JAVA
@Test
    public void testGenericApplicationContext() {
        //1 创建 GenericApplicationContext 对象
        GenericApplicationContext context = new GenericApplicationContext();
        //2 调用 context 的方法对象注册
        context.refresh();
        context.registerBean("user1",User.class,() -> new User());
        //3 获取在 spring 注册的对象
        // User user = (User)context.getBean("com.atguigu.spring5.test.User");
        User user = (User)context.getBean("user1");
        System.out.println(user);
    }
```

### 支持整合Junit5

1. 引入spring test的依赖包

2. 编写Junit4测试类

```JAVA
package com.pwddd.spring5new.test;

import com.pwddd.spring5new.config.SpringConfig;
import com.pwddd.spring5new.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class TestJunit {
    @Autowired
    private UserService userService;

    @Test
    public void testAdd(){
        userService.add();
    }
}
```

3. 整合Junit5

```JAVA
package com.pwddd.spring5new.test;

import com.pwddd.spring5new.config.SpringConfig;
import com.pwddd.spring5new.service.UserService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = SpringConfig.class)
public class TestJunit5 {
    @Autowired
    private UserService userService;
    @Test
    public void test(){
        userService.add();
    }
}
```

4. 使用一个注解代替上面的两个注解

```JAVA
//@ExtendWith(SpringExtension.class)
//@ContextConfiguration(classes = SpringConfig.class)
@SpringJUnitConfig(classes = SpringConfig.class)
```

### SpringWebflux

前置知识：SpringMVC、Java8新特性、SpringBoot

#TODO
## Spring整合MyBatis

目前我们开发功能的流程中，在service层会手动创建SQLSession对象，并使用SQLSession对象获取Mapper接口的实例化对象，但是我们真正使用的是Mapper接口的对象，目前的代码编写方式极大的影响了开发效率，而且mybatis层和service层之间的耦合性非常高。
使用SpringIOC技术实现service层和mybatis层的解耦：让Spring容器帮我们获取Mapper层接口的实例化 对象，我们直接从Spring容器中获取使用即可。
在业务层使用Spring容器对象获取Mapper接口实例化对象后，实现了service层和mybatis层的解耦，但是在controller层我们依然在Servlet中直接创建Service对象，耦合性过高。
将service对象配置为bean对象，Servlet中从Spring容器中，获取Service对象，完成功能开发。同时传统的获取Spring容器的方法写在每个Servlet的service方法中，假设每个请求调用service都要创建一个servlet，那么就会造成容器的资源浪费。

分别配置数据源，sqlSessionFactory，扫描Mapper

```xml
<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource" id="dataSource">
<property name="url" value="jdbc:mysql://localhost:3306/test?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai"/>
<property name="driverClassName" value="com.mysql.jdbc.Driver" />
<property name="username" value="root" />
<property name="password" value="123456" />
</bean>

<!--    配置sqlSessionFactory-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean" id="factory">
<property name="dataSource" ref="dataSource" />
</bean>

<!--    配置扫描mapper-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" id="mapperScanner">
<property name="sqlSessionFactory"  ref="factory"/>
<property name="basePackage" value="pers.jm.mapper"/>
</bean>
```

配置service层Bean
service层需要调用mapper层的方法，因此在service中需要mapper层的对象。在service层中声明mapper层的引用，并为之创建getset方法。

```java
UserMapper userMapper;

  public UserMapper getUserMapper() {
      return userMapper;
  }

  public void setUserMapper(UserMapper userMapper) {
      this.userMapper = userMapper;
  }
```

之后配置service层的bean,添加自动扫描mapper类的对象引用

```xml
<bean class="pers.jm.service.UserServiceImpl" id="userService">
    <property name="userMapper" ref="userMapper" />
</bean>
```

在web.xml加载spring的配置文件并设置监听器

```xml
<context-param>
    <param-name>contextConfigLocation</param-name><!--键名-->
    <param-value>classpath:applicationContext.xml</param-value><!--值-->
  </context-param>
  <listener>
    <listener-class>
      org.springframework.web.context.ContextLoaderListener
    </listener-class>
  </listener>
```

在servlet的init方法中，获取对象

```java
UserService userService;
@Override
public void init() throws ServletException {
    WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());
    userService = (UserService) webApplicationContext.getBean("userService");
}
```

至此，servlet → service → mapper 依赖配置完成

当服务器启动时，通过web.xml中配置的监听器，加载spring的配置文件，spring配置文件加载后，设置mybatis的数据源，sqlsession等并扫描创建对应的mapper对象。mapper对象创建后，根据配置创建service的对象，service对象中注入mapper层的对象引用。因此servlet获取service对象，实际上获取的是 有mapper引用的service层对象。