---
title: Springboot1 基础篇
date: 2022-04-28 03:11:00
permalink: /dev/java/core/springbootbase
author:
 name: p0jo
 link: https://wiki.pwddd.com
categories:
  - 开发
  - 后端
  - 微服务核心
tags:
  - Springboot
  - Spring
  - SpringMVC
---

# SpringBoot 基础 - 基于 1.5.9

## Springboot简介

Springboot是简化Spring应用开发的一个框架，其中整合了Spring技术栈，是J2EE开发的一站式解决方案。在传统的基于SSM框架进行项目开发的过程中，我们需要配置大量的配置文件，用于约束框架的功能和配置。Springboot基于“约定大于配置”的开发思想，各个组件的配置文件由Springboot帮助我们完成，我们只需要少量的配置即可搭建一个项目开发的基本环境，更专注于业务代码的编写。

使用Springboot的优点：

- 快速创建独立运行的Spring应用，并可以集成主流的框架
- 使用嵌入式的Servlet容器，应用无需打War包
- 使用starters进行自动依赖和版本控制
- 主流框架的自动默认配置，无代码生成，开箱即用
- 准生产环境的运行时监控
- 天然集成云计算

### 微服务

> [martinfowler.com](https://martinfowler.com/)

微服务是当前项目开发的热点。回顾传统的单体应用开发，我们整个项目默认是部署在同一台服务器上的，我们将编写好的项目打成war包，放到tomcat中运行。在用户量较少、项目较为简单的场景下没有什么异常，部署起来也相对方便。但是如果项目的访问量较大，我们服务器的资源压力较大，单体应用就无法支撑起用户的需求。在这种情况下，我们通常会将项目部署在多个服务器上，然后使用负载均衡将用户的访问分配到不同的服务器上。那么，如果只是单个功能访问量较大，比如：订单功能、会员功能，这种方式就会导致服务器的资源浪费。微服务的思想应运而生。

![image-20220225151642714](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220225151642714.png)

所谓微服务，就是将原本的单体应用抽离出多个功能模块，每个功能模块都可以单独部署。如果某个模块的访问要求较高，将不同模块之间的动态组合，部署到其他服务器上。每个功能模块都是可以独立替换和独立升级的单元。如下图所示：

![image-20220225151701348](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220225151701348.png)

## HelloWorld

#### helloworld编写

> 浏览器发送hello请求，服务器接收请求并将helloworld返回给浏览器。

1. 创建Maven工程，并导入springboot相关依赖。

   ```xml
   <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>1.5.9.RELEASE</version>
   </parent>
   
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
   </dependencies>
   ```

2. 编写主程序，用于启动springboot应用

   ```java
   package com.pwddd;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class SpringBootTestApplication {
       public static void main(String[] args) {
           SpringApplication.run(SpringBootTestApplication.class,args);
       }
   }
   ```

3. 编写controller处理用户请求

   ```java
   package com.pwddd.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.ResponseBody;
   
   @Controller
   public class HelloController {
   
       @GetMapping("/hello")
       @ResponseBody
       public String hello(){
           return "helloworld";
       }
   }
   ```

4. 运行主程序

5. Springboot应用打包

   - 导入Springboot项目插件

     ```xml
     <build>
         <plugins>
             <plugin>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-maven-plugin</artifactId>
             </plugin>
         </plugins>
     </build>
     ```

   - 运行maven -> package

   - java -jar运行

#### helloworld解析

##### 父项目版本仲裁

在创建Maven项目中，指定了Maven的父项目。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

该父项目又指定了另一个父项目。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>1.5.9.RELEASE</version>
    <relativePath>../../spring-boot-dependencies</relativePath>
</parent>
```

这个父项目中制定了相关组件的版本。

```xml
<properties>
    <!-- Dependency versions -->
    <activemq.version>5.14.5</activemq.version>
    <antlr2.version>2.7.7</antlr2.version>
    …………
```

##### 场景启动器

springboot starter是springboot的场景启动器，帮我们导入了相关模块运行的相关依赖。springboot将常见的功能场景抽离出来，我们使用时只需要引用相关的场景启动器，springboot会帮我们自动导入相关的依赖。

##### springboot应用的启动

在Springboot启动类上有`@SpringBootApplication`注解，该注解说明了该类是当前项目的主配置类，springboot项目可以运行该类的main方法启动项目。该注解是一个组合注解，又包含了以下的内容。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
```

`@SpringBootConfiguration`注解，标注springboot的配置类。

`@EnableAutoConfiguration`注解，开启了自动配置的功能。之前在使用SSM框架时，需要自己导入相关的依赖和配置，开启自动配置之后就可以自动完成相关配置。

在该注解中，包含了以下的注解内容：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";
```

`@AutoConfigurationPackage`: 自动配置包

自动配置包由如下的注解组成：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({Registrar.class})
public @interface AutoConfigurationPackage {
}
```

`@Import({Registrar.class})`: Import是Spring底层的注解，该注解给容器中导入一个组件。导入组件由`Registrar`定义。**该类将Application主配置类所在包下的所有子包中的组件添加扫描到Spring容器中。**

```java
 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());
        }
```

`EnableAutoConfigurationImportSelector`：自动配置导入的选择器。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。

```java
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    } else {
        try {
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            configurations = this.removeDuplicates(configurations);
            configurations = this.sort(configurations, autoConfigurationMetadata);
            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.filter(configurations, autoConfigurationMetadata);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return (String[])configurations.toArray(new String[configurations.size()]);
        } catch (IOException var6) {
            throw new IllegalStateException(var6);
        }
    }
}
```

其中Configuration中就包含了组件的全类名，由`this.getCandidateConfigurations(annotationMetadata, attributes);`方法获取，该方法中调用了`SpringFactoriesLoader.loadFactoryNames`。从配置文件中获取了全类名。

```java
Enumeration<URL> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");
```

Springboot在启动的时候从类路径下的`META-INF/spring.factories`中获取`EnableAutoConfiguration`指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。

## Springboot配置文件

springboot中有两种类型的配置文件：`application.properties`和`application.yml`。

配置文件的作用：Springboot在底层做好了组件的基本配置，当我们想要自定义配置时，就需要定义配置文件。

### YAML语法

#### 基本语法

YAML是基于键值对的语法模式，使用空格完成层级的缩进，只要是对齐的空格数，就认为是同一层级的。YAML相对于XML配置文件，更加关注数据。基本样式如下：

```yaml
server:
  port: 8081
```

#### 值语法

字面量：`k: v`字面量可以直接写，字符串默认不加单引号或者双引号。双引号不会转义字符串里面的特殊字符。而使用单引号会对特殊字符进行转义。

对象、Map：

```yaml
# 对象、map的写法
friends:
	lastName: zhangsan
	age: 20
	
# 对象、map的行内写法
friends: {lastName: zhangsan,age: 18}
```

数组：

```yaml
# 数组的写法
pets:
 - cat
 - dog
 - pig
# 数组的行内写法
pets: [cat,dog,pig]
```



### 配置文件值导入JavaBean

javaBean

```java
package com.pwddd.springboot.bean;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@ConfigurationProperties(prefix = "person")
@Component
public class Person {

    private String name;
    private Integer age;
    private boolean boss;
    private Map<String,String> maps;
    private List<String> lists;
    private Dog dog;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", boss=" + boss +
                ", maps=" + maps +
                ", lists=" + lists +
                ", dog=" + dog +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public boolean isBoss() {
        return boss;
    }

    public void setBoss(boolean boss) {
        this.boss = boss;
    }

    public Map<String, String> getMaps() {
        return maps;
    }

    public void setMaps(Map<String, String> maps) {
        this.maps = maps;
    }

    public List<String> getLists() {
        return lists;
    }

    public void setLists(List<String> lists) {
        this.lists = lists;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }
}

```

```java
package com.pwddd.bean;

public class Dog {
    private String name;
    private Integer age;

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public Dog() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
```

添加配置处理器，用来提示配置文件

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

编写配置文件

```yaml
person:
  name: zhangsan
  age: 12
  maps: {zhangsan: aaa,lisi: bbb}
  lists:
    - zhangsan
    - lisi
  dog:
    name: zhangsan
    age: 12
	
```

编写测试

```java
@SpringBootTest
class SpringbootApplicationTests {

    @Autowired
    Person person;

    @Test
    public void testProperties(){
        System.out.println(person);
    }
}
```

### 其他获取值的方法

```java
//@ConfigurationProperties(prefix = "person")
@Component
public class Person {

    private String name;
    @Value("${person.age}")
    private Integer age;
```

ConfigurationProperties和Value的区别：

|                      | @ConfigurationProperties | @Value     |
| -------------------- | ------------------------ | ---------- |
| 功能                 | 批量注入配置文件中的属性 | 一个个指定 |
| 松散绑定（松散语法） | 支持                     | 不支持     |
| SpEL                 | 不支持                   | 支持       |
| JSR303数据校验       | 支持                     | 不支持     |
| 复杂类型封装         | 支持                     | 不支持     |

如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。

### 配置文件注入值数据校验

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {
/**
* <bean class="Person">
* <property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#
{SpEL}"></property>
* <bean/>
*/
//lastName必须是邮箱格式
@Email
//@Value("${person.last‐name}")
private String lastName;
//@Value("#{11*2}")
private Integer age;
//@Value("true")
private Boolean boss;
private Date birth;
private Map<String,Object> maps;
private List<Object> lists;
private Dog dog;

```

### @PropertieSource

`@PropertieSource`:加载指定的配置文件。默认从全局配置文件中加载配置，如果需要指定其他的配置文件的位置，就可以使用该注解。

`@ImportResource`：导入Spring的配置文件，让配置文件里面的内容生效。SpringBoot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。想让Spring的配置文件生效，加载进来。

```java
@ImportResource(locations = {"classpath:beans.xml"})
//导入Spring的配置文件让其生效
```

SpringBoot推荐给容器中添加组件的方式，推荐使用全注解的方式。

1. 配置类添加`@Configuration`注解，指明当前类是一个配置类。

2. 使用`@Bean`给容器中添加组件

```java
package com.pwddd.springboot.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class MyAppConfig {
//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
    
}
```

### 配置文件占位符

#### 随机数

```yaml
${random.value}、${random.int}、${random.long}
${random.int(10)}、${random.int[1024,65536]}
```

#### 占位符获取配置值

```yaml
person.last‐name=张三${random.uuid}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=${person.hello:hello}_dog
person.dog.age=15
```

### profile多环境支持

我们在主配置文件编写的时候，文件名可以是 `application-{profile}.properties/yml`。

默认使用application.properties的配置。当我们需要激活指定的配置文件时，可以在主配置文件中指定：`spring.profiles.active=dev`或者使用命令行方式`java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev`，或者使用虚拟机方式`-Dspring.profiles.active=dev`。



### yml多文档块模式

```yaml
server:
 port: 8081
 spring:
 profiles:
 active: prod
‐‐‐
server:
 port: 8083
 spring:
 profiles: dev
‐‐‐
server:
 port: 8084
 spring:
 profiles: prod #指定属于哪个环境
```

### 配置文件的加载

springboot启动会扫描以下位置的`application.properties`或者`application.yml`文件作为Springboot的默认配置文件。

```text
–file:./config/  当前项目的config目录
–file:./
–classpath:/config/
–classpath:/
```

**优先级由高到底**，高优先级的配置会覆盖低优先级的配置。只要以上的配置文件存在Springboot就会加载，形成配置文件的互补。

我们还可以通过spring.config.location来改变默认的配置文件位置(**使用命令行参数的方式**)：

```yaml
java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev --spring.config.location=xxx
```

这个配置文件的位置会和其他位置上的配置文件共同加载。

SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会 形成互补配置。

1. 命令行参数
2. 来自java:comp/env的JNDI属性
3. Java系统属性（System.getProperties()）
4. 操作系统环境变量
5. RandomValuePropertySource配置的random.*属性值
6. jar包外部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件
7. jar包内部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件
8. jar包外部的`application.properties`或`application.yml`(不带spring.profile)配置文件
9. jar包内部的`application.properties`或`application.yml`(不带spring.profile)配置文件
10. `@Configuration`注解类上的`@PropertySource`
11. 通过`SpringApplication.setDefaultProperties`指定的默认属性



### 自动配置原理

配置文件能够配置的属性可以参考：[Springboot配置文件](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties)

1. Springboot启动类上有一个注解`@SpringBootApplication`，该注解是一个组合注解

   ```java
   @Target({ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   @Inherited
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(
       excludeFilters = {@Filter(
       type = FilterType.CUSTOM,
       classes = {TypeExcludeFilter.class}
   ), @Filter(
       type = FilterType.CUSTOM,
       classes = {AutoConfigurationExcludeFilter.class}
   )}
   )
   public @interface SpringBootApplication {
   ```

2. 其中有一个`@EnableAutoConfiguration`，该注解就是实现自动配置有关的注解。

   ```java
   @Target({ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   @Inherited
   @AutoConfigurationPackage
   @Import({AutoConfigurationImportSelector.class})
   public @interface EnableAutoConfiguration {
   ```

3. 其中`@Import`导入了一个自动配置导入选择器，在该选择器中，有一个方法，将所有的自动配置全类名保存到一个configurations中。

   ```java
       protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
           if (!this.isEnabled(annotationMetadata)) {
               return EMPTY_ENTRY;
           } else {
               AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
               List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
               configurations = this.removeDuplicates(configurations);
               Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
               this.checkExcludedClasses(configurations, exclusions);
               configurations.removeAll(exclusions);
               configurations = this.getConfigurationClassFilter().filter(configurations);
               this.fireAutoConfigurationImportEvents(configurations, exclusions);
               return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
           }
       }
   ```

4. 获取configuration的方法是`getCandidateConfigurations`。

   ```java
       protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
           List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
           Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
           return configurations;
       }
   ```

5. 该方法中调用了`SpringFactoriesLoader`中的`loadFactoryNames`获取到了所有的配置文件中配置的Auto Configuration全类名。

   ```java
   Enumeration urls = classLoader.getResources("META-INF/spring.factories");
   ```

6. 该方法扫描所有Jar包下的`META-INF/spring.factories`，把扫描到的这些文件的内容包装成properties对象，从properties中获取到`EnableAutoConfiguration.class`类(类名)对应的值，然后把他们添加在容器中。

7. 每一个这样的`xxxAutoConfiguration`类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。

8. 以`HttpEncodingAutoConfiguration`（Http编码自动配置）为例解释自动配置原理。

   ```java
   @Configuration(
       proxyBeanMethods = false
   )  // //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
   @EnableConfigurationProperties({ServerProperties.class})  ////启动指定类的ConfigurationProperties功能；将配置文件中对应的值和ServerProperties绑定起来；并把ServerProperties加入到ioc容器中
   
   @ConditionalOnWebApplication(
       type = Type.SERVLET
   )  // n //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效
   
   @ConditionalOnClass({CharacterEncodingFilter.class})  //判断当前项目有没有这个类, CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
   
   @ConditionalOnProperty(
       prefix = "server.servlet.encoding",
       value = {"enabled"},
       matchIfMissing = true
   ) // //判断配置文件中是否存在某个配置 server.servlet.encoding；如果不存在，判断也是成立的
   //即使我们配置文件中不配置server.servlet.encoding=true，也是默认生效的；
   public class HttpEncodingAutoConfiguration {
       
       // 和encoding做映射，encoding类中配置对应的相关配置文件的内容，加上上面的前缀。
       private final Encoding properties;
   
       //只有一个有参构造器的情况下，参数的值就会从容器中拿
       public HttpEncodingAutoConfiguration(ServerProperties properties) {
           this.properties = properties.getServlet().getEncoding();
       }
   
       @Bean  ////给容器中添加一个组件，这个组件的某些值需要从properties中获取
       @ConditionalOnMissingBean  //判断容器没有这个组件？
       public CharacterEncodingFilter characterEncodingFilter() {
           CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
           filter.setEncoding(this.properties.getCharset().name());
           filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));
           filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));
           return filter;
       }
   ```

9. 根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。

10. 所有在配置文件中能配置的属性都是在`xxxxProperties`类中封装的，配置文件能配置什么就可以参照某个功能对应的这个属性类。

    ```java
    public class Encoding {
        public static final Charset DEFAULT_CHARSET;
        private Charset charset;
        private Boolean force;
        private Boolean forceRequest;
        private Boolean forceResponse;
        private Map<Locale, Charset> mapping;
    ```



### Springboot的精髓

- SpringBoot启动会加载大量的自动配置类
- 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类
- 我们再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）
- 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。



### @Conditional派生注解

作用：对生效条件进行判断，必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。

| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |
| ------------------------------- | ------------------------------------------------ |
| @ConditionalOnJava              | 系统的java版本是否符合要求                       |
| @ConditionalOnBean              | 容器中存在指定Bean                               |
| @ConditionalOnMissingBean       | 容器中不存在指定Bean                             |
| @ConditionalOnExpression        | 满足SpEL表达式指定                               |
| @ConditionalOnClass             | 系统中有指定的类                                 |
| @ConditionalOnMissingClass      | 系统中没有指定的类                               |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |
| @ConditionalOnWebApplication    | 当前是web环境                                    |
| @ConditionalOnNotWebApplication | 当前不是web环境                                  |
| @ConditionalOnJndi              | JNDI存在指定项                                   |

因此，我们自动配置类需要在该类满足配置以上注解的条件下才能使用，我们可以在配置文件中开启debug模式，该模式可以打印自动配置报告，在该报告中标明了哪些类生效，哪些类不生效。

```text

============================
CONDITIONS EVALUATION REPORT
============================


Positive matches:
-----------------

   AopAutoConfiguration matched:
      - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)

   AopAutoConfiguration.ClassProxyingConfiguration matched:
      - @ConditionalOnMissingClass did not find unwanted class 'org.aspectj.weaver.Advice' (OnClassCondition)
      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)

   DispatcherServletAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition)
      - found 'session' scope (OnWebApplicationCondition)

   DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched:
      - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition)
      - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)

   DispatcherServletAutoConfiguration.DispatcherServletRegistrationConfiguration matched:
      - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition)
      - DispatcherServlet Registration did not find servlet registration bean (DispatcherServletAutoConfiguration.DispatcherServletRegistrationCondition)

……………………

Negative matches:
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)

   AopAutoConfiguration.AspectJAutoProxyingConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)

 …………………

Exclusions:
-----------

    None


Unconditional classes:
----------------------

    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration

    org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration

    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration

    org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration

    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration

```

## 日志

场景：小张在开发一个大型的系统，在系统中为了调试方便，小张使用`System.out.Print`打印了一些调试信息。有一天，领导说想要将打印的信息移除掉，虽然很困难，小张还是将自己写的`System.out`一行一行的删掉了。删除之后，领导说小张写的调试输出还是很有用的，想要重新加上，并且最好能够输出到一个文件中去。于是小张写了一个日志的框架`zhanglogging.jar`，调用框架中的api打印日志并且输出到文件中。过了一段时间，小张想给他的框架中添加一些功能，于是写了一个`zhanglogging-better.jar`。那么怎么替换项目中的日志框架呢？还需要重新将使用过日志的地方替换为新的日志框架。小张想到了JDBC，JDBC提供了一个数据库的连接器，后面的实现用的不同的具体实现的jar。于是小张写了一个日志的抽象层，项目中引用了日志的抽象层，然后具体的日志jar实现了抽象层。下次如果更新就可以直接替换具体的实现就好了。

主流的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……

但是这些框架并不都是日志的具体实现。

| 日志门面 （日志的抽象层）                                    | 日志实现                                            |
| ------------------------------------------------------------ | --------------------------------------------------- |
| JCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for Java） 、jboss-logging | Log4j 、JUL（java.util.logging） 、Log4j2 、Logback |

我们在项目中最好是使用日志的抽象层，然后选择一个具体的实现。这样在切换日志框架时就只需要替换掉日志的具体实现就好了。其中log4j、logback和slf4j是同一个作者研发的。slf4j是抽象层（门面）,logback是log4j的功能升级版。

springboot默认选用的日志框架是slf4j和logback的组合，而spring默认使用的是JCL。

### SLF4J的使用方法

[SLF4J官网](https://www.slf4j.org/)

以后开发的时候，日志记录方法的调用不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。并且给系统里面导入slf4j的jar和 logback的实现jar。

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HelloWorld {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(HelloWorld.class);
        logger.info("Hello World");
    }
}
```

![image-20220226092435951](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220226092435951.png)

每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。

### 日志的统一

在项目中，不同的组件可能使用的不同的日志框架。那么我们怎么使用统一的log4j框架呢？

![image-20220226092734205](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220226092734205.png)

我们需要将所有的日志框架都统统一到slf4j+logback的组合：

1. 去除之前项目中的日志框架
2. 添加`xxx-over-slf4j.jar`，这个jar包内部的包名是原来的日志框架，具体实现是调用slf4j的api，然后再由slf4j调用具体的日志实现框架。
3. 导入slf4j的其他实现。

### springboot的日志关系

每个springboot场景启动器中都会包含一个springboot的启动器。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter</artifactId>
</dependency>

```

该启动器中又包含了一个日志的启动器

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter</artifactId>
</dependency>

```

底层的依赖关系：

![image-20220226093407210](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220226093407210.png)

如果需要引入其他框架，首先就需要将该框架的日志包排除出去，然后使用`xxx-over-slf4j.jar`，统一到slf4j上。

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring‐core</artifactId>
    <exclusions>
        <exclusion>
            <groupId>commons‐logging</groupId>
            <artifactId>commons‐logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>

```

### 日志的使用方法

```java
//记录器
Logger logger = LoggerFactory.getLogger(getClass());
@Test
public void contextLoads() {
    //System.out.println();
    //日志的级别；
    //由低到高 trace<debug<info<warn<error
    //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效
    logger.trace("这是trace日志...");
    logger.debug("这是debug日志...");
    //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root
    级别
        logger.info("这是info日志...");
    logger.warn("这是warn日志...");
    logger.error("这是error日志...");
}

```

日志输出的格式设置：

```text
日志输出格式：
%d表示日期时间，
%thread表示线程名，
%‐5level：级别从左显示5个字符宽度
%logger{50} 表示logger名字最长50个字符，否则按照句点分割。
%msg：日志消息，
%n是换行符
%d{yyyy‐MM‐dd HH:mm:ss.SSS} [%thread] %‐5level %logger{50} ‐ %msg%n

```

Springboot修改配置文件修改日志：

```properties
logging.level.com.atguigu=trace
#logging.path=
# 不指定路径在当前项目下生成springboot.log日志
# 可以指定完整的路径；
#logging.file=G:/springboot.log
# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
logging.path=/spring/log
# 在控制台输出的日志的格式
logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n
# 指定文件中日志输出的格式
logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n
```



| logging.file | logging.path | Example  | Description                        |
| ------------ | ------------ | -------- | ---------------------------------- |
| (none)       | (none)       |          | 只在控制台输出                     |
| 指定文件名   | (none)       | my.log   | 输出日志到my.log文件               |
| (none)       | 指定目录     | /var/log | 输出到指定目录的 spring.log 文件中 |



### 日志配置文件

给类路径下放上每个日志框架自己的配置文件，SpringBoot就不使用他默认配置。

| Logging System          | Customization                                                |
| ----------------------- | ------------------------------------------------------------ |
| Logback                 | logback-spring.xml , logback-spring.groovy , logback.xml or logback.groovy |
| Log4j2                  | log4j2-spring.xml or log4j2.xml                              |
| JDK (Java Util Logging) | logging.properties                                           |

其中，可以使用`logback-spring.xml`配置文件，该配置文件可以根据环境profile，选择不同的配置。该配置文件会被springboot识别，而`logback.xml`将会被logback组件直接识别，其中不能编写相关的其他配置。

```xml
<springProfile name="staging">
    <!‐‐ configuration to be enabled when the "staging" profile is active ‐‐>
    可以指定某段配置只在某个环境下生效
</springProfile>

<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
    <!‐‐
    日志输出格式：
    %d表示日期时间，
    %thread表示线程名，
    %‐5level：级别从左显示5个字符宽度
    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。
    %msg：日志消息，
    %n是换行符
    ‐‐>
    <layout class="ch.qos.logback.classic.PatternLayout">
        <springProfile name="dev">
            <pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐‐‐> [%thread] ‐‐‐> %‐5level
                %logger{50} ‐ %msg%n</pattern>
        </springProfile>
        <springProfile name="!dev">
            <pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ==== [%thread] ==== %‐5level
                %logger{50} ‐ %msg%n</pattern>
        </springProfile>
    </layout>
</appender>

```

### 切换日志框架为slf4j+log4j

首先将logback排除，然后将log4j-over-slf4j排除，引入slf4j-log4j12

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>logback‐classic</artifactId>
            <groupId>ch.qos.logback</groupId>
        </exclusion>
        <exclusion>
            <artifactId>log4j‐over‐slf4j</artifactId>
            <groupId>org.slf4j</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j‐log4j12</artifactId>
</dependency>
```

这么做没有什么意义，因为logback是log4j的升级版本，通常情况下，我们会使用log4j2。



### 切换日志框架slf4j+log4j2

首先将starter-logging排除，使用starter-log4j2

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring‐boot‐starter‐logging</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐log4j2</artifactId>
</dependency>

```

## Web开发

使用Springboot进行web开发的流程：

1. 创建Springboot应用，并选择相关的组件
2. 编写少量的配置文件
3. 编写业务代码

### Springboot对静态资源的处理

Springboot对静态资源的自动配置相关参数在下面这个类里面完成的。

```java
@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
public class ResourceProperties implements ResourceLoaderAware {
//可以设置和静态资源有关的参数，缓存时间等
```

SpringMVC相关的自动配置都会配置到WebMvcAutoConfiguration中，下面的内容是导入webjars导入静态资源的方式：

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug("Default resource handling disabled");
        return;
    }
    Integer cachePeriod = this.resourceProperties.getCachePeriod();
    if (!registry.hasMappingForPattern("/webjars/**")) {
        customizeResourceHandlerRegistration(
            registry.addResourceHandler("/webjars/**")
            .addResourceLocations(
                "classpath:/META-INF/resources/webjars/")
            .setCachePeriod(cachePeriod));
    }
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(
            registry.addResourceHandler(staticPathPattern)
            .addResourceLocations(
                this.resourceProperties.getStaticLocations())
            .setCachePeriod(cachePeriod));
    }
}
```

通过webjars我们可以使用jar包的方式将静态资源引入项目中。对于请求中`/webjars`下的任意请求都去`classpath:/META-INF/resources/webjars/`这个路径去寻找。

```java
String staticPathPattern = this.mvcProperties.getStaticPathPattern();
```

这行代码获取了`/**`的路径，访问当前项目的所有资源如果没人处理，默认从resourceProperties中获取静态路径，配置的静态路径是：

```java
	private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
			"classpath:/META-INF/resources/", "classpath:/resources/",
			"classpath:/static/", "classpath:/public/" };

	private static final String[] RESOURCE_LOCATIONS;

	static {
		RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length
				+ SERVLET_RESOURCE_LOCATIONS.length];
		System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,
				SERVLET_RESOURCE_LOCATIONS.length);
		System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,
				SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);
	}

	/**
	 * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
	 * /resources/, /static/, /public/] plus context:/ (the root of the servlet context).
	 */
	private String[] staticLocations = RESOURCE_LOCATIONS;
```

因此，对于`/**`的访问路径，如果没有人处理就访问下面的几个路径寻找资源:

```text
"classpath:/META-INF/resources/"
"classpath:/resources/",
"classpath:/static/"
"classpath:/public/" 
```

对于欢迎页的访问映射，映射到每个静态资源文件夹中的所有`index.html`。

```java
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(
    ResourceProperties resourceProperties) {
    return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),
                                         this.mvcProperties.getStaticPathPattern());  //private String staticPathPattern = "/**";
}

private String[] getStaticWelcomePageLocations() {
    String[] result = new String[this.staticLocations.length];
    for (int i = 0; i < result.length; i++) {
        String location = this.staticLocations[i];
        if (!location.endsWith("/")) {
            location = location + "/";
        }
        result[i] = location + "index.html";
    }
    return result;
}
```

对于图标的映射

```java
@Configuration
@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)
public static class FaviconConfiguration {

    private final ResourceProperties resourceProperties;

    public FaviconConfiguration(ResourceProperties resourceProperties) {
        this.resourceProperties = resourceProperties;
    }

    @Bean
    public SimpleUrlHandlerMapping faviconHandlerMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
        mapping.setUrlMap(Collections.singletonMap("**/favicon.ico",     // 还是在静态资源文件夹下寻找
                                                   faviconRequestHandler()));
        return mapping;
    }


    List<Resource> getFaviconLocations() {
        List<Resource> locations = new ArrayList<Resource>(
            this.staticLocations.length + 1);
        if (this.resourceLoader != null) {
            for (String location : this.staticLocations) {
                locations.add(this.resourceLoader.getResource(location));
            }
        }
        locations.add(new ClassPathResource("/"));
        return Collections.unmodifiableList(locations);
    }
```

### Thymeleaf模板引擎

Springboot是以Jar的方式打包，并且嵌入式的tomcat并不支持jsp，springboot推荐使用thymeleaf模板引擎进行开发。

![image-20220226214338631](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220226214338631.png)

引入thymeleaf模板引擎的方法

```xml
<properties>
    <thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>
    <!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 -->
    <!-- thymeleaf2 layout1 -->
    <thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>
</properties>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

Thymeleaf的自动配置，默认帮我们添加了模板解析器等组件，而默认规则配置在`ThymeleafProperties`中

```java
@ConfigurationProperties(prefix = "spring.thymeleaf")
public class ThymeleafProperties {

    private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8");

    private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html");

    public static final String DEFAULT_PREFIX = "classpath:/templates/";

    public static final String DEFAULT_SUFFIX = ".html";
```

根据以上的配置，只需要将我们的thymeleaf模板放置到`classpath:/templates/`中，并以html结尾，就可以被Thymeleaf模板引擎解析。

#### 使用方法

1. 导入thymeleaf名称空间

```html
<html lang="en" xmlns:th="http://www.thymeleaf.org">
```

2. Thymeleaf语法：参考[文档下载](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.pdf)

3. 标签

![image-20220226215304593](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220226215304593.png)

4. 表达式

```text
简单表达式：
变量表达式 ${...}：获取变量值；OGNL；
	1）、获取对象的属性、调用方法
	2）、使用内置的基本对象：
	#ctx : the context object.
    #vars: the context variables.
    #locale : the context locale.
    #request : (only in Web Contexts) the HttpServletRequest object.
    #response : (only in Web Contexts) the HttpServletResponse object.
    #session : (only in Web Contexts) the HttpSession object.
    #servletContext : (only in Web Contexts) the ServletContext object.
    ${session.foo}
内置的一些工具对象：
    #execInfo : information about the template being processed.
    #messages : methods for obtaining externalized messages inside variables expressions, in the
    same way as they would be obtained using #{…} syntax.
    #uris : methods for escaping parts of URLs/URIs
    #conversions : methods for executing the configured conversion service (if any).
    #dates : methods for java.util.Date objects: formatting, component extraction, etc.
    #calendars : analogous to #dates , but for java.util.Calendar objects.
    #numbers : methods for formatting numeric objects.
    #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
    #objects : methods for objects in general.
    #bools : methods for boolean evaluation.
    #arrays : methods for arrays.
    #lists : methods for lists.
    #sets : methods for sets.
    #maps : methods for maps.
    #aggregates : methods for creating aggregates on arrays or collections.
    #ids : methods for dealing with id attributes that might be repeated (for example, as a
    result of an iteration).
选择变量表达式 *{...}：选择表达式：和${}在功能上是一样
	补充：配合 th:object="${session.user}：
    <div th:object="${session.user}">
    <p>Name: <span th:text="*{firstName}">Sebastian</span>.</p>
    <p>Surname: <span th:text="*{lastName}">Pepper</span>.</p>
    <p>Nationality: <span th:text="*{nationality}">Saturn</span>.</p>
    </div>
Message Expressions: #{...}：获取国际化内容
Link URL Expressions: @{...}：定义URL；
	@{/order/process(execId=${execId},execType='FAST')}
Fragment Expressions: ~{...}：片段引用表达式
	<div th:insert="~{commons :: main}">...</div>
Literals（字面量）
    Text literals: 'one text' , 'Another one!' ,…
    Number literals: 0 , 34 , 3.0 , 12.3 ,…
    Boolean literals: true , false
    Null literal: null
    Literal tokens: one , sometext , main ,…
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is ${name}|
Arithmetic operations:（数学运算）
    Binary operators: + , ‐ , * , / , %
    Minus sign (unary operator): ‐
    Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    Comparisons and equality:（比较运算）
    Comparators: > , < , >= , <= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    Conditional operators:条件运算（三元运算符）
    If‐then: (if) ? (then)
    If‐then‐else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
Special tokens:
	No‐Operation: _
```

### SpringMVC自动配置

Springboot帮我们完成了Springmvc的自动配置，定义在`WebMvcAutoConfiguration`中。

Spring Boot provides auto-configuration for Spring MVC that works well with most applications.

The auto-configuration adds the following features on top of Spring’s defaults:

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.

  - 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染）
  - ContentNegotiatingViewResolver：用于组合所有的视图解析器
  - 我们可以自己给容器中添加一个视图解析器，会自动将其组合进来。

- Support for serving static resources, including support for WebJars (see below).

- Automatic registration of `Converter`, `GenericConverter`, `Formatter` beans.

  - Converter：转换器； public String hello(User user)：类型转换使用Converter
  - Formatter 格式化器； 2017.12.17==>Date

- Support for `HttpMessageConverters` (see below).

  - HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json
  - HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter.
  - 自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中 （@Bean,@Component）

- Automatic registration of `MessageCodesResolver` (see below).

  - 定义错误代码生成规则

- Static `index.html` support.

- Custom `Favicon` support (see below).

- Automatic use of a `ConfigurableWebBindingInitializer` bean (see below).

  - 我们可以配置一个ConfigurableWebBindingInitializer来替换默认的。（添加到容器）

If you want to keep Spring Boot MVC features, and you just want to add additional [MVC configuration](https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc) (interceptors, formatters, view controllers etc.) you can add your own `@Configuration` class of type `WebMvcConfigurerAdapter`, but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` or `ExceptionHandlerExceptionResolver` you can declare a `WebMvcRegistrationsAdapter` instance providing such components.

If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.

如果我们想要拓展SpringMVC相关配置，如拦截器，资源映射等：

```xml
<mvc:view‐controller path="/hello" view‐name="success"/>
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/hello"/>
        <bean></bean>
    </mvc:interceptor>
</mvc:interceptors>

```

我们就需要编写一个配置类，继承`WebMvcConfigurerAdapter`。

```java
//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // super.addViewControllers(registry);
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController("/atguigu").setViewName("success");
    }
}

```

原因：

1. WebMvcAutoConfiguration是SpringMVC的自动配置类
2. 在做其他自动配置时会导入`@Import(EnableWebMvcConfiguration.class)`
3. 容器中所有的WebMvcConfigurer都会一起起作用，我们自己编写的也会被调用

```java
@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    //从容器中获取所有的WebMvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List<WebMvcConfigurer> configurers) {
        if (!CollectionUtils.isEmpty(configurers)) {
            this.configurers.addWebMvcConfigurers(configurers);
            //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；
            @Override
            // public void addViewControllers(ViewControllerRegistry registry) {
            // for (WebMvcConfigurer delegate : this.delegates) {
            // delegate.addViewControllers(registry);
            // }
        }
    }
}
```

全面接管SpringMVC

当我们想要配置SPringMVC的所有细节时，可以使用`@EnableWebMvc`注解，标注到配置类上。

```java
//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@EnableWebMvc
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // super.addViewControllers(registry);
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController("/atguigu").setViewName("success");
    }
}

```

原理：

1. @EnableWebMvc的核心

```java
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
```

2. ```java
   @Configuration
   public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
   ```

3. ```java
   @Configuration
   @ConditionalOnWebApplication
   @ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
                        WebMvcConfigurerAdapter.class })
   //容器中没有这个组件的时候，这个自动配置类才生效
   @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
   @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
   @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
                        ValidationAutoConfiguration.class })
   public class WebMvcAutoConfiguration {
   
   ```

4. @EnableWebMvc将WebMvcConfigurationSupport组件导入进来



### 修改Spingboot默认配置

SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有，就用用户配置的。如果没有，才自动配置。如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来使用。

在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置。在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置

### RestFulCRUD

#### 1. 引入静态资源

根据上面的Springboot关于静态资源的自动配置，我们只需要将静态资源放置到指定的目录中，如果服务器处理不了指定的请求，就会去静态资源文件夹下寻找。我们在页面中引入静态资源时，也可以使用`thymeleaf`的语法，这样在请求时就可以排除项目名称对于静态资源的影响了。

#### 2. 国际化信息

- 创建国际化配置文件

  ```properties
  # ========= 默认properties
  login.btn=登录~
  login.password=密码~
  login.remember=记住我~
  login.tip=请登录~
  login.username=用户名~
  
  # ========= Login_en_US
  login.btn=Login In.
  login.password=Password
  login.remember=Remember Me.
  login.tip=Please login.
  login.username=Username
  
  # ========= Login_zh_CN
  login.btn=登录
  login.password=密码
  login.remember=记住我
  login.tip=请登录
  login.username=用户名
  ```

- 由于springboot已经帮助我们配置好了，我们只需要在页面上取值就可以了。但是由于默认配置的路径是类路径下的message，我们的国际化文件放置在i18n目录下，需要在springboot配置文件中指定路径。

  ```java
  @Configuration
  @ConditionalOnMissingBean(value = MessageSource.class, search = SearchStrategy.CURRENT)
  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
  @Conditional(ResourceBundleCondition.class)
  @EnableConfigurationProperties
  @ConfigurationProperties(prefix = "spring.messages")
  public class MessageSourceAutoConfiguration {
  
      private String basename = "messages";
  
      @Bean
      public MessageSource messageSource() {
          ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
          if (StringUtils.hasText(this.basename)) {
              messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(
                  StringUtils.trimAllWhitespace(this.basename)));
          }
          if (this.encoding != null) {
              messageSource.setDefaultEncoding(this.encoding.name());
          }
          messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);
          messageSource.setCacheSeconds(this.cacheSeconds);
          messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);
          return messageSource;
      }
  ```

  ```yml
  spring:
    messages:
      basename: i18n/login
  ```

- Thymeleaf获取国际化的值

  ```html
  <!DOCTYPE html>
  <html lang="en" xmlns:th="https://www.thymeleaf.org">
  	<head>
  		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  		<meta name="description" content="">
  		<meta name="author" content="">
  		<title>Signin Template for Bootstrap</title>
  		<!-- Bootstrap core CSS -->
  		<link th:href="@{/asserts/css/bootstrap.min.css}" rel="stylesheet">
  		<!-- Custom styles for this template -->
  		<link th:href="@{/asserts/css/signin.css}" rel="stylesheet">
  	</head>
  
  	<body class="text-center">
  		<form class="form-signin" action="dashboard.html">
  			<img class="mb-4" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72">
  			<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>
  			<label class="sr-only" th:text="#{login.username}">Username</label>
  			<input type="text" class="form-control" th:placeholder="#{login.username}" placeholder="Username" required="" autofocus="">
  			<label class="sr-only" th:text="#{login.password}">Password</label>
  			<input type="password" class="form-control" th:placeholder="#{login.password}" placeholder="Password" required="">
  			<div class="checkbox mb-3">
  				<label>
            <input type="checkbox" value="remember-me"> [[#{login.remember}]]
          </label>
  			</div>
  			<button class="btn btn-lg btn-primary btn-block" type="submit">[[#{login.btn}]]</button>
  			<p class="mt-5 mb-3 text-muted">© 2017-2018</p>
  			<a class="btn btn-sm">中文</a>
  			<a class="btn btn-sm">English</a>
  		</form>
  
  	</body>
  
  </html>	
  ```

springboot完成国际化的原理：

服务器知道我们需要进行国际化的语言，是因为我们在发送请求时，请求包携带了一个`Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7`字段，服务器根据该字段将指定的国际化页面返回。有时候我们希望自定义国际化的规则，比如在请求参数中携带当前页面的国际化参数。

```html
<a class="btn btn-sm" th:href="@{/index(language='zh_CN')}">中文</a>
<a class="btn btn-sm" th:href="@{/index(language='en_US')}">English</a>
```

自定义国际化处理器：

```java
package com.pwddd.springboot.component;

import org.apache.tomcat.jni.Local;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

public class ParamLocalResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest httpServletRequest) {
        String language = httpServletRequest.getParameter("language");
        Locale locale = Locale.getDefault();
        if (!StringUtils.isEmpty(language)){
            String[] s = language.split("_");
            locale = new Locale(s[0],s[1]);
        }else{
            String languages = httpServletRequest.getHeader("Accept-Language");
            String defaultLanguage = languages.split(",")[0];
            String[] split = defaultLanguage.split("-");
            locale = new Locale(split[0],split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {

    }
}

```

注册国际化处理器，将我们自己的国际化处理器放到容器中。

```java
@Bean
public LocaleResolver localeResolver(){
    return new ParamLocalResolver();
}
```

#### 3. 登录功能

这次设计的登录功能就不需要链接数据库了，只要提交了用户名，并且密码为123456就判定为登录成功。

- 控制器设置

  ```java
  package com.pwddd.springboot.controller;
  
  import org.springframework.stereotype.Controller;
  import org.springframework.util.StringUtils;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PostMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  import java.util.Map;
  
  @Controller
  @RequestMapping("/user")
  public class UserController {
  
      @PostMapping("/login")
      public String login(@RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){
          if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){
              return "dashboard";
          }else {
              map.put("msg","登陆失败，请确认用户名密码是否正确~");
              return "login";
          }
      }
  }
  
  ```

- 错误信息显示

  ```html
  <p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}" ></p>
  当msg不是空的时候显示。
  ```

- 处理登录信息重复提交 - 使用重定向

  ```java
  // 设置视图解析
  registry.addViewController("/main").setViewName("dashboard");
  
  // 修改控制器
  package com.pwddd.springboot.controller;
  
  import org.springframework.stereotype.Controller;
  import org.springframework.util.StringUtils;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PostMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  import java.util.Map;
  
  @Controller
  @RequestMapping("/user")
  public class UserController {
  
      @PostMapping("/login")
      public String login(@RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){
          if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){
              return "redirect:/main";
          }else {
              map.put("msg","登陆失败，请确认用户名密码是否正确~");
              return "login";
          }
      }
  }
  
  ```

- 登录拦截器机制

  ```java
  // 登录添加cookie
  package com.pwddd.springboot.controller;
  
  import org.springframework.stereotype.Controller;
  import org.springframework.util.StringUtils;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PostMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  import javax.servlet.http.HttpSession;
  import java.util.Map;
  
  @Controller
  @RequestMapping("/user")
  public class UserController {
  
      @PostMapping("/login")
      public String login(HttpSession httpSession,
                          @RequestParam("username") String username, @RequestParam("password") String password, Map<String,Object> map){
          if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password) && password.equals("123456")){
              httpSession.setAttribute("username",username);
              return "redirect:/main";
          }else {
              map.put("msg","登陆失败，请确认用户名密码是否正确~");
              return "login";
          }
      }
  }
  
  
  // 设置拦截器
  package com.pwddd.springboot.component;
  
  import org.springframework.util.StringUtils;
  import org.springframework.web.servlet.HandlerInterceptor;
  import org.springframework.web.servlet.ModelAndView;
  
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import javax.servlet.http.HttpSession;
  
  public class LoginHandlerInterceptor implements HandlerInterceptor {
      @Override
      public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
          // 从Session获取信息
          HttpSession session = httpServletRequest.getSession();
          String username = (String) session.getAttribute("username");
          if (StringUtils.isEmpty(username)){
              httpServletRequest.setAttribute("msg","没有权限使用~");
              httpServletRequest.getRequestDispatcher("/index").forward(httpServletRequest,httpServletResponse);
  
              return false;
          }else {
              return true;
          }
      }
  
      @Override
      public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
  
      }
  
      @Override
      public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
  
      }
  }
  
  
  // 添加到容器
  @Override
  public void addInterceptors(InterceptorRegistry registry) {
      registry.addInterceptor(new LoginHandlerInterceptor())
          .addPathPatterns("/**")
          .excludePathPatterns("/login","/index","/user/login");
  }
  
  springboot已经做好了静态资源映射，因此不需要我们进行处理。
  
  ```

#### 4. 公共页面抽取和高亮处理

```html
抽取公共片段
<div th:fragment="copy">
&copy; 2011 The Good Thymes Virtual Grocery
</div>
2、引入公共片段
<div th:insert="~{footer :: copy}"></div>
~{templatename::selector}：模板名::选择器
~{templatename::fragmentname}:模板名::片段名
3、默认效果：
insert的公共片段在div标签中
如果使用th:insert等属性进行引入，可以不用写~{}：
行内写法可以加上：[[~{}]];[(~{})]；
```

三种引入公共片段的th属性： 

- th:insert：将公共片段整个插入到声明引入的元素中 
- th:replace：将声明引入的元素替换为公共片段 
- th:include：将被引入的片段的内容包含进这个标签中

```html
<footer th:fragment="copy">
    &copy; 2011 The Good Thymes Virtual Grocery
</footer>
引入方式
<div th:insert="footer :: copy"></div>
<div th:replace="footer :: copy"></div>
<div th:include="footer :: copy"></div>
效果
<div>
    <footer>
        &copy; 2011 The Good Thymes Virtual Grocery
    </footer>
</div>
<footer>
    &copy; 2011 The Good Thymes Virtual Grocery
</footer>
<div>
    &copy; 2011 The Good Thymes Virtual Grocery
</div>
```

抽取方式：将所有的公共页面放到templates目录下的common中，在寻找片段时也会去遵循模板的映射。

```html
<nav th:fragment="navbar" class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0">
    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">[[${session.username}]]</a>
    <input class="form-control form-control-dark w-100" type="text" placeholder="Search" aria-label="Search">
    <ul class="navbar-nav px-3">
        <li class="nav-item text-nowrap">
            <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#">Sign out</a>
        </li>
    </ul>
</nav>
```

引入方式：

```html
<div th:replace="common/bar :: navbar" ></div>
	<!--使用选择器引入：-->
<div th:replace="common/bar :: #sidebar" ></div>
```

在我们的页面中，当我们选择员工管理时，侧边栏并没有高亮到员工管理标签，bootstrap中使用active属性来控制标签是否高亮。

我们可以使用参数化的片段签名来动态的指定标签：

在引入片段时传入参数，在页面上判断参数，动态添加active。

```html
<a class="nav-link" th:class="${activeUri == 'emps' ? 'nav-link active' : 'nav-link'}"
   th:href="@{/emps}">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users">
        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
        <circle cx="9" cy="7" r="4"></circle>
        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
    </svg>
    员工管理
</a>
```

在引入的时候指定参数：

```html
<div th:replace="common/bar :: #sidebar(acitveUrl='main')" ></div>
```

#### 5.Restful请求

| 实验功能                             | 请求URI | 请求方式 |
| ------------------------------------ | ------- | -------- |
| 查询所有员工                         | emps    | GET      |
| 查询某个员工(来到修改页面)           | emp/1   | GET      |
| 来到添加页面                         | emp     | GET      |
| 添加员工                             | emp     | POST     |
| 来到修改页面（查出员工进行信息回显） | emp/1   | GET      |
| 修改员工                             | emp     | PUT      |
| 删除员工                             | emp/1   | DELETE   |

- 查询全部员工信息

  ```java
  @GetMapping("/emps")
  public String empList(Model model){
      Collection<Employee> employees = employeeDao.getAll();
      model.addAttribute("emps",employees);
      return "emp/list";
  }
  ```

  ```html
  <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
      <h2>员工列表</h2>
      <a class="btn btn-secondary btn-success">新增</a>
  
      <div class="table-responsive">
          <table class="table table-striped table-sm">
              <thead>
                  <tr>
                      <th>#</th>
                      <th>姓名</th>
                      <th>邮箱</th>
                      <th>性别</th>
                      <th>生日</th>
                      <th>部门</th>
                      <th>操作</th>
                  </tr>
              </thead>
              <tbody>
                  <tr th:each="emp:${emps}">
                      <td th:text="${emp.id}"></td>
                      <td th:text="${emp.lastName}"></td>
                      <td th:text="${emp.email}"></td>
                      <td th:text="${emp.gender} == 0? '女':'男'"></td>
                      <td th:text="${#dates.format(emp.birth,'yyyy-MM-dd')}"></td>
                      <td th:text="${emp.department.departmentName}"></td>
                      <td>
                          <button class="btn btn-sm btn-primary">修改</button>
                          <button class="btn btn-sm btn-danger">删除</button>
                      </td>
                  </tr>
              </tbody>
          </table>
      </div>
  </main>
  ```

- 员工添加操作

  ```java
  <a class="btn btn-secondary btn-success" th:href="@{/emp}">新增</a>
  ```

  ```html
  <!DOCTYPE html>
  <!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ -->
  <html lang="en" xmlns:th="http://www.thymeleaf.org">
  
      <head>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
          <meta name="description" content="">
          <meta name="author" content="">
  
          <title>Dashboard Template for Bootstrap</title>
          <!-- Bootstrap core CSS -->
          <link href="asserts/css/bootstrap.min.css" th:href="@{/webjars/bootstrap/4.0.0/css/bootstrap.css}" rel="stylesheet">
  
          <!-- Custom styles for this template -->
          <link href="asserts/css/dashboard.css" th:href="@{/asserts/css/dashboard.css}" rel="stylesheet">
          <style type="text/css">
              /* Chart.js */
  
              @-webkit-keyframes chartjs-render-animation {
                  from {
                      opacity: 0.99
                  }
                  to {
                      opacity: 1
                  }
              }
  
              @keyframes chartjs-render-animation {
                  from {
                      opacity: 0.99
                  }
                  to {
                      opacity: 1
                  }
              }
  
              .chartjs-render-monitor {
                  -webkit-animation: chartjs-render-animation 0.001s;
                  animation: chartjs-render-animation 0.001s;
              }
          </style>
      </head>
  
      <body>
          <!--引入抽取的topbar-->
          <!--模板名：会使用thymeleaf的前后缀配置规则进行解析-->
          <div th:replace="common/bar::navbar"></div>
  
          <div class="container-fluid">
              <div class="row">
                  <!--引入侧边栏-->
                  <div th:replace="common/bar::#sidebar(activeUri='emps')"></div>
  
                  <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
                      <!--需要区分是员工修改还是添加；-->
                      <form th:action="@{/emp}" method="post">
                          <!--发送put请求修改员工数据-->
                          <!--
  1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）
  2、页面创建一个post表单
  3、创建一个input项，name="_method";值就是我们指定的请求方式
  -->
                          <input type="hidden" name="_method" value="put" th:if="${emp!=null}"/>
                          <input type="hidden" name="id" th:if="${emp!=null}" th:value="${emp.id}">
                          <div class="form-group">
                              <label>LastName</label>
                              <input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${emp.lastName}">
                          </div>
                          <div class="form-group">
                              <label>Email</label>
                              <input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="${emp!=null}?${emp.email}">
                          </div>
                          <div class="form-group">
                              <label>Gender</label><br/>
                              <div class="form-check form-check-inline">
                                  <input class="form-check-input" type="radio" name="gender" value="1" th:checked="${emp!=null}?${emp.gender==1}">
                                  <label class="form-check-label">男</label>
                              </div>
                              <div class="form-check form-check-inline">
                                  <input class="form-check-input" type="radio" name="gender" value="0" th:checked="${emp!=null}?${emp.gender==0}">
                                  <label class="form-check-label">女</label>
                              </div>
                          </div>
                          <div class="form-group">
                              <label>department</label>
                              <!--提交的是部门的id-->
                              <select class="form-control" name="department.id">
                                  <option th:selected="${emp!=null}?${dept.id == emp.department.id}" th:value="${dept.id}" th:each="dept:${depts}" th:text="${dept.departmentName}">1</option>
                              </select>
                          </div>
                          <div class="form-group">
                              <label>Birth</label>
                              <input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}">
                          </div>
                          <button type="submit" class="btn btn-primary" th:text="${emp!=null}?'修改':'添加'">添加</button>
                      </form>
                  </main>
              </div>
          </div>
  
          <!-- Bootstrap core JavaScript
  ================================================== -->
          <!-- Placed at the end of the document so the pages load faster -->
          <script type="text/javascript" src="asserts/js/jquery-3.2.1.slim.min.js" th:src="@{/webjars/jquery/3.3.1/jquery.js}"></script>
          <script type="text/javascript" src="asserts/js/popper.min.js" th:src="@{/webjars/popper.js/1.11.1/dist/popper.js}"></script>
          <script type="text/javascript" src="asserts/js/bootstrap.min.js" th:src="@{/webjars/bootstrap/4.0.0/js/bootstrap.js}"></script>
  
          <!-- Icons -->
          <script type="text/javascript" src="asserts/js/feather.min.js" th:src="@{/asserts/js/feather.min.js}"></script>
          <script>
              feather.replace()
          </script>
  
      </body>
  
  </html>
  
  ```

  ```java
  @GetMapping("/emp")
  public String empPage(Model model){
      Collection<Department> departments = departmentDao.getDepartments();
      model.addAttribute("depts",departments);
      return "emp/add";
  }
  
  @PostMapping("/emp")
  public String save(Employee employee){
      employeeDao.save(employee);
      return "redirect:/emps";
  }
  ```

  提交时如果出现400错误说明类型转化出现了问题，默认按照`yyyy/MM/dd`进行格式化。

  ![image-20220228161944993](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220228161944993.png)

```java
@Bean
@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")
public Formatter<Date> dateFormatter() {
    return new DateFormatter(this.mvcProperties.getDateFormat());
}

public String getDateFormat() {
    return this.dateFormat;
}
```

需要在配置文件中配置格式化日期的格式：`spring.mvc.date-format: yyyy-MM-dd`

- 员工修改页面

  ```html
  <a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">修改</a>
  
  ```

  因为员工修改页面和员工添加页面组成类似，因此可以复用一个页面。

  ```java
  /**
       * 来到update页面
       * @param id
       * @return
       */
  @GetMapping("/emp/{id}")
  public String update(@PathVariable("id")Integer id,Model model){
      Collection<Department> departments = departmentDao.getDepartments();
      model.addAttribute("depts",departments);
      Employee employee = employeeDao.get(id);
      model.addAttribute("emp",employee);
      return "emp/add";
  }
  
  @PutMapping("/emp")
  public String update(Employee employee){
      employeeDao.save(employee);
      return "redirect:/emps";
  }
  ```

  **注意： 提交put请求时，需要配置httphiddenmethodfilter，并且隐藏input框name为"_method"，value为提交方法。**

  

- 删除员工信息

  页面添加删除表单。下面的这种添加方式会影响页面的布局

  ```html
  <form th:action="@{/emp}+${emp.id}" method="post">
      <input type="hidden" name="_method" value="delete">
      <button class="btn btn-sm btn-danger" type="submit">删除</button>
  </form>
  ```

​	最好是改成下面的方式：	

```html
<button th:attr="del_uri=@{/emp/}+${emp.id}" class="btn btn-sm btn-danger deleteBtn">删除</button>


<form id="deleteEmpForm"  method="post">
    <input type="hidden" name="_method" value="delete"/>
</form>

<script>
	$(".deleteBtn").click(function(){
		//删除当前员工的
		$("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit();
		return false;
	});
</script>

```

### spring 错误处理机制

#### 错误机制原理

Springboot在出错时（客户端、服务器）都会返回一个默认的页面或者默认的json数据。主要是由MvcErrorAutoConfiguration进行自动配置的。我们需要定制返回的数据和页面。

MvcErrorAutoConfiguration给容器中添加了以下的组件：

- DefaultErrorAttributes

  ```java
  // 帮我们在页面获取信息
      @Override
  public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,
                                                boolean includeStackTrace) {
      Map<String, Object> errorAttributes = new LinkedHashMap<String, Object>();
      errorAttributes.put("timestamp", new Date());
      addStatus(errorAttributes, requestAttributes);
      addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);
      addPath(errorAttributes, requestAttributes);
      return errorAttributes;
  }
  ```

- BasicErrorController

  ```java
  @Controller
  @RequestMapping("${server.error.path:${error.path:/error}}")
  public class BasicErrorController extends AbstractErrorController {
      @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理
      public ModelAndView errorHtml(HttpServletRequest request,
                                    HttpServletResponse response) {
          HttpStatus status = getStatus(request);
          Map<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(
              request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
          response.setStatus(status.value());
          //去哪个页面作为错误页面；包含页面地址和页面内容
          ModelAndView modelAndView = resolveErrorView(request, response, status, model);
          return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);
      }
      @RequestMapping
      @ResponseBody //产生json数据，其他客户端来到这个方法处理；
      public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {
          Map<String, Object> body = getErrorAttributes(request,
                                                        isIncludeStackTrace(request, MediaType.ALL));
          HttpStatus status = getStatus(request);
          return new ResponseEntity<Map<String, Object>>(body, status);
      }
  
  ```

- ErrorPageCustomizer

  ```java
  @Value("${error.path:/error}")
  private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页
      面规则）
  ```

- DefaultErrorViewResolver

  ```java
  @Override
  public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,
                                       Map<String, Object> model) {
      ModelAndView modelAndView = resolve(String.valueOf(status), model);
      if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {
          modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
      }
      return modelAndView;
  }
  private ModelAndView resolve(String viewName, Map<String, Object> model) {
      //默认SpringBoot可以去找到一个页面？ error/404
      String errorViewName = "error/" + viewName;
      //模板引擎可以解析这个页面地址就用模板引擎解析
      TemplateAvailabilityProvider provider = this.templateAvailabilityProviders
          .getProvider(errorViewName, this.applicationContext);
      if (provider != null) {
          //模板引擎可用的情况下返回到errorViewName指定的视图地址
          return new ModelAndView(errorViewName, model);
      }
      //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html
      return resolveResource(errorViewName, model);
  }
  ```

一但系统出现4xx或者5xx之类的错误，`ErrorPageCustomizer`就会生效（定制错误的响应规则），就会来到`/error`请求；就会被`BasicErrorController`处理。

关于响应页面，去哪个页面是由`DefaultErrorViewResolver`解析得到的。

```java
protected ModelAndView resolveErrorView(HttpServletRequest request,
                                        HttpServletResponse response, HttpStatus status, Map<String, Object> model) {
    //所有的ErrorViewResolver得到ModelAndView
    for (ErrorViewResolver resolver : this.errorViewResolvers) {
        ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
        if (modelAndView != null) {
            return modelAndView;
        }
    }
    return null;
}

```

#### 定制错误页面

有模板引擎的情况下，将错误页面命名为`错误状态码.html`，放在模板引擎文件夹里面的error文件夹下。我们可以使用`4xx`和`5xx`作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）。

没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找，静态资源文件夹下的不会被模板引擎解析  。以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面。

我们能在页面获取的信息是：

- timestamp：时间戳 
- status：状态码 
- error：错误提示 
- exception：异常对象 
- message：异常消息 
- errors：JSR303数据校验的错误

#### 定制错误的json数据

1. 自定义异常处理器

   ```java
   package com.pwddd.springboot.exception;
   
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.ResponseBody;
   
   import java.util.HashMap;
   import java.util.Map;
   
   @ControllerAdvice
   public class MyExceptionHandler {
   
       @ResponseBody
       @ExceptionHandler(UserNotExistException.class)
       public Map<String,Object> handleException(Exception e){
           HashMap<String, Object> map = new HashMap<>();
           map.put("code",404);
           map.put("msg","用户不存在");
           return map;
       }
   }
   ```

2. 以上的代码虽然可以返回json数据，但是，浏览器访问也返回json数据。我们需要转发到error上，完成自适应处理器

   ```java
   @ExceptionHandler(UserNotExistException.class)
   public String handleException(Exception e){
       HashMap<String, Object> map = new HashMap<>();
       map.put("code",404);
       map.put("msg","用户不存在");
       //        return map;
       return "redirect:/error";
   }
   ```

3. 转到error之后，因为我们的错误状态码问题，导致没有对应的错误页面，因此显示还是默认的空白页。我们需要传入默认的状态码

   ```java
   @ExceptionHandler(UserNotExistException.class)
   public String handleException(Exception e, HttpServletRequest request){
       HashMap<String, Object> map = new HashMap<>();
       request.setAttribute("javax.servlet.error.status_code",400);
       map.put("code",404);
       map.put("msg","用户不存在");
       //        return map;
       return "redirect:/error";
   }
   ```

4. 我们定制的数据这样携带不出去，我们需要将定制的数据携带出去。相应的数据是由getErrorAttributes获取的。我们想要定制的话，我们可以完全编写一个实现类，完全替代。但是这样太麻烦了，我们可以继承并重写相应的方法。页面上能用的数据，或者是json返回能用的数据都是通过`errorAttributes.getErrorAttributes`得到。容器中`DefaultErrorAttributes.getErrorAttributes()`默认进行数据处理的

   ```java
   //给容器中加入我们自己定义的ErrorAttributes
   @Component
   public class MyErrorAttributes extends DefaultErrorAttributes {
       @Override
       public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,
                                                     boolean includeStackTrace) {
           Map<String, Object> map = super.getErrorAttributes(requestAttributes,
                                                              includeStackTrace);
           //requestAttributes.getAttributes("ext",0);   // 获取异常处理器的数据。
           map.put("company","atguigu");
           return map;
       }
   }
   
   ```

   最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容。

### 嵌入式Web容器

SpringBoot默认使用Tomcat作为嵌入式的Servlet容器。我们需要考虑，定制配置、切换其他的容器。

![image-20220228213606912](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220228213606912.png)

#### 定制tomcat配置

1. 修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）。

```properties
erver.port=8081
server.context‐path=/crud
server.tomcat.uri‐encoding=UTF‐8
//通用的Servlet容器设置
server.xxx
//Tomcat的设置
server.tomcat.xxx
```

2. 编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器，来修改Servlet容器的配置

``` java
@Bean //一定要将这个定制器加入到容器中
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
    return new EmbeddedServletContainerCustomizer() {
        //定制嵌入式的Servlet容器相关的规则
        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            container.setPort(8083);
        }
    };
}
```

#### 注册Servlet三大组件【Servlet、Filter、Listener】

Servlet:

```java
//注册三大组件
@Bean
public ServletRegistrationBean myServlet(){
    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new
                                                                           MyServlet(),"/myServlet");
    return registrationBean;
}

```

Filter:

```java
@Bean
public FilterRegistrationBean myFilter(){
    FilterRegistrationBean registrationBean = new FilterRegistrationBean();
    registrationBean.setFilter(new MyFilter());
    registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet"));
    return registrationBean;
}
```

Listener:

```java
@Bean
public ServletListenerRegistrationBean myListener(){
    ServletListenerRegistrationBean<MyListener> registrationBean = new
        ServletListenerRegistrationBean<>(new MyListener());
    return registrationBean;
}

```

SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器。DIspatcherServlet。

DispatcherServletAutoConfiguration：

```java
@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name =
                   DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
public ServletRegistrationBean dispatcherServletRegistration(
    DispatcherServlet dispatcherServlet) {
    ServletRegistrationBean registration = new ServletRegistrationBean(
        dispatcherServlet, this.serverProperties.getServletMapping());
    //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp
    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径
    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
    registration.setLoadOnStartup(
        this.webMvcProperties.getServlet().getLoadOnStartup());
    if (this.multipartConfig != null) {
        registration.setMultipartConfig(this.multipartConfig);
    }
    return registration;
}

```

#### 替换其他容器

Tomcat默认支持：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐web</artifactId>
    引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；
</dependency>
```

Jetty:

```xml
<!‐‐ 引入web模块 ‐‐>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring‐boot‐starter‐tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<!‐‐引入其他的Servlet容器‐‐>
<dependency>
    <artifactId>spring‐boot‐starter‐jetty</artifactId>
    <groupId>org.springframework.boot</groupId>
</dependency>
```

Undertow：

```xml
<!‐‐ 引入web模块 ‐‐>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring‐boot‐starter‐tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<!‐‐引入其他的Servlet容器‐‐>
<dependency>
    <artifactId>spring‐boot‐starter‐undertow</artifactId>
    <groupId>org.springframework.boot</groupId>
</dependency>
```

### 自动配置原理

EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置

```java
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件
//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：
//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作
public class EmbeddedServletContainerAutoConfiguration {
    @Configuration
    @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =
                              SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的
    Servlet容器工厂；作用：创建嵌入式的Servlet容器
        public static class EmbeddedTomcat {
            @Bean
            public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory()
            {
                return new TomcatEmbeddedServletContainerFactory();
            }
        }
    /**
* Nested configuration if Jetty is being used.
*/
    @Configuration
    @ConditionalOnClass({ Servlet.class, Server.class, Loader.class,
                         WebAppContext.class })
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =
                              SearchStrategy.CURRENT)
    public static class EmbeddedJetty {
        @Bean
        public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {
            return new JettyEmbeddedServletContainerFactory();
        }
    }
    /**
* Nested configuration if Undertow is being used.
*/
    @Configuration
    @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search =
                              SearchStrategy.CURRENT)
    public static class EmbeddedUndertow {
        @Bean
        public UndertowEmbeddedServletContainerFactory
            undertowEmbeddedServletContainerFactory() {
            return new UndertowEmbeddedServletContainerFactory();
        }
    }

```

EmbeddedServletContainerFactory嵌入式Servlet容器工厂

```java
public interface EmbeddedServletContainerFactory {
    //获取嵌入式的Servlet容器
    EmbeddedServletContainer getEmbeddedServletContainer(
        ServletContextInitializer... initializers);
}

```



嵌入式的容器工厂：

![image-20220228214942664](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220228214942664.png)

嵌入式的容器：

![image-20220228214956554](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220228214956554.png)





```java
@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
    ServletContextInitializer... initializers) {
    //创建一个Tomcat
    Tomcat tomcat = new Tomcat();
    //配置Tomcat的基本环节
    File baseDir = (this.baseDirectory != null ? this.baseDirectory
                    : createTempDir("tomcat"));
    tomcat.setBaseDir(baseDir.getAbsolutePath());
    Connector connector = new Connector(this.protocol);
    tomcat.getService().addConnector(connector);
    customizeConnector(connector);
    tomcat.setConnector(connector);
    tomcat.getHost().setAutoDeploy(false);
    configureEngine(tomcat.getEngine());
    for (Connector additionalConnector : this.additionalTomcatConnectors) {
        tomcat.getService().addConnector(additionalConnector);
    }
    prepareContext(tomcat.getHost(), initializers);
    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器
    return getTomcatEmbeddedServletContainer(tomcat);
}
```

EmbeddedServletContainerCustomizer定制器帮我们修改了Servlet容器的配置。

容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor。

```java
//初始化之前
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
    throws BeansException {
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件
    if (bean instanceof ConfigurableEmbeddedServletContainer) {
        //
        postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
    }
    return bean;
}
private void postProcessBeforeInitialization(
    ConfigurableEmbeddedServletContainer bean) {
    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
        customizer.customize(bean);
    }
}
private Collection<EmbeddedServletContainerCustomizer> getCustomizers() {
    if (this.customizers == null) {
        // Look up does not include the parent context
        this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(
            this.beanFactory
            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }
    return this.customizers;
}
```

1）、SpringBoot根据导入的依赖情况，给容器中添加相应的 `EmbeddedServletContainerFactory`【TomcatEmbeddedServletContainerFactory】

2）、容器中某个组件要创建对象就会惊动后置处理器。`EmbeddedServletContainerCustomizerBeanPostProcessor`。只要是嵌入式的Servlet容器工厂，后置处理器就工作。 

3）、后置处理器，从容器中获取所有的`EmbeddedServletContainerCustomizer`，调用定制器的定制方法



### 嵌入式Servlet容器启动原理

什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat？获取嵌入式的Servlet容器工厂：

1. SpringBoot应用启动运行run方法
2. refreshContext(context)。SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一 个组件】。如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则： AnnotationConfigApplicationContext
3. refresh(context)。刷新刚才创建好的ioc容器。

```java
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // Prepare this context for refreshing.
        prepareRefresh();
        // Tell the subclass to refresh the internal bean factory.
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        // Prepare the bean factory for use in this context.
        prepareBeanFactory(beanFactory);
        try {
            // Allows post‐processing of the bean factory in context subclasses.
            postProcessBeanFactory(beanFactory);
            // Invoke factory processors registered as beans in the context.
            invokeBeanFactoryPostProcessors(beanFactory);
            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);
            // Initialize message source for this context.
            initMessageSource();
            // Initialize event multicaster for this context.
            initApplicationEventMulticaster();
            // Initialize other special beans in specific context subclasses.
            onRefresh();
            // Check for listener beans and register them.
            registerListeners();
            // Instantiate all remaining (non‐lazy‐init) singletons.
            finishBeanFactoryInitialization(beanFactory);
            // Last step: publish corresponding event.
            finishRefresh();
        }
        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization ‐ " +
                            "cancelling refresh attempt: " + ex);
            }
            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();
            // Reset 'active' flag.
            cancelRefresh(ex);
            // Propagate exception to caller.
            throw ex;
        }
        finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
        }
    }
}
```

4.  onRefresh()。web的ioc容器重写了onRefresh方法

5. webioc容器会创建嵌入式的Servlet容器。createEmbeddedServletContainer()。

6. 获取嵌入式的Servlet容器工厂

   `EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();` 从ioc容器中获取`EmbeddedServletContainerFactory`组件。`TomcatEmbeddedServletContainerFactory`创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置。

7. 使用容器工厂获取嵌入式的Servlet容器：`this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());`

8. 嵌入式的Servlet容器创建对象并启动Servlet容器

9. 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来。

### 使用外置的Servlet容器

1. 必须创建一个war项目

2. 将嵌入式的Tomcat指定为provided

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring‐boot‐starter‐tomcat</artifactId>
       <scope>provided</scope>
   </dependency>
   
   ```

3. 必须编写一个SpringBootServletInitializer的子类，并调用configure方法

   ```java
   public class ServletInitializer extends SpringBootServletInitializer {
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
           //传入SpringBoot应用的主程序
           return application.sources(SpringBoot04WebJspApplication.class);
       }
   }
   ```

4. 启动服务器就可以使用

### 外置Servlet原理

jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器

war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器

规则： 

1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面`ServletContainerInitializer`实例

2）、`ServletContainerInitializer`的实现放在jar包的`META-INF/services`文件夹下，有一个名为`javax.servlet.ServletContainerInitializer`的文件，内容就是`ServletContainerInitializer`的实现类的全类名 

3）、还可以使用`@HandlesTypes`，在应用启动的时候加载我们感兴趣的类； 

​	流程： 

​	1）、启动Tomcat 

​	2）、`org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\METAINF\services\javax.servlet.ServletContainerInitializer`： 

Spring的web模块里面有这个文件：`org.springframework.web.SpringServletContainerInitializer`

 	3）、`SpringServletContainerInitializer`将`@HandlesTypes(WebApplicationInitializer.class)`标注的所有这个类型 的类都传入到onStartup方法的`<Set>`，为这些`WebApplicationInitializer`类型的类创建实例

​	4）、每一个WebApplicationInitializer都调用自己的onStartup。相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法。

​	6）、`SpringBootServletInitializer`实例执行onStartup的时候会`createRootApplicationContext`创建容器

```java
protected WebApplicationContext createRootApplicationContext(
    ServletContext servletContext) {
    //1、创建SpringApplicationBuilder
    SpringApplicationBuilder builder = createSpringApplicationBuilder();
    StandardServletEnvironment environment = new StandardServletEnvironment();
    environment.initPropertySources(servletContext, null);
    builder.environment(environment);
    builder.main(getClass());
    ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
    if (parent != null) {
        this.logger.info("Root context already created (using as parent).");
        servletContext.setAttribute(
            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
        builder.initializers(new ParentContextApplicationContextInitializer(parent));
    }
    builder.initializers(
        new ServletContextApplicationContextInitializer(servletContext));
    builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);
    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来
    builder = configure(builder);
    //使用builder创建一个Spring应用
    SpringApplication application = builder.build();
    if (application.getSources().isEmpty() && AnnotationUtils
        .findAnnotation(getClass(), Configuration.class) != null) {
        application.getSources().add(getClass());
    }
    Assert.state(!application.getSources().isEmpty(),
                 "No SpringApplication sources have been defined. Either override the "
                 + "configure method or add an @Configuration annotation");
    // Ensure error pages are registered
    if (this.registerErrorPageFilter) {
        application.getSources().add(ErrorPageFilterConfiguration.class);
    }
    //启动Spring应用
    return run(application);
}

```

7）、Spring的应用就启动并且创建IOC容器

```java
public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    ConfigurableApplicationContext context = null;
    FailureAnalyzers analyzers = null;
    configureHeadlessProperty();
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
        ConfigurableEnvironment environment = prepareEnvironment(listeners,
                                                                 applicationArguments);
        Banner printedBanner = printBanner(environment);
        context = createApplicationContext();
        analyzers = new FailureAnalyzers(context);
        prepareContext(context, environment, listeners, applicationArguments,
                       printedBanner);
        //刷新IOC容器
        refreshContext(context);
        afterRefresh(context, applicationArguments);
        listeners.finished(context, null);
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass)
                .logStarted(getApplicationLog(), stopWatch);
        }
        return context;
    }
    catch (Throwable ex) {
        handleRunFailure(context, listeners, analyzers, ex);
        throw new IllegalStateException(ex);
    }
}
```

## Springboot数据交互

### JDBC

添加依赖：

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>

<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
</dependency>
```

配置配置文件

```properties
# 此处如果切换为高版本的mysql驱动 需要更换为cj下的Driver
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  

# 如果因为驱动版本小于数据库的版本可能会导致连接问题。加上参数useSSL=false可以解决，建议更换版本。
spring.datasource.url=jdbc:mysql://localhost:3307/springboot
spring.datasource.username=root
spring.datasource.password=123456
```

添加测试依赖：

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
  </dependency>
```

配置启动器，如果不配置，测试启动会报错。

```java
package com.pwddd.jdbc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JDBCApplication {
  public static void main(String[] args) {
    SpringApplication.run(JDBCApplication.class,args);
  }
}

```

测试：

```java
import com.pwddd.jdbc.JDBCApplication;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import javax.sql.DataSource;
import java.sql.SQLException;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = {JDBCApplication.class})  // 此处如果不指定class,且当前测试类的路径和启动类的路径不一致，则找不到启动类报错。https://blog.csdn.net/pmdream/article/details/109119689
public class TestJDBC {

  @Autowired
  JdbcTemplate jdbcTemplate;

  @Autowired
  DataSource dataSource;

  @Test
  public void test() throws SQLException {
    System.out.println(dataSource.getConnection());
  }

}

```

### 数据交互配置原理

在Springboot中默认使用`org.apache.tomcat.jdbc.pool.DataSource`作为数据源。数据源的相关配置在`DataSourceProperties`中。在`org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration`根据条件给容器中添加了多种数据源。可以使用`spring.datasource.type`配置要使用的数据源。如下面的代码所示

```java
@ConditionalOnClass({org.apache.tomcat.jdbc.pool.DataSource.class})
@ConditionalOnProperty(
  name = {"spring.datasource.type"},
  havingValue = "org.apache.tomcat.jdbc.pool.DataSource",
  matchIfMissing = true
)
static class Tomcat extends DataSourceConfiguration {
  Tomcat() {
  }

  @Bean
  @ConfigurationProperties(
    prefix = "spring.datasource.tomcat"
  )
  public org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) {
    org.apache.tomcat.jdbc.pool.DataSource dataSource = (org.apache.tomcat.jdbc.pool.DataSource)this.createDataSource(properties, org.apache.tomcat.jdbc.pool.DataSource.class);
    DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());
    String validationQuery = databaseDriver.getValidationQuery();
    if (validationQuery != null) {
      dataSource.setTestOnBorrow(true);
      dataSource.setValidationQuery(validationQuery);
    }

    return dataSource;
  }
}
```

除此之外，在`org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer`中定义了在程序运行时进行的数据操作：运行建表语句和创建数据库的语句。SQL语句位于classpath下的`schema/data-all.sql或者schema/data.sql`，也可以指定`spring.datasource.data/schema`

```java
List<Resource> scripts = this.getScripts("spring.datasource.data", this.properties.getData(), "data");
List<Resource> scripts = this.getScripts("spring.datasource.schema", this.properties.getSchema(), "schema");
private List<Resource> getScripts(String propertyName, List<String> resources, String fallback) {
  if (resources != null) {
    return this.getResources(propertyName, resources, true);
  } else {
    String platform = this.properties.getPlatform();
    List<String> fallbackResources = new ArrayList();
    fallbackResources.add("classpath*:" + fallback + "-" + platform + ".sql");
    fallbackResources.add("classpath*:" + fallback + ".sql");
    return this.getResources(propertyName, fallbackResources, false);
  }
}
```

如下所示：

```properties
spring.datasource.schema=classpath:sql/schema-all.sql
spring.datasource.data=classpath:sql/data-all.sql
```

Springboot默认配置了一个JDBCTemplate数据源

```java
@Test
public void testJdbcTemplate(){
  List<Map<String, Object>> maps = jdbcTemplate.queryForList("select * from t_admin");
  System.out.println(maps.get(0));
}
```

### Druid数据源

引入Druid数据源

```xml
<dependency>
  <groupId>com.alibaba</groupId>
  <artifactId>druid</artifactId>
  <version>1.2.8</version>
</dependency>
```

指定数据源的类型：

```properties
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
```

配置文件中配置相关的参数：

```properties 
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3307/springboot
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.schema=classpath:sql/schema-all.sql
spring.datasource.data=classpath:sql/data-all.sql

# Druid配置
spring.datasource.initialSize: 5
spring.datasource.min-idle=5
spring.datasource.max-active=20
spring.datasource.max-wait=60000
spring.datasource.time-between-eviction-runs-millis=6000
spring.datasource.min-evictable-idle-time-millis=300000
spring.datasource.validation-query=SELECT 1 FROM DUAL
spring.datasource.test-while-idle=false
spring.datasource.test-on-return=false
spring.datasource.pool-prepared-statements=true

spring.datasource.druid.filters=stat,wall,log4j
spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20
spring.datasource.druid.use-global-data-source-stat=true
spring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

```

直接这么配置没有办法注入到参数中，我们需要自定义Druid的配置类，然后指定配置文件的前缀

```java
package com.pwddd.jdbc.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DruidConfig {

  @ConfigurationProperties(prefix = "spring.datasource.druid")
  @Bean
  public DataSource druidDataSource(){
    return new DruidDataSource();
  }
}

```

配置druid的监控

```java
package com.pwddd.jdbc.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;
import java.util.Arrays;
import java.util.HashMap;

@Configuration
public class DruidConfig {

  @ConfigurationProperties(prefix = "spring.datasource.druid")
  @Bean
  public DataSource druidDataSource(){
    return new DruidDataSource();
  }

  @Bean
  public ServletRegistrationBean statViewServlet(){

    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
    HashMap<String, String> map = new HashMap<>();
    map.put("loginUsername","admin");
    map.put("loginPassword","123456");
    registrationBean.setInitParameters(map);
    return registrationBean;
  }

  @Bean
  public FilterRegistrationBean webStatFilter(){
    FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter());
    HashMap<String, String> initParameters = new HashMap<>();
    initParameters.put("exclusions","*.js,*.css,*.html,/druid/*");
    registrationBean.setInitParameters(initParameters);
    registrationBean.setUrlPatterns(Arrays.asList("/*"));
    return registrationBean;
  }
}

```

### 整合mybatis

1. 引入相关依赖：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.pwddd.mybatis</groupId>
  <artifactId>springboot-mybatis</artifactId>
  <version>1.0-SNAPSHOT</version>

  <parent>
    <artifactId>spring-boot-starter-parent</artifactId>
    <groupId>org.springframework.boot</groupId>
    <version>1.5.9.RELEASE</version>
  </parent>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.28</version>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.2.8</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>2.2.2</version>
    </dependency>
  </dependencies>

</project>

```

2. 配置Druid数据源

```properties
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3307/springboot
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.schema=classpath:sql/schema-all.sql
spring.datasource.data=classpath:sql/data-all.sql

# Druid配置
spring.datasource.initialSize: 5
spring.datasource.min-idle=5
spring.datasource.max-active=20
spring.datasource.max-wait=60000
spring.datasource.time-between-eviction-runs-millis=6000
spring.datasource.min-evictable-idle-time-millis=300000
spring.datasource.validation-query=SELECT 1 FROM DUAL
spring.datasource.test-while-idle=false
spring.datasource.test-on-return=false
spring.datasource.pool-prepared-statements=true

spring.datasource.druid.filters=stat,wall,log4j
spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20
spring.datasource.druid.use-global-data-source-stat=true
spring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

```



```java
package com.pwddd.mybatis.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewFilter;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;
import java.util.Arrays;
import java.util.HashMap;

@Configuration
public class DruidConfig {

    @ConfigurationProperties("spring.datasource")
    @Bean
    public DataSource dataSource(){
        return new DruidDataSource();
    }

    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean registrationBean =
                new ServletRegistrationBean(new StatViewServlet(),"/druid/*");
        HashMap<String, String> map = new HashMap<>();
        map.put("loginUsername","admin");
        map.put("loginPassword","123456");
        registrationBean.setInitParameters(map);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean statFilter(){
        WebStatFilter filter = new WebStatFilter();
        FilterRegistrationBean bean = new FilterRegistrationBean(filter);
        HashMap<String, String> initParameters = new HashMap<>();
        initParameters.put("exclusions","*.js,*.html,*.css,/druid/*");
        bean.setInitParameters(initParameters);
        bean.setUrlPatterns(Arrays.asList("/*"));
        return bean;
    }
}

```

3. 创建JavaBean

```java
package com.pwddd.mybatis.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Admin {
  private String id;
  private String username;
  private String passwd;

}

```

4. 创建mapper和对应的接口

```java
package com.pwddd.mybatis.mapper;

import com.pwddd.mybatis.bean.Admin;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface AdminMapper {

  List<Admin> list();
}

```

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.pwddd.mybatis.mapper.AdminMapper">

  <select id="list" resultType="Admin">
    select * from t_admin
  </select>
</mapper>

```

5. 添加配置

```properties
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.pwddd.mybatis.be注入Mapper
```

```java
@RestController
@RequestMapping("/admin")
public class AdminController {

  @Autowired
  private AdminMapper adminMapper;

  @RequestMapping("/list")
  public List<Admin> adminList(){
    return adminMapper.list();
  }
}

```

6. 批量扫描包

```java
@SpringBootApplication
@MapperScan(basePackages = "com.pwddd.mybatis.mapper")
public class MybatisApplication {
  public static void main(String[] args) {
    SpringApplication.run(MybatisApplication.class,args);
  }
}
```

7. 自定义Myabtis配置

springboot配置mybatis也是使用自动配置完成的。在创建SQL SessionFactory时会获取所有的Configuration，因此我们只需要自定义一个ConfigurationCustomizer，然后加入到容器中即可。

```java
package com.pwddd.mybatis.config;

import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisConfig {

  @Bean
  public ConfigurationCustomizer configurationCustomizer(){
    return new ConfigurationCustomizer() {

      @Override
      public void customize(org.apache.ibatis.session.Configuration configuration) {
        configuration.setAggressiveLazyLoading(true);
      }
    };
  }
}

```

源码：

```java
private void applyConfiguration(SqlSessionFactoryBean factory) {
  org.apache.ibatis.session.Configuration configuration = this.properties.getConfiguration();
  if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
    configuration = new org.apache.ibatis.session.Configuration();
  }

  if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
    Iterator var3 = this.configurationCustomizers.iterator();

    while(var3.hasNext()) {
      ConfigurationCustomizer customizer = (ConfigurationCustomizer)var3.next();
      customizer.customize(configuration);
    }
  }

  factory.setConfiguration(configuration);
}
```

8. 配置全局配置文件

```properties
mybatis.config-location=classpath:mybatis-config.xml
```



### 整合JPA

#### SpringData简介

![image-20220428020947814](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220428020947814.png)

应用程序面向SpringData编程，由SpringData帮助我们完成具体的实现。



#### 整合方法

1. 创建项目，引入spring-boot-starter-jpa

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.pwddd.jpa</groupId>
  <artifactId>springboot-jpa</artifactId>
  <version>1.0-SNAPSHOT</version>

  <parent>
    <artifactId>spring-boot-starter-parent</artifactId>
    <groupId>org.springframework.boot</groupId>
    <version>1.5.9.RELEASE</version>
  </parent>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.28</version>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
  </dependencies>

</project>

```

2. 创建配置文件

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    password: 123456
    username: root
    url: jdbc:mysql://localhost:3307/springboot
```

3. 编写实体类，配置映射关系

```java
package com.pwddd.jpa.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import javax.persistence.criteria.CriteriaBuilder;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity // 配置标识
@Table(name = "t_admin") // 配置数据表
public class Admin {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增主键
    private Integer id;

    @Column(name = "user_name",length = 255)
    private String username;
    @Column(length = 255)
    private String passwd;
}

```

4. 编写接口操作数据

```java
package com.pwddd.jpa.repository;

import com.pwddd.jpa.entity.Admin;
import org.springframework.data.jpa.repository.JpaRepository;
//                                                    操作的实体，主键类型
public interface AdminRepository extends JpaRepository<Admin,String> {
}

```

5. 配置jpa

```yaml
jpa:
	hibernate:
		ddl-auto: update # 更新或者创建表结构
	show-sql: true # 显示查询
```

6. 注入repository

```java
package com.pwddd.jpa.controller;

import com.pwddd.jpa.entity.Admin;
import com.pwddd.jpa.repository.AdminRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/admin")
public class AdminController {

    @Autowired
    private AdminRepository repository;

    @RequestMapping("/add")
    public void addAdmin(Admin admin){
        repository.save(admin);
    }
}

```

## Springboot 启动配置原理

### 启动流程：

- 创建SpringApplication对象

- 调用initialize方法

```java
    private void initialize(Object[] sources) {
        if (sources != null && sources.length > 0) {
            this.sources.addAll(Arrays.asList(sources));
        }
			// 判断是否为web应用
        this.webEnvironment = this.deduceWebEnvironment();
      
      // 类路径下寻找ApplicationInitalizer保存
      this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
      // 类路径下寻找  ApplicationListener 并保存
      this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
      // 多个配置类中找到有Main方法的配置类。 
      this.mainApplicationClass = this.deduceMainApplicationClass();
    }
```

- 运行run方法

```java
public ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        ConfigurableApplicationContext context = null;
        FailureAnalyzers analyzers = null;
        this.configureHeadlessProperty();
  // 	获取SpringApplicationRUnListener 从类路径下的MATE-INF/spring.factories里寻找
        SpringApplicationRunListeners listeners = this.getRunListeners(args);
  
  		// 回掉所有listener的starting方法
        listeners.starting();

        try {
          // 封装Args
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
          	// 准备环境， 创建环境  配置环境  回调listener的environmentPrepared  方法
          ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
          	// 打印启动时的banner 
          Banner printedBanner = this.printBanner(environment);
            
          	// 创建context ioc容器
          context = this.createApplicationContext();
            
          new FailureAnalyzers(context);
          // 准备上下文环境
       			// 将env保存到ioc，获取所有的ApplicationInitalizer 调用initailze方法 ， 回调所有listener的contextPrepared方法。 最后回调 listener的contextLoaded方法
          this.prepareContext(context, environment, liteners, applicationArguments, printedBanner);
				// 刷线容器 ioc容器初始化
          this.refreshContext(context);
          // callRUnner 获取所有的ApplicationRunner 、 然后获取所有的CommandLineRunner 并运行他们的run方法
            this.afterRefresh(context, applicationArguments);
          // 回调listener的finished方法
            listeners.finished(context, (Throwable)null);
            stopWatch.stop();
            if (this.logStartupInfo) {
                (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
            }
// 返回IOC容器
            return context;
        } catch (Throwable var9) {
            this.handleRunFailure(context, listeners, (FailureAnalyzers)analyzers, var9);
            throw new IllegalStateException(var9);
        }
    }
```

### 事件监听机制

几个重要的事件回调机制 

配置在META-INF/spring.factories 

ApplicationContextInitializer 

SpringApplicationRunListener

只需要放在ioc容器中 

ApplicationRunner 

CommandLineRunner



## Springboot自定义starter

starter场景启动器：

1. 需要导入的依赖

2. 如何编写自动配置

```java
@Configuration //指定这个类是一个配置类 
@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效 
@AutoConfigureAfter //指定自动配置类的顺序 
@Bean //给容器中添加组件

@ConfigurationPropertie//结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties //让xxxProperties生效加入到容器中

自动配置类要能加载 将需要启动就加载的自动配置类，配置在META‐INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
```

![image-20220428025854521](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220428025854521.png)



### 步骤

1. 创建两个maven项目

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema‐instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven‐4.0.0.xsd"> <modelVersion>4.0.0</modelVersion>

<groupId>com.atguigu.starter</groupId> 
  <artifactId>atguigu‐spring‐boot‐starter</artifactId> 
  <version>1.0‐SNAPSHOT</version>

<!‐‐启动器‐‐> 
  <dependencies>

<!‐‐引入自动配置模块‐‐> 
    <dependency> 
      <groupId>com.atguigu.starter</groupId> 
      <artifactId>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactId> 
      <version>0.0.1‐SNAPSHOT</version> 
    </dependency> 
  </dependencies>


</project>
```



```xml
<?xml version="1.0" encoding="UTF‐8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema‐instance"

         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>com.atguigu.starter</groupId>
    <artifactId>atguigu‐spring‐boot‐starter‐autoconfigurer</artifactId>
    <version>0.0.1‐SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>atguigu‐spring‐boot‐starter‐autoconfigurer</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring‐boot‐starter‐parent</artifactId>
        <version>1.5.10.RELEASE</version>
        <relativePath/>
        <!‐‐ lookup parent from repository ‐‐>
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF‐8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF‐8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <!‐‐引入spring‐boot‐starter；所有starter的基本配置‐‐>
        <dependency>

            <groupId>org.springframework.boot</groupId>

            <artifactId>spring‐boot‐starter</artifactId>
        </dependency>

    </dependencies>

</project>
```



自定义properties

```java
package com.atguigu.starter;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "atguigu.hello")
public class HelloProperties {
private String prefix; 
  private String suffix;

public String getPrefix() { return prefix; }

public void setPrefix(String prefix) { this.prefix = prefix; }

public String getSuffix() { return suffix; }

public void setSuffix(String suffix) { this.suffix = suffix; }

}
```

自定义Service

```java
package com.atguigu.starter;

public class HelloService {

HelloProperties helloProperties;

public HelloProperties getHelloProperties() { return helloProperties; }

public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; }

public String sayHellAtguigu(String name){ 
  return helloProperties.getPrefix()+"‐" +name + helloProperties.getSuffix(); }

}
```

自动配置

```java
package com.atguigu.starter;

import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication //web应用才生效 @EnableConfigurationProperties(HelloProperties.class) 
public class HelloServiceAutoConfiguration {

  @Autowired HelloProperties helloProperties; 
  @Bean 
  public HelloService helloService(){

    HelloService service = new HelloService();

    service.setHelloProperties(helloProperties);

    return service; 
  }

}
```


