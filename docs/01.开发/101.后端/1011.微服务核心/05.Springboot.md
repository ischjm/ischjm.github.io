---
title: Springboot
date: 2022-02-26 00:00:00
permalink: /dev/java/core/springboot
author: p0jo
categories:
  - 开发
  - 后端
  - 微服务核心
tags:
  - Springboot
  - Spring
  - SpringMVC
---


# SpringBoot

## Springboot简介

Springboot是简化Spring应用开发的一个框架，其中整合了Spring技术栈，是J2EE开发的一站式解决方案。在传统的基于SSM框架进行项目开发的过程中，我们需要配置大量的配置文件，用于约束框架的功能和配置。Springboot基于“约定大于配置”的开发思想，各个组件的配置文件由Springboot帮助我们完成，我们只需要少量的配置即可搭建一个项目开发的基本环境，更专注于业务代码的编写。

使用Springboot的优点：

- 快速创建独立运行的Spring应用，并可以集成主流的框架
- 使用嵌入式的Servlet容器，应用无需打War包
- 使用starters进行自动依赖和版本控制
- 主流框架的自动默认配置，无代码生成，开箱即用
- 准生产环境的运行时监控
- 天然集成云计算

### 微服务

> [martinfowler.com](https://martinfowler.com/)

微服务是当前项目开发的热点。回顾传统的单体应用开发，我们整个项目默认是部署在同一台服务器上的，我们将编写好的项目打成war包，放到tomcat中运行。在用户量较少、项目较为简单的场景下没有什么异常，部署起来也相对方便。但是如果项目的访问量较大，我们服务器的资源压力较大，单体应用就无法支撑起用户的需求。在这种情况下，我们通常会将项目部署在多个服务器上，然后使用负载均衡将用户的访问分配到不同的服务器上。那么，如果只是单个功能访问量较大，比如：订单功能、会员功能，那么这种方式就会导致服务器的资源浪费。微服务的思想应运而生。

![image-20220225151642714](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220225151642714.png)

所谓微服务，就是将原本的单体应用抽离出多个功能模块，每个功能模块都可以单独部署。如果某个模块的访问要求较高，将不同模块之间的动态组合，部署到其他服务器上。每个功能模块都是可以独立替换和独立升级的单元。如下图所示：

![image-20220225151701348](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220225151701348.png)

## HelloWorld

#### helloworld编写

> 浏览器发送hello请求，服务器接收请求并将helloworld返回给浏览器。

1. 创建Maven工程，并导入springboot相关依赖。

   ```xml
   <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>1.5.9.RELEASE</version>
   </parent>
   
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
   </dependencies>
   ```

2. 编写主程序，用于启动springboot应用

   ```java
   package com.pwddd;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   @SpringBootApplication
   public class SpringBootTestApplication {
       public static void main(String[] args) {
           SpringApplication.run(SpringBootTestApplication.class,args);
       }
   }
   ```

3. 编写controller处理用户请求

   ```java
   package com.pwddd.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.ResponseBody;
   
   @Controller
   public class HelloController {
   
       @GetMapping("/hello")
       @ResponseBody
       public String hello(){
           return "helloworld";
       }
   }
   ```

4. 运行主程序

5. Springboot应用打包

   - 导入Springboot项目插件

     ```xml
     <build>
         <plugins>
             <plugin>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-maven-plugin</artifactId>
             </plugin>
         </plugins>
     </build>
     ```

   - 运行maven -> package

   - java -jar运行

#### helloworld解析

##### 父项目版本仲裁

在创建Maven项目中，指定了Maven的父项目。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

该父项目又指定了另一个父项目。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>1.5.9.RELEASE</version>
    <relativePath>../../spring-boot-dependencies</relativePath>
</parent>
```

这个父项目中制定了相关组件的版本。

```xml
<properties>
    <!-- Dependency versions -->
    <activemq.version>5.14.5</activemq.version>
    <antlr2.version>2.7.7</antlr2.version>
    …………
```

##### 场景启动器

springboot starter是springboot的场景启动器，帮我们导入了相关模块运行的相关依赖。springboot将常见的功能场景抽离出来，我们使用时只需要引用相关的场景启动器，springboot会帮我们自动导入相关的依赖。

##### springboot应用的启动

在Springboot启动类上有`@SpringBootApplication`注解，该注解说明了该类是当前项目的主配置类，springboot项目可以运行该类的main方法启动项目。该注解是一个组合注解，又包含了以下的内容。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
```

`@SpringBootConfiguration`注解，标注springboot的配置类。

`@EnableAutoConfiguration`注解，开启了自动配置的功能。之前在使用SSM框架时，需要自己导入相关的依赖和配置，开启自动配置之后就可以自动完成相关配置。

在该注解中，包含了以下的注解内容：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";
```

`@AutoConfigurationPackage`: 自动配置包

自动配置包由如下的注解组成：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({Registrar.class})
public @interface AutoConfigurationPackage {
}
```

`@Import({Registrar.class})`: Import是Spring底层的注解，该注解给容器中导入一个组件。导入组件由`Registrar`定义。**该类将Application主配置类所在包下的所有子包中的组件添加扫描到Spring容器中。**

```java
 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());
        }
```

`EnableAutoConfigurationImportSelector`：自动配置导入的选择器。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。

```java
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    } else {
        try {
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            configurations = this.removeDuplicates(configurations);
            configurations = this.sort(configurations, autoConfigurationMetadata);
            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.filter(configurations, autoConfigurationMetadata);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return (String[])configurations.toArray(new String[configurations.size()]);
        } catch (IOException var6) {
            throw new IllegalStateException(var6);
        }
    }
}
```

其中Configuration中就包含了组件的全类名，由`this.getCandidateConfigurations(annotationMetadata, attributes);`方法获取，该方法中调用了`SpringFactoriesLoader.loadFactoryNames`。从配置文件中获取了全类名。

```java
Enumeration<URL> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");
```

Springboot在启动的时候从类路径下的`META-INF/spring.factories`中获取`EnableAutoConfiguration`指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。



## Springboot配置文件

springboot中有两种类型的配置文件：`application.properties`和`application.yml`。

配置文件的作用：Springboot在底层做好了组件的基本配置，当我们想要自定义配置时，就需要定义配置文件。

### YAML语法

#### 基本语法

YAML是基于键值对的语法模式，使用空格完成层级的缩进，只要是对齐的空格数，就认为是同一层级的。YAML相对于XML配置文件，更加关注数据。基本样式如下：

```yaml
server:
  port: 8081
```

#### 值语法

字面量：`k: v`字面量可以直接写，字符串默认不加单引号或者双引号。双引号不会转义字符串里面的特殊字符。而使用单引号会对特殊字符进行转义。

对象、Map：

```yaml
# 对象、map的写法
friends:
	lastName: zhangsan
	age: 20
	
# 对象、map的行内写法
friends: {lastName: zhangsan,age: 18}
```

数组：

```yaml
# 数组的写法
pets:
 - cat
 - dog
 - pig
# 数组的行内写法
pets: [cat,dog,pig]
```



### 配置文件值导入JavaBean

javaBean

```java
package com.pwddd.springboot.bean;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@ConfigurationProperties(prefix = "person")
@Component
public class Person {

    private String name;
    private Integer age;
    private boolean boss;
    private Map<String,String> maps;
    private List<String> lists;
    private Dog dog;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", boss=" + boss +
                ", maps=" + maps +
                ", lists=" + lists +
                ", dog=" + dog +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public boolean isBoss() {
        return boss;
    }

    public void setBoss(boolean boss) {
        this.boss = boss;
    }

    public Map<String, String> getMaps() {
        return maps;
    }

    public void setMaps(Map<String, String> maps) {
        this.maps = maps;
    }

    public List<String> getLists() {
        return lists;
    }

    public void setLists(List<String> lists) {
        this.lists = lists;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }
}

```

```java
package com.pwddd.bean;

public class Dog {
    private String name;
    private Integer age;

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public Dog() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
```

添加配置处理器，用来提示配置文件

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

编写配置文件

```yaml
person:
  name: zhangsan
  age: 12
  maps: {zhangsan: aaa,lisi: bbb}
  lists:
    - zhangsan
    - lisi
  dog:
    name: zhangsan
    age: 12
	
```

编写测试

```java
@SpringBootTest
class SpringbootApplicationTests {

    @Autowired
    Person person;

    @Test
    public void testProperties(){
        System.out.println(person);
    }
}
```

### 其他获取值的方法

```java
//@ConfigurationProperties(prefix = "person")
@Component
public class Person {

    private String name;
    @Value("${person.age}")
    private Integer age;
```

ConfigurationProperties和Value的区别：

|                      | @ConfigurationProperties | @Value     |
| -------------------- | ------------------------ | ---------- |
| 功能                 | 批量注入配置文件中的属性 | 一个个指定 |
| 松散绑定（松散语法） | 支持                     | 不支持     |
| SpEL                 | 不支持                   | 支持       |
| JSR303数据校验       | 支持                     | 不支持     |
| 复杂类型封装         | 支持                     | 不支持     |

如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。

### 配置文件注入值数据校验

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {
/**
* <bean class="Person">
* <property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#
{SpEL}"></property>
* <bean/>
*/
//lastName必须是邮箱格式
@Email
//@Value("${person.last‐name}")
private String lastName;
//@Value("#{11*2}")
private Integer age;
//@Value("true")
private Boolean boss;
private Date birth;
private Map<String,Object> maps;
private List<Object> lists;
private Dog dog;

```

### @PropertieSource

`@PropertieSource`:加载指定的配置文件。默认从全局配置文件中加载配置，如果需要指定其他的配置文件的位置，就可以使用该注解。

`@ImportResource`：导入Spring的配置文件，让配置文件里面的内容生效。SpringBoot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。想让Spring的配置文件生效，加载进来。

```java
@ImportResource(locations = {"classpath:beans.xml"})
//导入Spring的配置文件让其生效
```

SpringBoot推荐给容器中添加组件的方式，推荐使用全注解的方式。

1. 配置类添加`@Configuration`注解，指明当前类是一个配置类。

2. 使用`@Bean`给容器中添加组件

```java
package com.pwddd.springboot.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class MyAppConfig {
//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
    
}
```

### 配置文件占位符

#### 随机数

```yaml
${random.value}、${random.int}、${random.long}
${random.int(10)}、${random.int[1024,65536]}
```

#### 占位符获取配置值

```yaml
person.last‐name=张三${random.uuid}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=${person.hello:hello}_dog
person.dog.age=15
```

### profile多环境支持

我们在主配置文件编写的时候，文件名可以是 `application-{profile}.properties/yml`。

默认使用application.properties的配置。当我们需要激活指定的配置文件时，可以在主配置文件中指定：`spring.profiles.active=dev`或者使用命令行方式`java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev`，或者使用虚拟机方式`-Dspring.profiles.active=dev`。



### yml多文档块模式

```yaml
server:
 port: 8081
 spring:
 profiles:
 active: prod
‐‐‐
server:
 port: 8083
 spring:
 profiles: dev
‐‐‐
server:
 port: 8084
 spring:
 profiles: prod #指定属于哪个环境
```

### 配置文件的加载

springboot启动会扫描以下位置的`application.properties`或者`application.yml`文件作为Springboot的默认配置文件。

```text
–file:./config/  当前项目的config目录
–file:./
–classpath:/config/
–classpath:/
```

**优先级由高到底**，高优先级的配置会覆盖低优先级的配置。只要以上的配置文件存在Springboot就会加载，形成配置文件的互补。

我们还可以通过spring.config.location来改变默认的配置文件位置(**使用命令行参数的方式**)：

```yaml
java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev --spring.config.location=xxx
```

这个配置文件的位置会和其他位置上的配置文件共同加载。

SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会 形成互补配置。

1. 命令行参数
2. 来自java:comp/env的JNDI属性
3. Java系统属性（System.getProperties()）
4. 操作系统环境变量
5. RandomValuePropertySource配置的random.*属性值
6. jar包外部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件
7. jar包内部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件
8. jar包外部的`application.properties`或`application.yml`(不带spring.profile)配置文件
9. jar包内部的`application.properties`或`application.yml`(不带spring.profile)配置文件
10. `@Configuration`注解类上的`@PropertySource`
11. 通过`SpringApplication.setDefaultProperties`指定的默认属性



### 自动配置原理

配置文件能够配置的属性可以参考：[Springboot配置文件](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties)

1. Springboot启动类上有一个注解`@SpringBootApplication`，该注解是一个组合注解

   ```java
   @Target({ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   @Inherited
   @SpringBootConfiguration
   @EnableAutoConfiguration
   @ComponentScan(
       excludeFilters = {@Filter(
       type = FilterType.CUSTOM,
       classes = {TypeExcludeFilter.class}
   ), @Filter(
       type = FilterType.CUSTOM,
       classes = {AutoConfigurationExcludeFilter.class}
   )}
   )
   public @interface SpringBootApplication {
   ```

2. 其中有一个`@EnableAutoConfiguration`，该注解就是实现自动配置有关的注解。

   ```java
   @Target({ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   @Inherited
   @AutoConfigurationPackage
   @Import({AutoConfigurationImportSelector.class})
   public @interface EnableAutoConfiguration {
   ```

3. 其中`@Import`导入了一个自动配置导入选择器，在该选择器中，有一个方法，将所有的自动配置全类名保存到一个configurations中。

   ```java
       protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
           if (!this.isEnabled(annotationMetadata)) {
               return EMPTY_ENTRY;
           } else {
               AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
               List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
               configurations = this.removeDuplicates(configurations);
               Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
               this.checkExcludedClasses(configurations, exclusions);
               configurations.removeAll(exclusions);
               configurations = this.getConfigurationClassFilter().filter(configurations);
               this.fireAutoConfigurationImportEvents(configurations, exclusions);
               return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
           }
       }
   ```

4. 获取configuration的方法是`getCandidateConfigurations`。

   ```java
       protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
           List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
           Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
           return configurations;
       }
   ```

5. 该方法中调用了`SpringFactoriesLoader`中的`loadFactoryNames`获取到了所有的配置文件中配置的Auto Configuration全类名。

   ```java
   Enumeration urls = classLoader.getResources("META-INF/spring.factories");
   ```

6. 该方法扫描所有Jar包下的`META-INF/spring.factories`，把扫描到的这些文件的内容包装成properties对象，从properties中获取到`EnableAutoConfiguration.class`类(类名)对应的值，然后把他们添加在容器中。

7. 每一个这样的`xxxAutoConfiguration`类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。

8. 以`HttpEncodingAutoConfiguration`（Http编码自动配置）为例解释自动配置原理。

   ```java
   @Configuration(
       proxyBeanMethods = false
   )  // //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
   @EnableConfigurationProperties({ServerProperties.class})  ////启动指定类的ConfigurationProperties功能；将配置文件中对应的值和ServerProperties绑定起来；并把ServerProperties加入到ioc容器中
   
   @ConditionalOnWebApplication(
       type = Type.SERVLET
   )  // n //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效
   
   @ConditionalOnClass({CharacterEncodingFilter.class})  //判断当前项目有没有这个类, CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
   
   @ConditionalOnProperty(
       prefix = "server.servlet.encoding",
       value = {"enabled"},
       matchIfMissing = true
   ) // //判断配置文件中是否存在某个配置 server.servlet.encoding；如果不存在，判断也是成立的
   //即使我们配置文件中不配置server.servlet.encoding=true，也是默认生效的；
   public class HttpEncodingAutoConfiguration {
       
       // 和encoding做映射，encoding类中配置对应的相关配置文件的内容，加上上面的前缀。
       private final Encoding properties;
   
       //只有一个有参构造器的情况下，参数的值就会从容器中拿
       public HttpEncodingAutoConfiguration(ServerProperties properties) {
           this.properties = properties.getServlet().getEncoding();
       }
   
       @Bean  ////给容器中添加一个组件，这个组件的某些值需要从properties中获取
       @ConditionalOnMissingBean  //判断容器没有这个组件？
       public CharacterEncodingFilter characterEncodingFilter() {
           CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
           filter.setEncoding(this.properties.getCharset().name());
           filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));
           filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));
           return filter;
       }
   ```

9. 根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。

10. 所有在配置文件中能配置的属性都是在`xxxxProperties`类中封装的，配置文件能配置什么就可以参照某个功能对应的这个属性类。

    ```java
    public class Encoding {
        public static final Charset DEFAULT_CHARSET;
        private Charset charset;
        private Boolean force;
        private Boolean forceRequest;
        private Boolean forceResponse;
        private Map<Locale, Charset> mapping;
    ```



### Springboot的精髓

- SpringBoot启动会加载大量的自动配置类
- 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类
- 我们再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）
- 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。



### @Conditional派生注解

作用：对生效条件进行判断，必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。

| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |
| ------------------------------- | ------------------------------------------------ |
| @ConditionalOnJava              | 系统的java版本是否符合要求                       |
| @ConditionalOnBean              | 容器中存在指定Bean                               |
| @ConditionalOnMissingBean       | 容器中不存在指定Bean                             |
| @ConditionalOnExpression        | 满足SpEL表达式指定                               |
| @ConditionalOnClass             | 系统中有指定的类                                 |
| @ConditionalOnMissingClass      | 系统中没有指定的类                               |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |
| @ConditionalOnWebApplication    | 当前是web环境                                    |
| @ConditionalOnNotWebApplication | 当前不是web环境                                  |
| @ConditionalOnJndi              | JNDI存在指定项                                   |

因此，我们自动配置类需要在该类满足配置以上注解的条件下才能使用，我们可以在配置文件中开启debug模式，该模式可以打印自动配置报告，在该报告中标明了哪些类生效，哪些类不生效。

```text

============================
CONDITIONS EVALUATION REPORT
============================


Positive matches:
-----------------

   AopAutoConfiguration matched:
      - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)

   AopAutoConfiguration.ClassProxyingConfiguration matched:
      - @ConditionalOnMissingClass did not find unwanted class 'org.aspectj.weaver.Advice' (OnClassCondition)
      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)

   DispatcherServletAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition)
      - found 'session' scope (OnWebApplicationCondition)

   DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched:
      - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition)
      - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)

   DispatcherServletAutoConfiguration.DispatcherServletRegistrationConfiguration matched:
      - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition)
      - DispatcherServlet Registration did not find servlet registration bean (DispatcherServletAutoConfiguration.DispatcherServletRegistrationCondition)

……………………

Negative matches:
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)

   AopAutoConfiguration.AspectJAutoProxyingConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)

 …………………

Exclusions:
-----------

    None


Unconditional classes:
----------------------

    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration

    org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration

    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration

    org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration

    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration

```



## 日志
