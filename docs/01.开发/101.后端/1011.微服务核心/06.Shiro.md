---
title: Shiro
date: 2022-04-15 00:00:00
permalink: /dev/java/core/shiro
author:
 name: p0jo
 link: https://wiki.pwddd.com
categories:
  - 开发
  - 后端
  - 微服务核心
tags:
  - Springboot
  - Shiro
---

# Shiro

Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。

<!-- more -->

## 权限管理

### 权限管理的概念

基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现`对用户访问系统的控制`，按照安全规则或者[安全策略](http://baike.baidu.com/view/160028.htm)控制用户可以访问而且只能访问自己被授权的资源。

权限管理包括用户`身份认证`和`授权`两部分，简称`认证授权`。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。

### 身份认证的概念

`身份认证`，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用[指纹](http://baike.baidu.com/view/5628.htm)等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。

### 授权的概念

`授权，即访问控制`，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。



## Shiro的简介

> **Apache Shiro™** is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.  
>
> Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。
>
> Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。

### Shiro的核心架构

![image-20220328153324085](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328153324085.png)

#### subject

`Subject即主体`，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权。

#### securityManager

`SecurityManager即安全管理器`，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。

`SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。`

#### Authenticator

`Authenticator即认证器`，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。

#### Authorizer

`Authorizer即授权器`，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。

#### Realm

`Realm即领域`，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。

注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。

#### SessionManager

`sessionManager即会话管理`，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。

#### SessionDAO

`SessionDAO即会话dao`，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。

#### CacheManager

`CacheManager即缓存管理`，将用户权限数据存储在缓存，这样可以提高性能。

#### Cryptography

`Cryptography即密码管理`，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。



## Shiro认证

> 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。

### 认证的相关对象

#### subject 主体

访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； 

#### principal 身份信息

主体（subject）进行身份认证的标识，标识必须具有`唯一性`，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。

#### credential 凭证信息

只有主体自己知道的安全信息，如密码、证书等。

### 认证的流程

![image-20220328153743809](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328153743809.png)



### 实现一个最简单的认证

1. 添加shiro的依赖，本次使用的shiro版本是：shiro1.5.3

   ```xml
   <dependencies>
     <dependency>
       <groupId>org.apache.shiro</groupId>
       <artifactId>shiro-core</artifactId>
       <version>1.5.3</version>
     </dependency>
   ```

2. 引入shiro配置文件，这个配置文件在后续的整合中用不到，只是为了学习使用的一个模拟的场景，以后的用户身份信息是要从数据库中取的。

   ```ini
   [users]
   zhangsan=123456
   lisi=123.bmk
   ```

3. 测试认证的代码

   ```java
   package com.pwddd.shirodemo;
   
   import org.apache.shiro.SecurityUtils;
   import org.apache.shiro.authc.IncorrectCredentialsException;
   import org.apache.shiro.authc.UnknownAccountException;
   import org.apache.shiro.authc.UsernamePasswordToken;
   import org.apache.shiro.mgt.DefaultSecurityManager;
   import org.apache.shiro.realm.text.IniRealm;
   import org.apache.shiro.subject.Subject;
   
   public class TestAuthenticator {
       public static void main(String[] args) {
   
           // 1. 创建SecurityManager
           DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
   
           // 2. 创建默认的IniRealm 指定ini配置文件的位置
           IniRealm iniRealm = new IniRealm("classpath:shiro.ini");
   
           // 3. 给securityManager设置一个realm
           defaultSecurityManager.setRealm(iniRealm);
   
           // 4. 将安全工具类中设置一个安全管理器
           SecurityUtils.setSecurityManager(defaultSecurityManager);
   
           // 5. 获取主体对象
           Subject subject = SecurityUtils.getSubject();
   
           // 6. 模拟登陆信息创建令牌
           UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");
   
           try {
   
               // 7. 尝试使用令牌登陆
               subject.login(token);
               System.out.println("认证成功"+subject.isAuthenticated());
           }catch (UnknownAccountException e){
               System.out.println("用户名不存在");
           }catch (IncorrectCredentialsException e){
               System.out.println("认证未通过");
           }
       }
   }
   
   ```

对应的异常分类：

- DisabledAccountException（帐号被禁用）

- LockedAccountException（帐号被锁定）

- ExcessiveAttemptsException（登录失败次数过多）

- ExpiredCredentialsException（凭证过期）等



### 源码追踪shiro中的认证过程

用户名验证的调用：

```
doGetAuthenticationInfo:162, SimpleAccountRealm (org.apache.shiro.realm)
getAuthenticationInfo:571, AuthenticatingRealm (org.apache.shiro.realm)
doSingleRealmAuthentication:180, ModularRealmAuthenticator (org.apache.shiro.authc.pam)
doAuthenticate:273, ModularRealmAuthenticator (org.apache.shiro.authc.pam)
authenticate:198, AbstractAuthenticator (org.apache.shiro.authc)
authenticate:106, AuthenticatingSecurityManager (org.apache.shiro.mgt)
login:275, DefaultSecurityManager (org.apache.shiro.mgt)
login:260, DelegatingSubject (org.apache.shiro.subject.support)
main:35, TestAuthenticator (com.pwddd.shirodemo)
```

最终在org.apache.shiro.realm.SimpleAccountRealm#doGetAuthenticationInfo根据token中的用户名在在对应的配置文件中查找对应的用户，**此处还没有做密码的校验。**

![image-20220328160136369](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328160136369.png)



密码校验的调用：

```
doCredentialsMatch:127, SimpleCredentialsMatcher (org.apache.shiro.authc.credential)
assertCredentialsMatch:600, AuthenticatingRealm (org.apache.shiro.realm)
getAuthenticationInfo:581, AuthenticatingRealm (org.apache.shiro.realm)
doSingleRealmAuthentication:180, ModularRealmAuthenticator (org.apache.shiro.authc.pam)
doAuthenticate:273, ModularRealmAuthenticator (org.apache.shiro.authc.pam)
authenticate:198, AbstractAuthenticator (org.apache.shiro.authc)
authenticate:106, AuthenticatingSecurityManager (org.apache.shiro.mgt)
login:275, DefaultSecurityManager (org.apache.shiro.mgt)
login:260, DelegatingSubject (org.apache.shiro.subject.support)
main:35, TestAuthenticator (com.pwddd.shirodemo)
```

最终在org.apache.shiro.authc.credential.SimpleCredentialsMatcher#doCredentialsMatch中验证密码是否匹配。

![image-20220328160440723](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328160440723.png)



shiro中的Realm的类结构如下：

![image-20220328160636674](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328160636674.png)

根据源码发现，认证使用的是SimpleAccountRealm

![image-20220328160807171](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328160807171.png)

在SimpleAccountRealm有两个方法，一个是用来认证的，另一个是用来授权的。

```java
public class SimpleAccountRealm extends AuthorizingRealm {
  //.......省略
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    UsernamePasswordToken upToken = (UsernamePasswordToken) token;
    SimpleAccount account = getUser(upToken.getUsername());

    if (account != null) {

      if (account.isLocked()) {
        throw new LockedAccountException("Account [" + account + "] is locked.");
      }
      if (account.isCredentialsExpired()) {
        String msg = "The credentials for account [" + account + "] are expired";
        throw new ExpiredCredentialsException(msg);
      }

    }

    return account;
  }

  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
    String username = getUsername(principals);
    USERS_LOCK.readLock().lock();
    try {
      return this.users.get(username);
    } finally {
      USERS_LOCK.readLock().unlock();
    }
  }
}
```



### 自定义的Realm

在上面的程序中，我们使用的shiro自带的IniRealm，并且用户名密码是储存到ini配置文件中的，在大部分的情况下，我们需要从系统的数据库中读取相关的用户信息，因此需要自定义Realm。

```java
package com.pwddd.shirodemo.realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

public class CustomerRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        String principal = (String) authenticationToken.getPrincipal();
        if ("zhangsan".equals(principal)){
          
          	// 这里模拟从数据库中查询获取到的用户名和密码
            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo("zhangsan", "123", this.getName());
            return authenticationInfo;
        }
        return null;
    }
}

```

自定义Realm的测试方法：

```java
package com.pwddd.shirodemo;

import com.pwddd.shirodemo.realm.CustomerRealm;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.subject.Subject;

public class TestCustomerRealm {
    public static void main(String[] args) {
        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
        defaultSecurityManager.setRealm(new CustomerRealm());

        SecurityUtils.setSecurityManager(defaultSecurityManager);

        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123");


        try {
            subject.login(token);
        } catch (AuthenticationException e) {
            e.printStackTrace();
        }
    }
}
```



#### 使用MD5加密和盐

> 在上面的测试中，我们一直使用的是明文密码的方式，这种方式有很大的安全隐患，和我们使用安全框架的初衷相背离。在实际的场景中，一般是在注册阶段，将用户设置的密码加盐然后散列存储到数据库中，然后使用shiro从数据库中读取出盐和秘文，完成密码校验。

##### MD5测试

```java
package com.pwddd.shirodemo;

import org.apache.shiro.crypto.hash.Md5Hash;

public class TestMD5 {
  public static void main(String[] args) {

    Md5Hash hash = new Md5Hash();
    hash.setBytes("123456".getBytes());
    System.out.println(hash.toHex()); // 313233343536


    // md5加密
    Md5Hash md5Hash = new Md5Hash("123456");
    System.out.println(md5Hash.toHex()); // e10adc3949ba59abbe56e057f20f883e
    // 加盐
    Md5Hash md5HashWithSalt = new Md5Hash("123456","123/BMK#");
    System.out.println(md5HashWithSalt.toHex()); //a43ebab3045680d4b3d6c5ccac659d10

    //散列
    Md5Hash hashInter = new Md5Hash("123456", "123/BMK#", 1024);
    System.out.println(hashInter.toHex()); //a991e133559f1891893b60a3c04e8740

  }
}
```

##### 自定义Realm实现MD5

```java
package com.pwddd.shirodemo.realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

public class CustomerRealm extends AuthorizingRealm {
  @Override
  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
    return null;
  }

  @Override
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
    String credentials = (String) authenticationToken.getCredentials();
    if ("zhangsan".equals(credentials)){
      
      // 模拟查出来的密码是加密后的密码，其他不变
      SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
        "zhangsan",
        "e10adc3949ba59abbe56e057f20f883e",
        this.getName());

      return authenticationInfo;
    }
    return null;
  }
}

```



测试方法：

```java
package com.pwddd.shirodemo;

import com.pwddd.shirodemo.realm.CustomerRealm;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.subject.Subject;

public class TestMD5Realm {
    public static void main(String[] args) {
        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();

        CustomerRealm customerRealm = new CustomerRealm();

        // 设置md5加密
        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName("MD5");

        customerRealm.setCredentialsMatcher(hashedCredentialsMatcher);

        defaultSecurityManager.setRealm(customerRealm);

        SecurityUtils.setSecurityManager(defaultSecurityManager);

        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");

        try {
            subject.login(token);
            System.out.println("登陆成功");
        } catch (AuthenticationException e) {
            e.printStackTrace();
        }


    }
}

```



##### 自定义Realm实现MD5加salt方式

```java
package com.pwddd.shirodemo.realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;

public class CustomerRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        String principal = (String) authenticationToken.getPrincipal();

        if ("zhangsan".equals(principal)){
            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                    "zhangsan",
                    "a43ebab3045680d4b3d6c5ccac659d10",
                    // 由于盐也是从数据库中查出来的，因此在这里一起配置了
                    ByteSource.Util.bytes("123/BMK#"),
                    this.getName());

            return authenticationInfo;
        }
        return null;
    }
}

```

测试方法和上面的一样。



##### 自定义Realm 实现 自定义MD5+salt+散列

1. 如果使用了散列hash，则从数据库中查出来的是散列之后的，因此realm不需要变

2. 测试方法中需要指定散列的次数，因为用户输入明文密码时，shrio不知道散列的次数，因此对比会失败。

   ```java
   package com.pwddd.shirodemo;
   
   import com.pwddd.shirodemo.realm.CustomerRealm;
   import org.apache.shiro.SecurityUtils;
   import org.apache.shiro.authc.AuthenticationException;
   import org.apache.shiro.authc.IncorrectCredentialsException;
   import org.apache.shiro.authc.UsernamePasswordToken;
   import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
   import org.apache.shiro.mgt.DefaultSecurityManager;
   import org.apache.shiro.subject.Subject;
   
   public class TestMD5Realm {
     public static void main(String[] args) {
       DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
   
       CustomerRealm customerRealm = new CustomerRealm();
   
       // 设置md5加密
       HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
       hashedCredentialsMatcher.setHashAlgorithmName("MD5");
       // 设置散列次数
       hashedCredentialsMatcher.setHashIterations(1024);
   
       customerRealm.setCredentialsMatcher(hashedCredentialsMatcher);
   
       defaultSecurityManager.setRealm(customerRealm);
   
       SecurityUtils.setSecurityManager(defaultSecurityManager);
   
       Subject subject = SecurityUtils.getSubject();
   
       UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");
   
       try {
         subject.login(token);
         System.out.println("登陆成功");
       } catch (IncorrectCredentialsException e) {
         e.printStackTrace();
         System.out.println("密码错误");
       }
     }
   }
   
   ```

   

## Shiro授权

> 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。

### Shiro 授权的关键对象

`Who，即主体（Subject）`，主体需要访问系统中的资源。

`What，即资源（Resource)`，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括`资源类型`和`资源实例`，比如`商品信息为资源类型`，类型为t01的商品为`资源实例`，编号为001的商品信息也属于资源实例。

`How，权限/许可（Permission)`，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。

### 授权的流程

![image-20220328190052598](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328190052598.png)



### 授权的方式

-  基于角色的访问控制

  - RBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制

  ```java
  if(subject.hasRole("admin")){
     //操作什么资源
  }
  ```

- 基于资源的访问控制

  - RBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制

  ```java
  if(subject.isPermission("user:update:01")){ //资源实例
    //对01用户进行修改
  }
  if(subject.isPermission("user:update:*")){  //资源类型
    //对01用户进行修改
  }
  ```
  

### 权限字符串

权限字符串的规则是：**资源标识符：操作：资源实例标识符**，意思是 对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。

例子：

- 用户创建权限：user:create，或user:create:*
- 用户修改实例001的权限：user:update:001
- 用户实例001的所有权限：user:*：001

### 授权实现方式

- 编程式

```java
Subject subject = SecurityUtils.getSubject();
if(subject.hasRole(“admin”)) {
	//有权限
} else {
	//无权限
}
```

- 注解式

```java
@RequiresRoles("admin")
public void hello() {
	//有权限
}
```

- 标签式

```jsp
JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成：
<shiro:hasRole name="admin">
	<!— 有权限—>
</shiro:hasRole>
注意: Thymeleaf 中使用shiro需要额外集成!
```

### 开发实现

1. 自定义realm

```java
package com.pwddd.shirodemo.realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;

public class CustomerMD5Realm extends AuthorizingRealm {
    /**
     * 授权
     * @param principalCollection
     * @return
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {

        String principal = (String) principalCollection.getPrimaryPrincipal();
        System.out.println("--------------------------------------------");
        System.out.println("principal:"+principal);

        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        simpleAuthorizationInfo.addRole("admin");

        simpleAuthorizationInfo.addStringPermission("user:create:*");
        return simpleAuthorizationInfo;
    }

    /**
     * 认证
     * @param authenticationToken
     * @return
     * @throws AuthenticationException
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {

        String principal = (String) authenticationToken.getPrincipal();

        if ("zhangsan".equals(principal)){

            AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                    principal,
                    "a991e133559f1891893b60a3c04e8740",
                    ByteSource.Util.bytes("123/BMK#"),
                    this.getName()
            );
            return authenticationInfo;

        }
        return null;
    }
}

```



2. 授权测试代码

```java
package com.pwddd.shirodemo;

import com.pwddd.shirodemo.realm.CustomerMD5Realm;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.subject.Subject;

public class TestCustomerMD5Realm {
    public static void main(String[] args) {

        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
        CustomerMD5Realm customerMD5Realm = new CustomerMD5Realm();

        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName("MD5");
        hashedCredentialsMatcher.setHashIterations(1024);

        customerMD5Realm.setCredentialsMatcher(hashedCredentialsMatcher);
        defaultSecurityManager.setRealm(customerMD5Realm);

        SecurityUtils.setSecurityManager(defaultSecurityManager);

        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");

        try {
            subject.login(token);
            System.out.println("认证成功");
            System.out.println(subject.hasRole("admin"));
            System.out.println(subject.isPermitted("user:create:01"));
        } catch (UnknownAccountException e) {
//            e.printStackTrace();
            System.out.println("用户名不存在");
        } catch (IncorrectCredentialsException e){
            System.out.println("密码错误");
        }


    }
}

```

## 整合Springboot

### 整合的思路

![image-20220328201751896](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328201751896.png)

### 整合的步骤

#### 0. 创建Springboot项目

![image-20220328202724915](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220328202724915.png)

#### 1. 引入相关依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.pwddd</groupId>
    <artifactId>springboot_jsp_shiro</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-parent</artifactId>
        <version>2.6.4</version>
    </parent>
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.2</version>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-jasper</artifactId>
        </dependency>

        <dependency>
            <groupId>jstl</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>

    </dependencies>

</project>

```

引入shiro整合springboot

```xml
<dependency>
  <groupId>org.apache.shiro</groupId>
  <artifactId>shiro-spring-boot-starter</artifactId>
  <version>1.5.3</version>
</dependency>
```

#### 2. 配置Spring Boot项目

配置Springboot配置文件

```properties
server.port=8888
server.servlet.context-path=/shiro
spring.mvc.view.prefix=/
spring.mvc.view.suffix=.jsp
```

配置工作目录

![image-20220414214927415](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220414214927415.png)

#### 3. 配置shiro环境

##### 0. 创建配置类

```java
package com.pwddd.shiro.config;

import com.pwddd.shiro.realm.CustomerRealm;
import org.apache.shiro.realm.Realm;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * 用于整合shiro的配置类
 */
@Configuration
public class ShiroConfig {
    //1. 创建shiro filter
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager){
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
        factoryBean.setSecurityManager(defaultWebSecurityManager);

        // 配置系统的受限资源和公共资源
        Map<String,String> map = new HashMap<>();
        map.put("/login.jsp","anon");
        map.put("/user/login","anon");
        map.put("/**","authc");

        // 默认的认证界面 login.jsp
        factoryBean.setLoginUrl("/login.jsp");

        factoryBean.setFilterChainDefinitionMap(map);
        return factoryBean;


    }
    //2. 创建安全管理器
    @Bean
    public DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
        defaultWebSecurityManager.setRealm(realm);
        return defaultWebSecurityManager;
    }
}

```

##### 1. 创建自定义realm

```java
package com.pwddd.shiro.realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

public class CustomerRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        System.out.println("====================================");
        String principal = (String) authenticationToken.getPrincipal();

        if ("zhangsan".equals(principal)){

            SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                    principal,
                    "123456",
                    this.getName()
            );
            return authenticationInfo;
        }
        return null;
    }
}

```

##### 2. 配置页面跳转

```java
package com.pwddd.shiro.controller;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.subject.Subject;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("user")
public class UserController {

    @PostMapping("login")
    public String login(String username,String password){

        Subject subject = SecurityUtils.getSubject();

        try {
            subject.login(new UsernamePasswordToken(username,password));
            return "redirect:/index.jsp";
        } catch (UnknownAccountException e) {
//            e.printStackTrace();
            System.out.println("用户名错误");
        } catch (IncorrectCredentialsException e){
            System.out.println("密码错误");
        }

        return "redirect:/login.jsp";
    }
    @GetMapping("logout")
    public String logout(){
        Subject subject = SecurityUtils.getSubject();
        subject.logout();
        return "redirect:/login.jsp";
    }
}

```

注意:

**默认在配置好shiro环境后默认环境中没有对项目中任何资源进行权限控制,所有现在项目中所有资源都可以通过路径访问**

#### 4. 常见过滤器

注意: **shiro提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限：**

| 配置缩写          | 对应的过滤器                   | 功能                                                         |
| ----------------- | ------------------------------ | ------------------------------------------------------------ |
| anon              | AnonymousFilter                | 指定url可以匿名访问                                          |
| authc             | FormAuthenticationFilter       | 指定url需要form表单登录，默认会从请求中获取`username`、`password`,`rememberMe`等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 |
| authcBasic        | BasicHttpAuthenticationFilter  | 指定url需要basic登录                                         |
| logout            | LogoutFilter                   | 登出过滤器，配置指定url就可以实现退出功能，非常方便          |
| noSessionCreation | NoSessionCreationFilter        | 禁止创建会话                                                 |
| perms             | PermissionsAuthorizationFilter | 需要指定权限才能访问                                         |
| port              | PortFilter                     | 需要指定端口才能访问                                         |
| rest              | HttpMethodPermissionFilter     | 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 |
| roles             | RolesAuthorizationFilter       | 需要指定角色才能访问                                         |
| ssl               | SslFilter                      | 需要https请求才能访问                                        |
| user              | UserFilter                     | 需要已登录或“记住我”的用户才能访问                           |

#### 5. 认证的实现

##### 1. login.jsp开发认证界面

```jsp
<%--
  Created by IntelliJ IDEA.
  User: plankton
  Date: 2022/3/28
  Time: 20:26
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>登录</title>
  </head>
  <body>
    <h1>登录</h1>
    <form action="${pageContext.request.contextPath}/user/login" method="post">
      用户名：<input type="text" name="username" > <br>
      密码 ：<input type="password" name="password"> <br>
      <input type="submit" name="提交">
    </form>
  </body>
</html>

```

##### 2. index页面

```JSP
<%--
  Created by IntelliJ IDEA.
  User: plankton
  Date: 2022/3/28
  Time: 20:26
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>首页</title>
  </head>
  <body>
    <h1>首页</h1>
    <a href="${pageContext.request.contextPath}/user/logout">退出登陆</a> <br>
    <ul>
      <li><a href="#">用户管理</a></li>
      <li><a href="#">商品管理</a></li>
      <li><a href="#">订单管理</a></li>
      <li><a href="#">物流管理</a></li>
    </ul>
  </body>
</html>

```

#### 7. MD5和salt认证的实现

##### 0. 实现注册

 注册页面：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>注册</title>
</head>
<body>
<h1>注册</h1>
<form action="${pageContext.request.contextPath}/user/register" method="post">
    用户名：<input type="text" name="username" > <br>
    密码 ：<input type="password" name="password"> <br>
    <input type="submit" name="提交">
</form>
</body>
</html>


```

##### 1. 引入数据库

相关依赖

```xml
<dependency>
  <groupId>org.mybatis.spring.boot</groupId>
  <artifactId>mybatis-spring-boot-starter</artifactId>
  <version>2.2.2</version>
</dependency>

<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>8.0.28</version>
</dependency>

<dependency>
  <groupId>com.alibaba</groupId>
  <artifactId>druid</artifactId>
  <version>1.2.8</version>
</dependency>

```

配置

```properties
# 数据源
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://localhost:3306/shirodemo?characterEncoding=utf8
spring.datasource.username=root
spring.datasource.password=123456
```

创建entity

```java
package com.pwddd.shirojsp.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String id;
    private String username;
    private String password;
}

```

编写mapper文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--名称空间和查询中的名称空间一致-->
<mapper namespace="com.pwddd.shirojsp.mapper.UserMapper">

    <insert id="save" parameterType="com.pwddd.shirojsp.entity.User">
        insert into t_user values(#{id},#{username},#{password})
    </insert>
</mapper>

```

配置mybatis

```properties
# mybatis
mybatis.type-aliases-package=com.pwddd.shirojsp.entity
mybatis.mapper-locations=classpath:mapper/*.xml
```

创建service层

```java
package com.pwddd.shirojsp.service.impl;

import com.pwddd.shirojsp.entity.User;
import com.pwddd.shirojsp.mapper.UserMapper;
import com.pwddd.shirojsp.service.UserService;
import org.apache.shiro.crypto.hash.Md5Hash;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.UUID;

@Service("userServiceImpl")
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public void register(User user) {
        String uuid = UUID.randomUUID().toString();
        uuid = uuid.replace("-","");
        user.setId(uuid);
        Md5Hash md5Hash = new Md5Hash(user.getPassword(), uuid, 1024);
        user.setPassword(md5Hash.toHex());
        userMapper.save(user);
    }
}

```

编写controller层

```java
@PostMapping("register")
public String register(User user){
  userService.register(user);
  return "redirect:/login.jsp";
}
```

##### 3. 认证实现

数据库查询用户信息

```java
 @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        System.out.println("====================================");
        String principal = (String) authenticationToken.getPrincipal();

        // 1. 利用名字去查询数据库
        User user = userService.getUser(principal);
        if (user != null){
            return new SimpleAuthenticationInfo(
                    user.getUsername(),
                    user.getPassword(),
                    ByteSource.Util.bytes(user.getId()),
                    this.getName()
            );
        }
        return null;
    }
```

设置加密算法和散列次数

```java
//2. 创建安全管理器
@Bean
public DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){
  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();

  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
  credentialsMatcher.setHashAlgorithmName("MD5");
  credentialsMatcher.setHashIterations(1024);
  realm.setCredentialsMatcher(credentialsMatcher);

  defaultWebSecurityManager.setRealm(realm);
  return defaultWebSecurityManager;
}
```

#### 8. 授权的实现

##### 0. 授权页面

```jsp
<%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>
<%--
  Created by IntelliJ IDEA.
  User: plankton
  Date: 2022/3/28
  Time: 20:26
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>首页</title>
</head>
<body>
<h1>首页</h1>
<a href="${pageContext.request.contextPath}/user/logout">退出登陆</a> <br>
<ul>
    <shiro:hasAnyRoles name="admin" >
        
        <shiro:hasAnyRoles name="user">
            <li><a href="#">用户管理</a></li>
        </shiro:hasAnyRoles>
        
        <shiro:hasAnyRoles name="order">
            <li><a href="#">商品管理</a></li>
            <li><a href="#">订单管理</a></li>
            <li><a href="#">物流管理</a></li>
        </shiro:hasAnyRoles>
        
    </shiro:hasAnyRoles>
</ul>
</body>
</html>
```

##### 1. 测试代码

```java
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
  String principal = (String) principalCollection.getPrimaryPrincipal();
  if ("admin".equals(principal)){
    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
    authorizationInfo.addRoles(Arrays.asList("admin","user"));
    return authorizationInfo;
  }
  return null;
}
```

##### 2. 方法调用中的权限控制

```java
@RequestMapping("delete/{username}")
@ResponseBody
@RequiresRoles(value = {"admin","user"})
public String deleteUser(@PathParam("username")String username){
    userService.deleteUser(username);
    return "success";
}
```

##### 3. 授权数据持久化

通常情况下，我们的授权信息存储到数据库中，我们这里使用一个用户对应多个角色，角色对应权限的RBAC模型进行设计。如下图所示：

![image-20220415094813133](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220415094813133.png)

创建对应的表：

```sql
drop table if exists t_role;
create table if not exists t_role
(
    rid   varchar(100) not null,
    rname varchar(200) not null,
    primary key (rid)
);

insert into t_role
values ('1', 'admin'),
       ('2', 'user'),
       ('3', 'order');

drop table if exists t_permission;
create table if not exists t_permission
(
    pid   varchar(100) not null,
    pname varchar(200) not null,
    url   varchar(200) not null,
    primary key (pid)
);

insert into t_permission
values ('1', 'user:*:*', '/user/*'),
       ('2', 'order:*:*', '/order/*'),
       ('3', 'user:delete:*', '/user/delete/');


drop table if exists t_user_role;
create table if not exists t_user_role
(
    id  varchar(100) not null,
    uid varchar(100) not null,
    rid varchar(100) not null,
    primary key (id)
);

insert into t_user_role
values ('1', '826975e8649341c1b6af743e4f9923f2', '1'),
       ('2', '826975e8649341c1b6af743e4f9923f2', '2'), -- admin all
       ('3', '826975e8649341c1b6af743e4f9923f2', '3'),
       ('4', '00b6c77cb7c048e9a6a8858a600cc206', '3'); -- lisi order

drop table if exists t_role_permission;
create table t_role_permission
(
    id  varchar(100) not null,
    rid varchar(100) not null,
    pid varchar(100) not null,
    primary key (id)
);

insert into t_role_permission
values ('1', '1', '1'),
       ('2', '1', '2'),
       ('3', '1', '3'),
       ('4', '2', '1'),
       ('5', '2', '3'),
       ('6', '3', '2'),
       ('7', '3', '2');
```

编写实体类：

```java
package com.pwddd.shirojsp.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

import java.util.List;

@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    
    private String id;
    private String rid;
    private String rname;
    
    private List<Perm> perms;
    
}


package com.pwddd.shirojsp.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

@Data
@Accessors(chain = true)
@NoArgsConstructor
@AllArgsConstructor
public class Perm {

    private String id;
    private String pid;
    private String pname;
}

```

查询用户时就查所有的用户权限和身份信息：

```xml
<resultMap id="usermap" type="User">
  <id column="id" property="id" />
  <result column="username" property="username" />
  <result column="password" property="password" />
  <collection property="roles" ofType="Role" >
    <id column="role_id" property="rid" />
    <result column="role_name" property="rname" />
    <collection property="perms" ofType="Perm">
      <id column="perm_id" property="pid" />
      <result column="perm_name" property="pname" />
      <result column="perm_url" property="purl" />
    </collection>
  </collection>
</resultMap>
<select id="selectUser" resultMap="usermap">
  select u.id, u.username, u.password, r.rid role_id, r.rname role_name,tp.pid perm_id,tp.pname perm_name,tp.url perm_url
  from t_user u
  left join t_user_role ur on u.id = ur.uid
  left join t_role r on ur.rid = r.rid
  left join t_role_permission trp on r.rid = trp.rid
  left join t_permission tp on trp.pid = tp.pid
  where username = #{username}
</select>
```

设置权限信息：

```java
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        String principal = (String) principalCollection.getPrimaryPrincipal();

        // 根据principal查询对应的用户组
        User user = userService.getUser(principal);
        if (user != null){
            SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
            for (Role role :
                    user.getRoles()) {
                authorizationInfo.addRole(role.getRname());
                for (Perm perm : role.getPerms()){
                    authorizationInfo.addStringPermission(perm.getPname());
                }
            }
            return authorizationInfo;
        }

        return null;
    }
```

#### 9. 使用CacheManager

##### 0. Ehcache

引入依赖

```xml
<dependency>
  <groupId>org.apache.shiro</groupId>
  <artifactId>shiro-ehcache</artifactId>
  <version>1.5.3</version>
</dependency>
```

开启缓存

```java
//2. 创建安全管理器
@Bean
public DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm){

  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();

  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
  credentialsMatcher.setHashAlgorithmName("MD5");
  credentialsMatcher.setHashIterations(1024);
  realm.setCredentialsMatcher(credentialsMatcher);
  realm.setCacheManager(new EhCacheManager());
  realm.setCachingEnabled(true);
  realm.setAuthorizationCachingEnabled(true);
  realm.setAuthenticationCachingEnabled(true);
  defaultWebSecurityManager.setRealm(realm);
  return defaultWebSecurityManager;
}
```

##### 1. redis

引入redis依赖：

```xml
<!--redis整合springboot-->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

配置连接：

```properties
# redis
spring.redis.database=0
spring.redis.host=localhost
spring.redis.port=6379
```

配置RedisCacheManager

```java
package com.pwddd.shirojsp.cache;

import org.apache.shiro.cache.Cache;
import org.apache.shiro.cache.CacheException;
import org.apache.shiro.cache.CacheManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.cache.CacheProperties;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

@Component
public class RedisCacheManager implements CacheManager {

    @Autowired
    private RedisCache redisCache;

    @Override
    public <K, V> Cache<K, V> getCache(String s) throws CacheException {
        System.out.println(s);
        redisCache.setCacheName(s);
        return redisCache;
    }
}

```

配置RedisCache

```java
package com.pwddd.shirojsp.cache;

import org.apache.shiro.cache.Cache;
import org.apache.shiro.cache.CacheException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Set;

@Component
public class RedisCache<K,V> implements Cache<K,V> {

    private String cacheName;


    public RedisCache() {
    }

    public String getCacheName() {
        return cacheName;
    }

    public void setCacheName(String cacheName) {
        this.cacheName = cacheName;
    }

    @Autowired
    private RedisTemplate redisTemplate;

    @Override
    public V get(K k) throws CacheException {
        V value = (V) redisTemplate.opsForHash().get(this.getCacheName(), k);
        System.out.println("【Redis - GET】{ key:"+k+",Value:"+value);
        return value;
    }

    @Override
    public V put(K k, V v) throws CacheException {
        System.out.println("【Redis - PUT】{ key:"+k+",Value:"+v);
        redisTemplate.opsForHash().put(this.cacheName,k.toString(),v);
        return null;
    }

    @Override
    public V remove(K k) throws CacheException {
        V value = (V) redisTemplate.opsForHash().delete(this.cacheName, k.toString());
        System.out.println("【Redis - PUT】{ key:"+k+",Value:"+value);
        return value;
    }

    @Override
    public void clear() throws CacheException {
        System.out.println("【Redis - CLEAR】{} ");
        redisTemplate.delete(this.getCacheName());
    }

    @Override
    public int size() {
        return redisTemplate.opsForHash().size(this.cacheName).intValue();
    }

    @Override
    public Set<K> keys() {
        return redisTemplate.opsForHash().keys(this.cacheName);
    }

    @Override
    public Collection<V> values() {
        return redisTemplate.opsForHash().values(this.cacheName);
    }
}

```

配置缓存管理器

```java
@Bean
public DefaultWebSecurityManager defaultWebSecurityManager(AuthorizingRealm realm,RedisCacheManager redisCacheManager){

  DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();

  HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
  credentialsMatcher.setHashAlgorithmName("MD5");
  credentialsMatcher.setHashIterations(1024);
  realm.setCredentialsMatcher(credentialsMatcher);
  realm.setCacheManager(redisCacheManager);
  realm.setCachingEnabled(true);
  realm.setAuthorizationCachingEnabled(true);
  realm.setAuthenticationCachingEnabled(true);
  defaultWebSecurityManager.setRealm(realm);
  return defaultWebSecurityManager;
}

```

测试之后报错，因为盐不能够序列化，因此还需要解决这个bug

`nested exception is java.io.NotSerializableException: org.apache.shiro.util.SimpleByteSource`

```java
package com.pwddd.shirojsp.cache;

import org.apache.shiro.codec.Base64;
import org.apache.shiro.codec.CodecSupport;
import org.apache.shiro.codec.Hex;
import org.apache.shiro.util.ByteSource;

import java.io.File;
import java.io.InputStream;
import java.io.Serializable;
import java.util.Arrays;

public class CustomerByteSource implements ByteSource, Serializable {


    private static final long serialVersionUID = -6698337076775679951L;
    private  byte[] bytes;
    private String cachedHex;
    private String cachedBase64;

    public CustomerByteSource(byte[] bytes) {
        this.bytes = bytes;
    }

    /**
     * Creates an instance by converting the characters to a byte array (assumes UTF-8 encoding).
     *
     * @param chars the source characters to use to create the underlying byte array.
     * @since 1.1
     */
    public CustomerByteSource(char[] chars) {
        this.bytes = CodecSupport.toBytes(chars);
    }

    /**
     * Creates an instance by converting the String to a byte array (assumes UTF-8 encoding).
     *
     * @param string the source string to convert to a byte array (assumes UTF-8 encoding).
     * @since 1.1
     */
    public CustomerByteSource(String string) {
        this.bytes = CodecSupport.toBytes(string);
    }

    /**
     * Creates an instance using the sources bytes directly - it does not create a copy of the
     * argument's byte array.
     *
     * @param source the source to use to populate the underlying byte array.
     * @since 1.1
     */
    public CustomerByteSource(ByteSource source) {
        this.bytes = source.getBytes();
    }

    /**
     * Creates an instance by converting the file to a byte array.
     *
     * @param file the file from which to acquire bytes.
     * @since 1.1
     */
    public CustomerByteSource(File file) {
        this.bytes = new CustomerByteSource.BytesHelper().getBytes(file);
    }

    /**
     * Creates an instance by converting the stream to a byte array.
     *
     * @param stream the stream from which to acquire bytes.
     * @since 1.1
     */
    public CustomerByteSource(InputStream stream) {
        this.bytes = new CustomerByteSource.BytesHelper().getBytes(stream);
    }

    /**
     * Returns {@code true} if the specified object is a recognized data type that can be easily converted to
     * bytes by instances of this class, {@code false} otherwise.
     * <p/>
     * This implementation returns {@code true} IFF the specified object is an instance of one of the following
     * types:
     * <ul>
     * <li>{@code byte[]}</li>
     * <li>{@code char[]}</li>
     * <li>{@link ByteSource}</li>
     * <li>{@link String}</li>
     * <li>{@link File}</li>
     * </li>{@link InputStream}</li>
     * </ul>
     *
     * @param o the object to test to see if it can be easily converted to bytes by instances of this class.
     * @return {@code true} if the specified object can be easily converted to bytes by instances of this class,
     *         {@code false} otherwise.
     * @since 1.2
     */
    public static boolean isCompatible(Object o) {
        return o instanceof byte[] || o instanceof char[] || o instanceof String ||
                o instanceof ByteSource || o instanceof File || o instanceof InputStream;
    }

    public byte[] getBytes() {
        return this.bytes;
    }

    public boolean isEmpty() {
        return this.bytes == null || this.bytes.length == 0;
    }

    public String toHex() {
        if ( this.cachedHex == null ) {
            this.cachedHex = Hex.encodeToString(getBytes());
        }
        return this.cachedHex;
    }

    public String toBase64() {
        if ( this.cachedBase64 == null ) {
            this.cachedBase64 = Base64.encodeToString(getBytes());
        }
        return this.cachedBase64;
    }

    public String toString() {
        return toBase64();
    }

    public int hashCode() {
        if (this.bytes == null || this.bytes.length == 0) {
            return 0;
        }
        return Arrays.hashCode(this.bytes);
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (o instanceof ByteSource) {
            ByteSource bs = (ByteSource) o;
            return Arrays.equals(getBytes(), bs.getBytes());
        }
        return false;
    }

    //will probably be removed in Shiro 2.0.  See SHIRO-203:
    //https://issues.apache.org/jira/browse/SHIRO-203
    private static final class BytesHelper extends CodecSupport {
        public byte[] getBytes(File file) {
            return toBytes(file);
        }

        public byte[] getBytes(InputStream stream) {
            return toBytes(stream);
        }
    }
}

```

自定义ByteSource之后修改生成盐的方式：

```java
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
  System.out.println("====================================");
  String principal = (String) authenticationToken.getPrincipal();

  System.out.println(principal);
  // 1. 利用名字去查询数据库
  User user = userService.getUser(principal);
  if (user != null){
    System.out.println(user.getId());
    return new SimpleAuthenticationInfo(
      user.getUsername(),
      user.getPassword(),
      new CustomerByteSource(user.getId().getBytes(StandardCharsets.UTF_8)),
      this.getName()
    );
  }
  return null;
}
```

这里不知道为什么只有授权的缓存，没有认证的缓存，另外，二次登陆会报错。



//TODO



#### 10. thymeleaf 权限控制

##### 0. 导入依赖

```xml
<dependency>
  <groupId>com.github.theborakompanioni</groupId> 
  <artifactId>thymeleaf-extras-shiro</artifactId> 
  <version>2.0.0</version> 
</dependency>
```

#####  1. 引入名称空间

```html
xmlns:shiro="http://www.pollix.at/thymeleaf/shiro"
```

##### 2. 常见的权限控制标签

```html
<!-- 验证当前用户是否为“访客”，即未认证（包含未记住）的用户。 -->
<p shiro:guest="">Please <a href="login.html">login</a></p>


<!-- 认证通过或已记住的用户。 -->
<p shiro:user="">
    Welcome back John! Not John? Click <a href="login.html">here</a> to login.
</p>

<!-- 已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。 -->
<p shiro:authenticated="">
    Hello, <span shiro:principal=""></span>, how are you today?
</p>
<a shiro:authenticated="" href="updateAccount.html">Update your contact information</a>

<!-- 输出当前用户信息，通常为登录帐号信息。 -->
<p>Hello, <shiro:principal/>, how are you today?</p>


<!-- 未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。 -->
<p shiro:notAuthenticated="">
    Please <a href="login.html">login</a> in order to update your credit card information.
</p>

<!-- 验证当前用户是否属于该角色。 -->
<a shiro:hasRole="admin" href="admin.html">Administer the system</a><!-- 拥有该角色 -->

<!-- 与hasRole标签逻辑相反，当用户不属于该角色时验证通过。 -->
<p shiro:lacksRole="developer"><!-- 没有该角色 -->
    Sorry, you are not allowed to developer the system.
</p>

<!-- 验证当前用户是否属于以下所有角色。 -->
<p shiro:hasAllRoles="developer, 2"><!-- 角色与判断 -->
    You are a developer and a admin.
</p>

<!-- 验证当前用户是否属于以下任意一个角色。  -->
<p shiro:hasAnyRoles="admin, vip, developer,1"><!-- 角色或判断 -->
    You are a admin, vip, or developer.
</p>

<!--验证当前用户是否拥有指定权限。  -->
<a shiro:hasPermission="userInfo:add" href="createUser.html">添加用户</a><!-- 拥有权限 -->

<!-- 与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过。 -->
<p shiro:lacksPermission="userInfo:del"><!-- 没有权限 -->
    Sorry, you are not allowed to delete user accounts.
</p>

<!-- 验证当前用户是否拥有以下所有角色。 -->
<p shiro:hasAllPermissions="userInfo:view, userInfo:add"><!-- 权限与判断 -->
    You can see or add users.
</p>

<!-- 验证当前用户是否拥有以下任意一个权限。  -->
<p shiro:hasAnyPermissions="userInfo:view, userInfo:del"><!-- 权限或判断 -->
    You can see or delete users.
</p>
<a shiro:hasPermission="pp" href="createUser.html">Create a new User</a>
```

##### 3. 加入方言解析

```java
@Bean(name = "shiroDialect")
public ShiroDialect shiroDialect(){
  return new ShiroDialect();
}
```

## 参考资料

1. Bilibiili编程不良人：https://www.bilibili.com/video/BV1uz4y197Zm


