---
title: MyBatis
date: 2022-01-11 00:00:00
permalink: /dev/java/core/mybatis
author: p0jo
categories:
  - 开发
  - 后端
  - 微服务核心
tags:
  - SSM
  - Mabatis
---
# MyBatis

## MyBatis简介

MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。

之前的数据库操作方式：原生JDBC-> JDBCUtils -> JDBCTemplates -> MyBatis

![image-20220129194108639](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129194108639.png)

![image-20220129194120528](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220129194120528.png)

## MyBatisDemo项目

### 老方法

0. 创建测试数据库，并创建测试表

```SQL
create table tbl_employee(
id int(11) PRIMARY KEY AUTO_INCREMENT,
last_name VARCHAR(200),
gender char(1),
email VARCHAR(200)

);
```

1. 建立Maven项目，引入Mybatis相关依赖

要使用 MyBatis， 只需将 [mybatis-x.x.x.jar](https://github.com/mybatis/mybatis-3/releases) 文件置于类路径（classpath）中即可。

如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：

```XML
<dependencies>  
     <dependency>  
 <groupId>org.mybatis</groupId>  
 <artifactId>mybatis</artifactId>  
 <version>3.5.9</version>  
 </dependency>  
  
 <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->  
 <dependency>  
 <groupId>mysql</groupId>  
 <artifactId>mysql-connector-java</artifactId>  
 <version>8.0.22</version>  
 </dependency>  
  
 <!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core -->  
 <dependency>  
 <groupId>org.apache.logging.log4j</groupId>  
 <artifactId>log4j-core</artifactId>  
 <version>2.17.1</version>  
 </dependency>  
  
</dependencies>
```

2. 配置日志打印

```XML
<settings>  
 <setting name="logImpl" value="STDOUT_LOGGING" />  
</settings>
```

3. 创建Mybatis-config.xml配置文件，配置数据源

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE configuration  
 PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  
 "http://mybatis.org/dtd/mybatis-3-config.dtd">  
<configuration>  
 <environments default="development">  
 <environment id="development">  
 <transactionManager type="JDBC"/>  
 <dataSource type="POOLED">  
 <property name="driver" value="com.mysql.jdbc.Driver"/>  
 <property name="url" value="jdbc:mysql://localhost:3306/testmybatis"/>  
 <property name="username" value="root"/>  
 <property name="password" value="123456"/>  
 </dataSource>  
 </environment>  
 </environments>  
 <mappers>  
     <!--映射文件位于classpath下 -->
 <mapper resource="EmployeeMapper.xml"></mapper>  
 </mappers>  
</configuration>
```

4. 从 XML 中构建 SqlSessionFactory

每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。

从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。

```java
public static void main(String[] args) throws IOException {  
 String resource = "mybatis-config.xml";  
 InputStream resourceAsStream = Resources.getResourceAsStream(resource);  
 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);  
 SqlSession sqlSession = sqlSessionFactory.openSession();  
 System.out.println(sqlSession);  
}

```

5. 创建实体类

```JAVA
package com.pwddd.mybatis3.entity;  
  
public class Employee {  
 private int id;  
 private String lastName;  
 private int gender;  
 private String email;  
  
 public int getId() {  
 return id;  
 }  
  
 public void setId(int id) {  
 this.id = id;  
 }  
  
 public String getLastName() {  
 return lastName;  
 }  
  
 public void setLastName(String lastName) {  
 this.lastName = lastName;  
 }  
  
 public int getGender() {  
 return gender;  
 }  
  
 public void setGender(int gender) {  
 this.gender = gender;  
 }  
  
 public String getEmail() {  
 return email;  
 }  
  
 public void setEmail(String email) {  
 this.email = email;  
 }  
  
 @Override  
 public String toString() {  
 return "Employee{" +  
 "id=" + id +  
 ", lastName='" + lastName + '\'' +  
 ", gender=" + gender +  
 ", email='" + email + '\'' +  
 '}';  
 }  
}
```

6. 创建映射SQL语句

```XML
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
<!--名称空间和查询中的名称空间一致-->
<mapper namespace="com.pwddd.mybatis3.EmployeeMapper">  
 <!--  
 namespace:名称空间;指定为接口的全类名  
 id：唯一标识  
 resultType：返回值类型  
 #{id}：从传递过来的参数中取出id值  
  
 public Employee getEmpById(Integer id); --> <select id="getEmpById" resultType="com.pwddd.mybatis3.entity.Employee"> 
   
 select id,last_name,email,gender from tbl_employee where id = #{id}  
 </select>  
</mapper>
```

7. 创建查询

```JAVA
public static void main(String[] args) {  
 String resource = "mybatis-config.xml";  
 InputStream resourceAsStream = null;  
 SqlSession sqlSession = null;  
 try {  
 resourceAsStream = Resources.getResourceAsStream(resource);  
 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);  
 sqlSession = sqlSessionFactory.openSession();  
  
 Employee employee = sqlSession.selectOne("com.pwddd.mybatis3.EmployeeMapper.getEmpById", 1);  
 System.out.println(employee);  
 } catch (IOException e) {  
 e.printStackTrace();  
 } finally {  
 sqlSession.close();  
 }  
}
```

### 接口式编程方式

1. 创建接口

```java
package com.pwddd.mybatis3.dao;  
  
import com.pwddd.mybatis3.entity.Employee;  
  
public interface EmployeeMapper {  
 Employee getEmpById(Integer id);  
}
```

2. namespace配置接口全类名

```xml
<mapper namespace="com.pwddd.mybatis3.dao.EmployeeMapper">
```

3. mapper.xml中查询方法名和接口中定义的方法名一致

```XML
<select id="getEmpById" resultType="com.pwddd.mybatis3.entity.Employee">  
 select id,last_name as lastName,email,gender from tbl_employee where id = #{id}  
</select>
```

4. 编写测试方法

```java
@Test
public void testInterface() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
    Employee emp = mapper.getEmpById(1);
    System.out.println(emp);
}
```

## MyBatis配置文件

### properties 标签

在Mybatis配置文件中的一些属性（如数据库链接的相关信息）可以配置在外部的配置文件中，通过`properties`标签将外部的配置文件引入，然后使用`${}`将配置导入到mybatis配置文件中。具体的用法如下面所示：

```XML
<properties resource="jdbc.properties" />
```

除此之外，还可以在`properties` 标签内设置相关属性的值，但是这样不会替换掉外部配置文件中设置的值，只是增加值：

```XML
<properties resource="jdbc.properties">  
 <property name="username" value="root"/>  
 <property name="password" value="123456"/>  
</properties>
```

除此之外，还可以在创建`SqlSessionFactory`时将配置文件传入：

```JAVA
@Test
public void testResource() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    Properties properties = new Properties();
    properties.load(new FileInputStream(new File("src/main/resources/jdbc.properties")));
    SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream, properties);
    SqlSession sqlSession = build.openSession();
    System.out.println(sqlSession);
}
```

从`Mybatis 3.4.2`版本开始，可以为属性设置一个默认值，如果获取不到值则使用默认值，但是默认值的属性没有开启，并且默认的分隔符是`：`，可以使用如下的配置进行设置和使用。修改默认的分隔符的目的是如果属性名中含有其他的冒号则容易冲突，如果不含，那么可以正常使用默认值：

```xml
<property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/>  
<property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/>

<property name="username" value="${mysql.username?:root}"/>
```

### settings 标签

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。用来对Mybatis进行一些设置的配置。

常用的配置内容和功能如下：

#TODO 



![image-20220220102416729](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220220102416729.png)



开启驼峰命名：

```xml
<setting name="mapUnderscoreToCamelCase" value="true"/>
```

数据库对于NULL值的匹配处理

```xml
<setting name="jdbcTypeForNull" value="Null"/>
```

开启分步查询懒加载：

```xml
<setting name="lazyLoadingEnabled" value="true"/>
<!--        按照需要进行属性的加载-->
<setting name="aggressiveLazyLoading" value="false"/>
```



### typeAliases 别名处理器

用于给类型起别名，仅用于 XML 配置，意在降低冗余的全限定类名书写。在通常情况下，我们在Mapper中配置的`ResultType`通常为类的全类名，这种方法过于冗余，可以使用别名的方式，以后配置就可以用别名代替全类名了。

```xml
<typeAliases>
    <typeAlias type="com.pwddd.mybatis.bean.Employee" alias="emp" />
</typeAliases>
```

除此之外，还可以配置批量包下面的别名，如下配置中的包下的所有类都会有一个首字母小写的别名：

```xml
<typeAliases> 
	<package name="domain.blog"/> 
</typeAliases>
```

还可以使用注解的方式，为类起别名，但是前提是配置包的别名：

```XML
<typeAliases>  
    <package name="com.pwddd.hello.entity"/>  
    <!--        <typeAlias type="com.pwddd.hello.entity.Employee" alias="employee" />-->  
</typeAliases>
```

```java
@Alias("emp")  
public class Employee {
```

### typeHandlers

MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API）。

### plugins

MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：
-   Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
-   ParameterHandler (getParameterObject, setParameters)
-   ResultSetHandler (handleResultSets, handleOutputParameters)
-   StatementHandler (prepare, parameterize, batch, update, query)

### environments

Mybaits为了更好的适应多种数据库的连接需要，并且方便多个数据库之间的切换使用，使用`environments`对数据库进行配置。`environments`标签有一个`default`属性用于指定当前使用的环境。在`environments`标签下又有`ENVIRONMENT`标签，用于配置多个数据库环境。

```XML
<environments default="mysql">  
 <environment id="mysql">  
 <transactionManager type="JDBC" />  
 <dataSource type="POOLED">  
 <property name="driver" value="${mysql.driver}"/>  
 <property name="url" value="${mysql.url}"/>  
 <property name="username" value="${username?:root}"/>  
 <property name="password" value="${mysql.password}"/>  
 </dataSource>  
 </environment>  
</environments>
```

#### transactionManager

在 MyBatis 中有两种类型的事务管理器（也就是 `type="[JDBC|MANAGED]"`）：

-   JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。
-   MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。

但是如果使用的spring+Mybatis，则可以将事务处理交给Spring来做。

#### dataSource

Mybatis有三大内建的数据源：

- UNPOOLED：这个数据源的实现会每次请求时打开和关闭连接。
- POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。
- JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。

除此之外还可以自定义数据源，type为自定义数据源的全类名。

### databaseIdProvider

MyBatis为不同的数据库设置了不同的数据库的标识。这种多厂商的支持是基于映射语句中的 `databaseId` 属性。 MyBatis 会加载带有匹配当前数据库 `databaseId` 属性和所有不带 `databaseId` 属性的语句。这种多厂商的支持是基于映射语句中的 `databaseId` 属性。 MyBatis 会加载带有匹配当前数据库 `databaseId` 属性和所有不带 `databaseId` 属性的语句。只需要为不同的sql语句配置数据库标签（`dataBaseId`）即可。

```XML
<databaseIdProvider type="DB_VENDOR">  
 <property name="SQL Server" value="sqlserver"/>  
 <property name="DB2" value="db2"/>  
 <property name="Oracle" value="oracle" />  
</databaseIdProvider>
```

### mappers

我们需要告诉Mabatis去哪里寻找我们的mapper配置文件。你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 `file:///` 形式的 URL），或类名和包名等。例如：

```xml

<!-- 使用相对于类路径的资源引用 -->  
<mappers>  
 <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>  
 <mapper resource="org/mybatis/builder/BlogMapper.xml"/>  
 <mapper resource="org/mybatis/builder/PostMapper.xml"/>  
</mappers>  
<!-- 使用完全限定资源定位符（URL） -->  
<mappers>  
 <mapper url="file:///var/mappers/AuthorMapper.xml"/>  
 <mapper url="file:///var/mappers/BlogMapper.xml"/>  
 <mapper url="file:///var/mappers/PostMapper.xml"/>  
</mappers>  
<!-- 使用映射器接口实现类的完全限定类名 -->  
<mappers>  
 <mapper class="org.mybatis.builder.AuthorMapper"/>  
 <mapper class="org.mybatis.builder.BlogMapper"/>  
 <mapper class="org.mybatis.builder.PostMapper"/>  
</mappers>  
<!-- 将包内的映射器接口实现全部注册为映射器 -->  
<mappers>  
 <package name="org.mybatis.builder"/>  
</mappers>

```

其中，使用映射器接口实现类的完全限定类名进行注册时，可以使用注解的方式进行配置。

```java
	@Select("select * from tbl_employee where id=#{id}")
	public Employee getEmpById(Integer id);
```

这种方式虽然便捷，但是对于复杂的SQL语句不是很友好，因此复杂的语句建议还是在Mapper配置文件中编写。

## Mapper映射文件

SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：

- `cache` – 该命名空间的缓存配置。
- `cache-ref` – 引用其它命名空间的缓存配置。
- `resultMap` – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。
- `parameterMap` – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。
- `sql` – 可被其它语句引用的可重用语句块。
- `insert` – 映射插入语句。
- `update` – 映射更新语句。
- `delete` – 映射删除语句。
- `select` – 映射查询语句。

### 增删改查

Mapper映射文件：

```xml
<select id="getEmpById" resultType="employee">
        select * from tbl_employee where id = #{id}
    </select>

    <insert id="addEmp" >
        insert into tbl_employee(last_name,gender,email) values (#{lastName},#{gender},#{email})
    </insert>

    <update id="updateEmp" >
        update tbl_employee
            set last_name = #{lastName},
             gender = #{gender},
             email = #{email}
        where id = #{id};
    </update>

    <delete id="deleteEmp" >
        delete
        from tbl_employee
        where id=#{id};
    </delete>
```

对应接口：

```java
Employee getEmpById(Integer id);
Integer addEmp(Employee employee);
Integer updateEmp(Employee employee);
Integer deleteEmp(Integer id);
```

测试：

```java
@Test
public void testCRUD() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);
    System.out.println(employeeMapper.deleteEmp(2));
    System.out.println(employeeMapper.addEmp(new Employee(4, "zhangsan", 1, "123@qq.com")));
    System.out.println(employeeMapper.updateEmp(new Employee(1, "wangwu", 1, "wangwu@qq.com")));
    sqlSession.commit();  // 由于mybatis默认关闭了自动提交功能 因此需要手动提交执行才会影响数据库
}
```



### 传入参数处理

1. 传递单个参数：`#{任意}` mybatis不做处理
2. 多个参数：
   - SQL中使用`#{参数名}`和接口名中传递的参数同名，这种方式会出错，多个参数会被封装成map，`#{}`从map中取值，可以使用`param1,param2`或者0，1直接取值。
   - 命名参数：使用注解改变将封装map的key，`@Param("id")`，直接使用`#{id}`取值
3. 如果多个参数，使用pojo对象，`#{}`传递pojo对象属性
4. 直接传入map，`#{key}`传递map对象对应的key值。
5. 经常要使用的多个参数，可以封装成TO对象。
6. 如果传递的是Collection(Set List)、数组，也会进行特殊封装到map中，List使用`#{list[0]}`，数组使用`#{array[0]}`

![image-20220220120923844](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220220120923844.png)



### 查询结果返回

- 如果返回的是一个集合，则`resultType`返回集合的泛型。

```XML
    <select id="selectAllEmp" resultType="employee">
        select * from tbl_employee
    </select>
```

- 如果返回一个map，key是列名，value是值的内容，`resultType`则是map。

```XML
    <select id="selectById" resultType="map">
        select * from tbl_employee where id=#{id}
    </select>
```

- 如果返回一个map，key是主键，value是所有的查询结果。`resultType`是map中封装的类型，并给方法加上`@MapKey`注解，指明主键。

```XML
<select id="selectAll" resultType="employee">
select * from tbl_employee
</select>
```

```JAVA
    @MapKey("id")
    Map<Integer,Employee> selectAll();
```



### 封装返回结果

当数据库列名和我们定义的javaBean属性名不一致时，使用resultType指定返回值类型将会导致查出来的数据无法注入到结果中。有三种解决方式：

- 如果数据库中的列名和javabean属性名满足驼峰命名法的转换，则在mybatis配置文件中开启驼峰命名法转换即可
- 查询数据库语句起别名
- 使用resultMap封装返回结果

```xml
<resultMap id="emp" type="com.pwddd.mybatis.bean.Employee">
    <id property="id" column="id" />
    <result property="lastName" column="last_name" />
    <result property="gender" column="gender" />
    <result property="email" column="email" />
</resultMap>
<select id="selectById" resultMap="emp">
    select * from tbl_employee where id = #{id}
</select>
```



### 联合查询的结果返回

#### 方式一：使用级联赋值方式

```XML
<resultMap id="empanddept" type="com.pwddd.mybatis.bean.Employee">
    <id column="id" property="id" />
    <result column="last_name" property="lastName" />
    <result column="gender" property="gender" />
    <result column="email" property="email" />
    <result column="did" property="dept.did" />
    <result column="dname" property="dept.dname" />
</resultMap>

<select id="selectEmpAndDeptById" resultMap="empanddept">
    select *
    from tbl_employee e , tbl_dept d
    where e.did = d.did
    and e.id = #{id}
</select>
```

#### 方式二：使用association赋值

```XML
<resultMap id="empanddept" type="com.pwddd.mybatis.bean.Employee">
    <id column="id" property="id" />
    <result column="last_name" property="lastName" />
    <result column="gender" property="gender" />
    <result column="email" property="email" />
    <!--        <result column="did" property="dept.did" />-->
    <!--        <result column="dname" property="dept.dname" />-->
    <association property="dept" javaType="com.pwddd.mybatis.bean.Dept">
        <id column="did" property="did" />
        <result column="dname" property="dname" />
    </association>
</resultMap>

<select id="selectEmpAndDeptById" resultMap="empanddept">
    select *
    from tbl_employee e , tbl_dept d
    where e.did = d.did
    and e.id = #{id}
</select>
```

#### 方式三：分步查询

1. 按照员工ID查出员工信息
2. 根据查询的员工信息中的did 查询对应的dept信息
3. 将部门设置到dept属性中

```xml
<resultMap id="step" type="com.pwddd.mybatis.bean.Employee">
    <id column="id" property="id" />
    <result column="last_name" property="lastName" />
    <result column="gender" property="gender" />
    <result column="email" property="email" />
    <association property="dept" select="com.pwddd.mybatis.mapper.DeptMapper.selectById" column="did" >
        <id column="did" property="did" />
        <result column="dname" property="dname" />
    </association>
</resultMap>
<select id="getEmpByIdStep" resultMap="step">
    select * from tbl_employee where id = #{id}
</select>
```



#### 基于分步查询的延迟加载功能

mybatis配置文件中增加开启懒加载配置：

```xml
<setting name="lazyLoadingEnabled" value="true"/>
<!--        按照需要进行属性的加载-->
<setting name="aggressiveLazyLoading" value="false"/>
```

只使用employee中的字段时，就只查询一条SQL语句

```java
@Test
public void testStep() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    EmployeeMapperPlus mapper1 = sqlSessionFactory.openSession().getMapper(EmployeeMapperPlus.class);
    Employee empByIdStep = mapper1.getEmpByIdStep(1);
    System.out.println(empByIdStep.getEmail());
}
```

```text
[2022-02-20 20:23:29:798-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?
[2022-02-20 20:23:29:799-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)
[2022-02-20 20:23:29:841-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - <==      Total: 1
wangwu@qq.com
```

当时用到dept中查询的字段时再加载第二条SQL语句

```java
@Test
public void testStep() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    EmployeeMapperPlus mapper1 = sqlSessionFactory.openSession().getMapper(EmployeeMapperPlus.class);
    Employee empByIdStep = mapper1.getEmpByIdStep(1);
    System.out.println(empByIdStep.getEmail());
    System.out.println("============================================");
    System.out.println(empByIdStep.getDept().getDid());
}
```

```TEXT
[2022-02-20 20:26:02:673-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?
[2022-02-20 20:26:02:702-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)
[2022-02-20 20:26:02:748-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - <==      Total: 1
wangwu@qq.com
============================================
[2022-02-20 20:26:02:748-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_dept where did = ?
[2022-02-20 20:26:02:749-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)
[2022-02-20 20:26:02:751-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - <==      Total: 1
1

Process finished with exit code 0

```



### 联合查询的集合结果返回

一个部门有多个员工，查询部门时，返回部门下的所有员工。

#### 方式一：多表联合查询

```XML
<resultMap id="depts" type="com.pwddd.mybatis.bean.Dept" >
    <id column="did" property="did" />
    <result column="dname" property="dname" />
    <!-- ofType 定义集合中的泛型类型-->
    <collection property="employees" ofType="com.pwddd.mybatis.bean.Employee" >
        <id column="id" property="id" />
        <result column="last_name" property="lastName" />
        <result column="email" property="email" />
        <result column="gender" property="gender" />
    </collection>

</resultMap>
<select id="getDeptById" resultMap="depts" >
    select e.id,e.last_name,e.email,e.gender,d.did,d.dname
    from tbl_employee e, tbl_dept d
    where d.did = e.did
    and e.did = #{did}
</select>
```

#### 方式二：分步查询

```XML
<resultMap id="deptsstep" type="com.pwddd.mybatis.bean.Dept" >
    <id column="did" property="did" />
    <result column="dname" property="dname" />
    <collection property="employees" select="com.pwddd.mybatis.mapper.EmployeeMapperPlus.getEmpByDid"
                ofType="com.pwddd.mybatis.bean.Employee" column="did" />
</resultMap>

<select id="getDeptByStep" resultMap="deptsstep" >
    select * from tbl_dept where did = #{did}
</select>
```

### 多列step查询

如果需要分步查询，第一步查询的结果的多列作为第二步查询的条件，可以封装成map

```xml
column="{did=did,dname=dname}"
```

### 关于延迟加载

针对分步查询可以单独设置懒加载

```
 fetchType="eager" 不开启懒加载
  fetchType="lazy" 开启懒加载
```

### 鉴别器

鉴别器可以根据条件设置查询的结果，比如如果是女生才将dept的结果返回，如果是男生，则将lastname的值赋值给email的值。虽然没有意义，只用来测试。

```xml
<resultMap id="gete" type="com.pwddd.mybatis.bean.Employee" >
<id column="id" property="id" />
<result column="last_name" property="lastName" />
<result column="gender" property="gender" />
<result column="email" property="email" />
<discriminator javaType="string" column="gender">
<case value="0">
<association property="dept" select="com.pwddd.mybatis.mapper.DeptMapper.selectById" column="did"/>
</case>
<case value="1">
<result column="last_name" property="email" />
</case>
</discriminator>
</resultMap>


<select id="getE" resultMap="gete" >
select * from tbl_employee where id = #{id}
</select>
```

## 动态SQL语句

动态SQL解决的是按照条件拼装SQL的问题。使用不同的标签，mybatis可以根据传递的参数条件动态的拼接SQL语句。

### if标签

if标签可以根据传入的参数判断是否拼接查询条件

```xml
<select id="getEmpsByCondition" resultType="employee" >
    select * from tbl_employee
    where
    <if test="id!=null" >
        id = #{id}
    </if>

    <if test="lastName != null">
        and last_name=#{lastName}
    </if>

    <if test="email != null">
        and email = #{email}
    </if>

    <if test="gender != null">
        and gender = #{gender}
    </if>
</select>
```

### where标签

这种拼接有一个问题，就是当id不存在时，后面的语句拼接会多一个and。常见的解决方法有两个：

1. where 后面拼接一个 1=1 
2. 使用where标签，去除前置的and 或者 or条件

```XML
第一种方式：
<select id="getEmpsByCondition" resultType="employee" >
    select * from tbl_employee
    where 1=1
    <if test="id!=null" >
        and id = #{id}
    </if>

    第二种方式：
    <select id="getEmpsByCondition" resultType="employee" >
        select * from tbl_employee
        <where>
            <if test="id!=null" >
                id = #{id}
            </if>

            <if test="lastName != null">
                and last_name=#{lastName}
            </if>

            <if test="email != null">
                and email = #{email}
            </if>

            <if test="gender != null">
                and gender = #{gender}
            </if>
        </where>
    </select>
```

上面的这种写法，如果在拼接条件时，and写在条件后面还会出问题，因为where标签只会删除掉第一个多余的and。

```xml
<select id="getEmpsByCondition" resultType="employee" >
    select * from tbl_employee
    <where>
        <if test="id!=null" >
            id = #{id} and
        </if>

        <if test="lastName != null">
            last_name=#{lastName} and
        </if>

        <if test="email != null">
            email = #{email} and
        </if>

        <if test="gender != null">
            gender = #{gender}
        </if>
    </where>
</select>
```

### trim标签

使用trim标签，可以解决上述问题，trim标签有如下的属性：

- prefix : 给语句加上一个前缀
- prefixOverides : 覆盖掉前缀的字符串
- suffix : 给语句加上一个后缀
- suffixOverrides : 覆盖掉后缀的字符串

上述的查询可以改成如下内容：

```XML
<select id="getEmpsByCondition" resultType="employee" >
    select * from tbl_employee
    <trim prefix="where" suffixOverrides="and">        
        <if test="id!=null" >
            id = #{id} and
        </if>

        <if test="lastName != null">
            last_name=#{lastName} and
        </if>

        <if test="email != null">
            email = #{email} and
        </if>

        <if test="gender != null">
            gender = #{gender}
        </if>
    </trim>
</select>
```

### choose标签

choose标签类似于java中的switch-case语句。

```xml
<select id="getEmpsByCOnditionChoose" resultType="employee">
    select * from tbl_employee
    <where>
        <choose>
            <when test="id!=null">
                id = #{id}
            </when>

            <when test="lastName != null">
                and last_name = #{lastName}
            </when>

            <otherwise>
                and gender = 1
            </otherwise>
        </choose>
    </where>
</select>
```

### set标签

where标签中封装的是查询的条件，而set标签中封装的是更新条件。

如果我们不使用set标签，而使用if标签拼接update语句的set条件的话，则会导致后面多一个逗号，SQL执行报错。

```xml
<update id="updateEmp">
    update tbl_employee
    set
    <if test="lastName != null">
        last_name = #{lastName},
    </if>
    <if test="gender != null">
        gender = #{gender},
    </if>
    <if test="email != null" >
        email = #{email}
    </if>

    where id = #{id}
</update>
```

```text
[2022-02-21 14:33:36:972-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: update tbl_employee set last_name = ?, where id = ?
[2022-02-21 14:33:36:997-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: lisi(String), 1(Integer)
```



使用set标签可以去除后面多余的逗号。

```XML
<update id="updateEmp">
    update tbl_employee
    <set>
        <if test="lastName != null">
            last_name = #{lastName},
        </if>
        <if test="gender != null">
            gender = #{gender},
        </if>
        <if test="email != null" >
            email = #{email}
        </if>
    </set>
    where id = #{id}
</update>
```



### foreach标签

foreach标签用来遍历传递过来的list或者map，常用来做in查询或者批量新增。

foreach标签有如下的属性可以选择：

- collection: 传进来的集合参数
- item: 遍历出来的单个值
- open: foreach拼接的开始符号
- close: foreach拼接的结束符号
- separator: 元素之间的分隔符
- index: 对于list来说，index是索引，item是value，对于map而言，index是key，item是value



IN查询employee

```xml
<select id="getEmpsByIn" resultType="employee">
    select * from tbl_employee
    where id in
    <foreach collection="list" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</select>
```



insert批量插入数据

```xml
<insert id="addEmps" >
    insert into tbl_employee(id,last_name,gender,email)
    values
    <foreach collection="collection"  separator="," item="emp">
        (#{emp.id},#{emp.lastName},#{emp.gender},#{emp.email})
    </foreach>
</insert>
```

第二种方式需要数据库开启可以批量提交

```TEXT
jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true
```

```xml
<insert id="addEmps" >
    <foreach collection="list" item="emp" separator=";" >
        insert into tbl_employee(id,last_name,gender,email)
        values (#{emp.id},#{emp.lastName},#{emp.gender},#{emp.email})
    </foreach>
</insert>
```

### 两个内置参数

mybatis中有两个内置参数可以用来取值。

- `_parameter`: 代表整个参数，如果传递多个参数，参数会被封装成一个map `_parameter`就代表这个map
- `_databaseId`: 如果配置了`databaseIdProvider`标签，则该值就代表我们配置的值。

栗子：

```xml
<select id="getDept" resultType="dept" >
    <if test="_databaseId=mysql">
        select * from tbl_dept where did = #{did}
    </if>
</select>
```

### bind标签

bind标签可以将OGNL表达式绑定到一个变量上。我们可以使用如下的方式进行模糊查询

```JAVA
System.out.println(mapper.getLikeEmp("%a%"));
```

我们也可以将%放到sql语句中，但不能使用下面的方式：

```sql
select * from tbl_employee
where last_name like "%#{lastName}%"  -- like后面的查询条件应该是一个整体
select * from tbl_employee
where last_name like "%${lastName}%"  -- 拼接不安全
```

我们可以使用bind将拼接进行绑定

```XML
<select id="getLikeEmp" resultType="employee">
    <bind name="_lastName" value="'%'+lastName+'%'"/>
    select * from tbl_employee
    where last_name like #{_lastName}
</select>
```



### sql标签

sql标签可以将多次的查询语句进行保存，下次使用直接引用。可以使用inclue进行引用。

```xml

<sql id="emp">
    id,last_name,email,gender
</sql>

<select id="getLikeEmp" resultType="employee">
    <bind name="_lastName" value="'%'+lastName+'%'"/>
    select 
    <include refid="emp" />
    from tbl_employee
    where last_name like #{_lastName}
</select>
```

inclue标签内可以自定义一些属性，然后使用${}取值。

```XML
<sql id="emp">
    id,${name},email,gender
</sql>

<select id="getLikeEmp" resultType="employee">
    <bind name="_lastName" value="'%'+lastName+'%'"/>
    select
    <include refid="emp" >
        <property name="name" value="last_name"/>
    </include>
    from tbl_employee
    where last_name like #{_lastName}
</select>
```

## 缓存

Mybatis中包含了一个非常强大的查询缓存特性，可以非常方便的配置和定制。缓存可以极大的提升查询效率。

MyBatis系统中默认定义了两级缓存。一级缓存，二级缓存。

1. 默认情况下，只有一级缓存（SQLSession级别的缓存，本地缓存）开启。
2. 二级缓存需要手动配置，是namespace级别的缓存
3. 为了提高扩展性。Mybatis定义了缓存接口Cache，我们可以实现Cache接口实现定义二级缓存。



### 一级缓存

与数据库同一次会话产生的数据会放到一级缓存中，以后如果需要取相同的数据则直接从缓存中取。

```JAVA
@Test
public void testFirstLevel() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();

    try {
        EmployeeMapperCache mapper = sqlSession.getMapper(EmployeeMapperCache.class);
        System.out.println(mapper.getEmp(1));
        System.out.println(mapper.getEmp(1));
    }finally {
        sqlSession.close();
    }
}
```

查询结果可以看出，只执行了一次查询

```text
[2022-02-21 19:26:09:969-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==>  Preparing: select * from tbl_employee where id = ?
[2022-02-21 19:26:09:994-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - ==> Parameters: 1(Integer)
[2022-02-21 19:26:10:011-main] [DEBUG] - org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:137) - <==      Total: 1
Employee{id=1, lastName='wangwu', gender=0, email='wangwu@qq.com', dept=null}
Employee{id=1, lastName='wangwu', gender=0, email='wangwu@qq.com', dept=null}
```

有以下几种情况导致缓存失效：

- 不同的sqlSession
- SQLSession相同，查询条件不同 - 缓存中没有
- SQLSession相同，两次查询之间有增删改查操作
- SQLSession相同，调用缓存清空`sqlsesson.clearCache()`

### 二级缓存

不同的SqlSession无法使用一级缓存，范围较小。当我们需要不同的SqlSession可以从缓存中查找数据，则需要开启二级缓存。二级缓存的作用域是namespace。

二级缓存机制：

1. 一个会话，查询一条语句，这个数据会被存储在一级缓存中。
2. 会话关闭，一级缓存中的数据会被保存到二级缓存中，新的查询会访问二级缓存。
3. 不同的namespace查询的数据会对应自己的缓存空间。



使用方法：

1. 开启全局二级缓存配置

```xml
<setting name="cacheEnabled" value="true"/>
```

2. 去mapper中配置二级缓存

```XML
<cache></cache>
```

二级缓存配置有以下可选参数：

- blocking: 
- eviction: 缓存的回收策略
  - LRU: 最近最少使用的，移除长时间未被访问的对象
  - FIFO: 先进先出，按照对象存储的顺序，先进来的先出去
  - SOFT: 软引用，移除基于垃圾回收器状态和软引用的对象
  - WEAK: 弱引用，更积极的移除基于垃圾收集器状态和弱引用的相关对象
  - 默认：LRU
- flushInterval：缓存刷新时间，默认不清空
- readOnly
  - true： 只读，mybatis认为所有缓存中的数据都是只读操作，不会修改数据。为了加快速度，会将缓存中的内容直接交给用户，不安全速度快。
  - false： 非只读，mybatis觉得数据是可以被修改的。mybatis会利用序列化等技术克隆一份新的数据给你。
- size：缓存多少数据
- type：指定缓存的全类名

3. pojo实现序列化接口

```java
@Test
public void testSecondLevel() throws IOException {
    String resource = "mybatis-config.xml";
    InputStream resourceAsStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    SqlSession sqlSession2 = sqlSessionFactory.openSession();

    EmployeeMapperCache mapper = sqlSession.getMapper(EmployeeMapperCache.class);
    EmployeeMapperCache mapper2 = sqlSession2.getMapper(EmployeeMapperCache.class);
    Employee emp = mapper.getEmp(1);
    sqlSession.close();
    System.out.println(mapper2.getEmp(1));
    sqlSession2.close();

}
```

注意，只有当SQLSession关闭之后，才会将数据移动到二级缓存。



### 缓存相关设置

- `cacheEnabled` 开启或者关闭二级缓存，配置在mybatis配置文件setting中
- mapper配置文件对应的查询标签中，设置`setCache=true`，开启或者关闭二级缓存
- 每个增删改标签上默认有`flushCache=true`，默认清空一级缓存和二级缓存
- 在每个查询标签中默认有`flushCache=false`，默认不清空缓存
- `sqlSession.flushCache()`默认清空一级缓存
- `localCacheScope=[SESSION|STATEMENT]` 本地缓存作用域

### 缓存工作原理

![image-20220221200214432](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220221200214432.png)



### 第三方缓存EHCACHE

1. 导入Ehcache包

```xml
<!-- https://mvnrepository.com/artifact/org.ehcache/ehcache -->
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.9.9</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache -->
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.2.2</version>
</dependency>
```

2. mapper中开启二级缓存

```xml
<cache readOnly="true" eviction="FIFO" size="640000" type="org.mybatis.caches.ehcache.EhcacheCache" />
<cache-ref namespace="com.pwddd.mybatis.mapper.EmployeeMapperCache"/> <!-引用其他文件的缓存-->
```

3. 配置ehcache配置文件

```xml
<ehcache>


    <!--
        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存
        path:指定在硬盘上存储对象的路径
     -->
    <diskStore path="java.io.tmpdir" />


    <!--
        defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理
        maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象
        eternal:代表对象是否永不过期
        timeToIdleSeconds:最大的发呆时间
        timeToLiveSeconds:最大的存活时间
        overflowToDisk:是否允许对象被写入到磁盘
     -->
    <defaultCache maxElementsInMemory="10000" eternal="false"
                  timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" />

    <!--
        cache:为指定名称的对象进行缓存的特殊配置
        name:指定对象的完整名
     -->
    <cache name="com.zbaccp.entity.Person" maxElementsInMemory="10000" eternal="false"
           timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="true" />


</ehcache>

```

## 整合Spring

1. 导入相关依赖包

```xml
<dependencies>
    
      <!--测试-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>${spring-version}</version>
  </dependency>

  
  <dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.11</version>
    <scope>test</scope>
  </dependency>

  <!--spring 依赖 核心-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <!--spring jdbc-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <!--spring web-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
    <version>2.5</version>
    <scope>provided</scope>
  </dependency>

  <dependency>
    <groupId>org.thymeleaf</groupId>
    <artifactId>thymeleaf-spring5</artifactId>
    <version>3.0.12.RELEASE</version>
  </dependency>

  <!--aop-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>${spring-version}</version>
  </dependency>

  <dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>2.2</version>
  </dependency>

  <dependency>
    <groupId>aopalliance</groupId>
    <artifactId>aopalliance</artifactId>
    <version>1.0</version>
  </dependency>

  <dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
  </dependency>

  <!--mybatis-->
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.9</version>
  </dependency>

  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.0.7</version>
  </dependency>

  <dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.2.2</version>
  </dependency>

  <dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.9.9</version>
  </dependency>
    
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.8</version>
  </dependency>

  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.21</version>
  </dependency>
    
    <!-- 其他辅助包 -->

  <dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.17.1</version>
  </dependency>

    <!--文件上传-->

  <dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
  </dependency>
    
   <!-- 响应json -->

  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.1</version>
  </dependency>


</dependencies>
```

2. 配置web.xml(WebInit)、Spring、SpringMVC配置文件

web.xml/WebInit

```java
package com.pwddd.ssmdemo.config;

import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.filter.HiddenHttpMethodFilter;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import javax.servlet.Filter;

public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
        characterEncodingFilter.setForceRequestEncoding(true);
        characterEncodingFilter.setEncoding("utf-8");
        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
        return new Filter[]{characterEncodingFilter,hiddenHttpMethodFilter};
    }
}
```

Spring配置文件

```java
package com.pwddd.ssmdemo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.thymeleaf.spring5.SpringTemplateEngine;
import org.thymeleaf.spring5.view.ThymeleafViewResolver;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.ITemplateResolver;
import org.thymeleaf.templateresolver.ServletContextTemplateResolver;

@Configuration
@ComponentScan("com.pwddd.ssmdemo.controller")
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
    }


    @Bean
    public ITemplateResolver templateResolver(WebApplicationContext applicationContext){
        ServletContextTemplateResolver servletContextTemplateResolver = new ServletContextTemplateResolver(applicationContext.getServletContext());
        servletContextTemplateResolver.setPrefix("/WEB-INF/templates/");
        servletContextTemplateResolver.setSuffix(".html");
        servletContextTemplateResolver.setCharacterEncoding("utf-8");
        servletContextTemplateResolver.setTemplateMode(TemplateMode.HTML);
        return servletContextTemplateResolver;
    }

    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver){
        SpringTemplateEngine springTemplateEngine = new SpringTemplateEngine();
        springTemplateEngine.setTemplateResolver(templateResolver);
        return springTemplateEngine;
    }

    @Bean
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine){
        ThymeleafViewResolver thymeleafViewResolver = new ThymeleafViewResolver();
        thymeleafViewResolver.setTemplateEngine(templateEngine);
        thymeleafViewResolver.setCharacterEncoding("utf-8");
        return thymeleafViewResolver;
    }
}

```

SpringMVC

```java
package com.pwddd.ssmdemo.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;
import java.io.IOException;

@Configuration
@ComponentScan("com.pwddd.ssmdemo.service")
@PropertySource("classpath:jdbc.properties")
@MapperScan("com.pwddd.ssmdemo.mapper")  // 配置mapper扫描
@EnableTransactionManagement  // 开启事务
@EnableAspectJAutoProxy(proxyTargetClass = true)  // 开启aop aspect注解
public class SpringConfig {

    @Value("${jdbc.driver}")
    private String driver;

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setDriverClassName(driver);
        druidDataSource.setUrl(url);
        druidDataSource.setUsername(username);
        druidDataSource.setPassword(password);
        return druidDataSource;
    }

    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource, ApplicationContext applicationContext) throws IOException {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setConfigLocation(applicationContext.getResource("classpath:mybatis-config.xml"));
//        sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources("classpath:mapper/*.xml"));
        return sqlSessionFactoryBean;
    }

}

```

jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssmdemo
jdbc.username=root
jdbc.password=123456
```

log4j2配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--设置log4j2的自身log级别为warn-->
<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，
    当设置成trace时，你会看到log4j2内部各种详细输出-->
<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数-->
<configuration status="warn" monitorInterval="30">
    <!--全局参数-->
    <Properties>
        <!--<Property name="logPath">/export/Logs/bt-middle-data-main</Property>-->
        <Property name="logPath">./log</Property>
    </Properties>
    <!--先定义所有的appender-->
    <appenders>
        <!--这个输出控制台的配置-->
        <console name="Console" target="SYSTEM_OUT">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） -->
            <!--<ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY"/>-->
            <!--输出日志的格式-->
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss:SSS}-%t] [%p] - %l - %m%n"/>
        </console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用-->
        <!--<File name="log" fileName="log/test.log" append="false">-->
        <!--<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>-->
        <!--</File>-->
        <!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，
        则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->
        <RollingFile name="RollingFileInfo" fileName="${logPath}/info.log"
                     filePattern="${logPath}/info_%d{yyyy-MM-dd}.log">
            <!--<Filters>-->
            <!--<!–控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）–>-->
            <!--<ThresholdFilter level="INFO" onMatch="ACCEPT" onMismatch="DENY"/>-->
            <!--<!–<ThresholdFilter level="WARN" onMatch="DENY" onMismatch="NEUTRAL"/>–>-->
            <!--</Filters>-->
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss:SSS}-%t] [%p] - %l - %m%n"/>
            <Policies>
                <!--按照filePattern 时间单位 interval 间隔生成文件-->
                <TimeBasedTriggeringPolicy modulate="true" interval="1"/>
                <!--定了当日志文件达到了指定的size时，触发rollover操作。size参数可以用KB、MB、GB等做后缀来指定具体的字节数-->
                <!--<SizeBasedTriggeringPolicy size="1G"/>-->
            </Policies>
        </RollingFile>


    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <loggers>
        <!--过滤掉spring和hibernate的一些无用的debug信息-->
        <logger name="org.springframework" level="DEBUG">
        </logger>
        <logger name="org.elasticsearch" level="INFO">
        </logger>
        <logger name="com.jd.jsf.gd" level="warn">
        </logger>
        <logger name="org.mybatis" level="DEBUG">
        </logger>
        <!-- 将业务dao接口填写进去,并用控制台输出即可 -->
        <logger name="com.pwddd.ssmdemo.mapper" level="debug" additivity="false">
            <appender-ref ref="Console"/>
            <appender-ref ref="RollingFileInfo"/>
        </logger>

        <root level="info">
            <appender-ref ref="Console"/>
            <appender-ref ref="RollingFileInfo"/>
        </root>
    </loggers>

</configuration>

```

mybatis-config.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <setting name="lazyLoadingEnabled" value="true"/>
        <!--        按照需要进行属性的加载-->
        <setting name="aggressiveLazyLoading" value="false"/>
        <setting name="cacheEnabled" value="true"/>
    </settings>

    <typeAliases>
<!--        <typeAlias type="com.pwddd.mybatis.bean.Employee" alias="emp" />-->
        <package name="com.pwddd.ssmdemo.bean"/>
    </typeAliases>
</configuration>

```

ehcache.xml配置文件

```xml
<ehcache>


    <!--
        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存
        path:指定在硬盘上存储对象的路径
     -->
    <diskStore path="java.io.tmpdir" />


    <!--
        defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理
        maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象
        eternal:代表对象是否永不过期
        timeToIdleSeconds:最大的发呆时间
        timeToLiveSeconds:最大的存活时间
        overflowToDisk:是否允许对象被写入到磁盘
     -->
    <defaultCache maxElementsInMemory="10000" eternal="false"
                  timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" />

    <!--
        cache:为指定名称的对象进行缓存的特殊配置
        name:指定对象的完整名
     -->
    <cache name="com.zbaccp.entity.Person" maxElementsInMemory="10000" eternal="false"
           timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="true" />
</ehcache>
```

## 逆向工程

Mybatis代码生成器是mybatis提供的一个根据数据库表逆向自动生成xml、JavaBean等类的工具。

Mybatis逆向工程配置：

1. 引入mybatis-gentator

```xml
<dependency>
    <groupId>org.mybatis.generator</groupId>
    <artifactId>mybatis-generator-core</artifactId>
    <version>1.3.7</version>
</dependency>

<dependency>
    <groupId>org.mybatis.generator</groupId>
    <artifactId>mybatis-generator-maven-plugin</artifactId>
    <version>1.3.7</version>
</dependency>
```

2. 编写配置文件

```XML
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>

    <!--
        targetRuntime="MyBatis3Simple":生成简单版的CRUD
        MyBatis3:豪华版
     -->
    <context id="mysqlTables" targetRuntime="MyBatis3">
        <!-- jdbcConnection：指定如何连接到目标数据库 -->
        <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true"
                        userId="root"
                        password="123456">
        </jdbcConnection>

        <!--  -->
        <javaTypeResolver >
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>

        <!-- javaModelGenerator：指定javaBean的生成策略
        targetPackage="test.model"：目标包名
        targetProject="\MBGTestProject\src"：目标工程
        -->
        <javaModelGenerator targetPackage="com.pwddd.mybatis.bean"
                            targetProject=".\src\main\java\">
            <property name="enableSubPackages" value="true" />
            <property name="trimStrings" value="true" />
        </javaModelGenerator>

        <!-- sqlMapGenerator：sql映射生成策略： -->
        <sqlMapGenerator targetPackage="mapper"
                         targetProject=".\src\main\resources\">
            <property name="enableSubPackages" value="true" />
        </sqlMapGenerator>

        <!-- javaClientGenerator:指定mapper接口所在的位置 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.pwddd.mybatis.dao"
                             targetProject=".\src\main\java\">
            <property name="enableSubPackages" value="true" />
        </javaClientGenerator>

        <!-- 指定要逆向分析哪些表：根据表要创建javaBean -->
        <table tableName="tbl_dept" domainObjectName="Department"></table>
        <table tableName="tbl_employee" domainObjectName="Employee"></table>
    </context>
</generatorConfiguration>
```

3. 运行

```XML
@Test
public void mbg() throws XMLParserException, IOException, InvalidConfigurationException, SQLException, InterruptedException {

List<String> warnings = new ArrayList<String>();
    boolean overwrite = true;
    File configFile = new File("mbg.xml");
    ConfigurationParser cp = new ConfigurationParser(warnings);
    Configuration config = cp.parseConfiguration(configFile);
    DefaultShellCallback callback = new DefaultShellCallback(overwrite);
    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
    myBatisGenerator.generate(null);
    }
```

## MyBatis运行原理

![image-20220223091207172](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091207172.png)

![image-20220223091130352](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091130352.png)



### 创建SQLSessionFactory

![image-20220223091242314](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091242314.png)

### 创建SQLSession

![image-20220223091307170](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091307170.png)



### 获取Mapper的代理类对象

![image-20220223091331687](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091331687.png)

### 执行查询

![image-20220223091359155](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091359155.png)



### 流程总结

![image-20220223091434235](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223091434235.png)

## 插件

### 原理

1. 在四大对象创建的过程中，都会执行`interceptorChain.pluginAll(param);`,获取到所有的interceptor，调用`interceptor.plugin(target)` 返回target包装之后的对象。
2. 我们可以为四大对象创建一个代理对象，AOP切面编程的思想。通过代理对象我们就能拦截到四大对象中执行的方法。

### 编写插件

1. 实现interceptor接口
2. 实现相关方法
3. 使用@Interceptor实现插件签名
4. 将插件注册到mybatis配置文件中



```java
package com.pwddd.mybatis.plugins;

import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.plugin.*;

import java.util.Properties;

@Intercepts(
        @Signature(
                type = StatementHandler.class,
                method="parameterize",
                args=java.sql.Statement.class
        )
)
public class MyFirstPlugin implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        return invocation.proceed();
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target,this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
}
```



```xml
<plugins>
    <plugin interceptor="com.pwddd.mybatis.plugins.MyFirstPlugin">
        <property name="haha" value="123"/>
    </plugin>
</plugins>
```

![image-20220223095224912](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220223095224912.png)

## 扩展

### 分页

分页插件地址：[Mybatis-PageHelper-DOC](https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md)	

1. 引入依赖

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.3.0</version>
</dependency>
```

2. 引入插件

```xml
<!-- 
        plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:
        properties?, settings?, 
        typeAliases?, typeHandlers?, 
        objectFactory?,objectWrapperFactory?, 
        plugins?, 
        environments?, databaseIdProvider?, mappers?
    -->
<plugins>
    <!-- com.github.pagehelper为PageHelper类所在包名 -->
    <plugin interceptor="com.github.pagehelper.PageInterceptor">
        <!-- 使用下面的方式配置参数，后面会有所有的参数介绍 -->
        <property name="param1" value="value1"/>
    </plugin>
</plugins>
```

具体使用方法查看文档。

### 批量操作

```java
SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
```

spring整合时可以注入一个bean，然后autowired自动注入到dao层，使用该bean创建mapper代理类对象，进行查询。



### 自定义类型处理器 Type Handler

```java

public class MyEnumEmpStatusTypeHandler implements TypeHandler<EmpStatus> {

	/**
	 * 定义当前数据如何保存到数据库中
	 */
	@Override
	public void setParameter(PreparedStatement ps, int i, EmpStatus parameter,
			JdbcType jdbcType) throws SQLException {
		// TODO Auto-generated method stub
		System.out.println("要保存的状态码："+parameter.getCode());
		ps.setString(i, parameter.getCode().toString());
	}

	@Override
	public EmpStatus getResult(ResultSet rs, String columnName)
			throws SQLException {
		// TODO Auto-generated method stub
		//需要根据从数据库中拿到的枚举的状态码返回一个枚举对象
		int code = rs.getInt(columnName);
		System.out.println("从数据库中获取的状态码："+code);
		EmpStatus status = EmpStatus.getEmpStatusByCode(code);
		return status;
	}

	@Override
	public EmpStatus getResult(ResultSet rs, int columnIndex)
			throws SQLException {
		// TODO Auto-generated method stub
		int code = rs.getInt(columnIndex);
		System.out.println("从数据库中获取的状态码："+code);
		EmpStatus status = EmpStatus.getEmpStatusByCode(code);
		return status;
	}

	@Override
	public EmpStatus getResult(CallableStatement cs, int columnIndex)
			throws SQLException {
		// TODO Auto-generated method stub
		int code = cs.getInt(columnIndex);
		System.out.println("从数据库中获取的状态码："+code);
		EmpStatus status = EmpStatus.getEmpStatusByCode(code);
		return status;
	}

}

```



```xml
<typeHandlers>
    <!--1、配置我们自定义的TypeHandler  -->
    <typeHandler handler="com.atguigu.mybatis.typehandler.MyEnumEmpStatusTypeHandler" javaType="com.atguigu.mybatis.bean.EmpStatus"/>
    <!--2、也可以在处理某个字段的时候告诉MyBatis用什么类型处理器
    保存：#{empStatus,typeHandler=xxxx}
    查询：
     <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmp">
       <id column="id" property="id"/>
       <result column="empStatus" property="empStatus" typeHandler=""/>
      </resultMap>
    注意：如果在参数位置修改TypeHandler，应该保证保存数据和查询数据用的TypeHandler是一样的。
    -->
</typeHandlers>
```

