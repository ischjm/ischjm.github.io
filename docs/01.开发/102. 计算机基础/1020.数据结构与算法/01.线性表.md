---
title: 线性表
date: 2022-05-05 22:00:00
permalink: /dev/basic/ds/list
author:
 name: p0jo
 link: https://wiki.pwddd.com
categories:
  - 开发
  - 计算机基础
  - 数据结构与算法
tags:
  - 数据结构
  - 线性表
---

# 线性表

> 线性表和栈、队列、串以及数组都属于线性结构。线性结构基本特点是除了第一个元素无直接前驱、最后一个元素无直接后继，其他数据元素都有一个前驱和后继。

<!-- more -->


## 定义和特点

生活中有很多线性表的例子，比如26个英文字母、学生信息表等等。他们的数据元素虽然不相同，但是同一个线性表中的元素必定有相同的特性。

**诸如此类由`n(n>=0)`个数据特性相同的元素构成的有限序列称为*线性表*。线性表中的`n`称为线性表的长度，`n=0`时则为空表。**

非空线性表通常有如下的特征：

- 存在为一个被称为 **第一个**的数据元素
- 存在唯一一个被称为 **最后一个**的数据元素
- 除了第一个之外，每个元素都有且只有一个前驱
- 除了最后一个之外，每个元素都有且只有一个后继

## 线性表的类型定义

线性表是一个十分灵活的数据结构，长度可根据需求增加或缩短，还可以对线性表的元素进行访问、删除、插入等操作。以下给出线性表的抽闲数据类型定义：

![image-20220505192028321](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220505192028321.png)



## 线性表的顺序表示和实现（C语言版）

### 线性表的顺序存储表示

> 线性表的顺序表示指的是使用 **一组连续地址的存储单元**存储线性表的元素，这个表示也称为顺序存储结构或者顺序映像。通常这种存储结构的线性表称为 **顺序表**。**逻辑上相邻的元素在物理次序上也是相邻的**

假设一个元素占用`l`个存储空间，并且占用的第一个存储地址作为元素存储的起始位置。则线性表中第`i+1`个元素的存储位置和第`i`个元素的存储位置之间的关系如下：

```
LOC(ai+1) = LOC(ai) + l
```

- 线性表的第一个元素的起始位置`LOC(a1)`，通常称为线性表的起始位置或者基地址。
- 每个元素的存储位置和元素在线性表中的位序成正比
- 只要确定起始位置和元素大小，任意元素的位置都可随机存取
- 因此线性表的顺序存储结构是一种 **随机存取**的存储结构。

![image-20220505193107231](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220505193107231.png)



在高级程序设计语言中的数组有着类似的随机存取特性，因此通常使用数据描述数据结构中的顺序存储结构。C语言中的线性表可描述如下：

```c
#define MAXSIZE 100
typedef struct{
  ElemType * elem;
  int length;
}SqList;
```

- 数组空间大小为MAXSIZE通过初始化动态分配得到，初始化之后Elem指针指向顺序表的基地址。
- 元素类型ELemType可以根据实际类型进行定义。可以为int 、float登记本数据类型或者strut的结构体类型。
- length表示顺序表中存在的元素个数。

### 顺序表的基本操作

#### 0. 初始化

> 顺序表的初始化操作是构造一个空的顺序表。

```c
void InitList(SqList *list){
  // 分配空间
  list->elem = (ElemType *)malloc((size_t)(sizeof(ElemType) * DEFAULT_CAPACITY));
  if (list->elem == NULL){
    printf("%s\n",strerror(errno));
    exit(-1);
  }

  // 初始化参数
  list->size = 0;
  list->capacity = DEFAULT_CAPACITY;
}
```

#### 1. 顺序表扩容

> 当顺序表存储空间不足时，需要对顺序表进行扩容，这里定为扩容两倍大小。

```c
void SeqListExpand(SqList *list){
  list->elem = (ElemType *)realloc(list->elem,2 * list->capacity * sizeof(ElemType));
  if (list->elem == NULL){
    error();
  }
  list->capacity = 2 * list->capacity;
}
```

#### 2. 取值

> 取值操作是根据指定元素的位置序号i，获取顺序表中的第i个元素的值。

```c
ElemType GetItem(SqList *list,int index){
  if (index < 0 || index >= list->size){
    // 长度异常报错
    printf("%s\n", strerror(errno));
    exit(-2);
  }
  return list->elem[index];
}
```

#### 3. 查找

> 查找元素是根据指定元素值e，查找顺序表中与给定e相等的元素的第一个位置，成功则返回位置序号，失败则返回-1。

```c
int LocateELem(SqList *list,ElemType elemType){
  for (int i = 0; i < list->size; i++) {
    if (elemType == list->elem[i]){
      return i;
    }
  }
  return -1;
}
```

当在顺序表中查找一个元素时，需要从头开始遍历顺序表，比较的次数则取决为元素在线性表中的位置。

在查找时，为了确定元素在顺序表中的位置，需要和给定的值进行比较的数据元素个数的期望值称为查找算法阿兹查找成功时的**平均查找长度（ASL）**。

假设`pi`是查找第`i`个元素的概率，`Ci`为找到表中其关键字与给定的相等的第`i`个记录时，和给定值已经比较过的关键字个数，则在长度为`n`的线性表中，查找成功时平均查找长度为：

![image-20220505203655096](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220505203655096.png)

从查找的算法过程可知，当查找的元素是第一个记录时，只需要比较一次；当查找的元素为最后一个记录时，则需要比较`n`次。假设每个元素的查找概率相等，即`pi = 1/n`，则可以化简为：

![image-20220505203844333](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220505203844333.png)

得出顺序表的值查找平均时间复杂度为`O(n)`

#### 4. 插入

> 线性表的插入操作时在表的指定`i`位置插入一个新的元素`e`，并将长度为`n`的线性表变为`n+1`。

```c
ElemType ListInsert(SqList *list, int index, ElemType elem){
  // 判断索引是否正确
  if (index < 0 || index > list->size){
    error();
  }

  // 判断容量是否充足
  if (list->size == list->capacity){
    SeqListExpand(list);
  }
  //插入元素
  // 末尾插入
  if(index == list->size){
    list->elem[index] = elem;
    list-> size ++;
    return NULL;
  }else{
    for (int i = list->size ; i > index ; i--) {
      list->elem[i] = list->elem[i - 1];
    }
    ElemType oldElem = list->elem[index];
    list->elem[index] = elem;
    list->size ++;
    return oldElem;
  }

}
```

根据分析，算法插入时的平均时间复杂度为`O(n)`。

#### 5. 删除指定位置的元素

> 删除元素是指将指定索引位置的元素删除，并将该位置原本的元素返回。

```c
ElemType ListDelete(SqList *list,int index){
  if (index < 0 || index >= list->size){
    error();
  }
  // 删除最后一个元素
  if (index == list->size - 1){
    ElemType oldElem = list->elem[index];
    list->elem[index] = NULL;
    list->size --;
    return oldElem;
  } else{
    ElemType oldElem = list->elem[index];
    for (int i = index; i < list->size - 1; ++i) {
      list->elem[i] = list->elem[index + 1];
    }
    list->size --;
    return oldElem;
  }
}
```

顺序表的删除算法平均时间复杂度为:`O(n)`。

以上就是C语言实现的顺序表的关键操作，下面使用Java版本的实现。



## 线性表的顺序表示和实现（Java语言版）

> Java语言版的顺序表相对于C语言版的忽略了底层的一些操作。写法更为简单，同时Java语言的ArrayList实际上就是对顺序表的实现。

以下是Java版本的全部代码(不使用范型)：
```java
package com.pwddd.list;

public class ArrayList {

  private static final int ELEMENT_NOT_FOUND = -1;
  private int[] elems;
  private int size;
  private static final int DEFAULT_CAPACITY = 10;

  /**
     * 指定大小进行初始化
     *
     * @param capacity 自定义大小
     */
  public ArrayList(int capacity) {
    capacity = capacity > DEFAULT_CAPACITY ? capacity : DEFAULT_CAPACITY;
    elems = new int[capacity];
  }


  /**
     * 默认初始化
     */
  public ArrayList() {
    this(DEFAULT_CAPACITY);
  }

  /**
     * 清除所有元素
     */
  public void clear() {
    // 对于int类型而言，只需要让size=0 无法访问即可
    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null
    size = 0;
  }

  /**
     * 元素的数量
     *
     * @return 元素的数量
     */
  public int size() {
    return size;
  }

  /**
     * 是否为空
     *
     * @return 是否为空
     */
  public boolean isEmpty() {
    return size == 0;
  }

  /**
     * 是否包含某个元素
     *
     * @param element 指定元素
     * @return 是否包含
     */
  public boolean contains(int element) {
    return indexOf(element) != ELEMENT_NOT_FOUND;
  }

  /**
     * 添加元素到尾部
     *
     * @param element 指定的元素
     */
  public void add(int element) {
    add(size,element);
  }

  /**
     * 获取index位置的元素
     *
     * @param index  指定的索引位置
     * @return 索引位置的元素
     */
  public int get(int index) {
    checkIndex(index);
    return elems[index];
  }

  /**
     * 设置index位置的元素
     *
     * @param index 指定的索引位置
     * @param element 索引位置原来的元素
     * @return 原来的元素ֵ
     */
  public int set(int index, int element) {
    checkIndex(index);
    int oldElem = elems[index];
    elems[index] = element;
    return oldElem;
  }

  /**
     * 在index位置插入一个元素
     *
     * @param index 指定的索引位置
     * @param element 索引位置原来的元素
     */
  public void add(int index, int element) {
    checkIndexForAdd(index);
    ensureCapacity(size + 1);
    for (int i = size; i > index ; i --){
      elems[i] = elems[i-1];
    }
    elems[index] = element;
    size ++;
  }

  /**
     * 删除index位置的元素
     *
     * @param index 指定索引位置
     * @return 删除位置之前的元素
     */
  public int remove(int index) {
    checkIndex(index);
    int oldElem = elems[index];
    for (int i = index + 1; i < size ; i ++){
      elems[i - 1] = elems[i];
    }
    size --;
    return oldElem;
  }

  /**
     * 查看元素的索引
     *
     * @param element 指定查找的元素
     * @return 元素的索引
     */
  public int indexOf(int element) {
    for (int i = 0; i < size ; i++){
      if (elems[i] == element){
        return i;
      }
    }
    return ELEMENT_NOT_FOUND;
  }

  /**
     * 保证要有capacity的容量
     *
     * @param capacity 当前容量
     */
  private void ensureCapacity(int capacity) {
    int oldCapacity = elems.length;
    if (oldCapacity >= capacity) return;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    int[] newElems = new int[newCapacity];
    for (int i = 0; i < elems.length; i ++){
      newElems[i] = elems[i];
    }
    elems = newElems;
  }

  private void checkIndex(int index){
    if (index < 0 || index >= size){
      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);
    }
  }

  private void checkIndexForAdd(int index){
    if (index < 0 || index > size){
      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);
    }
  }

}

```

添加范型的Java实现方式：

```java
package com.pwddd.list;


public class ArrayList<E> {

  private static final int ELEMENT_NOT_FOUND = -1;
  private E[] elems;
  private int size;
  private static final int DEFAULT_CAPACITY = 10;

  /**
     * 指定大小进行初始化
     *
     * @param capacity 自定义大小
     */
  public ArrayList(int capacity) {
    capacity = capacity > DEFAULT_CAPACITY ? capacity : DEFAULT_CAPACITY;
    elems = (E[]) new Object[capacity];
  }


  /**
     * 默认初始化
     */
  public ArrayList() {
    this(DEFAULT_CAPACITY);
  }

  /**
     * 清除所有元素
     */
  public void clear() {
    // 对于int类型而言，只需要让size=0 无法访问即可
    // 如果是对象类型则为了让垃圾收集器工作，则需要设置为null
    //        size = 0;
    for (int i = 0; i < size; i++){
      elems[i] = null;
    }
  }

  /**
     * 元素的数量
     *
     * @return 元素的数量
     */
  public int size() {
    return size;
  }

  /**
     * 是否为空
     *
     * @return 是否为空
     */
  public boolean isEmpty() {
    return size == 0;
  }

  /**
     * 是否包含某个元素
     *
     * @param element 指定元素
     * @return 是否包含
     */
  public boolean contains(E element) {
    return indexOf(element) != ELEMENT_NOT_FOUND;
  }

  /**
     * 添加元素到尾部
     *
     * @param element 指定的元素
     */
  public void add(E element) {
    add(size,element);
  }

  /**
     * 获取index位置的元素
     *
     * @param index  指定的索引位置
     * @return 索引位置的元素
     */
  public E get(int index) {
    checkIndex(index);
    return elems[index];
  }

  /**
     * 设置index位置的元素
     *
     * @param index 指定的索引位置
     * @param element 索引位置原来的元素
     * @return 原来的元素ֵ
     */
  public E set(int index, E element) {
    checkIndex(index);
    E oldElem = elems[index];
    elems[index] = element;
    return oldElem;
  }

  /**
     * 在index位置插入一个元素
     *
     * @param index 指定的索引位置
     * @param element 索引位置原来的元素
     */
  public void add(int index, E element) {
    checkIndexForAdd(index);
    ensureCapacity(size + 1);
    for (int i = size; i > index ; i --){
      elems[i] = elems[i-1];
    }
    elems[index] = element;
    size ++;
  }

  /**
     * 删除index位置的元素
     *
     * @param index 指定索引位置
     * @return 删除位置之前的元素
     */
  public E remove(int index) {
    checkIndex(index);
    E oldElem = elems[index];
    for (int i = index + 1; i < size ; i ++){
      elems[i - 1] = elems[i];
    }
    elems[--size] = null;
    return oldElem;
  }

  /**
     * 查看元素的索引
     *
     * @param element 指定查找的元素
     * @return 元素的索引
     */
  public int indexOf(E element) {
    if (element == null) return -1;
    for (int i = 0; i < size ; i++){
      if (element.equals(elems[i])){
        return i;
      }
    }
    return ELEMENT_NOT_FOUND;
  }

  /**
     * 保证要有capacity的容量
     *
     * @param capacity 当前容量
     */
  private void ensureCapacity(int capacity) {
    int oldCapacity = elems.length;
    if (oldCapacity >= capacity) return;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    E[] newElems = (E[]) new Object[newCapacity];
    for (int i = 0; i < elems.length; i ++){
      newElems[i] = elems[i];
    }
    elems = newElems;
  }

  private void checkIndex(int index){
    if (index < 0 || index >= size){
      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);
    }
  }

  private void checkIndexForAdd(int index){
    if (index < 0 || index > size){
      throw new IndexOutOfBoundsException("元素索引越界--"+"[Index]:"+index+", [Size]:"+size);
    }
  }

}

```


