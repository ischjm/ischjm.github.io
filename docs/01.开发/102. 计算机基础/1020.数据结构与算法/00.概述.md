---
title: 【数据结构】概述
date: 2022-05-04 20:00:00
permalink: /dev/basic/ds/introduction
author:
 name: p0jo
 link: https://wiki.pwddd.com
categories:
  - 开发
  - 计算机基础
  - 数据结构与算法
tags:
  - 数据结构
---

# 【数据结构】概述

::: note
基础不牢固，打打基础吧。
:::

<!-- more -->

## 术语和概念

### 数据、数据元素、数据项、数据对象

- 数据：客观事物的符号表示，所有能够输入到计算机中并可以被计算机程序处理的符号的总称。比如：字符串、图像、声音等。
- 数据元素：数据的基本单位。数据元素也称为元素、记录。可以理解为数据库的一条记录。
- 数据项：组成数据元素的、有独立含义的、不可分割的最小单位。可以理解为数据库的某一列。
- 数据对象：性质相同的数据元素的集合。是数据的子集。可以理解为数据库的一张表。

### 数据结构

> 数据结构是相互之间存在的一种或者多种特定关系的数据元素的集合。
>
> 数据结构是带结构的数据元素的集合，结构是数据之间的关系。

#### 1. 逻辑结构

数据的逻辑结构是从 **逻辑关系**上描述数据，和数据的存储无关。可以看作是从具体问题中抽象出来的数学模型。逻辑结构的两个要素：**数据元素、关系**。通常存在以下四种数据的逻辑结构：

- 集合结构

  数据元素之间除了属于同一个集合之外，无其他关系。例如：学生属于一个班级。

  ![image-20220504232141566](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504232141566.png)

- 线性结构

  数据之间存在一对一的关系。例如：排队和糖葫芦。

  ![image-20220504232217255](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504232217255.png)

- 树结构

  数据中存在一对多的关系。例如：族谱、组织结构等。

  ![image-20220504232248690](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504232248690.png)

- 图结构

  数据之间存在多对多的关系。如：人物关系图。

  ![image-20220504232319249](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504232319249.png)

> 集合、树、图都属于非线性结构。
>
> 线性结构包含：线性表、栈、队列、字符串、数据、广义表等。
>
> 非线性结构包含：树、二叉树、有向图和无向图。

![image-20220504232510568](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504232510568.png)

#### 2. 存储结构

> 数据对象如何存储在计算机中，称为数据的存储结构。也叫 **物理结构**。在数据存储到计算机时，既要存储元素也要存储关系。数据元素在计算机中有两种基本的存储结构：**顺序存储结构和链式存储结构**。

- 顺序存储结构

  顺序存储结构借助数据在存储器中的相对位置来表示逻辑关系。

- 链式存储结构

  顺序存储结构要求所有的存储空间连续。链式存储结构无需占用完整存储空间。数据节点之间通过指针字段表示数据关系。

### 数据类型和抽象数据类型

> 数据类型（DT）：高级程序设计怨言的一个基本概念。
>
> 抽象数据类型（ADT）：抽象出实际问题的本质。包含三部分：数据对象、数据对象上关系的集合、数据对象的基本操作集合。

定义格式如下：

```text
ADT 抽象数据类型名{
	数据对象：
	数据关系：
	基本操作：基本操作名（参数列表）
						初始条件：
						操作结果：
}ADT 抽象数据类型名
```

### 抽象数据类型的表示与实现

使用介于伪代码和C语言之间的类C语言作为后续的描述工具。具体语法不在赘述。

以下是以复数为例，给出的一个完整的抽象数据类型的定义、表示和实现。

定义：

![image-20220504233930666](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504233930666.png)

表示：

![image-20220504233947009](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504233947009.png)

实现：

![image-20220504233958652](https://wiki-1251603812.cos.ap-shanghai.myqcloud.com/images/image-20220504233958652.png)



## 算法和算法分析

### 算法的定义

> 算法是为了解决某类问题而规定的有限长度的操作序列。

算法必须满足如下的五个特性：

- 有穷性：算法必须在执行有穷步数后结束
- 确定性：对于每种情况下的操作，不会产生二义性
- 可行性：算法中的所有操作都可以通过已经实现的操作运算的有限次操作完成
- 输入：一个算法有0个或多个输入
- 输出：一个算法有一个或多个输出



### 算法的评价标准

> 算法分析并非精确统计算法的实际执行时间，而是针对算法的执行次数进行估计。

算法的评价包含以下的几个维度：

- 正确性：在合理的数据输入下，总能得到正确的结果
- 可读性：便于理解
- 健壮性：输入非法数据，可以有效的处理
- 高效性：包含时间和空间两个维度

### 时间复杂度

> 衡量算法效率的两种方式：事后统计法和事前分析法。事后统计法需要实现算法并执行，计算时间和空间的开销。这种方法存在两个弊端：必须实现、硬件依赖。

#### 问题规模和语句频度

问题规模是算法求解问题输入量的多少，通常用 `n`表示。

语句频度是一条语句重复执行的次数。

#### 时间复杂度的定义

一般情况下，算法中的基本语句重复执行的次数是问题规模n的某个函数`f(n)`，算法的时间量可以表示为：

```
T(n) = O(f(n))
```

随着问题规模n的逐渐增大，算法的执行时间的增长率和`f(n)`的增长率相同，称为算法的`渐进时间复杂度`，简称为`时间复杂度`。

关于数学符号`O`的严格定义：

```
若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)和O(f(n))表示存在正的常数C和n0，使得当n>= n0时，都满足0<=T(n)<=Cf(n).
```

没必要纠结这个严格的定义方式，只需要如何进行计算即可。以下是常见的时间复杂度：

```c
// 常量复杂度 O(1)
{
  x++;
  s=0;
}

// 线性阶复杂度O(n)
for(i=0;i<n;i++){
  x++;
  s=0;
}

// 平方阶O(n2)
x = 0;y = 0;
for(i=0;i<ni++){
  for(j=0,j<n;j++){
    printf("hello\n");
  }
}

// 对数阶O(log2n)
for(i=0;i<n;i+=i){
  x++;
}
```

常见的时间复杂度按照数量级递增排列为：

```
O(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < …… < O(n^k) < O(2^n)
```

#### 最好最坏时间复杂度

算法在最好情况下的时间复杂度称为最好**时间复杂度**，指的是算法计算量可能达到的最小值；算法在最坏情况下的时间复杂度称为 **最坏时间复杂度**，指的是算法计算量达到的最大值。算法的 **平均时间复杂度**指的是算法在所有情况下的计算量的加权平均。

#### 算法空间复杂度

一般情况下，一个程序在机器上执行，除了需要寄存本身的指令、常数、变量、输入数据意外，还需要一些队数据进行操作的辅助空间。如果算法执行时所需要的辅助空间对于输入量而言是常数，称为 **原地工作**，辅助空间为 `O(1)`。

## 斐波那契数列

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

该题有两种算法，递归和迭代。

递归算法，时间复杂度为`O(n^2)`

```java
public int fib(int n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```

迭代算法，时间复杂度为`O(n)`

```java
public int fib(int n) {
  if (n <= 1) return n;

  int first = 0;
  int second = 1;

  for (int i = 0; i < n - 1; i++) {
    int sum = first + second;
    first = second;
    second = sum;
  }
  return second;
}
```




